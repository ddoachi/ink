---
id: E05-F04-T02
title: Pan to Object
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F04
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Medium
tags:
  - presentation
  - canvas
  - viewport
---

# Spec: E05-F04-T02 - Pan to Object

## 1. Overview

### 1.1 Problem Statement
Implement viewport panning functionality in the schematic canvas to center the view on a target object. The panning must calculate the object's center position, translate viewport coordinates, and optionally animate the transition for smooth user experience.

### 1.2 Goals
- Calculate bounding box for rendered objects on canvas
- Compute center point of object bounds
- Translate viewport to center on target point
- Support optional smooth animation (150ms transition)
- Handle edge cases (object at canvas boundary, very large objects)
- Complete pan operation in < 50ms (excluding animation time)

---

## 2. Technical Requirements

### 2.1 Canvas Viewport Control

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

**Implementation**:
```python
from typing import Optional
from PySide6.QtCore import QPointF, QRectF, QPropertyAnimation, QEasingCurve
from PySide6.QtWidgets import QGraphicsView

from ink.domain.value_objects.position import Position, BoundingBox
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.net import Net
from ink.domain.model.port import Port


class SchematicCanvas(QGraphicsView):
    """
    Schematic canvas with viewport control for navigation.

    Extends QGraphicsView with methods for panning to objects
    and managing viewport transformations.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self._pan_animation: Optional[QPropertyAnimation] = None
        # ... existing initialization ...

    def get_object_bounds(self, obj) -> Optional[BoundingBox]:
        """
        Get bounding box for rendered object on canvas.

        Args:
            obj: Domain entity (Cell, Pin, Net, Port)

        Returns:
            BoundingBox in scene coordinates, or None if object not rendered
        """
        # Find graphics item for domain object
        item = self._find_graphics_item(obj)
        if item is None:
            return None

        # Get bounding rect in scene coordinates
        scene_rect = item.sceneBoundingRect()

        # Convert QRectF to domain BoundingBox
        return BoundingBox(
            min_x=scene_rect.left(),
            min_y=scene_rect.top(),
            max_x=scene_rect.right(),
            max_y=scene_rect.bottom()
        )

    def pan_to_center(
        self,
        point: Position,
        animate: bool = True,
        duration_ms: int = 150
    ) -> None:
        """
        Pan viewport to center on a point in scene coordinates.

        Args:
            point: Target position in scene coordinates
            animate: If True, animate the pan transition
            duration_ms: Animation duration in milliseconds
        """
        # Convert scene point to viewport center
        target_scene_point = QPointF(point.x, point.y)

        if animate:
            self._animate_center_on(target_scene_point, duration_ms)
        else:
            self.centerOn(target_scene_point)

    def pan_to_object(
        self,
        obj,
        animate: bool = True,
        duration_ms: int = 150
    ) -> None:
        """
        Pan viewport to center on object.

        Convenience method that combines get_object_bounds() and pan_to_center().

        Args:
            obj: Domain entity to center on
            animate: If True, animate the pan transition
            duration_ms: Animation duration in milliseconds
        """
        bounds = self.get_object_bounds(obj)
        if bounds is None:
            self._logger.warning(f"Cannot pan to object: not rendered on canvas")
            return

        # Center on object's center point
        center = bounds.center()
        self.pan_to_center(center, animate=animate, duration_ms=duration_ms)

    def _find_graphics_item(self, obj):
        """
        Find QGraphicsItem corresponding to domain object.

        Args:
            obj: Domain entity (Cell, Pin, Net, Port)

        Returns:
            QGraphicsItem or None if not found
        """
        # Lookup in object-to-item mapping
        # (This mapping should be maintained during rendering)
        if isinstance(obj, Cell):
            return self._cell_items.get(obj.id)
        elif isinstance(obj, Pin):
            return self._pin_items.get(obj.id)
        elif isinstance(obj, Net):
            return self._net_items.get(obj.id)
        elif isinstance(obj, Port):
            return self._port_items.get(obj.id)
        return None

    def _animate_center_on(
        self,
        scene_point: QPointF,
        duration_ms: int
    ) -> None:
        """
        Animate viewport panning to center on scene point.

        Uses QPropertyAnimation on view's horizontal/vertical scrollbars
        for smooth transition.

        Args:
            scene_point: Target point in scene coordinates
            duration_ms: Animation duration
        """
        # Stop any existing animation
        if self._pan_animation:
            self._pan_animation.stop()

        # Calculate target scrollbar positions
        view_center = self.viewport().rect().center()
        scene_in_view = self.mapToScene(view_center)
        delta = scene_point - scene_in_view

        # Get current scrollbar values
        h_bar = self.horizontalScrollBar()
        v_bar = self.verticalScrollBar()
        current_h = h_bar.value()
        current_v = v_bar.value()

        # Calculate target scrollbar values
        # (simplified - actual implementation needs coordinate transformation)
        target_h = current_h + int(delta.x())
        target_v = current_v + int(delta.y())

        # Animate horizontal scrollbar
        self._pan_animation = QPropertyAnimation(h_bar, b"value")
        self._pan_animation.setDuration(duration_ms)
        self._pan_animation.setStartValue(current_h)
        self._pan_animation.setEndValue(target_h)
        self._pan_animation.setEasingCurve(QEasingCurve.Type.InOutQuad)

        # Chain vertical scrollbar animation
        # (In practice, might need parallel animations)
        self._pan_animation.finished.connect(
            lambda: self._animate_v_scrollbar(v_bar, current_v, target_v, duration_ms)
        )

        self._pan_animation.start()

    def _animate_v_scrollbar(
        self,
        v_bar,
        start_value: int,
        end_value: int,
        duration_ms: int
    ) -> None:
        """Animate vertical scrollbar (helper for _animate_center_on)"""
        anim = QPropertyAnimation(v_bar, b"value")
        anim.setDuration(duration_ms)
        anim.setStartValue(start_value)
        anim.setEndValue(end_value)
        anim.setEasingCurve(QEasingCurve.Type.InOutQuad)
        anim.start()
```

### 2.2 BoundingBox Value Object Updates

**Location**: `src/ink/domain/value_objects/position.py`

Add `center()` method to `BoundingBox`:
```python
@dataclass(frozen=True)
class BoundingBox:
    """Axis-aligned bounding box"""
    min_x: float
    min_y: float
    max_x: float
    max_y: float

    def center(self) -> Position:
        """Calculate center point of bounding box"""
        return Position(
            x=(self.min_x + self.max_x) / 2.0,
            y=(self.min_y + self.max_y) / 2.0
        )

    def width(self) -> float:
        """Calculate width of bounding box"""
        return self.max_x - self.min_x

    def height(self) -> float:
        """Calculate height of bounding box"""
        return self.max_y - self.min_y
```

### 2.3 Graphics Item Mapping

**Requirement**: Maintain mapping from domain objects to `QGraphicsItem` instances.

**Implementation** (in `SchematicCanvas` or rendering service):
```python
class SchematicCanvas:
    def __init__(self, parent=None):
        super().__init__(parent)
        # Mapping: domain object ID -> QGraphicsItem
        self._cell_items: Dict[CellId, CellGraphicsItem] = {}
        self._pin_items: Dict[PinId, PinGraphicsItem] = {}
        self._net_items: Dict[NetId, NetGraphicsItem] = {}
        self._port_items: Dict[PortId, PortGraphicsItem] = {}

    def _register_item(self, obj, item):
        """Register graphics item for domain object"""
        if isinstance(obj, Cell):
            self._cell_items[obj.id] = item
        elif isinstance(obj, Pin):
            self._pin_items[obj.id] = item
        # ... etc
```

### 2.4 Performance Requirements

| Operation | Target | Notes |
|-----------|--------|-------|
| Get object bounds | < 10ms | Hash table lookup + Qt bounds query |
| Calculate center point | < 1ms | Simple arithmetic |
| Pan without animation | < 20ms | Direct `centerOn()` call |
| Pan with animation | 150ms | Animation duration (user perceived) |
| Total pan operation | < 50ms | Excluding animation time |

---

## 3. Dependencies

### 3.1 Upstream
- Task E05-F04-T01: Provides object to pan to
- Domain value objects: `Position`, `BoundingBox`
- Presentation layer: `QGraphicsItem` subclasses for cells, pins, nets, ports

### 3.2 Downstream
- Task E05-F04-T03: Uses pan operation before zoom to fit
- E05-F01 (Search Panel): Triggers pan after navigation

### 3.3 External Dependencies
- PySide6: `QGraphicsView`, `QPropertyAnimation`, `QEasingCurve`
- Qt coordinate system and transformations

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `get_object_bounds()` returns correct bounding box for rendered objects
- [ ] Returns `None` for objects not currently rendered on canvas
- [ ] `pan_to_center()` centers viewport on target point (no animation)
- [ ] `pan_to_center(animate=True)` smoothly animates to target point
- [ ] `pan_to_object()` convenience method works for all object types
- [ ] Animation uses `InOutQuad` easing for smooth motion
- [ ] Animation duration configurable (default 150ms)
- [ ] Panning works correctly at different zoom levels
- [ ] Panning handles objects at canvas boundaries gracefully
- [ ] Object-to-item mapping maintained during rendering

### 4.2 Edge Cases
- [ ] Handle objects larger than viewport (center on object center)
- [ ] Handle objects near canvas edge (clamp to valid scroll range)
- [ ] Handle rapid sequential pan requests (stop previous animation)
- [ ] Handle pan to non-rendered object (log warning, no-op)

### 4.3 Performance
- [ ] Get object bounds in < 10ms
- [ ] Pan without animation in < 20ms
- [ ] Animation completes in 150ms (configurable)
- [ ] No frame drops during animation (60 FPS)

### 4.4 Testing
- [ ] Unit tests for `BoundingBox.center()` calculation
- [ ] Widget tests for `pan_to_center()` without animation
- [ ] Widget tests for `pan_to_object()` with all object types
- [ ] Test animation behavior (start, stop, duration)
- [ ] Test edge cases (large objects, boundary cases)
- [ ] Performance tests with timing assertions
- [ ] Visual regression test for smooth animation

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate `pan_to_center()` and `pan_to_object()`?**
- `pan_to_center()` is lower-level, reusable for arbitrary points
- `pan_to_object()` is convenience wrapper for common use case
- Allows testing coordinate logic independently from object lookup

**Why optional animation?**
- Animation improves UX for user-triggered navigation
- Skip animation for programmatic/batch operations
- Performance: no animation overhead when not needed

**Why 150ms animation duration?**
- Research shows 100-300ms feels responsive yet smooth
- Matches typical UI animation durations (iOS, Material Design)
- Configurable for user preference or accessibility

**Why `InOutQuad` easing?**
- Smooth acceleration and deceleration
- Feels natural (not linear or abrupt)
- Common default in UI frameworks

### 5.2 Qt Coordinate System Notes

**Scene vs View vs Viewport coordinates**:
- **Scene**: Abstract coordinate space where objects are laid out
- **View**: Transformed scene coordinates (includes zoom, rotation)
- **Viewport**: Widget pixel coordinates

**Panning implementation**:
- `centerOn(QPointF)` takes scene coordinates
- Internally adjusts scrollbars to center that scene point in viewport
- Must account for current view transformation

### 5.3 Testing Strategy

**Widget Tests** (`tests/ui/canvas/test_schematic_canvas_pan.py`):
- Create `SchematicCanvas` with mock scene
- Add test graphics items
- Verify `pan_to_center()` adjusts viewport correctly
- Measure animation duration

**Visual Tests** (manual or screenshot comparison):
- Verify smooth animation visually
- Check easing curve feels natural
- Test at different zoom levels

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F04 split |
