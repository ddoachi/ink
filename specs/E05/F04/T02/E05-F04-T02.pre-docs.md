# E05-F04-T02 - Pan to Object: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F04-T02 - Pan to Object
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

E05-F04-T02 implements viewport panning functionality in the schematic canvas to center the view on a target object. The panning system must calculate object bounding boxes, determine center points, and smoothly translate the viewport using Qt's coordinate transformation system. This capability is essential for the search-to-schematic workflow, enabling users to visually locate search results.

The implementation leverages Qt's `QGraphicsView` coordinate system and provides both instant and animated panning modes for different use cases.

### 1.2 Core Capabilities

The task delivers these primary capabilities:

1. **Object Bounds Calculation**: Query rendered graphics items to get bounding boxes in scene coordinates
2. **Object-to-Item Mapping**: Maintain bidirectional mapping between domain objects and Qt graphics items
3. **Center Point Calculation**: Compute geometric center of bounding boxes
4. **Viewport Translation**: Transform viewport to center on target points in scene coordinates
5. **Smooth Animation**: Optional animated panning with configurable duration and easing
6. **Coordinate System Handling**: Correctly translate between scene, view, and viewport coordinate spaces

### 1.3 Success Metrics

- Calculate object bounds in <10ms
- Pan without animation in <20ms
- Animated pan completes in 150ms (configurable)
- Panning works correctly at all zoom levels
- Smooth 60 FPS animation with no frame drops

---

## 2. Architecture Decisions

### 2.1 Separate pan_to_center() and pan_to_object()

**Decision**: Provide two methods - low-level `pan_to_center(point)` and high-level `pan_to_object(obj)`.

**Rationale**:
- `pan_to_center()` is generic, reusable for arbitrary scene coordinates (e.g., center on cursor, center on selection bounds)
- `pan_to_object()` is convenience wrapper for common use case (combines bounds lookup + centering)
- Separation allows testing coordinate logic independently from object lookup

**Alternatives Considered**:
- **Single pan_to_object() only**: Rejected - doesn't support centering on arbitrary points (reduces flexibility)
- **Single pan_to_point() only**: Rejected - inconvenient API (callers must always compute bounds manually)

**Implementation**:
```python
def pan_to_center(self, point: Position, animate: bool = True) -> None:
    """Low-level: center on scene point"""

def pan_to_object(self, obj, animate: bool = True) -> None:
    """High-level: center on object (calls pan_to_center internally)"""
    bounds = self.get_object_bounds(obj)
    if bounds:
        self.pan_to_center(bounds.center(), animate)
```

**Trade-offs**:
- **Pro**: Flexible API supports multiple use cases
- **Pro**: Easier to test coordinate math separately
- **Con**: Two methods to document and maintain (minimal cost)

### 2.2 Optional Animation

**Decision**: Support both instant and animated panning via `animate` parameter.

**Rationale**:
- **Animated panning**: Better UX for user-triggered navigation (search results, double-click)
  - User can track viewport movement (not disorienting)
  - Feels smooth and professional
- **Instant panning**: Better for programmatic/batch operations
  - Loading saved viewport state
  - Sequential pan+zoom operations (no double animation)
  - Performance testing (deterministic timing)

**Alternatives Considered**:
- **Always animate**: Rejected - animation adds overhead for programmatic use
- **Never animate (instant only)**: Rejected - poor UX for interactive navigation

**Default**: `animate=True` (prioritize UX for common case)

**Trade-offs**:
- **Pro**: Flexibility for different use cases
- **Pro**: Performance optimization when animation not needed
- **Con**: Caller must choose (but sensible default handles 90% of cases)

### 2.3 Animation Implementation Strategy

**Decision**: Use `QPropertyAnimation` on scrollbars for smooth panning.

**Rationale**:
- Qt's animation framework handles interpolation, timing, and easing
- Scrollbar animation is well-supported and performant
- Alternative (`centerOn()` in animation loop) requires manual frame timing

**Alternatives Considered**:
- **Manual QTimer loop**: Rejected - more complex, harder to get smooth 60 FPS
- **QVariantAnimation on view transform**: Over-engineered for panning (better suited for zoom)
- **Just use `centerOn()` without animation**: Already supported as `animate=False` option

**Qt Animation Approach**:
```python
def _animate_center_on(self, scene_point: QPointF, duration_ms: int):
    # Animate horizontal and vertical scrollbars
    h_bar = self.horizontalScrollBar()
    v_bar = self.verticalScrollBar()

    # Create parallel animations for both axes
    h_anim = QPropertyAnimation(h_bar, b"value")
    v_anim = QPropertyAnimation(v_bar, b"value")

    # Both use InOutQuad easing for smooth motion
    h_anim.setEasingCurve(QEasingCurve.Type.InOutQuad)
    v_anim.setEasingCurve(QEasingCurve.Type.InOutQuad)
```

**Trade-offs**:
- **Pro**: Leverages Qt's battle-tested animation framework
- **Pro**: Smooth interpolation and easing handled automatically
- **Con**: More complex than simple `centerOn()` call (but abstracted in method)

### 2.4 Object-to-Item Mapping Strategy

**Decision**: Maintain dictionaries mapping domain object IDs to `QGraphicsItem` instances.

**Rationale**:
- Need fast lookup from domain object → graphics item for bounds calculation
- Items are created during rendering and must be registered
- O(1) lookup time with hash table

**Alternatives Considered**:
- **Scene.items() iteration**: Rejected - O(n) search, too slow
- **Store mapping on domain objects**: Rejected - violates layer architecture (domain can't depend on presentation)
- **Qt's user data on items**: Rejected - bidirectional lookup still needs mapping

**Data Structure**:
```python
class SchematicCanvas(QGraphicsView):
    def __init__(self):
        self._cell_items: Dict[CellId, CellGraphicsItem] = {}
        self._pin_items: Dict[PinId, PinGraphicsItem] = {}
        self._net_items: Dict[NetId, NetGraphicsItem] = {}
        self._port_items: Dict[PortId, PortGraphicsItem] = {}
```

**Lifecycle Management**:
- **Add**: When graphics item created during rendering
- **Remove**: When object collapsed or design cleared
- **Update**: When item replaced (re-layout)

**Trade-offs**:
- **Pro**: Fast O(1) lookup by domain object ID
- **Pro**: Clean separation (mapping owned by canvas, not domain)
- **Con**: Memory overhead (but negligible compared to graphics items themselves)
- **Con**: Must maintain consistency (add/remove on item lifecycle)

### 2.5 BoundingBox as Value Object

**Decision**: Extend `BoundingBox` value object with `center()`, `width()`, `height()` methods.

**Rationale**:
- Bounding box is domain concept (spatial extent of object)
- Center calculation is geometric operation, belongs in value object
- Reusable across presentation, application, and domain layers

**Alternatives Considered**:
- **Calculate center in canvas**: Rejected - duplicates logic across callers
- **Separate utility function**: Rejected - less discoverable, not object-oriented

**Implementation**:
```python
@dataclass(frozen=True)
class BoundingBox:
    min_x: float
    min_y: float
    max_x: float
    max_y: float

    def center(self) -> Position:
        return Position(
            x=(self.min_x + self.max_x) / 2.0,
            y=(self.min_y + self.max_y) / 2.0
        )

    def width(self) -> float:
        return self.max_x - self.min_x

    def height(self) -> float:
        return self.max_y - self.min_y
```

**Trade-offs**:
- **Pro**: Reusable geometric operations
- **Pro**: Domain value object (no Qt dependencies)
- **Con**: None (straightforward extension)

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: Value Object Extensions (30 minutes)**
- Add `center()`, `width()`, `height()` methods to `BoundingBox`
- Unit tests for geometric calculations
- Edge cases: zero-size boxes, negative coordinates

**Phase 2: Object-to-Item Mapping (1 hour)**
- Add mapping dictionaries to `SchematicCanvas`
- Implement `_register_item()` and `_unregister_item()` helpers
- Update rendering code to register items on creation
- Unit tests for mapping lifecycle

**Phase 3: Bounds Calculation (1 hour)**
- Implement `get_object_bounds()` method
- Implement `_find_graphics_item()` lookup
- Convert Qt `QRectF` to domain `BoundingBox`
- Widget tests with mock graphics items

**Phase 4: Panning Implementation (1.5 hours)**
- Implement `pan_to_center()` (instant mode)
- Implement `_animate_center_on()` (animated mode)
- Implement `pan_to_object()` convenience method
- Widget tests with real `QGraphicsView`
- Test at different zoom levels

### 3.2 Incremental Deliverables

Each phase produces testable functionality:

1. **Phase 1**: BoundingBox supports geometric queries
2. **Phase 2**: Canvas tracks graphics items for domain objects
3. **Phase 3**: Object bounding boxes can be queried
4. **Phase 4**: Viewport can pan to objects (instant and animated)

### 3.3 Integration Points

**With Domain Layer**:
- `BoundingBox` value object extended with geometric methods
- `Position` value object used for center points

**With Presentation Layer**:
- Graphics items (`CellGraphicsItem`, `PinGraphicsItem`, etc.) must be registered on creation
- `SchematicCanvas` must own object-to-item mapping
- Qt's `sceneBoundingRect()` used for bounds calculation

**With Application Layer**:
- Task E05-F04-T01 (Navigation Service) provides object to pan to
- Task E05-F04-T03 (Zoom to Fit) may combine pan + zoom operations

---

## 4. Technical Deep Dive

### 4.1 Qt Coordinate Systems

**Three Coordinate Spaces**:

1. **Scene Coordinates**:
   - Abstract 2D space where objects are positioned
   - Example: Cell at (100, 200) in scene
   - Infinite coordinate space (not limited by viewport)

2. **View Coordinates**:
   - Scene coordinates transformed by view matrix (zoom, rotation, shear)
   - Example: Scene (100, 200) at 2x zoom → View (200, 400)

3. **Viewport Coordinates**:
   - Widget pixel coordinates (0,0 is top-left of visible area)
   - Example: View (200, 400) scrolled to center → Viewport (400, 300)

**Panning Implementation**:
```python
def pan_to_center(self, point: Position, animate: bool = True):
    # point is in scene coordinates
    target_scene_point = QPointF(point.x, point.y)

    # centerOn() handles scene → viewport transformation
    self.centerOn(target_scene_point)
```

**Key Qt Methods**:
- `centerOn(QPointF)`: Adjust scrollbars to center scene point in viewport
- `mapToScene(QPoint)`: Convert viewport → scene coordinates
- `mapFromScene(QPointF)`: Convert scene → viewport coordinates
- `sceneBoundingRect()`: Get item bounds in scene coordinates

### 4.2 Scrollbar Animation Algorithm

**Challenge**: Qt's `centerOn()` is instant. Need smooth animation.

**Approach**: Animate scrollbar values (horizontal and vertical) to target positions.

**Algorithm**:
```python
def _animate_center_on(self, scene_point: QPointF, duration_ms: int):
    # 1. Calculate target scrollbar positions
    #    (where scrollbars should be to center scene_point)
    view_center = self.viewport().rect().center()
    current_scene_center = self.mapToScene(view_center)
    delta = scene_point - current_scene_center

    # 2. Get current scrollbar values
    h_bar = self.horizontalScrollBar()
    v_bar = self.verticalScrollBar()
    current_h = h_bar.value()
    current_v = v_bar.value()

    # 3. Calculate target scrollbar values
    #    (simplified - actual requires view transform)
    scale = self.transform().m11()  # Zoom factor
    target_h = current_h + int(delta.x() * scale)
    target_v = current_v + int(delta.y() * scale)

    # 4. Animate both scrollbars in parallel
    h_anim = QPropertyAnimation(h_bar, b"value")
    h_anim.setDuration(duration_ms)
    h_anim.setStartValue(current_h)
    h_anim.setEndValue(target_h)
    h_anim.setEasingCurve(QEasingCurve.Type.InOutQuad)

    v_anim = QPropertyAnimation(v_bar, b"value")
    v_anim.setDuration(duration_ms)
    v_anim.setStartValue(current_v)
    v_anim.setEndValue(target_v)
    v_anim.setEasingCurve(QEasingCurve.Type.InOutQuad)

    # 5. Start both animations
    h_anim.start()
    v_anim.start()

    # 6. Store references to prevent garbage collection
    self._h_anim = h_anim
    self._v_anim = v_anim
```

**Easing Curve**: `InOutQuad` (quadratic ease-in-out)
- Smooth acceleration at start
- Smooth deceleration at end
- Feels natural (not linear or abrupt)
- Standard in Material Design and iOS

### 4.3 Bounds Calculation Edge Cases

**Case 1: Object Not Rendered**
```python
def get_object_bounds(self, obj) -> Optional[BoundingBox]:
    item = self._find_graphics_item(obj)
    if item is None:
        return None  # Caller must handle
```

**Case 2: Zero-Size Object** (e.g., pin as point)
```python
# QRectF may have width/height = 0
# BoundingBox handles this gracefully
bbox = BoundingBox(min_x=10, min_y=20, max_x=10, max_y=20)
center = bbox.center()  # (10, 20) - valid
```

**Case 3: Object Larger Than Viewport**
```python
# Panning centers on object's center, even if object extends beyond viewport
# This is correct behavior - user sees "middle" of large object
self.centerOn(large_object_center)
```

**Case 4: Object Near Canvas Edge**
```python
# Qt scrollbars automatically clamp to valid range
# If object is at edge, panning gets "as close as possible"
# No special handling needed
```

### 4.4 Performance Optimization

**Bounds Lookup**: O(1) via dictionary
```python
def _find_graphics_item(self, obj):
    if isinstance(obj, Cell):
        return self._cell_items.get(obj.id)  # Hash lookup
    # ... etc
```

**Avoid Scene Iteration**: Don't use `scene().items()`
```python
# BAD - O(n) iteration over all items
for item in self.scene().items():
    if item.domain_object == obj:
        return item

# GOOD - O(1) hash lookup
return self._cell_items.get(obj.id)
```

**Animation Performance**:
- Qt's animation framework uses hardware-accelerated rendering
- Scrollbar value changes trigger viewport update (optimized by Qt)
- No custom rendering needed - just update scrollbar values

**Benchmark Targets**:
```
get_object_bounds():     <10ms  (hash lookup + Qt bounds query)
pan_to_center():         <20ms  (scrollbar value update)
_animate_center_on():    <10ms  (setup animation, start async)
Animation execution:     150ms  (configurable, runs in Qt event loop)
```

---

## 5. Risk Analysis

### 5.1 Coordinate System Risk: Incorrect Transformation

**Risk**: Panning centers on wrong location due to coordinate system confusion.

**Impact**: High - User navigates to wrong area, poor UX
**Probability**: Medium - Qt coordinate systems are complex (scene vs view vs viewport)

**Mitigation**:
- Use Qt's `centerOn()` (tested and proven)
- Avoid manual coordinate math where possible
- Widget tests verify panning at different zoom levels
- Visual regression tests (screenshot comparison)

**Testing**:
```python
def test_pan_at_2x_zoom():
    canvas.set_zoom(2.0)
    canvas.pan_to_center(Position(100, 200))

    # Verify center of viewport maps to (100, 200) in scene
    viewport_center = canvas.viewport().rect().center()
    scene_center = canvas.mapToScene(viewport_center)
    assert abs(scene_center.x() - 100) < 1.0
    assert abs(scene_center.y() - 200) < 1.0
```

### 5.2 Animation Risk: Choppy or Janky Motion

**Risk**: Panning animation drops frames, feels laggy.

**Impact**: Medium - Poor UX, unprofessional feel
**Probability**: Low - Qt animation framework is well-optimized

**Mitigation**:
- Use Qt's built-in animation (GPU-accelerated)
- Use lightweight easing curve (`InOutQuad`, not complex curves)
- Avoid expensive operations during animation (no re-layout)
- Test on lower-end hardware (minimum spec: Intel HD Graphics 4000)

**Performance Monitoring**:
```python
def test_animation_frame_rate():
    # Record frame times during animation
    frame_times = []

    def on_frame():
        frame_times.append(time.time())

    timer = QTimer()
    timer.timeout.connect(on_frame)
    timer.start(16)  # 60 FPS = 16.67ms per frame

    canvas.pan_to_center(Position(1000, 1000), animate=True)

    # Wait for animation to complete
    QTest.qWait(200)

    # Verify frame rate
    frame_deltas = [t2 - t1 for t1, t2 in zip(frame_times, frame_times[1:])]
    assert max(frame_deltas) < 0.033  # No frame should take >33ms (30 FPS min)
```

### 5.3 State Risk: Animation Interrupted

**Risk**: User triggers new pan while animation in progress, causing visual glitches.

**Impact**: Low - Brief visual hiccup, no data corruption
**Probability**: Medium - User may rapidly click multiple search results

**Mitigation**:
- Stop previous animation before starting new one
- Store animation references to prevent garbage collection
- Qt animation framework handles cleanup

**Implementation**:
```python
def _animate_center_on(self, scene_point: QPointF, duration_ms: int):
    # Stop any existing animation
    if self._h_anim:
        self._h_anim.stop()
    if self._v_anim:
        self._v_anim.stop()

    # Create new animations
    self._h_anim = QPropertyAnimation(...)
    self._v_anim = QPropertyAnimation(...)

    # Start new animations
    self._h_anim.start()
    self._v_anim.start()
```

### 5.4 Mapping Risk: Object-to-Item Desync

**Risk**: Object-to-item mapping becomes stale (items deleted but not removed from map).

**Impact**: Medium - `get_object_bounds()` returns bounds for wrong object or crashes
**Probability**: Low - If item lifecycle properly managed

**Mitigation**:
- Clear mapping when scene cleared
- Remove entries when items deleted (collapse operation)
- Use weak references if Qt supports (check documentation)
- Validation mode: assert item still in scene

**Lifecycle Hooks**:
```python
def clear_scene(self):
    self.scene().clear()
    # Clear all mappings
    self._cell_items.clear()
    self._pin_items.clear()
    self._net_items.clear()
    self._port_items.clear()

def remove_cell(self, cell: Cell):
    item = self._cell_items.get(cell.id)
    if item:
        self.scene().removeItem(item)
        del self._cell_items[cell.id]  # Remove mapping
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**BoundingBox Geometric Tests** (`tests/unit/domain/value_objects/test_position.py`):
```python
def test_bounding_box_center():
    bbox = BoundingBox(min_x=0, min_y=0, max_x=100, max_y=200)
    center = bbox.center()
    assert center.x == 50
    assert center.y == 100

def test_bounding_box_width_height():
    bbox = BoundingBox(min_x=10, min_y=20, max_x=110, max_y=120)
    assert bbox.width() == 100
    assert bbox.height() == 100

def test_bounding_box_zero_size():
    bbox = BoundingBox(min_x=50, min_y=50, max_x=50, max_y=50)
    assert bbox.width() == 0
    assert bbox.height() == 0
    assert bbox.center() == Position(50, 50)
```

### 6.2 Widget Testing

**Object Bounds Tests** (`tests/ui/canvas/test_schematic_canvas_pan.py`):
```python
def test_get_object_bounds_returns_correct_rect(qtbot):
    canvas = SchematicCanvas()
    cell = Cell(id="U1", name="U1")

    # Create and register mock item
    item = QGraphicsRectItem(0, 0, 100, 50)
    canvas._cell_items[cell.id] = item
    canvas.scene().addItem(item)

    # Get bounds
    bounds = canvas.get_object_bounds(cell)
    assert bounds.width() == 100
    assert bounds.height() == 50

def test_get_object_bounds_returns_none_for_unrendered(qtbot):
    canvas = SchematicCanvas()
    cell = Cell(id="U1", name="U1")

    # Cell not registered
    bounds = canvas.get_object_bounds(cell)
    assert bounds is None
```

**Panning Tests**:
```python
def test_pan_to_center_instant(qtbot):
    canvas = SchematicCanvas()
    canvas.show()
    qtbot.addWidget(canvas)

    # Pan to point
    canvas.pan_to_center(Position(500, 300), animate=False)

    # Verify viewport centered on target
    viewport_center = canvas.viewport().rect().center()
    scene_center = canvas.mapToScene(viewport_center)
    assert abs(scene_center.x() - 500) < 5.0
    assert abs(scene_center.y() - 300) < 5.0

def test_pan_to_center_animated(qtbot):
    canvas = SchematicCanvas()
    canvas.show()
    qtbot.addWidget(canvas)

    # Start position
    start_center = canvas.mapToScene(canvas.viewport().rect().center())

    # Animate pan
    canvas.pan_to_center(Position(1000, 1000), animate=True, duration_ms=100)

    # Wait for animation to complete
    qtbot.wait(150)

    # Verify end position
    end_center = canvas.mapToScene(canvas.viewport().rect().center())
    assert abs(end_center.x() - 1000) < 5.0
    assert abs(end_center.y() - 1000) < 5.0

def test_pan_to_object(qtbot):
    canvas = SchematicCanvas()
    cell = Cell(id="U1", name="U1")

    # Register item at specific location
    item = QGraphicsRectItem(100, 200, 50, 30)
    canvas._cell_items[cell.id] = item
    canvas.scene().addItem(item)

    # Pan to object
    canvas.pan_to_object(cell, animate=False)

    # Verify centered on object's center (125, 215)
    viewport_center = canvas.viewport().rect().center()
    scene_center = canvas.mapToScene(viewport_center)
    assert abs(scene_center.x() - 125) < 5.0
    assert abs(scene_center.y() - 215) < 5.0
```

### 6.3 Integration Testing

**End-to-End Navigation** (`tests/integration/ui/test_navigation_flow.py`):
```python
def test_navigate_and_pan_to_cell(qtbot):
    # Setup
    app = create_test_app()
    canvas = app.main_window.canvas
    navigator = app.navigator

    # Load design
    design = load_test_design("counter.ckt")

    # Navigate to cell
    result = navigator.navigate_to("U1")
    assert result.success

    # Pan to navigated object
    canvas.pan_to_object(result.object, animate=False)

    # Verify cell is centered
    viewport_center = canvas.viewport().rect().center()
    scene_center = canvas.mapToScene(viewport_center)

    cell_bounds = canvas.get_object_bounds(result.object)
    cell_center = cell_bounds.center()

    assert abs(scene_center.x() - cell_center.x) < 5.0
    assert abs(scene_center.y() - cell_center.y) < 5.0
```

### 6.4 Performance Testing

**Timing Benchmarks** (`tests/performance/test_pan_performance.py`):
```python
@pytest.mark.benchmark
def test_get_object_bounds_performance(benchmark, qtbot):
    canvas = create_test_canvas_with_items(100)  # 100 items
    cell = get_test_cell()

    result = benchmark(canvas.get_object_bounds, cell)
    assert benchmark.stats.mean < 0.01  # <10ms

@pytest.mark.benchmark
def test_pan_instant_performance(benchmark, qtbot):
    canvas = create_test_canvas()

    result = benchmark(canvas.pan_to_center, Position(1000, 1000), animate=False)
    assert benchmark.stats.mean < 0.02  # <20ms
```

---

## 7. Definition of Done

### 7.1 Functionality Criteria

- [ ] `get_object_bounds()` returns correct bounding box for rendered objects
- [ ] `get_object_bounds()` returns `None` for non-rendered objects
- [ ] `pan_to_center()` centers viewport on target point (instant mode)
- [ ] `pan_to_center()` animates smoothly to target point (animated mode)
- [ ] `pan_to_object()` convenience method works for all object types
- [ ] Animation uses `InOutQuad` easing
- [ ] Animation duration is configurable (default 150ms)
- [ ] Panning works correctly at different zoom levels (1x, 2x, 0.5x)
- [ ] Object-to-item mapping maintained during rendering
- [ ] Rapid sequential pans stop previous animation gracefully

### 7.2 Performance Criteria

- [ ] `get_object_bounds()` completes in <10ms
- [ ] `pan_to_center()` (instant) completes in <20ms
- [ ] Animation setup completes in <10ms
- [ ] Animation runs at 60 FPS (no frame drops)
- [ ] Animation completes in configured duration (±10ms)

### 7.3 Quality Criteria

**Test Coverage**:
- [ ] Unit tests for `BoundingBox` geometric methods
- [ ] Widget tests for all panning modes
- [ ] Tests for all object types (Cell, Pin, Net, Port)
- [ ] Tests for edge cases (non-rendered, zero-size, boundary)
- [ ] Performance benchmarks pass

**Code Quality**:
- [ ] Type hints on all public methods
- [ ] Docstrings for all public methods
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Qt best practices followed (proper coordinate transformations)

### 7.4 Integration Criteria

**With Domain Layer**:
- [ ] `BoundingBox.center()`, `width()`, `height()` implemented
- [ ] Value object methods have unit tests

**With Presentation Layer**:
- [ ] Graphics items registered in mapping on creation
- [ ] Mapping cleared when scene cleared
- [ ] All graphics item types supported (Cell, Pin, Net, Port)

**With Application Layer**:
- [ ] Task E05-F04-T01 can use `pan_to_object()` for navigation
- [ ] Task E05-F04-T03 can coordinate pan + zoom operations

---

## 8. Open Questions

### 8.1 Technical Questions

**Q1**: Should we use parallel animations or sequential for H/V scrollbars?
**Answer**: Parallel - both axes should animate simultaneously for natural diagonal motion.

**Q2**: How to handle panning during active user scrolling?
**Answer**: Stop user scrolling (take control of scrollbars). Animation supersedes manual scroll.

**Q3**: Should animation be interruptible?
**Answer**: Yes - new pan stops previous animation. User always has control.

**Q4**: Should we cache object bounds?
**Answer**: No - Qt already caches `sceneBoundingRect()`. Additional caching adds complexity.

### 8.2 UX Questions

**Q1**: Should animation speed vary with distance?
**Answer**: No for MVP - fixed 150ms feels consistent. Consider distance-based duration in P1.

**Q2**: Should we preview pan destination before animating?
**Answer**: No - animation itself is the preview. Instant feedback on click.

**Q3**: Should large pans (off-screen targets) use different animation?
**Answer**: No for MVP - same animation. May add "jump cut" for very large distances in P1.

### 8.3 Product Questions

**Q1**: Priority for edge smoothing (objects at canvas boundaries)?
**Answer**: P0 - Qt handles this automatically via scrollbar clamping. No special code needed.

**Q2**: Should pan be undoable?
**Answer**: No - viewport changes are not data changes. Undo applies to expansion/selection only.

---

## 9. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/T02/E05-F04-T02.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/E05-F04.spec.md`
- **Related Tasks**:
  - E05-F04-T01: Navigation Service (provides object to pan to)
  - E05-F04-T03: Zoom to Fit Object (combines pan + zoom)
- **Qt Documentation**:
  - `QGraphicsView` coordinate systems
  - `QPropertyAnimation` API
  - Easing curves

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
