---
id: E05-F04-T03
title: Zoom to Fit Object
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F04
created: 2025-12-26
estimated_hours: 5
actual_hours:
effort: Medium
tags:
  - presentation
  - canvas
  - viewport
  - zoom
---

# Spec: E05-F04-T03 - Zoom to Fit Object

## 1. Overview

### 1.1 Problem Statement
Implement automatic zoom functionality to fit a target object in the viewport at an optimal size with configurable margin. The zoom must calculate the appropriate scale factor to show the object clearly without filling the entire viewport, maintaining context around the object.

### 1.2 Goals
- Calculate zoom scale to fit object bounding box in viewport
- Apply configurable margin around object (default 20%)
- Clamp zoom to min/max limits (avoid extreme zoom levels)
- Support optional smooth animation (150ms transition)
- Maintain aspect ratio during zoom
- Complete zoom operation in < 50ms (excluding animation)

---

## 2. Technical Requirements

### 2.1 Zoom to Fit Implementation

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

**Implementation**:
```python
from typing import Optional
from PySide6.QtCore import QRectF, QPropertyAnimation, QEasingCurve
from PySide6.QtWidgets import QGraphicsView

from ink.domain.value_objects.position import BoundingBox


class SchematicCanvas(QGraphicsView):
    """Schematic canvas with zoom to fit functionality"""

    # Zoom limits (factor relative to 1.0 = 100%)
    MIN_ZOOM = 0.01   # 1% - very zoomed out
    MAX_ZOOM = 100.0  # 10000% - very zoomed in
    DEFAULT_ZOOM = 1.0

    def __init__(self, parent=None):
        super().__init__(parent)
        self._zoom_level: float = self.DEFAULT_ZOOM
        self._zoom_animation: Optional[QPropertyAnimation] = None
        # ... existing initialization ...

    def zoom_to_fit(
        self,
        bbox: BoundingBox,
        margin: float = 0.2,
        animate: bool = True,
        duration_ms: int = 150
    ) -> None:
        """
        Zoom to fit bounding box in viewport with margin.

        Args:
            bbox: Object bounding box in scene coordinates
            margin: Margin around object (0.0-1.0, default 20%)
            animate: If True, animate zoom transition
            duration_ms: Animation duration in milliseconds
        """
        # Calculate target zoom to fit bbox in viewport
        target_zoom = self._calculate_zoom_to_fit(bbox, margin)

        # Clamp to min/max zoom limits
        target_zoom = max(self.MIN_ZOOM, min(self.MAX_ZOOM, target_zoom))

        # Apply zoom
        if animate:
            self._animate_zoom_to(target_zoom, duration_ms)
        else:
            self._set_zoom(target_zoom)

    def zoom_to_fit_object(
        self,
        obj,
        margin: float = 0.2,
        animate: bool = True,
        duration_ms: int = 150
    ) -> None:
        """
        Zoom to fit object in viewport.

        Convenience method combining get_object_bounds() and zoom_to_fit().

        Args:
            obj: Domain entity to zoom to
            margin: Margin around object (0.0-1.0)
            animate: If True, animate zoom transition
            duration_ms: Animation duration
        """
        bounds = self.get_object_bounds(obj)
        if bounds is None:
            self._logger.warning(f"Cannot zoom to object: not rendered on canvas")
            return

        self.zoom_to_fit(bounds, margin=margin, animate=animate, duration_ms=duration_ms)

    def _calculate_zoom_to_fit(self, bbox: BoundingBox, margin: float) -> float:
        """
        Calculate zoom level to fit bounding box in viewport.

        Algorithm:
        1. Get viewport dimensions
        2. Calculate bbox dimensions with margin
        3. Calculate scale factors for width and height
        4. Use minimum (most restrictive) scale factor
        5. Return zoom level relative to current zoom

        Args:
            bbox: Bounding box in scene coordinates
            margin: Margin percentage (0.0-1.0)

        Returns:
            Target zoom level (1.0 = 100%)
        """
        # Get viewport size in pixels
        viewport_rect = self.viewport().rect()
        viewport_width = viewport_rect.width()
        viewport_height = viewport_rect.height()

        # Calculate bbox size with margin
        bbox_width = bbox.width()
        bbox_height = bbox.height()

        # Add margin (e.g., 20% margin means object takes 80% of viewport)
        margin_multiplier = 1.0 + (2.0 * margin)  # margin on both sides
        target_width = bbox_width * margin_multiplier
        target_height = bbox_height * margin_multiplier

        # Calculate scale factors to fit in viewport
        # (how much to scale scene to fit in viewport)
        if target_width == 0 or target_height == 0:
            return self._zoom_level  # Keep current zoom

        scale_x = viewport_width / target_width
        scale_y = viewport_height / target_height

        # Use minimum scale (most restrictive) to ensure both dimensions fit
        scale = min(scale_x, scale_y)

        # Convert scale to zoom level
        # (scale is relative to scene, zoom is absolute)
        return scale

    def _set_zoom(self, zoom_level: float) -> None:
        """
        Set zoom level without animation.

        Uses QGraphicsView.resetTransform() and scale() for zoom.

        Args:
            zoom_level: Target zoom (1.0 = 100%)
        """
        # Calculate scale factor relative to default (1.0)
        scale_factor = zoom_level / self._zoom_level

        # Apply scale transformation
        self.scale(scale_factor, scale_factor)

        # Update current zoom level
        self._zoom_level = zoom_level

    def _animate_zoom_to(self, target_zoom: float, duration_ms: int) -> None:
        """
        Animate zoom transition.

        Note: QGraphicsView doesn't have a built-in zoom property,
        so we need to create a custom animation or use QVariantAnimation.

        Args:
            target_zoom: Target zoom level
            duration_ms: Animation duration
        """
        # Stop any existing zoom animation
        if self._zoom_animation:
            self._zoom_animation.stop()

        # Create custom zoom animation
        self._zoom_animation = QPropertyAnimation(self, b"zoom_property")
        self._zoom_animation.setDuration(duration_ms)
        self._zoom_animation.setStartValue(self._zoom_level)
        self._zoom_animation.setEndValue(target_zoom)
        self._zoom_animation.setEasingCurve(QEasingCurve.Type.InOutQuad)

        # Connect to apply zoom during animation
        self._zoom_animation.valueChanged.connect(self._apply_zoom_step)
        self._zoom_animation.start()

    def _apply_zoom_step(self, value: float) -> None:
        """
        Apply incremental zoom during animation.

        Called by animation framework for each animation step.

        Args:
            value: Current zoom level from animation
        """
        # Calculate incremental scale factor
        scale_factor = value / self._zoom_level

        # Apply incremental scale
        self.scale(scale_factor, scale_factor)

        # Update zoom level
        self._zoom_level = value

    # Property for Qt animation system
    def _get_zoom_property(self) -> float:
        """Get current zoom level (for Qt property animation)"""
        return self._zoom_level

    def _set_zoom_property(self, value: float) -> None:
        """Set zoom level (for Qt property animation)"""
        self._apply_zoom_step(value)

    zoom_property = property(_get_zoom_property, _set_zoom_property)

    def get_zoom_level(self) -> float:
        """Get current zoom level (1.0 = 100%)"""
        return self._zoom_level

    def set_zoom_level(self, zoom: float, animate: bool = False) -> None:
        """
        Set absolute zoom level.

        Args:
            zoom: Target zoom level (1.0 = 100%)
            animate: If True, animate transition
        """
        zoom = max(self.MIN_ZOOM, min(self.MAX_ZOOM, zoom))

        if animate:
            self._animate_zoom_to(zoom, 150)
        else:
            self._set_zoom(zoom)

    def zoom_in(self, factor: float = 1.2) -> None:
        """Zoom in by factor (default 20%)"""
        new_zoom = self._zoom_level * factor
        self.set_zoom_level(new_zoom)

    def zoom_out(self, factor: float = 1.2) -> None:
        """Zoom out by factor (default 20%)"""
        new_zoom = self._zoom_level / factor
        self.set_zoom_level(new_zoom)

    def zoom_reset(self) -> None:
        """Reset zoom to 100%"""
        self.set_zoom_level(self.DEFAULT_ZOOM, animate=True)
```

### 2.2 Zoom Limits Configuration

**Configurable Constants**:
- `MIN_ZOOM = 0.01` (1% - view entire large design)
- `MAX_ZOOM = 100.0` (10000% - inspect individual pins)
- `DEFAULT_ZOOM = 1.0` (100% - normal view)

**Rationale**:
- Min zoom: Supports very large netlists (1000s of cells)
- Max zoom: Allows detailed inspection of pin-level connections
- Limits prevent infinite zoom and numerical instability

### 2.3 Performance Requirements

| Operation | Target | Notes |
|-----------|--------|-------|
| Calculate zoom level | < 10ms | Simple arithmetic on bbox |
| Apply zoom (no animation) | < 20ms | Qt transform update |
| Zoom animation | 150ms | Animation duration |
| Zoom + pan combined | < 200ms | Sequential operations |

---

## 3. Dependencies

### 3.1 Upstream
- Task E05-F04-T02: Provides `get_object_bounds()` method
- Domain value objects: `BoundingBox` with `width()`, `height()` methods

### 3.2 Downstream
- Task E05-F04-T01: Navigator service combines pan + zoom for navigation
- E06 (Viewport Control): Uses zoom methods for user-triggered zoom

### 3.3 External Dependencies
- PySide6: `QGraphicsView` transformation system, `QPropertyAnimation`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `zoom_to_fit()` calculates correct zoom for bounding box + margin
- [ ] Default margin is 20% (object occupies 60% of viewport width/height)
- [ ] Margin configurable from 0.0 (no margin) to 1.0 (100% margin)
- [ ] Zoom uses minimum of width/height scale (both dimensions fit)
- [ ] Zoom clamped to MIN_ZOOM and MAX_ZOOM limits
- [ ] `zoom_to_fit_object()` convenience method works for all object types
- [ ] Zoom maintains aspect ratio (no stretching)
- [ ] Optional animation with configurable duration
- [ ] Animation uses `InOutQuad` easing
- [ ] `zoom_in()`, `zoom_out()` methods for incremental zoom
- [ ] `zoom_reset()` returns to 100% zoom

### 4.2 Edge Cases
- [ ] Handle zero-size bounding box (keep current zoom)
- [ ] Handle bbox larger than viewport (zoom out to fit)
- [ ] Handle bbox smaller than viewport (zoom in with margin)
- [ ] Handle very large zoom factors (clamp to MAX_ZOOM)
- [ ] Handle very small zoom factors (clamp to MIN_ZOOM)
- [ ] Handle rapid sequential zoom requests (stop previous animation)

### 4.3 Performance
- [ ] Calculate zoom level in < 10ms
- [ ] Apply zoom without animation in < 20ms
- [ ] Animation completes in 150ms (configurable)
- [ ] Combined pan + zoom in < 200ms (excluding animation)
- [ ] No frame drops during animation (60 FPS)

### 4.4 Testing
- [ ] Unit tests for `_calculate_zoom_to_fit()` with various bbox sizes
- [ ] Test margin calculations (0%, 20%, 50%, 100%)
- [ ] Test zoom clamping (below MIN_ZOOM, above MAX_ZOOM)
- [ ] Widget tests for `zoom_to_fit()` and `zoom_to_fit_object()`
- [ ] Test zoom maintains aspect ratio
- [ ] Test animation behavior (start, stop, duration)
- [ ] Test incremental zoom (zoom_in, zoom_out)
- [ ] Performance tests with timing assertions
- [ ] Visual regression test for smooth zoom animation

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why margin parameter instead of fixed zoom?**
- Provides context around object (not just object pixels)
- 20% margin feels natural (object clearly visible but not cramped)
- Configurable for different use cases (detailed vs overview)

**Why minimum of width/height scale?**
- Ensures object fully fits in viewport (both dimensions)
- Using maximum would crop object in one dimension
- Maintains aspect ratio (no distortion)

**Why clamp to MIN_ZOOM/MAX_ZOOM?**
- Prevents infinite zoom (numerical instability)
- Protects against extreme zoom (unreadable or performance issues)
- Provides consistent user experience

**Why animate zoom?**
- Helps user track viewport change (not disorienting)
- Smoother perceived motion than instant jump
- Optional for programmatic/batch operations

### 5.2 Qt Zoom Implementation

**QGraphicsView zoom approaches**:
1. **Transform-based** (used here): `scale(sx, sy)` on view
2. **Scene rect-based**: Adjust `sceneRect()` and `fitInView()`
3. **Matrix-based**: Direct `QTransform` manipulation

**Chosen approach**: Transform-based
- Most direct control over zoom level
- Easy to track absolute zoom factor
- Works well with panning

### 5.3 Zoom Property Animation

Qt's `QPropertyAnimation` requires a Q_PROPERTY. Two approaches:
1. **Custom property** (used here): Define getter/setter for `zoom_property`
2. **QVariantAnimation**: Manually interpolate zoom values

**Chosen approach**: Custom property
- Cleaner API (consistent with Qt patterns)
- Reusable for other zoom animations

### 5.4 Testing Strategy

**Unit Tests** (`tests/unit/presentation/canvas/test_zoom_calculations.py`):
- Test `_calculate_zoom_to_fit()` with various bbox sizes
- Test margin calculations
- Test zoom clamping logic
- Mock viewport rect for deterministic results

**Widget Tests** (`tests/ui/canvas/test_schematic_canvas_zoom.py`):
- Create `SchematicCanvas` with test scene
- Add objects of known size
- Verify zoom transformation applied correctly
- Measure animation duration

**Visual Tests** (manual or screenshot comparison):
- Verify smooth animation
- Check margin looks correct visually
- Test at various object sizes

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F04 split |
