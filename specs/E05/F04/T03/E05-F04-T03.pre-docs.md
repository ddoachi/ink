# E05-F04-T03 - Zoom to Fit Object: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F04-T03 - Zoom to Fit Object
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

E05-F04-T03 implements automatic zoom functionality to fit a target object in the viewport at an optimal size with configurable margin. The zoom system calculates appropriate scale factors to show objects clearly without filling the entire viewport, maintaining visual context around the object. This capability completes the search-to-schematic workflow, ensuring users can not only locate but also optimally view search results.

The implementation builds on Qt's transformation system and provides both instant and animated zoom modes with careful attention to maintaining aspect ratio and preventing extreme zoom levels.

### 1.2 Core Capabilities

The task delivers these primary capabilities:

1. **Zoom Scale Calculation**: Compute optimal zoom level to fit bounding box in viewport with margin
2. **Margin Support**: Configurable margin around object (default 20% on each side)
3. **Zoom Clamping**: Enforce min/max zoom limits to prevent unusable views
4. **Aspect Ratio Preservation**: Maintain correct proportions during zoom (no stretching)
5. **Smooth Animation**: Optional animated zoom transition with easing
6. **Incremental Zoom Controls**: Zoom in/out by factor, reset to 100%
7. **Zoom Level Tracking**: Maintain absolute zoom level for UI display

### 1.3 Success Metrics

- Calculate zoom level in <10ms
- Apply instant zoom in <20ms
- Animated zoom completes in 150ms (configurable)
- Combined pan + zoom in <200ms (excluding animation)
- Smooth 60 FPS animation with no frame drops
- Zoom works correctly at all scale levels (0.01x to 100x)

---

## 2. Architecture Decisions

### 2.1 Separate zoom_to_fit() and zoom_to_fit_object()

**Decision**: Provide two methods - low-level `zoom_to_fit(bbox)` and high-level `zoom_to_fit_object(obj)`.

**Rationale**:
- `zoom_to_fit()` is generic, works with any bounding box (e.g., selection bounds, custom region)
- `zoom_to_fit_object()` is convenience wrapper for common use case
- Separation allows testing zoom calculation independently from object lookup
- Matches pattern from pan_to_center() / pan_to_object()

**Alternatives Considered**:
- **Single zoom_to_fit_object() only**: Rejected - doesn't support zooming to arbitrary regions
- **Single zoom_to_fit() only**: Rejected - inconvenient API (callers must always get bounds manually)

**Implementation**:
```python
def zoom_to_fit(self, bbox: BoundingBox, margin: float = 0.2, animate: bool = True) -> None:
    """Low-level: zoom to fit bounding box"""

def zoom_to_fit_object(self, obj, margin: float = 0.2, animate: bool = True) -> None:
    """High-level: zoom to fit object (calls zoom_to_fit internally)"""
    bounds = self.get_object_bounds(obj)
    if bounds:
        self.zoom_to_fit(bounds, margin, animate)
```

**Trade-offs**:
- **Pro**: Flexible API supports multiple use cases
- **Pro**: Easier to test calculation logic separately
- **Con**: Two methods to document (minimal cost)

### 2.2 Configurable Margin

**Decision**: Support configurable margin parameter (default 20%).

**Rationale**:
- **Context visibility**: Margin ensures object doesn't fill entire viewport (claustrophobic)
- **Visual breathing room**: 20% margin feels natural (object clearly visible but not cramped)
- **Flexibility**: Different use cases need different margins:
  - Detailed inspection: 10% margin (maximize object size)
  - Overview: 30% margin (show more context)
  - Screenshot export: 5% margin (minimize whitespace)

**Alternatives Considered**:
- **Fixed margin**: Rejected - reduces flexibility
- **Separate width/height margins**: Over-engineered for MVP, deferred

**Default**: 20% margin (0.2) based on UX best practices

**Calculation**:
```python
# 20% margin means object occupies 60% of viewport
# (20% margin on each side: left, right, top, bottom)
margin_multiplier = 1.0 + (2.0 * margin)  # Both sides
target_width = bbox.width() * margin_multiplier
```

**Trade-offs**:
- **Pro**: Flexibility for different use cases
- **Pro**: Prevents object from touching viewport edges (better aesthetics)
- **Con**: One more parameter to document (but has sensible default)

### 2.3 Zoom Limits (MIN_ZOOM, MAX_ZOOM)

**Decision**: Clamp zoom to 0.01x (1%) minimum and 100x (10000%) maximum.

**Rationale**:
- **Min zoom (0.01x)**: Support viewing very large designs (10,000+ cells at once)
  - 0.01x means viewport shows 100x more area
  - Prevents infinite zoom-out (numerical instability)
- **Max zoom (100x)**: Enable detailed pin-level inspection
  - 100x means 1 pixel in design becomes 100 pixels on screen
  - Prevents infinite zoom-in (pixel artifacts, performance issues)

**Alternatives Considered**:
- **Wider limits (0.001x - 1000x)**: Rejected - extreme zooms are unusable, just add bugs
- **Tighter limits (0.1x - 10x)**: Rejected - insufficient range for large designs and detailed inspection

**Configurable**: Limits are class constants, can be overridden for special cases

**Trade-offs**:
- **Pro**: Prevents unusable zoom levels (blank screen or pixelated view)
- **Pro**: Protects against numerical instability in Qt transformations
- **Con**: May limit edge cases (extremely large or tiny designs) - acceptable for MVP

### 2.4 Minimum of Width/Height Scale

**Decision**: Use `min(scale_x, scale_y)` to ensure both dimensions fit.

**Rationale**:
- Object must fit entirely in viewport (no cropping)
- If viewport is wider than tall, height may be limiting factor (or vice versa)
- Minimum scale ensures both width and height fit
- Preserves aspect ratio (no stretching)

**Alternatives Considered**:
- **Maximum scale**: Rejected - would crop object in one dimension
- **Average scale**: Rejected - would still crop if aspect ratios differ
- **Separate X/Y scales**: Rejected - would stretch/squash object (breaks aspect ratio)

**Algorithm**:
```python
scale_x = viewport_width / target_width
scale_y = viewport_height / target_height
scale = min(scale_x, scale_y)  # Most restrictive (ensures both fit)
```

**Trade-offs**:
- **Pro**: Guarantees object fully visible
- **Pro**: Maintains aspect ratio (correct proportions)
- **Con**: May leave whitespace in non-limiting dimension (acceptable - needed for margin)

### 2.5 Custom Qt Property for Animation

**Decision**: Create custom `zoom_property` for `QPropertyAnimation`.

**Rationale**:
- Qt's `QGraphicsView` doesn't have built-in zoom property
- `QPropertyAnimation` requires Q_PROPERTY or Python property
- Custom property enables smooth animation via Qt framework

**Alternatives Considered**:
- **QVariantAnimation**: Rejected - requires manual value interpolation (more complex)
- **QTimer loop**: Rejected - harder to achieve smooth 60 FPS, manual easing
- **No animation**: Already supported as `animate=False` option

**Implementation**:
```python
class SchematicCanvas(QGraphicsView):
    def _get_zoom_property(self) -> float:
        return self._zoom_level

    def _set_zoom_property(self, value: float) -> None:
        self._apply_zoom_step(value)

    zoom_property = property(_get_zoom_property, _set_zoom_property)

    def _animate_zoom_to(self, target_zoom: float, duration_ms: int):
        self._zoom_animation = QPropertyAnimation(self, b"zoom_property")
        self._zoom_animation.setStartValue(self._zoom_level)
        self._zoom_animation.setEndValue(target_zoom)
        # Animation framework calls _set_zoom_property() for each frame
```

**Trade-offs**:
- **Pro**: Leverages Qt's animation framework (proven, optimized)
- **Pro**: Automatic interpolation and easing
- **Con**: Requires property boilerplate (but minimal code)

### 2.6 Incremental vs Absolute Zoom

**Decision**: Track absolute zoom level, apply incremental scale transformations.

**Rationale**:
- **Absolute zoom level** (`_zoom_level`): User-facing, displayed in UI (e.g., "200%")
- **Incremental scale**: Qt's `scale(sx, sy)` is relative to current transform
- Track absolute, calculate incremental delta when applying

**Algorithm**:
```python
def _set_zoom(self, zoom_level: float) -> None:
    # Calculate scale factor relative to current zoom
    scale_factor = zoom_level / self._zoom_level

    # Apply incremental scale to existing transform
    self.scale(scale_factor, scale_factor)

    # Update absolute zoom level
    self._zoom_level = zoom_level
```

**Alternatives Considered**:
- **Only track transform**: Rejected - hard to extract absolute zoom for UI display
- **Only track absolute**: Rejected - must still apply incremental for Qt transform
- **Reset transform each time**: Rejected - loses rotation/shear if added later

**Trade-offs**:
- **Pro**: Clean separation (absolute for logic, incremental for Qt)
- **Pro**: Easy to display zoom percentage in UI
- **Con**: Must maintain consistency (but straightforward arithmetic)

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: Zoom Calculation (1.5 hours)**
- Implement `_calculate_zoom_to_fit()` algorithm
- Unit tests for margin calculations
- Unit tests for min/max clamping
- Edge cases: zero-size boxes, very large/small objects

**Phase 2: Zoom Application (1.5 hours)**
- Implement `_set_zoom()` for instant zoom
- Implement zoom level tracking (`_zoom_level`)
- Implement `zoom_in()`, `zoom_out()`, `zoom_reset()` helpers
- Widget tests with real `QGraphicsView`

**Phase 3: Zoom Animation (1.5 hours)**
- Implement `_animate_zoom_to()` with `QPropertyAnimation`
- Implement `zoom_property` getter/setter
- Implement `_apply_zoom_step()` for incremental animation
- Widget tests for animated zoom

**Phase 4: High-Level API (30 minutes)**
- Implement `zoom_to_fit()` method
- Implement `zoom_to_fit_object()` convenience method
- Integration tests combining pan + zoom
- Performance tests with timing assertions

### 3.2 Incremental Deliverables

Each phase produces testable functionality:

1. **Phase 1**: Zoom level can be calculated for arbitrary bounding boxes
2. **Phase 2**: Instant zoom can be applied to canvas
3. **Phase 3**: Zoom can be animated smoothly
4. **Phase 4**: Objects can be zoomed to fit with one method call

### 3.3 Integration Points

**With Domain Layer**:
- `BoundingBox` value object provides `width()`, `height()` methods (from T02)

**With Presentation Layer**:
- `SchematicCanvas` extends with zoom methods
- Graphics items automatically scale with view transform
- Object-to-item mapping used for `zoom_to_fit_object()`

**With Application Layer**:
- Task E05-F04-T01 (Navigation) can combine expand + zoom
- Task E05-F04-T02 (Pan) can coordinate pan + zoom sequence
- E06 (Viewport Control) uses zoom methods for user-triggered zoom

---

## 4. Technical Deep Dive

### 4.1 Zoom to Fit Calculation Algorithm

**Inputs**:
- `bbox`: Object bounding box (width, height)
- `margin`: Percentage margin (0.0 - 1.0)
- `viewport_rect`: Viewport dimensions (pixels)

**Outputs**:
- `zoom_level`: Target zoom (1.0 = 100%)

**Algorithm**:
```python
def _calculate_zoom_to_fit(self, bbox: BoundingBox, margin: float) -> float:
    # 1. Get viewport size in pixels
    viewport_rect = self.viewport().rect()
    viewport_width = viewport_rect.width()
    viewport_height = viewport_rect.height()

    # 2. Calculate bbox size with margin
    bbox_width = bbox.width()
    bbox_height = bbox.height()

    # Add margin (e.g., 20% margin means object takes 60% of viewport)
    # margin on left + right = 2 * margin
    margin_multiplier = 1.0 + (2.0 * margin)
    target_width = bbox_width * margin_multiplier
    target_height = bbox_height * margin_multiplier

    # 3. Handle zero-size bbox
    if target_width == 0 or target_height == 0:
        return self._zoom_level  # Keep current zoom

    # 4. Calculate scale factors to fit in viewport
    scale_x = viewport_width / target_width
    scale_y = viewport_height / target_height

    # 5. Use minimum scale (most restrictive) to ensure both fit
    scale = min(scale_x, scale_y)

    # 6. Clamp to min/max limits
    scale = max(self.MIN_ZOOM, min(self.MAX_ZOOM, scale))

    return scale
```

**Example Calculation**:
```
Viewport: 800x600 pixels
Object bbox: 100x50 scene units
Margin: 20% (0.2)

target_width = 100 * (1 + 2*0.2) = 100 * 1.4 = 140
target_height = 50 * (1 + 2*0.2) = 50 * 1.4 = 70

scale_x = 800 / 140 = 5.71
scale_y = 600 / 70 = 8.57

scale = min(5.71, 8.57) = 5.71

Result: Zoom to 5.71x (571%)
```

### 4.2 Incremental Scale Application

**Challenge**: Qt's `scale()` applies relative to current transform, not absolute.

**Approach**: Calculate incremental scale factor from current to target zoom.

**Algorithm**:
```python
def _set_zoom(self, zoom_level: float) -> None:
    # Current zoom: 1.0 (100%)
    # Target zoom: 2.0 (200%)
    # Scale factor: 2.0 / 1.0 = 2.0
    scale_factor = zoom_level / self._zoom_level

    # Apply scale transformation (relative)
    self.scale(scale_factor, scale_factor)

    # Update tracked zoom level (absolute)
    self._zoom_level = zoom_level
```

**Animated Zoom**:
```python
def _apply_zoom_step(self, value: float) -> None:
    # Called by animation framework for each frame
    # value ranges from start_zoom to end_zoom

    # Calculate incremental scale for this step
    scale_factor = value / self._zoom_level

    # Apply incremental scale
    self.scale(scale_factor, scale_factor)

    # Update zoom level
    self._zoom_level = value
```

**Example Animation**:
```
Start zoom: 1.0 (100%)
End zoom: 2.0 (200%)
Animation frames: 10 steps

Frame 1: value=1.1 → scale(1.1/1.0=1.1) → zoom=1.1
Frame 2: value=1.2 → scale(1.2/1.1=1.09) → zoom=1.2
Frame 3: value=1.3 → scale(1.3/1.2=1.08) → zoom=1.3
...
Frame 10: value=2.0 → scale(2.0/1.9=1.05) → zoom=2.0
```

### 4.3 Aspect Ratio Preservation

**Challenge**: Viewport and object may have different aspect ratios.

**Solution**: Use minimum scale factor (guarantees both dimensions fit).

**Cases**:

1. **Wide object, tall viewport**:
   ```
   Viewport: 600x800 (portrait)
   Object: 200x100 (landscape, aspect=2:1)

   scale_x = 600/200 = 3.0
   scale_y = 800/100 = 8.0
   scale = min(3.0, 8.0) = 3.0  (width limited)

   Result: Object is 600px wide, 300px tall
   Vertical whitespace: 800 - 300 = 500px (centered)
   ```

2. **Tall object, wide viewport**:
   ```
   Viewport: 800x600 (landscape)
   Object: 100x200 (portrait, aspect=1:2)

   scale_x = 800/100 = 8.0
   scale_y = 600/200 = 3.0
   scale = min(8.0, 3.0) = 3.0  (height limited)

   Result: Object is 300px wide, 600px tall
   Horizontal whitespace: 800 - 300 = 500px (centered)
   ```

**Key**: Whitespace in non-limiting dimension is expected and correct.

### 4.4 Edge Cases and Handling

**Case 1: Zero-Size Bounding Box**
```python
if target_width == 0 or target_height == 0:
    return self._zoom_level  # Keep current zoom (nothing to fit)
```

**Case 2: Very Large Object (zoom out)**
```python
# Object: 10000x10000, Viewport: 800x600
scale = min(800/10000, 600/10000) = 0.06 (6%)

# Clamp to MIN_ZOOM if needed
scale = max(0.01, 0.06) = 0.06  # OK, within limits
```

**Case 3: Very Small Object (zoom in)**
```python
# Object: 1x1, Viewport: 800x600
scale = min(800/1, 600/1) = 600 (60000%)

# Clamp to MAX_ZOOM
scale = min(600, 100.0) = 100.0  # Clamped to max
```

**Case 4: Negative Coordinates** (object in negative scene space)
```python
# BoundingBox handles negative coords correctly
bbox = BoundingBox(min_x=-100, min_y=-50, max_x=0, max_y=50)
bbox.width() = 0 - (-100) = 100  # Correct
bbox.height() = 50 - (-50) = 100  # Correct
```

### 4.5 Performance Optimization

**Zoom Calculation**: Pure arithmetic, <1ms
```python
# 7 operations: 2 multiplies, 2 divides, 2 min/max, 1 range check
# Modern CPU: ~10-20 nanoseconds each
# Total: <200 nanoseconds
```

**Zoom Application**: Single Qt transform update
```python
# Qt's scale() is highly optimized (GPU-accelerated)
# Typical time: 5-10ms for scene update
```

**Animation Performance**:
- Animation framework runs in Qt event loop (separate thread)
- Each frame updates transform (same cost as instant zoom)
- 60 FPS = 16.67ms per frame budget
- Transform update takes 5-10ms → plenty of headroom

**Benchmark Targets**:
```
_calculate_zoom_to_fit(): <10ms (generous, actual <<1ms)
_set_zoom():               <20ms (transform + scene update)
_animate_zoom_to():        <10ms (setup animation)
Animation execution:       150ms (configurable duration)
```

---

## 5. Risk Analysis

### 5.1 Numerical Stability Risk: Extreme Zoom Levels

**Risk**: Very large or small zoom factors cause numerical instability in Qt transformations.

**Impact**: High - Rendering artifacts, crashes, NaN values
**Probability**: Low - Zoom limits prevent extreme values

**Mitigation**:
- Enforce MIN_ZOOM (0.01x) and MAX_ZOOM (100x) limits
- Test at boundary conditions (0.01x and 100x)
- Validate transform matrix after zoom (detect NaN/infinity)

**Validation**:
```python
def _set_zoom(self, zoom_level: float) -> None:
    # Clamp before applying
    zoom_level = max(self.MIN_ZOOM, min(self.MAX_ZOOM, zoom_level))

    scale_factor = zoom_level / self._zoom_level
    self.scale(scale_factor, scale_factor)

    # Validate transform
    m = self.transform()
    if math.isnan(m.m11()) or math.isinf(m.m11()):
        self._logger.error("Transform became invalid, resetting")
        self.resetTransform()
        self._zoom_level = 1.0
    else:
        self._zoom_level = zoom_level
```

### 5.2 Animation Risk: Transform Accumulation Error

**Risk**: Repeated incremental scale operations accumulate floating-point error.

**Impact**: Medium - Zoom level drifts from target (e.g., target 2.0x, actual 2.0001x)
**Probability**: Low - Single animation has limited steps (~10 frames)

**Mitigation**:
- Use double precision (`float`) for zoom level
- Reset transform periodically (not feasible - loses position)
- Accept small error (<0.1%) as tolerable

**Measurement**:
```python
def test_zoom_animation_accuracy():
    canvas.set_zoom(1.0)
    canvas.zoom_to_fit(bbox, animate=True)
    # Wait for animation
    time.sleep(0.2)

    # Target zoom (calculated): 2.5
    actual_zoom = canvas.get_zoom_level()
    assert abs(actual_zoom - 2.5) < 0.01  # <1% error acceptable
```

### 5.3 UX Risk: Disorienting Zoom

**Risk**: Sudden zoom without panning disorients user (object moves off-screen).

**Impact**: Medium - Poor UX, user must manually pan to find object
**Probability**: High - Zoom changes object position in viewport if not centered first

**Mitigation**:
- **Recommend**: Pan before zoom in navigation workflow
- **Sequence**: 1) Pan to center object, 2) Zoom to fit object
- **Alternative**: Zoom around object center (requires custom transform origin)

**Recommended Workflow**:
```python
# In navigation handler
result = navigator.navigate_to("U1")
if result.success:
    canvas.pan_to_object(result.object, animate=True)  # Step 1: Center
    canvas.zoom_to_fit_object(result.object, animate=True)  # Step 2: Zoom
```

**Custom Transform Origin** (P1 enhancement):
```python
# Zoom around object center instead of viewport center
def zoom_to_fit_centered(self, obj):
    bounds = self.get_object_bounds(obj)
    center = bounds.center()

    # Set transform origin to object center
    self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
    # ... apply zoom ...
    # Reset transform origin
    self.setTransformationAnchor(QGraphicsView.AnchorViewCenter)
```

### 5.4 Performance Risk: Large Scene Updates

**Risk**: Zooming triggers re-layout or expensive rendering updates.

**Impact**: Medium - Slow zoom, animation drops frames
**Probability**: Low - Qt's scene graph is optimized for transforms

**Mitigation**:
- Use Qt's built-in optimization (scene caching, viewport updates)
- Disable expensive rendering during animation (e.g., anti-aliasing)
- Profile zoom performance on large scenes (1000+ items)

**Optimization**:
```python
def _animate_zoom_to(self, target_zoom: float, duration_ms: int):
    # Disable anti-aliasing during animation
    self.setRenderHint(QPainter.Antialiasing, False)

    self._zoom_animation = QPropertyAnimation(...)
    self._zoom_animation.finished.connect(self._restore_render_hints)
    self._zoom_animation.start()

def _restore_render_hints(self):
    # Re-enable after animation
    self.setRenderHint(QPainter.Antialiasing, True)
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Zoom Calculation Tests** (`tests/unit/presentation/canvas/test_zoom_calculations.py`):
```python
def test_calculate_zoom_to_fit_basic():
    # Viewport 800x600, Object 100x50, Margin 20%
    canvas = create_mock_canvas(viewport_size=(800, 600))
    bbox = BoundingBox(min_x=0, min_y=0, max_x=100, max_y=50)

    zoom = canvas._calculate_zoom_to_fit(bbox, margin=0.2)

    # Expected: min(800/140, 600/70) = min(5.71, 8.57) = 5.71
    assert abs(zoom - 5.71) < 0.01

def test_calculate_zoom_respects_margin():
    canvas = create_mock_canvas(viewport_size=(1000, 1000))
    bbox = BoundingBox(min_x=0, min_y=0, max_x=100, max_y=100)

    # No margin: object fills viewport
    zoom_no_margin = canvas._calculate_zoom_to_fit(bbox, margin=0.0)
    assert abs(zoom_no_margin - 10.0) < 0.01  # 1000/100 = 10

    # 50% margin: object takes 50% of viewport
    zoom_margin = canvas._calculate_zoom_to_fit(bbox, margin=0.5)
    assert abs(zoom_margin - 5.0) < 0.01  # 1000/200 = 5

def test_calculate_zoom_clamps_to_min():
    canvas = create_mock_canvas(viewport_size=(100, 100))
    bbox = BoundingBox(min_x=0, min_y=0, max_x=100000, max_y=100000)

    zoom = canvas._calculate_zoom_to_fit(bbox, margin=0.2)
    assert zoom == canvas.MIN_ZOOM  # Clamped to 0.01

def test_calculate_zoom_clamps_to_max():
    canvas = create_mock_canvas(viewport_size=(10000, 10000))
    bbox = BoundingBox(min_x=0, min_y=0, max_x=1, max_y=1)

    zoom = canvas._calculate_zoom_to_fit(bbox, margin=0.2)
    assert zoom == canvas.MAX_ZOOM  # Clamped to 100.0

def test_calculate_zoom_zero_size_bbox():
    canvas = create_mock_canvas(viewport_size=(800, 600))
    bbox = BoundingBox(min_x=50, min_y=50, max_x=50, max_y=50)

    zoom = canvas._calculate_zoom_to_fit(bbox, margin=0.2)
    assert zoom == canvas.get_zoom_level()  # Keeps current zoom
```

### 6.2 Widget Testing

**Zoom Application Tests** (`tests/ui/canvas/test_schematic_canvas_zoom.py`):
```python
def test_set_zoom_instant(qtbot):
    canvas = SchematicCanvas()
    canvas.show()
    qtbot.addWidget(canvas)

    canvas.set_zoom_level(2.0, animate=False)
    assert canvas.get_zoom_level() == 2.0

    # Verify transform
    m = canvas.transform()
    assert abs(m.m11() - 2.0) < 0.01  # X scale
    assert abs(m.m22() - 2.0) < 0.01  # Y scale

def test_zoom_in_out(qtbot):
    canvas = SchematicCanvas()
    canvas.set_zoom_level(1.0)

    canvas.zoom_in(factor=2.0)
    assert canvas.get_zoom_level() == 2.0

    canvas.zoom_out(factor=2.0)
    assert canvas.get_zoom_level() == 1.0

def test_zoom_reset(qtbot):
    canvas = SchematicCanvas()
    canvas.set_zoom_level(5.0)

    canvas.zoom_reset()
    assert canvas.get_zoom_level() == 1.0

def test_zoom_to_fit_bbox(qtbot):
    canvas = SchematicCanvas()
    canvas.resize(800, 600)

    bbox = BoundingBox(min_x=0, min_y=0, max_x=100, max_y=100)
    canvas.zoom_to_fit(bbox, margin=0.0, animate=False)

    # Expected: 800/100 = 8.0 (width limited)
    assert abs(canvas.get_zoom_level() - 8.0) < 0.1

def test_zoom_to_fit_object(qtbot):
    canvas = SchematicCanvas()
    canvas.resize(800, 600)
    cell = Cell(id="U1", name="U1")

    # Register item
    item = QGraphicsRectItem(0, 0, 100, 50)
    canvas._cell_items[cell.id] = item
    canvas.scene().addItem(item)

    canvas.zoom_to_fit_object(cell, margin=0.2, animate=False)

    # Expected: min(800/140, 600/70) = 5.71
    assert abs(canvas.get_zoom_level() - 5.71) < 0.1

def test_zoom_animated(qtbot):
    canvas = SchematicCanvas()
    canvas.set_zoom_level(1.0)

    canvas.set_zoom_level(3.0, animate=True)

    # Wait for animation
    qtbot.wait(200)

    assert abs(canvas.get_zoom_level() - 3.0) < 0.1
```

### 6.3 Integration Testing

**Pan + Zoom Workflow** (`tests/integration/ui/test_navigation_workflow.py`):
```python
def test_navigate_pan_zoom_workflow(qtbot):
    app = create_test_app()
    canvas = app.main_window.canvas
    navigator = app.navigator

    # Navigate to object
    result = navigator.navigate_to("U1")
    assert result.success

    # Pan to center
    canvas.pan_to_object(result.object, animate=False)

    # Zoom to fit
    canvas.zoom_to_fit_object(result.object, margin=0.2, animate=False)

    # Verify object is centered and optimally sized
    viewport_center = canvas.viewport().rect().center()
    scene_center = canvas.mapToScene(viewport_center)

    obj_bounds = canvas.get_object_bounds(result.object)
    obj_center = obj_bounds.center()

    # Object is centered
    assert abs(scene_center.x() - obj_center.x) < 5.0
    assert abs(scene_center.y() - obj_center.y) < 5.0

    # Object occupies ~60% of viewport (20% margin each side)
    viewport_width = canvas.viewport().width()
    obj_width_in_viewport = obj_bounds.width() * canvas.get_zoom_level()
    ratio = obj_width_in_viewport / viewport_width
    assert 0.5 < ratio < 0.7  # ~60% with tolerance
```

### 6.4 Performance Testing

**Timing Benchmarks** (`tests/performance/test_zoom_performance.py`):
```python
@pytest.mark.benchmark
def test_calculate_zoom_performance(benchmark):
    canvas = create_test_canvas()
    bbox = BoundingBox(0, 0, 100, 100)

    result = benchmark(canvas._calculate_zoom_to_fit, bbox, 0.2)
    assert benchmark.stats.mean < 0.01  # <10ms

@pytest.mark.benchmark
def test_set_zoom_performance(benchmark):
    canvas = create_test_canvas()

    result = benchmark(canvas._set_zoom, 2.0)
    assert benchmark.stats.mean < 0.02  # <20ms

@pytest.mark.benchmark
def test_zoom_to_fit_performance(benchmark):
    canvas = create_test_canvas()
    bbox = BoundingBox(0, 0, 100, 100)

    result = benchmark(canvas.zoom_to_fit, bbox, 0.2, animate=False)
    assert benchmark.stats.mean < 0.03  # <30ms total
```

---

## 7. Definition of Done

### 7.1 Functionality Criteria

- [ ] `zoom_to_fit()` calculates correct zoom for bounding box + margin
- [ ] Default margin is 20% (object occupies ~60% of viewport)
- [ ] Margin configurable from 0.0 (no margin) to 1.0 (100% margin)
- [ ] Zoom uses minimum of width/height scale (both dimensions fit)
- [ ] Zoom clamped to MIN_ZOOM (0.01x) and MAX_ZOOM (100x)
- [ ] `zoom_to_fit_object()` convenience method works for all object types
- [ ] Zoom maintains aspect ratio (no stretching)
- [ ] Optional animation with configurable duration (default 150ms)
- [ ] Animation uses `InOutQuad` easing
- [ ] `zoom_in()`, `zoom_out()` methods for incremental zoom (default factor 1.2)
- [ ] `zoom_reset()` returns to 100% zoom (1.0x)
- [ ] `get_zoom_level()` returns current zoom as float (1.0 = 100%)
- [ ] `set_zoom_level()` sets absolute zoom with optional animation

### 7.2 Edge Cases

- [ ] Zero-size bounding box keeps current zoom
- [ ] Very large object (requires zoom <0.01x) clamps to MIN_ZOOM
- [ ] Very small object (requires zoom >100x) clamps to MAX_ZOOM
- [ ] Rapid sequential zoom requests stop previous animation
- [ ] Negative coordinates handled correctly (object in negative scene space)
- [ ] Viewport resize updates zoom calculation correctly

### 7.3 Performance Criteria

- [ ] Calculate zoom level in <10ms
- [ ] Apply instant zoom in <20ms
- [ ] Animation setup in <10ms
- [ ] Animation completes in configured duration (±10ms)
- [ ] Combined pan + zoom in <200ms (excluding animation time)
- [ ] No frame drops during animation (60 FPS maintained)

### 7.4 Quality Criteria

**Test Coverage**:
- [ ] Unit tests for `_calculate_zoom_to_fit()` with various bbox sizes
- [ ] Tests for all margin values (0%, 10%, 20%, 50%, 100%)
- [ ] Tests for zoom clamping (below MIN_ZOOM, above MAX_ZOOM)
- [ ] Widget tests for all zoom methods
- [ ] Tests for aspect ratio preservation
- [ ] Tests for animation behavior
- [ ] Performance benchmarks pass

**Code Quality**:
- [ ] Type hints on all public methods
- [ ] Docstrings for all public methods
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Qt best practices followed (transform management)

### 7.5 Integration Criteria

**With Domain Layer**:
- [ ] `BoundingBox.width()`, `height()` used for calculations

**With Presentation Layer**:
- [ ] Object-to-item mapping used for `zoom_to_fit_object()`
- [ ] Zoom works with all graphics item types

**With Application Layer**:
- [ ] Task E05-F04-T01 can use zoom for navigation workflow
- [ ] Task E05-F04-T02 can coordinate pan + zoom operations
- [ ] E06 (Viewport Control) can use zoom methods for user controls

---

## 8. Open Questions

### 8.1 Technical Questions

**Q1**: Should zoom be around viewport center or object center?
**Answer**: Viewport center for MVP (simpler). Object-centered zoom is P1 enhancement (requires custom transform origin).

**Q2**: Should we support non-uniform zoom (different X/Y scales)?
**Answer**: No - breaks aspect ratio. Not needed for schematic viewing.

**Q3**: How to handle zoom during active user gestures (pinch-to-zoom)?
**Answer**: Deferred to P1 (touch/trackpad support). For MVP, zoom via methods only.

**Q4**: Should zoom level be clamped per-operation or globally?
**Answer**: Per-operation (in `_set_zoom()`). Prevents invalid states.

### 8.2 UX Questions

**Q1**: Should animation speed vary with zoom delta (large zoom = longer animation)?
**Answer**: No for MVP - fixed 150ms feels consistent. May add delta-based duration in P1.

**Q2**: Should very small zoom changes skip animation (below threshold)?
**Answer**: No - animation provides visual feedback even for small changes. User can disable via `animate=False`.

**Q3**: Should zoom_to_fit center object or just make it visible?
**Answer**: Recommend centering first (pan + zoom sequence). Zoom alone doesn't change viewport center.

### 8.3 Product Questions

**Q1**: Priority for zoom presets (25%, 50%, 100%, 200%, etc.)?
**Answer**: P1 - useful but not MVP blocker. Can use `set_zoom_level()` to implement.

**Q2**: Should zoom level persist across sessions?
**Answer**: Yes - part of session persistence (P1). Store in session file.

**Q3**: Should we show zoom percentage in status bar?
**Answer**: Yes - P0 (MVP). Use `get_zoom_level() * 100` for percentage.

---

## 9. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/T03/E05-F04-T03.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/E05-F04.spec.md`
- **Related Tasks**:
  - E05-F04-T01: Navigation Service (combines expand + pan + zoom)
  - E05-F04-T02: Pan to Object (coordinates pan before zoom)
- **Qt Documentation**:
  - `QGraphicsView::scale()` transformation
  - `QPropertyAnimation` for smooth zooming
  - Transform matrix and coordinate systems
- **UX Research**:
  - Material Design animation guidelines (150-300ms)
  - iOS zoom behavior (ease-in-out curves)

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
