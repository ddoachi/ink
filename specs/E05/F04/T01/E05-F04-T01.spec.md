---
id: E05-F04-T01
title: Navigation Service
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F04
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - application
  - navigation
  - service
clickup_task_id: ''
---

# Spec: E05-F04-T01 - Navigation Service

## 1. Overview

### 1.1 Problem Statement
Implement the core navigation service that orchestrates navigating to objects in the schematic canvas. The service must resolve object IDs, coordinate expansion if needed, trigger selection, and delegate viewport control to the canvas.

### 1.2 Goals
- Create `Navigator` application service for navigation orchestration
- Resolve object IDs to domain entities (Cell, Pin, Net, Port)
- Determine if objects are currently visible on canvas
- Coordinate expansion, selection, and viewport control
- Provide clean API for navigation from UI layer
- Complete navigation in < 200ms for hidden objects, < 50ms for visible objects

---

## 2. Technical Requirements

### 2.1 Navigator Service Implementation

**Location**: `src/ink/application/services/navigation_service.py`

**Class Structure**:
```python
from typing import Union, Optional
from dataclasses import dataclass
import logging

from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.domain.model.design import Design
from ink.domain.value_objects.identifiers import CellId, PinId, NetId, PortId
from ink.domain.value_objects.position import BoundingBox
from ink.application.services.expansion_service import ExpansionService
from ink.application.services.selection_service import SelectionService


ObjectType = Union[Cell, Pin, Net, Port]


@dataclass
class NavigationResult:
    """Result of navigation operation"""
    success: bool
    object: Optional[ObjectType]
    was_expanded: bool
    error_message: Optional[str] = None


class NavigationError(Exception):
    """Exception raised when navigation fails"""
    pass


class Navigator:
    """
    Application service for navigating to objects in schematic canvas.

    Orchestrates the navigation workflow:
    1. Resolve object ID to domain entity
    2. Expand object if not visible
    3. Select object
    4. Return object bounds for viewport control
    """

    def __init__(
        self,
        design: Design,
        expansion_service: ExpansionService,
        selection_service: SelectionService
    ):
        """
        Initialize Navigator service.

        Args:
            design: Design aggregate root
            expansion_service: Service for expanding hidden objects
            selection_service: Service for selecting objects
        """
        self._design = design
        self._expansion = expansion_service
        self._selection = selection_service
        self._logger = logging.getLogger(__name__)

    def navigate_to(self, object_id: str) -> NavigationResult:
        """
        Navigate to object by ID.

        Steps:
        1. Resolve object ID to entity
        2. Check if object is visible
        3. Expand if not visible
        4. Select object
        5. Return bounds for viewport control (delegated to canvas)

        Args:
            object_id: Unique identifier (cell_id, pin_id, net_id, port_id)

        Returns:
            NavigationResult with success status and object info

        Raises:
            NavigationError: If object cannot be found or navigation fails
        """
        self._logger.info(f"Navigating to object: {object_id}")

        try:
            # Step 1: Resolve object ID
            obj = self._resolve_object(object_id)
            if obj is None:
                return NavigationResult(
                    success=False,
                    object=None,
                    was_expanded=False,
                    error_message=f"Object not found: {object_id}"
                )

            # Step 2: Check visibility and expand if needed
            was_expanded = False
            if not self._is_visible(obj):
                self._logger.debug(f"Object {object_id} not visible, expanding...")
                self._expand_to_object(obj)
                was_expanded = True

            # Step 3: Select object
            self._selection.select(obj)

            self._logger.info(
                f"Navigation successful: {object_id} "
                f"(expanded={was_expanded})"
            )

            return NavigationResult(
                success=True,
                object=obj,
                was_expanded=was_expanded
            )

        except Exception as e:
            self._logger.error(f"Navigation failed for {object_id}: {e}")
            raise NavigationError(f"Failed to navigate to {object_id}") from e

    def _resolve_object(self, object_id: str) -> Optional[ObjectType]:
        """
        Resolve object ID to domain entity.

        ID format conventions:
        - Cell: "cell:<name>" or just "<name>"
        - Pin: "pin:<cell_name>.<pin_name>" or "<cell_name>.<pin_name>"
        - Net: "net:<name>" or just "<name>"
        - Port: "port:<name>" or just "<name>"

        Args:
            object_id: String identifier

        Returns:
            Resolved domain entity or None if not found
        """
        # Parse ID format
        if ":" in object_id:
            obj_type, obj_name = object_id.split(":", 1)
        else:
            # Try to infer type from name format
            if "." in object_id:
                obj_type = "pin"
                obj_name = object_id
            else:
                # Ambiguous - try cell, then net, then port
                obj = self._design.get_cell(object_id)
                if obj:
                    return obj
                obj = self._design.get_net(object_id)
                if obj:
                    return obj
                obj = self._design.get_port(object_id)
                return obj

        # Resolve by explicit type
        if obj_type == "cell":
            return self._design.get_cell(obj_name)
        elif obj_type == "pin":
            # Format: "cell_name.pin_name"
            if "." in obj_name:
                cell_name, pin_name = obj_name.split(".", 1)
                cell = self._design.get_cell(cell_name)
                if cell:
                    return cell.get_pin(pin_name)
            return None
        elif obj_type == "net":
            return self._design.get_net(obj_name)
        elif obj_type == "port":
            return self._design.get_port(obj_name)
        else:
            self._logger.warning(f"Unknown object type: {obj_type}")
            return None

    def _is_visible(self, obj: ObjectType) -> bool:
        """
        Check if object is currently visible on canvas.

        Delegates to expansion service to check expansion state.

        Args:
            obj: Domain entity to check

        Returns:
            True if object is currently expanded/visible
        """
        # Delegate to expansion service
        return self._expansion.is_visible(obj)

    def _expand_to_object(self, obj: ObjectType) -> None:
        """
        Expand schematic to reveal object.

        Strategy:
        - For cells: Expand parent context to show cell (1-hop fanin/fanout)
        - For pins: Expand parent cell and connected nets
        - For nets: Expand all connected pins/cells
        - For ports: Expand connected nets

        Args:
            obj: Domain entity to expand
        """
        if isinstance(obj, Cell):
            # Expand 1-hop fanin/fanout to show context
            self._expansion.expand_cell(obj, hops=1, direction="both")

        elif isinstance(obj, Pin):
            # Expand parent cell to show pin
            self._expansion.expand_cell(obj.parent_cell, hops=0)

        elif isinstance(obj, Net):
            # Expand all connected pins' parent cells
            for pin in obj.connected_pins:
                self._expansion.expand_cell(pin.parent_cell, hops=0)

        elif isinstance(obj, Port):
            # Expand connected net
            if obj.connected_net:
                self._expand_to_object(obj.connected_net)
```

### 2.2 Design Interface Updates

**Update**: `src/ink/domain/model/design.py`

Add query methods for object lookup:
```python
def get_cell(self, cell_id: Union[str, CellId]) -> Optional[Cell]:
    """Get cell by ID or name"""

def get_net(self, net_id: Union[str, NetId]) -> Optional[Net]:
    """Get net by ID or name"""

def get_port(self, port_id: Union[str, PortId]) -> Optional[Port]:
    """Get port by ID or name"""
```

### 2.3 ExpansionService Interface Updates

**Update**: `src/ink/application/services/expansion_service.py`

Add visibility check method:
```python
def is_visible(self, obj: Union[Cell, Pin, Net, Port]) -> bool:
    """Check if object is currently visible on canvas"""
```

### 2.4 Performance Requirements

| Operation | Target | Notes |
|-----------|--------|-------|
| Object ID resolution | < 5ms | Hash table lookup |
| Visibility check | < 5ms | Check expansion state |
| Expand hidden object | < 150ms | 1-hop expansion |
| Object selection | < 10ms | Update selection state |
| Total navigation (visible) | < 50ms | No expansion needed |
| Total navigation (hidden) | < 200ms | Includes expansion |

---

## 3. Dependencies

### 3.1 Upstream
- Domain model: `Design`, `Cell`, `Pin`, `Net`, `Port`
- Application services: `ExpansionService`, `SelectionService`
- Value objects: Identifiers, `BoundingBox`

### 3.2 Downstream
- Task E05-F04-T02: Uses `NavigationResult.object` for pan to object
- Task E05-F04-T04: Uses `_expand_to_object()` expansion strategy
- E05-F01 (Search Panel UI): Calls `navigator.navigate_to()`

### 3.3 External Dependencies
- Python standard library: `logging`, `dataclasses`, `typing`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `navigate_to()` accepts object IDs for cells, pins, nets, ports
- [ ] Supports both explicit type prefixes (`cell:name`) and implicit formats
- [ ] Pin ID format `cell_name.pin_name` correctly resolves to Pin entity
- [ ] Ambiguous IDs try cell, then net, then port resolution order
- [ ] Returns `NavigationResult` with success status and object reference
- [ ] Hidden objects are expanded before selection
- [ ] Visible objects skip expansion step
- [ ] Objects are selected after expansion
- [ ] Logs navigation events at INFO level
- [ ] Logs expansion at DEBUG level
- [ ] Returns error message for non-existent objects

### 4.2 Error Handling
- [ ] Returns `NavigationResult(success=False)` for non-existent objects
- [ ] Raises `NavigationError` for unexpected failures
- [ ] Logs errors with context (object ID, exception)
- [ ] Gracefully handles malformed object IDs

### 4.3 Performance
- [ ] Navigate to visible object in < 50ms
- [ ] Navigate to hidden object in < 200ms
- [ ] Object resolution in < 5ms
- [ ] Visibility check in < 5ms

### 4.4 Testing
- [ ] Unit tests for object ID resolution (all types and formats)
- [ ] Unit tests for visibility checks (mocked expansion service)
- [ ] Unit tests for expansion strategies (each object type)
- [ ] Integration test with real Design and ExpansionService
- [ ] Test navigation to visible vs hidden objects
- [ ] Test error handling for non-existent objects
- [ ] Test performance requirements with timing assertions
- [ ] 90%+ code coverage on `Navigator` class

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why string-based object IDs?**
- Simple API for UI layer (search results return strings)
- Flexible format supporting type prefixes or inference
- Avoids coupling UI to domain ID types

**Why return `NavigationResult` instead of raising exceptions?**
- Navigation failure (object not found) is a normal case, not exceptional
- Result object provides structured error information
- Caller can handle gracefully without try/catch

**Why delegate viewport control to canvas?**
- Navigator orchestrates workflow but doesn't know canvas details
- Canvas (presentation layer) handles actual pan/zoom
- Maintains separation of concerns (application vs presentation)

**Why 1-hop expansion for cells?**
- Shows immediate context (what drives/is driven by the cell)
- Balances visibility vs schematic clutter
- Matches user mental model of "show me this cell and its connections"

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/application/services/test_navigation_service.py`):
- Mock `Design`, `ExpansionService`, `SelectionService`
- Test each navigation path independently
- Verify expansion strategies for each object type
- Test object ID resolution formats

**Integration Tests** (`tests/integration/application/test_navigation_integration.py`):
- Use real Design aggregate with sample netlist
- Real ExpansionService and SelectionService
- Verify end-to-end navigation workflow
- Measure performance with timing assertions

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F04 split |
