# E05-F04-T01 - Navigation Service: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F04-T01 - Navigation Service
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

E05-F04-T01 implements the core navigation orchestration service that coordinates the workflow of navigating to objects in the schematic canvas. The `Navigator` service acts as an application-layer coordinator that resolves object IDs, checks visibility, triggers expansion when needed, manages selection, and provides object bounds for viewport control.

This service is the critical orchestrator that bridges the search functionality (E05-F01) with the canvas presentation layer, enabling users to quickly jump to search results in the schematic view.

### 1.2 Core Capabilities

The task delivers these primary capabilities:

1. **Object ID Resolution**: Parse flexible string-based object IDs (with or without type prefixes) and resolve them to domain entities
2. **Visibility Checking**: Determine if target objects are currently rendered on the canvas
3. **Smart Expansion**: Automatically expand hidden objects with appropriate context (1-hop for cells, connected nets for pins)
4. **Selection Coordination**: Delegate object selection to the selection service after expansion
5. **Result Reporting**: Return structured navigation results indicating success, expansion status, and error messages

### 1.3 Success Metrics

- Navigate to visible objects in <50ms
- Navigate to hidden objects (requiring expansion) in <200ms
- Object ID resolution in <5ms
- Support all object types: Cell, Pin, Net, Port
- Handle both explicit (`cell:name`) and implicit (`name`) ID formats

---

## 2. Architecture Decisions

### 2.1 String-Based Object IDs vs Typed IDs

**Decision**: Use flexible string-based object IDs as the public API.

**Rationale**:
- Search results naturally produce string identifiers
- UI layer doesn't need to understand domain ID types (`CellId`, `NetId`, etc.)
- Enables both explicit type prefixes (`cell:U1`) and implicit formats (`U1`, `U1.A`)
- Simplifies integration with external tools (TCL commands, CLI)

**Alternatives Considered**:
- **Typed ID parameters**: Rejected - would require UI to construct domain value objects, creating tight coupling
- **Union type of all ID types**: Rejected - makes API complex, doesn't support string parsing from user input

**Trade-offs**:
- **Pro**: Flexible, user-friendly API that works with strings from any source
- **Pro**: Decouples presentation layer from domain ID implementation
- **Con**: Requires runtime parsing and validation (minimal overhead)
- **Con**: String format must be documented and maintained

### 2.2 NavigationResult vs Exception-Based Error Handling

**Decision**: Return `NavigationResult` dataclass with `success` flag instead of raising exceptions for not-found objects.

**Rationale**:
- Navigation failure (object not found) is a **normal case**, not exceptional
- Caller can handle gracefully without try/catch blocks
- Structured result provides detailed information (object reference, expansion status, error message)
- Matches modern API design patterns (Result types)

**Alternatives Considered**:
- **Raise NavigationError for all failures**: Rejected - forces exception handling for common case (typo in search)
- **Return None on failure**: Rejected - loses error context, harder to provide user feedback

**Implementation**:
```python
@dataclass
class NavigationResult:
    success: bool
    object: Optional[ObjectType]
    was_expanded: bool
    error_message: Optional[str] = None
```

**Trade-offs**:
- **Pro**: Caller can easily check `result.success` and provide appropriate feedback
- **Pro**: Avoids performance overhead of exception handling
- **Con**: Caller must remember to check success flag (but this is standard pattern)

### 2.3 Expansion Strategy for Different Object Types

**Decision**: Use object-type-specific expansion strategies to show appropriate context.

**Rationale**:
- **Cells**: 1-hop fanin/fanout shows immediate connectivity (what drives/is driven by the cell)
- **Pins**: Show parent cell (pin can't exist without cell context)
- **Nets**: Show all connected cells (net is defined by its endpoints)
- **Ports**: Show connected net (port's purpose is its connection)

**Alternatives Considered**:
- **Uniform expansion**: Always expand 1-hop for all types - Rejected because pins/nets need different context
- **No automatic expansion**: Require user to manually expand - Rejected because defeats navigation purpose

**Implementation**:
```python
def _expand_to_object(self, obj: ObjectType) -> None:
    if isinstance(obj, Cell):
        self._expansion.expand_cell(obj, hops=1, direction="both")
    elif isinstance(obj, Pin):
        self._expansion.expand_cell(obj.parent_cell, hops=0)
    elif isinstance(obj, Net):
        for pin in obj.connected_pins:
            self._expansion.expand_cell(pin.parent_cell, hops=0)
    elif isinstance(obj, Port):
        if obj.connected_net:
            self._expand_to_object(obj.connected_net)
```

**Trade-offs**:
- **Pro**: User always sees meaningful context, not just isolated object
- **Pro**: Balances visibility (show enough) vs clutter (not too much)
- **Con**: Expansion might be slow for nets with many connected pins

### 2.4 Separation of Navigation and Viewport Control

**Decision**: `Navigator` returns object reference; canvas handles actual pan/zoom.

**Rationale**:
- Navigator is application layer (business logic)
- Canvas is presentation layer (UI rendering)
- Viewport control (pan, zoom, animation) is purely a rendering concern
- Maintains clean separation of concerns per DDD architecture

**Alternatives Considered**:
- **Navigator directly controls viewport**: Rejected - violates layer architecture (application shouldn't depend on presentation)
- **Navigator emits viewport events**: Over-engineered for MVP, deferred

**Flow**:
```
1. Navigator.navigate_to("U1") → NavigationResult
2. Caller gets result.object
3. Caller calls canvas.pan_to_object(result.object)
4. Caller calls canvas.zoom_to_fit_object(result.object)
```

**Trade-offs**:
- **Pro**: Clear separation enables testing navigation logic without Qt dependencies
- **Pro**: Flexible - caller can customize viewport behavior (pan only, zoom only, both)
- **Con**: Requires caller to coordinate pan/zoom (but this is typically one-liner)

### 2.5 Ambiguous ID Resolution Order

**Decision**: For IDs without type prefix, try cell → net → port order.

**Rationale**:
- Cells are most common navigation targets (engineers think in terms of gates)
- Nets are second most common (signal names)
- Ports are least ambiguous (usually distinct from cell/net names)
- Pins always have dots (`cell.pin`) so are unambiguous

**Alternatives Considered**:
- **Require explicit prefixes**: Rejected - too verbose for common case
- **Try all types and return error if multiple matches**: Over-engineered, deferred

**Edge Cases**:
- Name collision (cell and net both named "clk"): Cell wins (documented behavior)
- User can use explicit prefix (`net:clk`) to override

**Trade-offs**:
- **Pro**: Convenient API for 99% of cases (unique names)
- **Con**: Ambiguous behavior if names collide (mitigated by documentation)

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: Core Navigation (2 hours)**
- Implement `NavigationResult` dataclass
- Implement `Navigator` class skeleton
- Implement `_resolve_object()` with all ID format parsing
- Unit tests for object resolution (mock Design)

**Phase 2: Visibility and Expansion (2 hours)**
- Implement `_is_visible()` delegation to expansion service
- Implement `_expand_to_object()` for all object types
- Update `ExpansionService` with `is_visible()` method
- Unit tests for expansion strategies

**Phase 3: Design Interface (1 hour)**
- Add `get_cell()`, `get_net()`, `get_port()` methods to Design
- Unit tests for Design query methods
- Integration test with real Design aggregate

**Phase 4: End-to-End Integration (1 hour)**
- Integration test: navigate to visible object
- Integration test: navigate to hidden object (with expansion)
- Integration test: navigate to non-existent object (error handling)
- Performance tests with timing assertions

### 3.2 Incremental Deliverables

Each phase produces testable functionality:

1. **Phase 1**: Object IDs can be resolved to domain entities programmatically
2. **Phase 2**: Hidden objects can be expanded with appropriate strategy
3. **Phase 3**: Design provides query API for lookups
4. **Phase 4**: Full navigation workflow works from string ID to selected object

### 3.3 Integration Points

**With Domain Layer**:
- `Design` aggregate must provide query methods for cells, nets, ports
- `Cell`, `Pin`, `Net`, `Port` entities must have stable IDs
- `Pin` must reference parent cell

**With Application Layer**:
- `ExpansionService` must provide `is_visible()` and `expand_cell()` methods
- `SelectionService` must provide `select()` method
- Navigation coordinates between these services

**With Presentation Layer**:
- Canvas receives `NavigationResult.object` for viewport control
- Task E05-F04-T02 (Pan to Object) uses the object reference
- Task E05-F04-T03 (Zoom to Fit) uses the object reference

---

## 4. Technical Deep Dive

### 4.1 Object ID Parsing Algorithm

**Supported Formats**:
```
# Explicit type prefix
cell:U1
pin:U1.A
net:clk
port:IN[0]

# Implicit formats
U1          → Try cell, then net, then port
U1.A        → Pin (dot indicates pin)
clk         → Try cell, then net, then port
```

**Implementation**:
```python
def _resolve_object(self, object_id: str) -> Optional[ObjectType]:
    # Parse ID format
    if ":" in object_id:
        obj_type, obj_name = object_id.split(":", 1)
    else:
        # Infer type from format
        if "." in object_id:
            obj_type = "pin"
            obj_name = object_id
        else:
            # Ambiguous - try resolution order
            obj = self._design.get_cell(object_id)
            if obj: return obj
            obj = self._design.get_net(object_id)
            if obj: return obj
            obj = self._design.get_port(object_id)
            return obj

    # Resolve by explicit type
    if obj_type == "cell":
        return self._design.get_cell(obj_name)
    elif obj_type == "pin":
        if "." in obj_name:
            cell_name, pin_name = obj_name.split(".", 1)
            cell = self._design.get_cell(cell_name)
            if cell:
                return cell.get_pin(pin_name)
        return None
    # ... etc
```

**Error Handling**:
- Malformed IDs (e.g., "pin:invalid") → Return None
- Non-existent objects → Return None (caller checks `NavigationResult.success`)
- Multiple colons (e.g., "cell:a:b") → Split on first colon only

### 4.2 Visibility Checking

**Challenge**: Determine if object is rendered on canvas without tight coupling.

**Approach**: Delegate to `ExpansionService` which tracks visible cells.

**Implementation in ExpansionService**:
```python
class ExpansionService:
    def is_visible(self, obj: Union[Cell, Pin, Net, Port]) -> bool:
        if isinstance(obj, Cell):
            return obj.id in self._expansion_state.visible_cells
        elif isinstance(obj, Pin):
            return self.is_visible(obj.parent_cell)
        elif isinstance(obj, Net):
            # Net is visible if any connected cell is visible
            return any(
                self.is_visible(pin.parent_cell)
                for pin in obj.connected_pins
            )
        elif isinstance(obj, Port):
            # Port is always visible (top-level)
            return True
```

**Trade-offs**:
- **Pro**: Single source of truth (expansion state)
- **Con**: ExpansionService needs to know about all object types

### 4.3 Expansion Context Calculation

**Design Principle**: Show enough context to understand object's role, but not too much.

**Cell Expansion**:
```python
# 1-hop fanin/fanout shows:
# - What drives this cell (input sources)
# - What this cell drives (output loads)
self._expansion.expand_cell(cell, hops=1, direction="both")
```

**Pin Expansion**:
```python
# Show parent cell (pin needs cell context)
self._expansion.expand_cell(pin.parent_cell, hops=0)
```

**Net Expansion**:
```python
# Show all endpoints (net defined by connections)
for pin in net.connected_pins:
    self._expansion.expand_cell(pin.parent_cell, hops=0)
```

**Port Expansion**:
```python
# Show connected internal net, then its cells
if port.connected_net:
    self._expand_to_object(port.connected_net)  # Recursive
```

**Performance Considerations**:
- Net with 100+ connected pins → Could be slow
- Mitigation: Warn if net has >50 pins, limit expansion to first 50

### 4.4 Performance Optimization

**Object Lookup Caching**:
```python
class Design:
    def __init__(self):
        self._cell_index: Dict[str, Cell] = {}    # Built during parsing
        self._net_index: Dict[str, Net] = {}
        self._port_index: Dict[str, Port] = {}

    def get_cell(self, name: str) -> Optional[Cell]:
        return self._cell_index.get(name)  # O(1) lookup
```

**Visibility Check Caching**:
- `ExpansionState.visible_cells` is a set → O(1) membership check

**Timing Breakdown** (target <200ms total):
```
1. Object ID resolution:    <5ms   (hash lookup)
2. Visibility check:        <5ms   (set membership)
3. Expansion (if needed):   <150ms (1-hop traversal + layout)
4. Selection:               <10ms  (update selection state)
5. Logging and overhead:    <30ms
-------------------------------------------
Total:                      <200ms
```

---

## 5. Risk Analysis

### 5.1 Performance Risk: Large Net Expansion

**Risk**: Navigating to net with hundreds of connected pins triggers massive expansion.

**Impact**: High - Application freeze, poor user experience
**Probability**: Medium - High-fanout nets (clock, reset) are common in large designs

**Mitigation**:
- Set threshold for "large net" (e.g., 50 pins)
- For large nets, expand only a representative subset (e.g., first 20 pins)
- Show warning dialog: "Net 'clk' has 237 connections. Show sample (20) or all?"
- Provide "Expand All" button for user confirmation

**Implementation**:
```python
def _expand_to_object(self, obj: ObjectType) -> None:
    if isinstance(obj, Net):
        pins = obj.connected_pins
        if len(pins) > 50:
            self._logger.warning(f"Large net expansion: {len(pins)} pins")
            # Show first 20 only
            pins = list(pins)[:20]
        for pin in pins:
            self._expansion.expand_cell(pin.parent_cell, hops=0)
```

### 5.2 API Risk: ID Format Ambiguity

**Risk**: Users confused by implicit ID resolution order (cell vs net vs port).

**Impact**: Low - User navigates to wrong object, must retry with explicit prefix
**Probability**: Low - Most designs have distinct naming (cells: U*, nets: lowercase)

**Mitigation**:
- Document resolution order prominently (cell → net → port)
- Show object type in navigation result for user feedback
- Log resolution decisions at DEBUG level for troubleshooting
- Consider future enhancement: show disambiguation dialog if multiple matches

**User Feedback**:
```python
# In UI layer after navigation:
if result.success:
    obj_type = type(result.object).__name__
    status_bar.show(f"Navigated to {obj_type}: {object_id}")
```

### 5.3 State Risk: ExpansionService and Canvas Desync

**Risk**: Navigator expands objects, but canvas doesn't reflect changes.

**Impact**: High - User sees wrong schematic, loss of trust
**Probability**: Low - Proper event handling prevents this

**Mitigation**:
- ExpansionService emits events when expansion state changes
- Canvas observes expansion events and re-renders
- Integration tests verify canvas state matches expansion state
- Add validation mode: assert canvas cells match `visible_cells`

**Validation**:
```python
def _validate_state(self):
    if DEBUG_MODE:
        canvas_cells = {c.id for c in self.canvas.get_rendered_cells()}
        state_cells = self._expansion.get_visible_cells()
        assert canvas_cells == state_cells, "State desync detected"
```

### 5.4 Error Handling Risk: Silent Failures

**Risk**: Navigation fails but user isn't notified (silent failure).

**Impact**: Medium - User confused, doesn't know why object not shown
**Probability**: Low - NavigationResult provides error messages

**Mitigation**:
- Always check `NavigationResult.success` in caller
- Display error message from `result.error_message` in UI
- Log all failures at WARNING level for debugging
- Never swallow exceptions during expansion

**UI Integration**:
```python
result = navigator.navigate_to(object_id)
if not result.success:
    QMessageBox.warning(
        self,
        "Navigation Failed",
        f"Could not navigate to '{object_id}': {result.error_message}"
    )
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Object Resolution Tests** (`tests/unit/application/services/test_navigation_service.py`):
```python
def test_resolve_cell_explicit_prefix():
    # "cell:U1" → Cell("U1")

def test_resolve_cell_implicit():
    # "U1" → Cell("U1") if exists

def test_resolve_pin_with_dot():
    # "U1.A" → Pin on Cell("U1") named "A"

def test_resolve_pin_explicit_prefix():
    # "pin:U1.A" → Pin

def test_resolve_ambiguous_cell_wins():
    # "clk" → Cell("clk") if both Cell and Net exist

def test_resolve_net_explicit_prefix():
    # "net:clk" → Net("clk") even if Cell("clk") exists

def test_resolve_nonexistent_returns_none():
    # "cell:INVALID" → None

def test_resolve_malformed_id():
    # "pin:invalid_format" → None
```

**Visibility Tests**:
```python
def test_visible_cell_returns_true():
    # Cell in expansion state → is_visible() = True

def test_hidden_cell_returns_false():
    # Cell not in expansion state → is_visible() = False

def test_pin_visibility_delegates_to_parent_cell():
    # Pin.parent_cell visible → Pin visible
```

**Expansion Strategy Tests**:
```python
def test_expand_cell_uses_1_hop_both_directions():
    # Verify expansion service called with hops=1, direction="both"

def test_expand_pin_shows_parent_cell():
    # Verify expansion service called for pin.parent_cell

def test_expand_net_shows_all_connected_cells():
    # Net with 3 pins → 3 cells expanded

def test_expand_port_shows_connected_net():
    # Port.connected_net expanded recursively
```

**Navigation Flow Tests**:
```python
def test_navigate_to_visible_object_skips_expansion():
    # Object already visible → expansion not called

def test_navigate_to_hidden_object_triggers_expansion():
    # Object hidden → expansion called before selection

def test_navigate_to_nonexistent_returns_error():
    # Invalid ID → NavigationResult(success=False, error_message=...)

def test_navigation_selects_object_after_expansion():
    # Selection service called after expansion completes
```

### 6.2 Integration Testing

**End-to-End Navigation** (`tests/integration/application/test_navigation_integration.py`):
```python
def test_navigate_to_hidden_cell_expands_and_selects():
    # Given: Design with Cell("U1") not expanded
    # When: navigator.navigate_to("U1")
    # Then:
    #   - Cell("U1") and 1-hop fanin/fanout are visible
    #   - Cell("U1") is selected
    #   - NavigationResult.success = True
    #   - NavigationResult.was_expanded = True

def test_navigate_to_visible_cell_selects_immediately():
    # Given: Cell("U1") already visible
    # When: navigator.navigate_to("U1")
    # Then:
    #   - No new cells expanded
    #   - Cell("U1") is selected
    #   - NavigationResult.was_expanded = False

def test_navigate_to_pin_shows_parent_cell():
    # Given: Pin("U1.A") not visible
    # When: navigator.navigate_to("U1.A")
    # Then:
    #   - Cell("U1") is visible
    #   - Pin("U1.A") is selected
```

### 6.3 Performance Testing

**Timing Tests** (`tests/performance/test_navigation_performance.py`):
```python
@pytest.mark.benchmark
def test_object_resolution_performance(benchmark):
    result = benchmark(navigator._resolve_object, "U1")
    assert benchmark.stats.mean < 0.005  # <5ms

@pytest.mark.benchmark
def test_navigate_visible_performance(benchmark):
    # Object already visible
    result = benchmark(navigator.navigate_to, "U1")
    assert benchmark.stats.mean < 0.05  # <50ms

@pytest.mark.benchmark
def test_navigate_hidden_performance(benchmark):
    # Object needs expansion
    result = benchmark(navigator.navigate_to, "U_HIDDEN")
    assert benchmark.stats.mean < 0.2  # <200ms
```

### 6.4 Manual Testing

**Test Cases**:
1. Navigate to cell by name ("U1")
2. Navigate to cell with explicit prefix ("cell:U1")
3. Navigate to pin with dot notation ("U1.A")
4. Navigate to pin with explicit prefix ("pin:U1.A")
5. Navigate to net ("clk")
6. Navigate to port ("IN[0]")
7. Navigate to ambiguous name (exists as both cell and net)
8. Navigate to non-existent object (error handling)
9. Navigate to large net (>50 pins) - check performance
10. Navigate multiple times to same object (idempotent)

---

## 7. Definition of Done

### 7.1 Functionality Criteria

- [ ] `navigate_to()` accepts object IDs for cells, pins, nets, ports
- [ ] Supports explicit type prefixes (`cell:`, `pin:`, `net:`, `port:`)
- [ ] Supports implicit formats (no prefix, dots for pins)
- [ ] Ambiguous IDs resolve in order: cell → net → port
- [ ] Returns `NavigationResult` with success status, object reference, expansion flag
- [ ] Hidden objects are expanded before selection
- [ ] Visible objects skip expansion step
- [ ] Selection service called after expansion
- [ ] Non-existent objects return error result with message
- [ ] All object types correctly resolved

### 7.2 Performance Criteria

- [ ] Object ID resolution in <5ms (95th percentile)
- [ ] Visibility check in <5ms
- [ ] Navigate to visible object in <50ms
- [ ] Navigate to hidden object in <200ms (including expansion)
- [ ] No memory leaks in repeated navigation

### 7.3 Quality Criteria

**Test Coverage**:
- [ ] Unit test coverage >90% for `Navigator` class
- [ ] All ID formats covered by tests
- [ ] All object types covered by tests
- [ ] All expansion strategies covered by tests
- [ ] Integration tests pass with real Design aggregate
- [ ] Performance benchmarks pass

**Code Quality**:
- [ ] Type hints on all public methods
- [ ] Docstrings for all public functions
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Logging at appropriate levels (INFO for navigation, DEBUG for expansion)

### 7.4 Integration Criteria

**With Domain Layer**:
- [ ] `Design.get_cell()`, `get_net()`, `get_port()` implemented
- [ ] `Cell.get_pin()` works for pin resolution
- [ ] All methods return `Optional[T]` for not-found cases

**With Application Layer**:
- [ ] `ExpansionService.is_visible()` implemented
- [ ] `ExpansionService.expand_cell()` works for all expansion strategies
- [ ] `SelectionService.select()` works with all object types

**With Presentation Layer**:
- [ ] Task E05-F04-T02 can use `NavigationResult.object` for panning
- [ ] Task E05-F04-T03 can use `NavigationResult.object` for zooming

---

## 8. Open Questions

### 8.1 Technical Questions

**Q1**: Should pin resolution support partial matching (e.g., "A" finds first cell with pin "A")?
**Answer**: No for MVP. Too ambiguous. Require full format "cell.pin".

**Q2**: Should we cache object lookups in Navigator?
**Answer**: No. Design already provides O(1) lookups via index. Caching adds complexity.

**Q3**: How to handle hierarchical designs (subcircuits)?
**Answer**: Deferred to P1. For MVP, assume flat netlist.

**Q4**: Should expansion be cancellable for large operations?
**Answer**: Deferred to expansion service. Navigator assumes expansion is fast.

### 8.2 UX Questions

**Q1**: Should navigation animate the expansion (fade-in)?
**Answer**: Yes, but handled by canvas (presentation layer), not Navigator.

**Q2**: Should navigation center on object or just make it visible?
**Answer**: Just make visible. Centering is handled by pan/zoom tasks (E05-F04-T02/T03).

**Q3**: Should we support regex in object IDs?
**Answer**: No for MVP. Too complex. Deferred to advanced search (P1).

### 8.3 Product Questions

**Q1**: Priority for large net handling?
**Answer**: P0 (MVP blocker). Clock/reset nets are very common and can have 1000+ connections.

**Q2**: Should navigation be undoable?
**Answer**: Selection is undoable, but expansion is already tracked by expansion undo. No special handling needed.

---

## 9. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/T01/E05-F04-T01.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F04/E05-F04.spec.md`
- **Related Tasks**:
  - E05-F04-T02: Pan to Object (uses navigation result)
  - E05-F04-T03: Zoom to Fit Object (uses navigation result)
  - E05-F01: Search Panel UI (calls navigation service)
- **Architecture**: `/home/joohan/dev/project-ink/ink/docs/architecture/layer-architecture.md`

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
