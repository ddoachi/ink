---
id: E05-F05-T03
title: History Persistence
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F05
created: 2025-12-26
estimated_hours: 2
actual_hours:
effort: Small
tags:
  - infrastructure
  - persistence
clickup_task_id: ''
---

# Spec: E05-F05-T03 - History Persistence

## 1. Overview

### 1.1 Problem Statement
Search history must persist across application sessions. Need a concrete implementation of the `HistoryStorage` protocol using Qt's `QSettings`.

### 1.2 Goals
- Implement `QSettingsHistoryStorage` adapter
- Store history in platform-appropriate location
- Handle serialization/deserialization of query list
- Ensure thread-safe storage operations
- Handle storage failures gracefully

---

## 2. Technical Requirements

### 2.1 QSettings Storage Implementation

**Location**: `src/ink/infrastructure/persistence/qsettings_history_storage.py`

```python
from typing import List
from PySide6.QtCore import QSettings


class QSettingsHistoryStorage:
    """
    Store search history using Qt's QSettings

    Storage location varies by platform:
    - Linux: ~/.config/Ink/SearchHistory.conf
    - Windows: Registry HKEY_CURRENT_USER\\Software\\Ink\\SearchHistory
    - macOS: ~/Library/Preferences/com.Ink.SearchHistory.plist
    """

    HISTORY_KEY = "search/history"
    ORGANIZATION = "Ink"
    APPLICATION = "SearchHistory"

    def __init__(self):
        """Initialize QSettings with organization and application name"""
        self._settings = QSettings(self.ORGANIZATION, self.APPLICATION)

    def load_history(self) -> List[str]:
        """
        Load search history from QSettings

        Returns:
            List of query strings (empty list if not found or error)
        """
        try:
            # QSettings.value() with type=list handles list deserialization
            history = self._settings.value(self.HISTORY_KEY, defaultValue=[], type=list)

            # Ensure all items are strings (QSettings may return QVariant)
            return [str(query) for query in history if query]
        except Exception as e:
            # Log error but don't crash
            print(f"Error loading search history: {e}")
            return []

    def save_history(self, queries: List[str]) -> None:
        """
        Save search history to QSettings

        Args:
            queries: List of query strings to persist
        """
        try:
            self._settings.setValue(self.HISTORY_KEY, queries)
            # Force immediate write to disk
            self._settings.sync()
        except Exception as e:
            # Log error but don't crash
            print(f"Error saving search history: {e}")

    def clear(self) -> None:
        """Clear all search history from storage"""
        try:
            self._settings.remove(self.HISTORY_KEY)
            self._settings.sync()
        except Exception as e:
            print(f"Error clearing search history: {e}")
```

### 2.2 Storage Behavior

| Scenario | Behavior |
|----------|----------|
| First run (no history) | `load_history()` returns empty list |
| Normal save | Data written to platform-specific location |
| Concurrent access | QSettings handles locking |
| Storage permission denied | Error logged, operation fails gracefully |
| Corrupted settings file | Returns empty list, doesn't crash |
| Large history (>10 items) | Stores as-is (size enforcement in domain) |
| Empty query in list | Filtered out during load |

### 2.3 Platform Storage Locations

**Linux:**
```
~/.config/Ink/SearchHistory.conf

[search]
history=["NAND2", "DFF", "clk_net"]
```

**Windows Registry:**
```
HKEY_CURRENT_USER\Software\Ink\SearchHistory
  search\history: REG_MULTI_SZ
    NAND2
    DFF
    clk_net
```

**macOS plist:**
```
~/Library/Preferences/com.Ink.SearchHistory.plist

<dict>
  <key>search</key>
  <dict>
    <key>history</key>
    <array>
      <string>NAND2</string>
      <string>DFF</string>
      <string>clk_net</string>
    </array>
  </dict>
</dict>
```

### 2.4 Integration with SearchHistory

```python
# In application composition root (main.py or app.py)

from ink.domain.services.search_history import SearchHistory
from ink.infrastructure.persistence.qsettings_history_storage import (
    QSettingsHistoryStorage
)

# Create storage adapter
history_storage = QSettingsHistoryStorage()

# Inject into domain service
search_history = SearchHistory(storage=history_storage)

# Pass to UI
search_panel = SearchPanel(
    search_service=search_service,
    search_history=search_history
)
```

---

## 3. Dependencies

- **Upstream**: T01 (HistoryStorage protocol definition)
- **Downstream**: Application composition root

---

## 4. Acceptance Criteria

- [ ] `QSettingsHistoryStorage` class implemented
- [ ] Uses organization "Ink" and application "SearchHistory"
- [ ] `load_history()` returns list of strings
- [ ] Empty list returned if no history exists
- [ ] `save_history()` persists to QSettings
- [ ] `sync()` called after save to force write
- [ ] `clear()` method removes history key
- [ ] All exceptions caught and logged
- [ ] No crashes on storage errors
- [ ] QVariant types converted to strings
- [ ] Empty strings filtered out during load
- [ ] Integration test verifies persistence across instances
- [ ] Manual testing on target platforms (Linux priority)

---

## 5. Implementation Notes

### Testing Strategy

```python
# tests/integration/infrastructure/persistence/test_qsettings_history_storage.py

import pytest
from PySide6.QtCore import QSettings
from ink.infrastructure.persistence.qsettings_history_storage import (
    QSettingsHistoryStorage
)


@pytest.fixture
def clean_settings():
    """Clear test settings before/after each test"""
    settings = QSettings("Ink", "SearchHistory")
    settings.clear()
    yield
    settings.clear()


def test_load_empty_history(clean_settings):
    """Loading with no saved history should return empty list"""
    storage = QSettingsHistoryStorage()
    assert storage.load_history() == []


def test_save_and_load_history(clean_settings):
    """Saved history should persist and be loadable"""
    storage = QSettingsHistoryStorage()
    queries = ["NAND2", "DFF", "clk_net"]

    storage.save_history(queries)
    loaded = storage.load_history()

    assert loaded == queries


def test_persistence_across_instances(clean_settings):
    """History should persist across different storage instances"""
    storage1 = QSettingsHistoryStorage()
    storage1.save_history(["query1", "query2"])

    storage2 = QSettingsHistoryStorage()
    loaded = storage2.load_history()

    assert loaded == ["query1", "query2"]


def test_clear_history(clean_settings):
    """Clear should remove all history"""
    storage = QSettingsHistoryStorage()
    storage.save_history(["NAND2", "DFF"])

    storage.clear()

    assert storage.load_history() == []


def test_handles_empty_strings(clean_settings):
    """Empty strings should be filtered out"""
    storage = QSettingsHistoryStorage()
    storage.save_history(["NAND2", "", "DFF", "   "])

    loaded = storage.load_history()

    # Empty strings filtered during load
    assert "" not in loaded
    assert "   " not in loaded
```

### File Structure
```
src/ink/infrastructure/persistence/
├── __init__.py
└── qsettings_history_storage.py

tests/integration/infrastructure/persistence/
└── test_qsettings_history_storage.py
```

### Error Handling Philosophy
- Storage layer should never crash the application
- Log errors for debugging but continue operation
- Return sensible defaults (empty list) on failures
- Domain layer handles business logic; infrastructure handles I/O

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
