# Pre-Implementation Documentation: E05-F05-T03 - History Persistence

## 1. Overview and Problem Context

### Problem Statement
Search history must persist across application sessions to provide value. Users expect their recent searches to survive application restarts. This requires a concrete implementation of the `HistoryStorage` protocol using Qt's platform-agnostic persistence framework.

### Context
- Qt provides `QSettings` for cross-platform application settings storage
- Different platforms use different storage backends (files, registry, plist)
- Infrastructure layer must implement domain protocol without leaking Qt dependencies
- Storage operations must be robust against I/O failures
- History data is simple (list of strings) but must be serialized correctly

### Core Challenge
Implementing a reliable, cross-platform persistence adapter that bridges Qt's `QSettings` API with the domain's `HistoryStorage` protocol while handling platform differences and failure scenarios gracefully.

---

## 2. Implementation Approach

### High-Level Strategy
1. Create `QSettingsHistoryStorage` class in infrastructure layer
2. Implement `HistoryStorage` protocol interface
3. Use Qt's `QSettings` with organization/application name for namespacing
4. Leverage `QSettings.value()` for automatic list serialization
5. Handle type conversions (QVariant to Python str)
6. Implement graceful error handling for I/O failures
7. Add `clear()` helper for complete history removal

### Component Architecture

**QSettingsHistoryStorage** (Infrastructure Adapter)
- Implements `HistoryStorage` protocol from domain layer
- Wraps Qt's `QSettings` API
- Manages serialization/deserialization
- Provides platform-appropriate storage locations

**Storage Key Structure**:
```
Organization: "Ink"
Application: "SearchHistory"
Key: "search/history" → List[str]
```

### Platform Storage Locations

**Linux** (INI file):
```
~/.config/Ink/SearchHistory.conf

[search]
history=["NAND2", "DFF.*", "clk_net"]
```

**Windows** (Registry):
```
HKEY_CURRENT_USER\Software\Ink\SearchHistory
  search\history: REG_MULTI_SZ
```

**macOS** (plist):
```
~/Library/Preferences/com.Ink.SearchHistory.plist

<dict>
  <key>search</key>
  <dict>
    <key>history</key>
    <array>
      <string>NAND2</string>
      <string>DFF.*</string>
    </array>
  </dict>
</dict>
```

### Data Flow

**Load Path**:
```
SearchHistory.__init__()
    ↓
storage.load_history()
    ↓
QSettings.value("search/history", defaultValue=[], type=list)
    ↓
Convert QVariant items to str
    ↓
Filter empty strings
    ↓
Return List[str] to domain
```

**Save Path**:
```
SearchHistory.add(query)
    ↓
storage.save_history(queries)
    ↓
QSettings.setValue("search/history", queries)
    ↓
QSettings.sync()  # Force write to disk
    ↓
Platform-specific backend writes data
```

---

## 3. Key Design Decisions

### Decision 1: QSettings Over Custom JSON Files
**Choice**: Use Qt's `QSettings` instead of custom JSON file handling
**Rationale**:
- Platform-appropriate storage locations handled automatically
- Thread-safe file locking built-in
- Atomic write operations prevent corruption
- Native integration with OS (registry on Windows, plist on macOS)
- Consistent with Qt application architecture

**Alternative Considered**: Manual JSON file in `~/.config/ink/`
**Why Rejected**:
- Must handle locking manually
- Platform differences require conditional code
- Reinvents what Qt already provides

### Decision 2: Organization and Application Naming
**Choice**: Use "Ink" as organization, "SearchHistory" as application
**Rationale**:
- Clear namespacing prevents conflicts with other apps
- "SearchHistory" separates from other app settings (future: window geometry, theme, etc.)
- Allows multiple QSettings instances for different concerns
- Standard Qt convention

**Alternative Considered**: Single "Ink" application with nested keys
**Why Rejected**: Less modular, harder to clear specific settings

### Decision 3: Hierarchical Key Structure
**Choice**: Use `"search/history"` as key instead of flat `"history"`
**Rationale**:
- Future-proof for other search-related settings (e.g., `"search/maxResults"`)
- Logical grouping in settings hierarchy
- Clearer organization in registry/config viewers

### Decision 4: Type Hint with defaultValue
**Choice**: Use `QSettings.value(key, defaultValue=[], type=list)`
**Rationale**:
- Qt automatically deserializes to Python list
- `type=list` hint ensures correct type conversion
- `defaultValue=[]` handles missing key gracefully
- More Pythonic than manual parsing

**Implementation**:
```python
history = self._settings.value("search/history", defaultValue=[], type=list)
```

### Decision 5: QVariant to String Conversion
**Choice**: Explicitly convert all list items to `str`
**Rationale**:
- QSettings may return `QVariant` objects instead of pure Python strings
- Platform differences in type handling
- Defensive programming ensures protocol contract (List[str]) is met
- Filters out None/empty values

**Implementation**:
```python
return [str(query) for query in history if query]
```

### Decision 6: sync() After Every Save
**Choice**: Call `QSettings.sync()` after `setValue()`
**Rationale**:
- Forces immediate write to disk (QSettings normally batches)
- Ensures persistence even if app crashes shortly after
- History is small, performance impact negligible
- Users expect immediate persistence for this feature

**Alternative Considered**: Rely on automatic flushing at app exit
**Why Rejected**: Risk of data loss on crash

### Decision 7: Graceful Error Handling
**Choice**: Catch all exceptions, log, return sensible defaults
**Rationale**:
- Storage failures shouldn't crash application
- History is convenience feature, not critical
- User can continue working even if persistence fails
- Matches domain service error handling philosophy

**Implementation**:
```python
try:
    return self._settings.value(...)
except Exception as e:
    print(f"Error loading: {e}")
    return []  # Sensible default
```

---

## 4. Dependencies and Integration Points

### Upstream Dependencies

**Required**:
1. **E05-F05-T01**: `HistoryStorage` protocol definition
   - Must implement: `load_history() -> List[str]`
   - Must implement: `save_history(queries: List[str]) -> None`

2. **PySide6.QtCore**: `QSettings` class
   - Platform-specific settings backend

### Downstream Consumers

**Direct Users**:
1. **SearchHistory** (domain service): Injects storage via constructor
2. **Application Composition Root**: Creates storage instance and wires dependencies

### Integration Pattern

**Dependency Injection**:
```python
# In app.py or main.py

from ink.infrastructure.persistence.qsettings_history_storage import (
    QSettingsHistoryStorage
)
from ink.domain.services.search_history import SearchHistory

# Infrastructure layer
storage = QSettingsHistoryStorage()

# Domain layer
history = SearchHistory(storage)

# Presentation layer
panel = SearchPanel(search_service, history)
```

**Protocol Compliance**:
```python
# Domain defines protocol
class HistoryStorage(Protocol):
    def load_history(self) -> List[str]: ...
    def save_history(self, queries: List[str]) -> None: ...

# Infrastructure implements protocol
class QSettingsHistoryStorage:  # No explicit inheritance
    def load_history(self) -> List[str]:
        # Implementation

    def save_history(self, queries: List[str]) -> None:
        # Implementation
```

Python's structural typing ensures protocol compliance without inheritance.

---

## 5. Testing Strategy

### Integration Test Categories

**1. Basic Persistence**
- `test_load_empty_history()`: First run returns empty list
- `test_save_and_load_history()`: Round-trip save/load works
- `test_persistence_across_instances()`: Multiple storage instances share data

**2. Data Integrity**
- `test_handles_empty_strings()`: Empty strings filtered out
- `test_preserves_order()`: List order maintained
- `test_preserves_special_characters()`: Regex patterns like `"DFF.*"` work

**3. Edge Cases**
- `test_large_history()`: Handles 10+ items (though domain limits to 10)
- `test_unicode_queries()`: UTF-8 strings handled correctly
- `test_very_long_queries()`: Long strings don't cause issues

**4. Management**
- `test_clear_history()`: `clear()` removes all data
- `test_clear_and_reload()`: After clear, load returns empty

### Testing Approach

**QSettings Fixture**:
```python
import pytest
from PySide6.QtCore import QSettings

@pytest.fixture
def clean_settings():
    """Ensure clean state before/after each test"""
    settings = QSettings("Ink", "SearchHistory")
    settings.clear()
    settings.sync()
    yield
    settings.clear()
    settings.sync()
```

**Test Structure**:
```python
def test_save_and_load_history(clean_settings):
    """Saved history should persist and be loadable"""
    storage = QSettingsHistoryStorage()

    # Save
    queries = ["NAND2", "DFF", "clk_net"]
    storage.save_history(queries)

    # Load
    loaded = storage.load_history()

    # Verify
    assert loaded == queries
```

**Cross-Instance Test**:
```python
def test_persistence_across_instances(clean_settings):
    """History should persist across different storage instances"""
    # Instance 1 saves
    storage1 = QSettingsHistoryStorage()
    storage1.save_history(["query1", "query2"])

    # Instance 2 loads
    storage2 = QSettingsHistoryStorage()
    loaded = storage2.load_history()

    # Verify
    assert loaded == ["query1", "query2"]
```

### Manual Testing

**Platform Testing Matrix**:
| Platform | Storage Location | Verification Method |
|----------|------------------|---------------------|
| Linux | `~/.config/Ink/SearchHistory.conf` | `cat ~/.config/Ink/SearchHistory.conf` |
| Windows | Registry | `regedit` → navigate to key |
| macOS | `~/Library/Preferences/com.Ink.SearchHistory.plist` | `defaults read com.Ink.SearchHistory` |

**Manual Test Scenarios**:
1. **First Run**: Verify no errors when settings file doesn't exist
2. **Persistence**: Save history, quit app, restart, verify history loaded
3. **Corruption**: Manually corrupt settings file, verify graceful handling
4. **Permissions**: Run with read-only home directory, verify error handling

---

## 6. Risks and Considerations

### Technical Risks

**Risk 1: QSettings Platform Differences**
- **Description**: Different platforms may serialize lists differently
- **Likelihood**: Low (Qt abstracts this)
- **Impact**: High (would break cross-platform use)
- **Mitigation**:
  - Test on all platforms
  - Explicit type conversion (`str()` cast)
  - Use `type=list` parameter

**Risk 2: QVariant Type Issues**
- **Description**: Qt might return QVariant instead of Python str
- **Likelihood**: Medium (depends on Qt version)
- **Impact**: Medium (domain service expects List[str])
- **Mitigation**: Explicit `[str(query) for query in history]` conversion (IMPLEMENTED)

**Risk 3: Storage Permissions**
- **Description**: User's home directory might be read-only or full
- **Likelihood**: Low (uncommon)
- **Impact**: Medium (history won't persist)
- **Mitigation**: Exception handling, application continues without persistence

**Risk 4: File Corruption**
- **Description**: Settings file might become corrupted (disk failure, concurrent access)
- **Likelihood**: Low
- **Impact**: Low (history is non-critical)
- **Mitigation**: Return empty list on parse error, fresh history starts

**Risk 5: Thread Safety**
- **Description**: Concurrent access from multiple threads
- **Likelihood**: Low (application is single-threaded)
- **Impact**: Low (QSettings handles locking)
- **Mitigation**: Document that SearchHistory is not thread-safe

### Implementation Risks

**Risk 6: Key Naming Conflicts**
- **Description**: Future settings might conflict with "search/history"
- **Likelihood**: Low
- **Impact**: Low (easy to rename)
- **Mitigation**: Clear key naming convention documented

**Risk 7: Migration from Old Settings**
- **Description**: If we change key structure, old data is lost
- **Likelihood**: Low (only an issue for future versions)
- **Impact**: Low (history rebuilds naturally)
- **Mitigation**: Not needed for MVP, consider migration utility in P1

### Data Integrity Risks

**Risk 8: List Serialization Limits**
- **Description**: Very large lists or very long strings might not serialize
- **Likelihood**: Low (domain limits to 10 items)
- **Impact**: Low
- **Mitigation**: Domain enforces size limit

**Risk 9: Special Characters in Queries**
- **Description**: Regex patterns might not serialize correctly (e.g., `"DFF.*"`)
- **Likelihood**: Medium
- **Impact**: Medium (could lose regex search history)
- **Mitigation**: Test with regex patterns, Qt should handle UTF-8 correctly

---

## 7. Open Questions

### Technical Questions
1. **QSettings Scope**: Should we use `QSettings.UserScope` explicitly?
   - **Current Assumption**: Default scope is sufficient
   - **Impact**: Low (UserScope is default)

2. **Error Logging**: Should we use proper logging framework or print?
   - **Current Assumption**: Use `print()` for MVP
   - **Impact**: Low (only affects debugging)
   - **Future**: Integrate with application logging in P1

3. **Clear Method**: Should `clear()` be part of `HistoryStorage` protocol?
   - **Current Assumption**: Extra method in concrete implementation
   - **Impact**: Low (not called by domain service)
   - **Decision**: Not part of protocol, utility method for testing

### Platform Questions
1. **Windows Registry Limits**: Are there size limits for REG_MULTI_SZ?
   - **Current Assumption**: No issue with 10 small strings
   - **Impact**: Low

2. **macOS Permissions**: Does plist storage work in sandboxed environments?
   - **Current Assumption**: Not planning sandboxed distribution for MVP
   - **Impact**: None for MVP

### Design Questions
1. **Synchronous vs. Asynchronous**: Should saves be async to avoid blocking UI?
   - **Current Assumption**: Synchronous is fine for small data
   - **Impact**: None (10 strings is trivial)
   - **Decision**: Keep synchronous for simplicity

---

## 8. Implementation Checklist

### Phase 1: Class Structure
- [ ] Create `src/ink/infrastructure/persistence/qsettings_history_storage.py`
- [ ] Define class constants:
  - [ ] `ORGANIZATION = "Ink"`
  - [ ] `APPLICATION = "SearchHistory"`
  - [ ] `HISTORY_KEY = "search/history"`
- [ ] Implement `__init__()` to create QSettings instance

### Phase 2: Load Implementation
- [ ] Implement `load_history()`:
  - [ ] Call `QSettings.value()` with defaultValue and type hint
  - [ ] Convert all items to str
  - [ ] Filter empty strings
  - [ ] Wrap in try/except
  - [ ] Return List[str]

### Phase 3: Save Implementation
- [ ] Implement `save_history()`:
  - [ ] Call `QSettings.setValue()`
  - [ ] Call `QSettings.sync()`
  - [ ] Wrap in try/except
  - [ ] Log errors but don't crash

### Phase 4: Clear Implementation
- [ ] Implement `clear()`:
  - [ ] Call `QSettings.remove()`
  - [ ] Call `QSettings.sync()`
  - [ ] Wrap in try/except

### Phase 5: Testing
- [ ] Create `tests/integration/infrastructure/persistence/test_qsettings_history_storage.py`
- [ ] Implement `clean_settings` fixture
- [ ] Write integration tests:
  - [ ] `test_load_empty_history()`
  - [ ] `test_save_and_load_history()`
  - [ ] `test_persistence_across_instances()`
  - [ ] `test_clear_history()`
  - [ ] `test_handles_empty_strings()`
- [ ] Manual testing on Linux

### Phase 6: Documentation
- [ ] Add comprehensive class docstring with storage location details
- [ ] Document all platform-specific behaviors
- [ ] Add method docstrings with examples
- [ ] Document error handling philosophy

### Phase 7: Integration
- [ ] Update composition root to create storage instance
- [ ] Wire storage into SearchHistory
- [ ] Test end-to-end persistence
- [ ] Verify settings file created in correct location

---

## 9. Success Criteria

### Functional Success
- [ ] All 13 acceptance criteria met
- [ ] History persists across application restarts
- [ ] Empty list returned on first run
- [ ] All integration tests pass
- [ ] Manual verification on Linux

### Quality Success
- [ ] Type hints on all methods
- [ ] Comprehensive docstrings
- [ ] No pylint/mypy errors
- [ ] Exception handling covers all I/O operations
- [ ] No crashes on storage errors

### Integration Success
- [ ] Implements `HistoryStorage` protocol correctly
- [ ] Works seamlessly with SearchHistory domain service
- [ ] Settings file created in platform-appropriate location
- [ ] No Qt dependencies leaked into domain layer

---

## 10. Estimated Effort Breakdown

**Total: 2 hours**

- Class implementation: 0.5 hours
- Integration tests: 0.5 hours
- Manual testing on Linux: 0.5 hours
- Documentation: 0.25 hours
- Composition root wiring: 0.25 hours

**Confidence**: High (straightforward Qt API usage)

---

## 11. Post-Implementation Validation

### Automated Tests
1. Run all integration tests with clean fixture
2. Verify no test pollution (each test cleans up)
3. Check coverage of error paths

### Manual Verification Checklist

**Linux Testing**:
- [ ] Run application, perform searches
- [ ] Quit application
- [ ] Verify `~/.config/Ink/SearchHistory.conf` exists
- [ ] Inspect file contents (should be INI format with list)
- [ ] Restart application
- [ ] Verify history loaded correctly

**Corruption Testing**:
- [ ] Manually corrupt settings file (invalid JSON/INI)
- [ ] Start application
- [ ] Verify graceful handling (empty history, no crash)
- [ ] Verify new searches save correctly (overwrite corruption)

**Permission Testing**:
- [ ] Make `~/.config/Ink/` read-only
- [ ] Start application
- [ ] Verify no crash on save failure
- [ ] Check error logged
- [ ] Restore permissions, verify normal operation

### Integration Validation

**End-to-End Test**:
1. Start application (clean state)
2. Perform 3 searches: "NAND2", "DFF", "AND2"
3. Verify history dropdown shows all three
4. Quit application
5. Restart application
6. Verify history dropdown shows same three queries
7. Perform new search "OR2"
8. Verify history updated to ["OR2", "NAND2", "DFF", "AND2"]
9. Clear history via context menu
10. Quit and restart
11. Verify history is empty

### Code Review Checklist
- [ ] No domain logic in infrastructure layer
- [ ] Protocol implementation is complete
- [ ] Type conversions are explicit
- [ ] Error handling is defensive
- [ ] Platform differences documented
- [ ] No hardcoded paths (use QSettings abstraction)
- [ ] sync() called after all modifications
- [ ] Class is testable (no hidden state)

---

## 12. Future Enhancements (Post-MVP)

### P1 Enhancements
1. **Migration Utility**: Handle settings key changes gracefully
2. **Logging Integration**: Use proper logging framework instead of print
3. **Settings Export/Import**: Allow backup of all application settings
4. **Size Limits**: Add checks for extremely large queries (> 1KB)

### P2 Enhancements
1. **Compression**: Compress history if storing more than 10 items
2. **Encryption**: Encrypt sensitive search patterns
3. **Cloud Sync**: Sync history across devices (with user consent)
4. **Analytics**: Track search pattern metrics (with user consent)

### Monitoring Opportunities
- Track QSettings file size over time
- Monitor save/load performance
- Log platform-specific serialization differences
