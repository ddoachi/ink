# Pre-Implementation Documentation: E05-F05-T02 - History UI Integration

## 1. Overview and Problem Context

### Problem Statement
Users need a convenient way to access and re-execute recent search queries without retyping them. This requires integrating search history into the SearchPanel UI with an intuitive dropdown interface and management controls.

### Context
- Modern applications provide search history as a standard UX feature
- Users expect click-to-reuse functionality for recent queries
- History should be visible but not intrusive
- Must integrate seamlessly with existing SearchPanel implementation
- Follows Qt/PySide6 widget patterns and signals/slots architecture

### Core Challenge
Designing a history dropdown that balances discoverability with minimal UI clutter while maintaining clean separation between UI (presentation) and business logic (domain/application).

---

## 2. Implementation Approach

### High-Level Strategy
1. Extend existing `SearchPanel` widget with history dropdown
2. Use `QComboBox` in non-editable mode for history selection
3. Add context menu for history management (clear)
4. Wire up signals to prevent unintended search triggers
5. Update dropdown automatically after each search execution
6. Maintain placeholder item for clear visual state

### Component Architecture

**SearchPanel Enhancement**
- Add `QComboBox` widget for history dropdown
- Inject `SearchHistory` domain service via constructor
- Implement signal blocking to prevent cascading searches
- Add context menu with "Clear History" action
- Update dropdown state after every search

**UI Layout Structure**
```
SearchPanel (QWidget)
  QVBoxLayout
    QHBoxLayout (search input row)
      QLineEdit (search_input)
      QPushButton (search_button)
    QHBoxLayout (history row)          ← NEW
      QLabel ("Recent:")                ← NEW
      QComboBox (history_dropdown)      ← NEW
    [Results area - existing]
```

### Data Flow

**Search Execution Flow**:
```
User submits search (Enter or button)
    ↓
_on_search_submitted()
    ↓
_execute_search(query)
    ↓
1. history.add(query)           # Domain layer updates
2. _update_history_dropdown()    # UI reflects changes
3. search_service.search(query)  # Execute search
4. _display_results(results)     # Show results
5. emit search_executed signal   # Notify other components
```

**History Selection Flow**:
```
User clicks dropdown item
    ↓
_on_history_selected(query)
    ↓
1. Validate not placeholder
2. Populate search input field
3. _execute_search(query)        # Same as manual search
4. Reset dropdown to placeholder
```

**Clear History Flow**:
```
User right-clicks dropdown → "Clear History"
    ↓
_clear_history()
    ↓
1. history.clear()               # Domain layer updates
2. _update_history_dropdown()     # UI reflects changes
```

---

## 3. Key Design Decisions

### Decision 1: QComboBox vs. Custom Dropdown
**Choice**: Use `QComboBox` in non-editable mode
**Rationale**:
- Built-in Qt widget with proven UX patterns
- Handles keyboard navigation, rendering, platform styling
- No need to reinvent dropdown behavior
- Non-editable mode prevents accidental text changes

**Alternative Considered**: Custom `QMenu` triggered by button
**Why Rejected**: Less discoverable, requires extra click, non-standard UX

### Decision 2: Placeholder Item Strategy
**Choice**: Always show "-- Recent Searches --" as first item (index 0)
**Rationale**:
- Clear visual state when no selection active
- Prevents accidental selection on dropdown open
- Standard pattern used by many applications (e.g., HTML `<select>` placeholders)

**Implementation Details**:
```python
dropdown.addItem("-- Recent Searches --")  # Always index 0
dropdown.addItems(recent_queries)           # Actual history
dropdown.setCurrentIndex(0)                 # Reset to placeholder
```

### Decision 3: Signal Blocking During Updates
**Choice**: Block signals during `_update_history_dropdown()`
**Rationale**:
- Prevents `currentTextChanged` signal from triggering search during programmatic updates
- Only user interactions should trigger searches
- Avoids infinite loops (search → update dropdown → search → ...)

**Implementation**:
```python
self.history_dropdown.blockSignals(True)
# ... update dropdown contents ...
self.history_dropdown.blockSignals(False)
```

**Alternative Considered**: Check sender in signal handler
**Why Rejected**: Error-prone, harder to maintain, signal blocking is cleaner

### Decision 4: Context Menu for Clear Action
**Choice**: Right-click context menu instead of dedicated button
**Rationale**:
- Reduces UI clutter (no extra button needed)
- Standard pattern for "management" actions
- Users discover by natural right-click exploration
- Matches Qt conventions (e.g., right-click in file dialogs)

**Alternative Considered**: Dedicated "Clear" button next to dropdown
**Why Rejected**: Adds visual noise, rarely needed action doesn't justify permanent UI space

### Decision 5: Auto-populate Input Field on Selection
**Choice**: Set `search_input.setText(query)` before executing
**Rationale**:
- User sees what query is being executed
- Allows editing before re-execution if needed (future enhancement)
- Maintains consistency: input field always reflects current search

**Alternative Considered**: Execute directly without showing in input
**Why Rejected**: Less transparent, confusing if user wants to modify

### Decision 6: Reset Dropdown After Selection
**Choice**: Set dropdown back to placeholder after executing from history
**Rationale**:
- Prevents dropdown from "sticking" on selected item
- Clear visual state for next interaction
- Dropdown serves as action trigger, not state display

---

## 4. Dependencies and Integration Points

### Upstream Dependencies

**Required Components**:
1. **E05-F05-T01**: `SearchHistory` domain service
   - `add(query: str) -> None`
   - `get_recent(limit: int) -> List[str]`
   - `clear() -> None`

2. **E05-F01**: Existing `SearchPanel` implementation
   - Search input field
   - Search button
   - Results display area
   - `SearchService` integration

3. **PySide6 Widgets**:
   - `QComboBox`: History dropdown
   - `QMenu`: Context menu
   - `QLabel`: "Recent:" label

### Downstream Consumers

**UI Integration**:
- MainWindow will instantiate SearchPanel with injected dependencies
- Other components may listen to `search_executed` signal

### Dependency Injection

**Constructor Signature**:
```python
def __init__(
    self,
    search_service: SearchService,
    search_history: SearchHistory,  # NEW
    parent: Optional[QWidget] = None
):
```

**Composition Root** (app.py or main_window.py):
```python
# Create dependencies
history_storage = QSettingsHistoryStorage()  # From T03
search_history = SearchHistory(history_storage)
search_service = SearchService(...)

# Inject into UI
search_panel = SearchPanel(
    search_service=search_service,
    search_history=search_history
)
```

---

## 5. Testing Strategy

### Unit Test Categories

**1. Dropdown Population**
- `test_history_dropdown_initialized()`: Dropdown shows placeholder on init
- `test_history_dropdown_populated()`: Dropdown populated with recent queries
- `test_empty_history_shows_placeholder_only()`: Only placeholder when no history

**2. User Interactions**
- `test_click_history_executes_search()`: Clicking item triggers search
- `test_click_history_populates_input()`: Input field updated before search
- `test_dropdown_resets_after_selection()`: Placeholder restored after use
- `test_placeholder_selection_ignored()`: Clicking placeholder does nothing

**3. History Updates**
- `test_dropdown_updates_after_search()`: New search updates dropdown
- `test_dropdown_reflects_deduplication()`: Duplicates handled correctly

**4. Context Menu**
- `test_right_click_shows_context_menu()`: Context menu appears
- `test_clear_history_action()`: "Clear History" action works
- `test_clear_updates_dropdown()`: Dropdown shows only placeholder after clear

**5. Signal Blocking**
- `test_programmatic_update_no_search()`: Signal blocking prevents unintended searches

### Testing Approach

**QTest Framework**:
```python
from PySide6.QtTest import QTest
from PySide6.QtCore import Qt, QPoint

def test_click_history_executes_search(qtbot):
    """Clicking history item should execute search"""
    # Setup
    mock_service = Mock()
    mock_history = Mock()
    mock_history.get_recent.return_value = ["NAND2", "DFF"]

    panel = SearchPanel(mock_service, mock_history)
    qtbot.addWidget(panel)

    # Simulate dropdown selection
    panel.history_dropdown.setCurrentText("NAND2")

    # Verify search executed
    mock_service.search.assert_called_once_with("NAND2")
    assert panel.search_input.text() == "NAND2"
```

**Mock Dependencies**:
```python
class MockSearchService:
    def search(self, query: str):
        return []  # Mock results

class MockSearchHistory:
    def __init__(self):
        self.history = []

    def add(self, query: str):
        self.history.insert(0, query)

    def get_recent(self, limit: int = 10):
        return self.history[:limit]

    def clear(self):
        self.history.clear()
```

### Manual Testing Scenarios

**Scenario 1: First Use**
1. Open application (no history)
2. Dropdown shows only "-- Recent Searches --"
3. Search for "NAND2"
4. Dropdown updates to show "NAND2"

**Scenario 2: History Reuse**
1. Search for "DFF", "AND2", "NAND2"
2. Dropdown shows all three (newest first)
3. Click "DFF" in dropdown
4. Search executes, input shows "DFF"
5. Dropdown resets to placeholder

**Scenario 3: Clear History**
1. Build history with multiple searches
2. Right-click dropdown
3. Select "Clear History"
4. Dropdown shows only placeholder
5. New searches work normally

---

## 6. Risks and Considerations

### Technical Risks

**Risk 1: Signal Loop**
- **Description**: Updating dropdown triggers search, which updates dropdown, etc.
- **Likelihood**: High without mitigation
- **Impact**: High (infinite loop, application hang)
- **Mitigation**: Signal blocking during programmatic updates (IMPLEMENTED)

**Risk 2: Qt Thread Safety**
- **Description**: SearchHistory might be called from non-UI thread
- **Likelihood**: Low (application is single-threaded)
- **Impact**: Medium (potential crashes)
- **Mitigation**: Document that SearchPanel must be used on main thread only

**Risk 3: Large History Performance**
- **Description**: Updating dropdown with many items might cause lag
- **Likelihood**: Low (max 10 items)
- **Impact**: Low (10 items is trivial for QComboBox)
- **Mitigation**: None needed (10 item limit sufficient)

### UX Risks

**Risk 4: Dropdown Discovery**
- **Description**: Users might not notice history dropdown
- **Likelihood**: Medium
- **Impact**: Low (reduces efficiency but doesn't break functionality)
- **Mitigation**: Clear label "Recent:", standard dropdown affordance

**Risk 5: Accidental Clear**
- **Description**: User might clear history by accident
- **Likelihood**: Low (requires right-click + select)
- **Impact**: Low (history rebuilds with new searches)
- **Mitigation**: Could add confirmation dialog in P1

**Risk 6: Placeholder Confusion**
- **Description**: Users might think "-- Recent Searches --" is a search query
- **Likelihood**: Low (clear separator formatting)
- **Impact**: Low (clicking it does nothing)
- **Mitigation**: Ignore placeholder in selection handler (IMPLEMENTED)

### Integration Risks

**Risk 7: SearchPanel Modifications**
- **Description**: Existing SearchPanel structure might not support easy extension
- **Likelihood**: Medium (depends on current implementation)
- **Impact**: Medium (might require refactoring)
- **Mitigation**: Review current SearchPanel before starting; plan refactor if needed

**Risk 8: Dependency Injection Complexity**
- **Description**: Adding new dependency might complicate composition root
- **Likelihood**: Low
- **Impact**: Low
- **Mitigation**: Clear documentation of dependency injection pattern

---

## 7. Open Questions

### UX Questions
1. **Dropdown Width**: Should dropdown match search input width or be independent?
   - **Current Assumption**: Use `setSizePolicy(Expanding, Fixed)` to match row width
   - **Impact**: Low (cosmetic only)

2. **History Item Formatting**: Should queries be truncated if too long?
   - **Current Assumption**: No truncation (typical queries are short)
   - **Impact**: Low
   - **Future**: Add ellipsis for queries > 50 chars in P1

3. **Keyboard Shortcuts**: Should there be shortcut to focus history dropdown?
   - **Current Assumption**: No shortcut for MVP
   - **Impact**: Low (power user feature, defer to P1)

### Technical Questions
1. **Signal Type**: Should `search_executed` signal include results or just query?
   - **Current Assumption**: Just query (str), results handled internally
   - **Impact**: Low (can change signal signature if needed)

2. **Context Menu Position**: Use widget coordinates or global coordinates?
   - **Current Assumption**: `mapToGlobal(pos)` for proper positioning
   - **Impact**: None (standard Qt practice)

### Implementation Questions
1. **Existing SearchPanel**: Does current implementation have `_execute_search()` method?
   - **Action Required**: Review E05-F01 implementation to determine refactoring needs

2. **Search Service Interface**: What does `search_service.search()` return?
   - **Action Required**: Check SearchService API contract

---

## 8. Implementation Checklist

### Phase 1: UI Layout Changes
- [ ] Add `QComboBox` to SearchPanel layout
- [ ] Add "Recent:" `QLabel` next to dropdown
- [ ] Position history row below search input row
- [ ] Set appropriate size policies

### Phase 2: Dependency Injection
- [ ] Update `__init__()` signature to accept `SearchHistory`
- [ ] Store history reference in instance variable
- [ ] Update composition root to inject dependency

### Phase 3: Dropdown Management
- [ ] Implement `_update_history_dropdown()`:
  - [ ] Block signals
  - [ ] Clear dropdown
  - [ ] Add placeholder item
  - [ ] Add recent queries from history
  - [ ] Set current index to placeholder
  - [ ] Unblock signals
- [ ] Call `_update_history_dropdown()` in `__init__()`

### Phase 4: Search Integration
- [ ] Refactor search execution into `_execute_search(query)` helper
- [ ] Update `_on_search_submitted()` to use `_execute_search()`
- [ ] Add `history.add(query)` call in `_execute_search()`
- [ ] Add dropdown update call after history add
- [ ] Emit `search_executed` signal

### Phase 5: History Selection
- [ ] Connect `currentTextChanged` signal to `_on_history_selected()`
- [ ] Implement `_on_history_selected()`:
  - [ ] Validate not placeholder
  - [ ] Populate search input field
  - [ ] Call `_execute_search()`
  - [ ] Reset dropdown to placeholder

### Phase 6: Context Menu
- [ ] Set context menu policy to `CustomContextMenu`
- [ ] Connect `customContextMenuRequested` signal
- [ ] Implement `_show_history_context_menu()`:
  - [ ] Create QMenu
  - [ ] Add "Clear History" action
  - [ ] Connect to `_clear_history()`
  - [ ] Show at global position
- [ ] Implement `_clear_history()`:
  - [ ] Call `history.clear()`
  - [ ] Update dropdown

### Phase 7: Testing
- [ ] Create `tests/ui/panels/test_search_panel_history.py`
- [ ] Implement unit tests for all interactions (10+ tests)
- [ ] Manual testing on Linux
- [ ] Verify signal blocking works correctly

### Phase 8: Documentation
- [ ] Add docstrings to new methods
- [ ] Update SearchPanel class docstring
- [ ] Document signal blocking rationale
- [ ] Add inline comments for complex logic

---

## 9. Success Criteria

### Functional Success
- [ ] All 14 acceptance criteria met
- [ ] Dropdown populated with recent queries
- [ ] Clicking history item executes search
- [ ] Context menu allows clearing history
- [ ] No unintended searches from programmatic updates
- [ ] Dropdown updates after each search

### Quality Success
- [ ] Type hints on all new methods
- [ ] Docstrings on all public methods
- [ ] No pylint/mypy errors
- [ ] Follows Qt signal/slot best practices
- [ ] UI remains responsive

### UX Success
- [ ] History dropdown is discoverable
- [ ] Interaction feels natural and intuitive
- [ ] No visual glitches or flashing
- [ ] Clear distinction between placeholder and queries

---

## 10. Estimated Effort Breakdown

**Total: 4 hours**

- Review existing SearchPanel: 0.5 hours
- UI layout changes: 0.5 hours
- Dropdown management logic: 1 hour
- Search integration refactoring: 0.5 hours
- Context menu implementation: 0.5 hours
- Unit tests: 1 hour
- Manual testing and polish: 0.5 hours

**Confidence**: Medium-High (depends on existing SearchPanel structure)

---

## 11. Post-Implementation Validation

### Manual Testing Checklist
1. **Initial State**
   - [ ] Dropdown shows only placeholder on first run
   - [ ] Dropdown width matches layout properly

2. **Search Execution**
   - [ ] Manual search adds to history
   - [ ] Dropdown updates immediately after search
   - [ ] Multiple searches maintain newest-first order

3. **History Selection**
   - [ ] Clicking placeholder does nothing
   - [ ] Clicking query populates input field
   - [ ] Clicking query executes search
   - [ ] Dropdown resets to placeholder after selection

4. **Context Menu**
   - [ ] Right-click shows context menu
   - [ ] "Clear History" removes all queries
   - [ ] Dropdown updates after clear

5. **Edge Cases**
   - [ ] Empty history shows only placeholder
   - [ ] 10+ searches only show 10 most recent
   - [ ] Duplicate searches handled correctly (moved to front)

### Integration Testing
1. Verify SearchPanel integrates with MainWindow
2. Check dependency injection in composition root
3. Ensure no crashes on missing dependencies
4. Validate signal emissions work correctly

### Code Review Checklist
- [ ] No business logic in presentation layer (only UI)
- [ ] SearchHistory domain service used correctly
- [ ] Signal blocking implemented properly
- [ ] Memory leaks prevented (no dangling signal connections)
- [ ] Qt best practices followed (parent/child relationships)
- [ ] Error handling for missing/null history
