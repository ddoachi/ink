---
id: E05-F05-T01
title: History Storage & Logic
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F05
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - domain
  - application
---

# Spec: E05-F05-T01 - History Storage & Logic

## 1. Overview

### 1.1 Problem Statement
Need a domain service to manage search query history with proper business rules for deduplication, ordering, and size limits.

### 1.2 Goals
- Implement `SearchHistory` domain service
- Define `HistoryStorage` protocol interface
- Enforce history management rules (max size, deduplication)
- Support add, retrieve, clear, and remove operations
- Ensure history ordering (newest first)

---

## 2. Technical Requirements

### 2.1 Domain Service - SearchHistory

**Location**: `src/ink/domain/services/search_history.py`

```python
from typing import List, Protocol


class HistoryStorage(Protocol):
    """Protocol for search history persistence"""

    def load_history(self) -> List[str]:
        """Load search history from storage"""
        ...

    def save_history(self, queries: List[str]) -> None:
        """Save search history to storage"""
        ...


class SearchHistory:
    """Manage search query history with business rules"""

    MAX_HISTORY_SIZE = 10

    def __init__(self, storage: HistoryStorage):
        self._storage = storage
        self._history: List[str] = []
        self._load()

    def add(self, query: str) -> None:
        """
        Add query to history with deduplication rules

        Rules:
        - Ignore empty strings
        - Remove existing duplicate and add to front
        - Ignore if same as most recent (consecutive duplicate)
        - Limit to MAX_HISTORY_SIZE (remove oldest)
        - Persist after each change
        """
        if not query or not query.strip():
            return

        query = query.strip()

        # Ignore consecutive duplicates
        if self._history and self._history[0] == query:
            return

        # Remove existing duplicate
        if query in self._history:
            self._history.remove(query)

        # Add to front
        self._history.insert(0, query)

        # Enforce size limit
        if len(self._history) > self.MAX_HISTORY_SIZE:
            self._history = self._history[:self.MAX_HISTORY_SIZE]

        self._save()

    def get_recent(self, limit: int = 10) -> List[str]:
        """
        Get recent queries (newest first)

        Args:
            limit: Maximum number of queries to return

        Returns:
            List of recent queries, limited by limit parameter
        """
        return self._history[:limit]

    def clear(self) -> None:
        """Clear all history and persist"""
        self._history.clear()
        self._save()

    def remove(self, query: str) -> None:
        """
        Remove specific query from history

        Args:
            query: Query string to remove
        """
        if query in self._history:
            self._history.remove(query)
            self._save()

    def _load(self) -> None:
        """Load history from persistent storage"""
        try:
            self._history = self._storage.load_history()
        except Exception:
            # If loading fails, start with empty history
            self._history = []

    def _save(self) -> None:
        """Save history to persistent storage"""
        try:
            self._storage.save_history(self._history)
        except Exception:
            # Log error but don't crash on save failure
            pass
```

### 2.2 Business Rules

| Rule | Implementation |
|------|----------------|
| Empty query | Ignore (don't add) |
| Whitespace-only query | Strip and ignore if empty |
| Consecutive duplicate | Ignore (don't re-add if same as most recent) |
| Non-consecutive duplicate | Remove old occurrence, add to front |
| Max size exceeded | Keep only newest MAX_HISTORY_SIZE entries |
| Case sensitivity | Treat different cases as different queries |
| Storage failure | Gracefully handle, don't crash application |

### 2.3 Test Cases

```python
def test_add_query_to_empty_history():
    """Adding first query should succeed"""
    history = SearchHistory(MockStorage())
    history.add("NAND2")
    assert history.get_recent() == ["NAND2"]


def test_add_duplicate_moves_to_front():
    """Duplicate query should be moved to front"""
    history = SearchHistory(MockStorage())
    history.add("NAND2")
    history.add("DFF")
    history.add("NAND2")
    assert history.get_recent() == ["NAND2", "DFF"]


def test_ignore_consecutive_duplicate():
    """Same query added twice in row should be ignored"""
    history = SearchHistory(MockStorage())
    history.add("NAND2")
    history.add("NAND2")
    assert history.get_recent() == ["NAND2"]


def test_ignore_empty_query():
    """Empty or whitespace queries should be ignored"""
    history = SearchHistory(MockStorage())
    history.add("")
    history.add("   ")
    assert history.get_recent() == []


def test_max_size_enforcement():
    """History should not exceed MAX_HISTORY_SIZE"""
    history = SearchHistory(MockStorage())
    for i in range(15):
        history.add(f"query_{i}")
    assert len(history.get_recent()) == 10
    assert history.get_recent()[0] == "query_14"  # Newest
    assert history.get_recent()[9] == "query_5"   # Oldest kept


def test_clear_history():
    """Clear should remove all entries"""
    history = SearchHistory(MockStorage())
    history.add("NAND2")
    history.add("DFF")
    history.clear()
    assert history.get_recent() == []


def test_remove_specific_query():
    """Remove should delete specific query"""
    history = SearchHistory(MockStorage())
    history.add("NAND2")
    history.add("DFF")
    history.add("AND2")
    history.remove("DFF")
    assert history.get_recent() == ["AND2", "NAND2"]


def test_persistence_on_add():
    """Storage should be updated on each add"""
    storage = MockStorage()
    history = SearchHistory(storage)
    history.add("NAND2")
    assert storage.saved_history == ["NAND2"]
```

---

## 3. Dependencies

- **Upstream**: None (pure domain logic)
- **Downstream**:
  - T03 (Persistence implementation)
  - Application layer search service

---

## 4. Acceptance Criteria

- [ ] `SearchHistory` class implemented in domain layer
- [ ] `HistoryStorage` protocol defined
- [ ] `add()` method enforces all business rules
- [ ] Empty queries ignored
- [ ] Consecutive duplicates ignored
- [ ] Non-consecutive duplicates moved to front
- [ ] Max size limit enforced (10 entries)
- [ ] `get_recent()` returns newest-first ordering
- [ ] `clear()` removes all history
- [ ] `remove()` deletes specific query
- [ ] Storage operations called on changes
- [ ] Storage failures handled gracefully
- [ ] Unit tests achieve 100% coverage
- [ ] All test cases pass

---

## 5. Implementation Notes

### File Structure
```
src/ink/domain/services/
└── search_history.py          # SearchHistory + HistoryStorage protocol
```

### Testing
```
tests/unit/domain/services/
└── test_search_history.py     # Unit tests with mock storage
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
