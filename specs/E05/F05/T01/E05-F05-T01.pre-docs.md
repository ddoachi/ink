# Pre-Implementation Documentation: E05-F05-T01 - History Storage & Logic

## 1. Overview and Problem Context

### Problem Statement
The search functionality requires persistent query history to improve user efficiency by allowing quick re-execution of common searches. This task implements the core domain logic for managing search history with proper business rules for deduplication, ordering, and size constraints.

### Context
- Search history is a cross-cutting concern that bridges domain logic (business rules) and infrastructure (persistence)
- Users expect modern search UX with recent query tracking
- History must be maintainable without bloating storage
- The implementation follows DDD principles with clear separation between domain logic and infrastructure

### Core Challenge
Designing a domain service that encapsulates all history management business rules while remaining agnostic to the persistence mechanism through the use of a protocol interface.

---

## 2. Implementation Approach

### High-Level Strategy
1. Define `HistoryStorage` protocol interface for dependency inversion
2. Implement `SearchHistory` domain service with complete business rules
3. Use in-memory list with protocol-based persistence delegation
4. Enforce all rules (deduplication, size limits, ordering) in domain layer
5. Handle storage failures gracefully without crashing

### Component Breakdown

**HistoryStorage Protocol** (Interface)
- `load_history() -> List[str]`: Load persisted queries
- `save_history(queries: List[str]) -> None`: Persist current queries
- Pure interface with no implementation details

**SearchHistory Service** (Domain Logic)
- Maintains in-memory ordered list of queries
- Enforces MAX_HISTORY_SIZE = 10 constant
- Implements deduplication rules:
  - Ignores empty/whitespace-only queries
  - Ignores consecutive duplicates (same as most recent)
  - Moves non-consecutive duplicates to front
- Provides CRUD operations: `add()`, `get_recent()`, `clear()`, `remove()`
- Delegates persistence to injected storage protocol

### Data Flow
```
User Action → SearchHistory.add(query)
    ↓
1. Validate query (not empty)
2. Check consecutive duplicate (ignore if same as [0])
3. Remove existing occurrence (if found elsewhere)
4. Insert at front (index 0)
5. Truncate to MAX_HISTORY_SIZE
6. Call storage.save_history()
    ↓
Persisted to storage backend
```

---

## 3. Key Design Decisions

### Decision 1: Protocol-Based Storage Abstraction
**Choice**: Use `HistoryStorage` protocol instead of abstract base class
**Rationale**:
- Follows Python 3.10+ best practices with structural subtyping
- More flexible than inheritance (duck typing)
- Allows easy mocking in tests without inheritance overhead
- Aligns with Clean Architecture dependency inversion principle

**Alternative Considered**: Abstract base class with ABC
**Why Rejected**: Protocols are more Pythonic and provide better IDE support

### Decision 2: Newest-First Ordering
**Choice**: Maintain history as `[newest, ..., oldest]` with insert at index 0
**Rationale**:
- Intuitive for UI dropdown display (most recent at top)
- Simple implementation: `insert(0, query)`
- Natural truncation: `history[:MAX_HISTORY_SIZE]`

**Alternative Considered**: Oldest-first with append
**Why Rejected**: Requires reverse iteration for display, less intuitive

### Decision 3: Consecutive Duplicate Handling
**Choice**: Ignore query if identical to `history[0]`
**Rationale**:
- Prevents useless duplicate entries from repeated searches
- User clicking "Search" multiple times shouldn't pollute history
- Non-consecutive duplicates still move to front (user's intent changed)

**Example**:
```python
history = ["DFF", "NAND2"]
add("DFF")  # Ignored (consecutive)
history = ["DFF", "NAND2"]

add("AND2")
history = ["AND2", "DFF", "NAND2"]

add("DFF")  # Moves to front (non-consecutive)
history = ["DFF", "AND2", "NAND2"]
```

### Decision 4: Graceful Storage Failure Handling
**Choice**: Catch all exceptions in `_load()` and `_save()`, continue with empty history or skip save
**Rationale**:
- Storage failures shouldn't crash the application
- History is a convenience feature, not critical functionality
- User can still search even if history doesn't persist
- Logging allows debugging without interrupting workflow

**Alternative Considered**: Propagate exceptions to caller
**Why Rejected**: Violates robustness principle; history is non-critical

---

## 4. Dependencies and Integration Points

### Upstream Dependencies
- **None** - Pure domain logic with no external dependencies
- Only uses Python standard library types (`List[str]`)

### Downstream Consumers
1. **T03 - History Persistence**: Implements `HistoryStorage` protocol using QSettings
2. **Application Layer**: `SearchService` or similar will inject and use `SearchHistory`
3. **T02 - History UI Integration**: SearchPanel will call `add()` and `get_recent()`

### Integration Contracts

**Protocol Contract** (HistoryStorage):
```python
def load_history(self) -> List[str]:
    """MUST return empty list on error, never None"""

def save_history(self, queries: List[str]) -> None:
    """MUST handle empty list gracefully"""
```

**Service Contract** (SearchHistory):
```python
def add(self, query: str) -> None:
    """Idempotent, safe to call repeatedly with same query"""

def get_recent(self, limit: int = 10) -> List[str]:
    """Always returns list (never None), respects limit"""
```

### Composition (Dependency Injection)
```python
# In application/presentation layer:
storage = QSettingsHistoryStorage()  # T03
history = SearchHistory(storage)     # T01
panel = SearchPanel(search_service, history)  # T02
```

---

## 5. Testing Strategy

### Unit Test Categories

**1. Core Business Rules**
- `test_add_query_to_empty_history()`: Basic add functionality
- `test_add_duplicate_moves_to_front()`: Non-consecutive duplicate handling
- `test_ignore_consecutive_duplicate()`: Prevents useless re-adds
- `test_ignore_empty_query()`: Input validation
- `test_max_size_enforcement()`: Size limit constraint

**2. CRUD Operations**
- `test_clear_history()`: Remove all entries
- `test_remove_specific_query()`: Targeted deletion
- `test_get_recent_with_limit()`: Retrieve subset

**3. Storage Integration**
- `test_persistence_on_add()`: Storage called on changes
- `test_load_on_init()`: Initial load from storage
- `test_storage_failure_handling()`: Graceful degradation

### Test Fixtures

**MockStorage Implementation**:
```python
class MockStorage:
    def __init__(self):
        self.saved_history: List[str] = []
        self.should_fail_load = False
        self.should_fail_save = False

    def load_history(self) -> List[str]:
        if self.should_fail_load:
            raise RuntimeError("Storage error")
        return self.saved_history.copy()

    def save_history(self, queries: List[str]) -> None:
        if self.should_fail_save:
            raise RuntimeError("Storage error")
        self.saved_history = queries.copy()
```

### Coverage Goals
- **Target**: 100% line and branch coverage
- **Critical Paths**: All business rule branches (empty query, duplicates, size limit)
- **Edge Cases**: Storage failures, empty history, single-item history

### Test Organization
```
tests/unit/domain/services/
└── test_search_history.py
    - TestSearchHistoryAdd
    - TestSearchHistoryRetrieve
    - TestSearchHistoryModify
    - TestSearchHistoryPersistence
    - TestSearchHistoryErrorHandling
```

---

## 6. Risks and Considerations

### Technical Risks

**Risk 1: Thread Safety**
- **Description**: Multiple UI components might access history concurrently
- **Likelihood**: Low (Qt uses single event loop)
- **Impact**: Medium (could corrupt history or cause crashes)
- **Mitigation**:
  - Document that `SearchHistory` is not thread-safe
  - All access should occur on main Qt thread
  - Future: Add threading locks if needed

**Risk 2: Memory Growth**
- **Description**: Large query strings could consume significant memory
- **Likelihood**: Low (typical queries are short)
- **Impact**: Low (10 queries max, even 1KB each = 10KB)
- **Mitigation**:
  - MAX_HISTORY_SIZE constant limits growth
  - No mitigation needed for MVP

**Risk 3: Storage Protocol Misuse**
- **Description**: Implementer might return None instead of empty list
- **Likelihood**: Medium (common Python error)
- **Impact**: High (would cause crashes in domain service)
- **Mitigation**:
  - Clear protocol documentation
  - Type hints enforce `List[str]` return
  - Example implementation in T03

### Implementation Risks

**Risk 4: Business Rule Complexity**
- **Description**: Deduplication logic might have edge cases
- **Likelihood**: Medium (multiple interacting rules)
- **Impact**: Low (just affects history order)
- **Mitigation**:
  - Comprehensive unit tests covering all combinations
  - Manual testing with real user scenarios

**Risk 5: Over-Engineering**
- **Description**: Might be tempting to add sorting, search, categories, etc.
- **Likelihood**: Medium (feature creep)
- **Impact**: Low (delays MVP)
- **Mitigation**:
  - Stick strictly to spec requirements
  - Defer advanced features to P1/P2

### Domain Model Risks

**Risk 6: Query Normalization**
- **Description**: Should "NAND2" and "nand2" be treated as same?
- **Likelihood**: High (spec unclear)
- **Impact**: Low (UX preference)
- **Current Decision**: Case-sensitive (treat as different)
- **Rationale**:
  - Simpler implementation
  - Preserves user's exact input
  - Can be changed later if needed
- **Future**: Consider case-insensitive deduplication in P1

---

## 7. Open Questions

### Questions for Stakeholders
1. **Case Sensitivity**: Should search history treat "NAND2" and "nand2" as duplicates?
   - **Current Assumption**: No, keep case-sensitive
   - **Impact**: Low

2. **Whitespace Normalization**: Should "NAND2" and "  NAND2  " be treated as same?
   - **Current Assumption**: Yes, strip whitespace before adding
   - **Impact**: Low

3. **MAX_HISTORY_SIZE**: Is 10 the right limit, or should it be configurable?
   - **Current Assumption**: Hardcoded constant is sufficient for MVP
   - **Impact**: Low

### Technical Questions
1. **Storage Failure Logging**: Should we use proper logging framework or just print?
   - **Current Assumption**: Use print() for MVP, upgrade to logging in P1
   - **Impact**: Low (only affects debugging)

2. **Performance**: Is O(n) remove operation acceptable for 10 items?
   - **Current Assumption**: Yes, trivial performance impact
   - **Impact**: None

---

## 8. Implementation Checklist

### Phase 1: Protocol Definition
- [ ] Create `src/ink/domain/services/search_history.py`
- [ ] Define `HistoryStorage` protocol with type hints
- [ ] Add docstrings explaining contract requirements

### Phase 2: Domain Service Implementation
- [ ] Implement `SearchHistory.__init__()` with storage injection
- [ ] Implement `_load()` with error handling
- [ ] Implement `add()` with all business rules:
  - [ ] Empty/whitespace validation
  - [ ] Consecutive duplicate check
  - [ ] Non-consecutive duplicate removal
  - [ ] Insert at front
  - [ ] Size limit enforcement
- [ ] Implement `get_recent()` with limit parameter
- [ ] Implement `clear()` with persistence
- [ ] Implement `remove()` with persistence
- [ ] Implement `_save()` with error handling

### Phase 3: Unit Testing
- [ ] Create `tests/unit/domain/services/test_search_history.py`
- [ ] Implement `MockStorage` fixture
- [ ] Write tests for all business rules (8 test cases from spec)
- [ ] Write storage integration tests
- [ ] Write error handling tests
- [ ] Verify 100% coverage

### Phase 4: Documentation
- [ ] Add module-level docstring
- [ ] Add class-level docstring with examples
- [ ] Document all business rules in `add()` docstring
- [ ] Add inline comments for complex logic

### Phase 5: Integration Preparation
- [ ] Ensure protocol is importable from domain layer
- [ ] Verify no infrastructure dependencies leaked in
- [ ] Update `__init__.py` exports if needed

---

## 9. Success Criteria

### Functional Success
- [ ] All 12 acceptance criteria met
- [ ] All 8+ unit tests pass
- [ ] 100% code coverage achieved
- [ ] Business rules correctly enforced

### Quality Success
- [ ] Type hints on all functions
- [ ] Docstrings on all public methods
- [ ] No pylint/mypy errors
- [ ] Follows project code style (PEP 8, 100 char limit)

### Integration Success
- [ ] Protocol can be implemented by T03
- [ ] Service can be injected into T02
- [ ] No circular dependencies
- [ ] Clean layer separation maintained

---

## 10. Estimated Effort Breakdown

**Total: 3 hours**

- Protocol definition: 0.5 hours
- Core implementation: 1 hour
- Unit tests: 1 hour
- Documentation: 0.5 hours

**Confidence**: High (straightforward domain logic, well-specified)

---

## 11. Post-Implementation Validation

### Manual Testing Scenarios
1. **Scenario**: Add 5 different queries
   - **Expected**: All stored in newest-first order

2. **Scenario**: Add "NAND2", then add "NAND2" again
   - **Expected**: Only one "NAND2" in history

3. **Scenario**: Add "NAND2", "DFF", then "NAND2" again
   - **Expected**: History is ["NAND2", "DFF"] (moved to front)

4. **Scenario**: Add 15 queries
   - **Expected**: Only 10 newest retained

5. **Scenario**: Clear history, then add new query
   - **Expected**: History contains only new query

### Integration Validation
1. Verify `MockStorage` captures all save calls
2. Verify load called during `__init__()`
3. Verify storage failures don't crash service

### Code Review Checklist
- [ ] No infrastructure dependencies in domain layer
- [ ] All public methods have docstrings
- [ ] Type hints are complete and accurate
- [ ] Error handling is appropriate (catch vs. propagate)
- [ ] Business rules match specification exactly
- [ ] Tests cover all edge cases
