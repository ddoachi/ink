---
id: E05-F02-T03
title: Search Service Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F02
created: 2025-12-26
estimated_hours: 8
actual_hours:
effort: Medium
tags:
  - application
  - search
clickup_task_id: '86evzm30q'
---

# Spec: E05-F02-T03 - Search Service Implementation

## 1. Overview

### 1.1 Problem Statement
The application layer needs a search service that indexes the domain model (`Design`) and provides fast query capabilities. This service orchestrates trie-based indexing, pattern matching, and result ranking to deliver sub-100ms search performance.

### 1.2 Goals
- Build search indexes from `Design` aggregate on load
- Execute searches with type filters and result limits
- Rank results by relevance (exact > prefix > contains > pattern)
- Support both literal and wildcard pattern queries
- Integrate with domain model while maintaining clean architecture

---

## 2. Technical Requirements

### 2.1 Search Service Interface

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/application/services/search_service.py`

```python
from dataclasses import dataclass, field
from typing import List, Optional
from ink.domain.model.design import Design
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.infrastructure.search.trie_index import Trie
from ink.infrastructure.search.pattern_matcher import parse_pattern, is_wildcard

@dataclass
class SearchFilters:
    """Search filtering configuration"""
    include_cells: bool = True
    include_pins: bool = True
    include_nets: bool = True
    include_ports: bool = True
    max_results: int = 100

@dataclass
class SearchResult:
    """Single search result with metadata"""
    object_type: str        # "cell", "pin", "net", "port"
    name: str               # Display name
    object_id: str          # Unique identifier for navigation
    context: str            # Additional context (e.g., "Pin of cell XI123")
    match_quality: float    # Relevance score: 1.0=exact, 0.8=prefix, 0.5=contains, 0.3=pattern

    def __lt__(self, other: 'SearchResult') -> bool:
        """Sort by match_quality descending, then name ascending"""
        if self.match_quality != other.match_quality:
            return self.match_quality > other.match_quality
        return self.name < other.name

class SearchService:
    """
    Application service for searching design objects.

    Responsibilities:
        - Index design objects for fast lookup
        - Execute queries with filters
        - Rank results by relevance
        - Convert domain objects to search results
    """

    def __init__(self, design: Design):
        """
        Initialize search service with design model.

        Args:
            design: Design aggregate root to index
        """
        self._design = design
        self._cell_trie: Trie[Cell] = Trie()
        self._net_trie: Trie[Net] = Trie()
        self._port_trie: Trie[Port] = Trie()
        self._pin_index: dict[str, list[Pin]] = {}  # pin name -> list of pins

        self._build_indexes()

    def _build_indexes(self) -> None:
        """Build search indexes from design model"""
        # Index cells
        for cell in self._design.cells.values():
            self._cell_trie.insert(cell.name, cell)

        # Index nets
        for net in self._design.nets.values():
            self._net_trie.insert(net.name, net)

        # Index ports
        for port in self._design.ports.values():
            self._port_trie.insert(port.name, port)

        # Index pins (grouped by pin name across cells)
        for cell in self._design.cells.values():
            for pin in cell.pins:
                pin_name = pin.name
                if pin_name not in self._pin_index:
                    self._pin_index[pin_name] = []
                self._pin_index[pin_name].append(pin)

    def search(
        self,
        query: str,
        filters: Optional[SearchFilters] = None
    ) -> List[SearchResult]:
        """
        Execute search query with filters.

        Args:
            query: Search string (literal or wildcard pattern)
            filters: Type filters and result limits

        Returns:
            Sorted list of search results by relevance
        """
        if filters is None:
            filters = SearchFilters()

        # Minimum query length
        if len(query) < 2:
            return []

        results: List[SearchResult] = []

        # Determine search strategy
        if is_wildcard(query):
            results = self._search_pattern(query, filters)
        else:
            results = self._search_literal(query, filters)

        # Sort by relevance and limit
        results.sort()
        return results[:filters.max_results]

    def _search_literal(self, query: str, filters: SearchFilters) -> List[SearchResult]:
        """Search using exact/prefix matching"""
        results = []

        if filters.include_cells:
            results.extend(self._search_cells_literal(query))

        if filters.include_nets:
            results.extend(self._search_nets_literal(query))

        if filters.include_ports:
            results.extend(self._search_ports_literal(query))

        if filters.include_pins:
            results.extend(self._search_pins_literal(query))

        return results

    def _search_cells_literal(self, query: str) -> List[SearchResult]:
        """Search cells using exact + prefix + contains"""
        results = []

        # 1. Exact match (quality = 1.0)
        exact_cell = self._cell_trie.search_exact(query)
        if exact_cell:
            results.append(SearchResult(
                object_type="cell",
                name=exact_cell.name,
                object_id=exact_cell.id,
                context=f"Cell type: {exact_cell.cell_type}",
                match_quality=1.0
            ))

        # 2. Prefix matches (quality = 0.8)
        prefix_matches = self._cell_trie.search_prefix(query, max_results=50)
        for name, cell in prefix_matches:
            if name != query:  # Skip exact match already added
                results.append(SearchResult(
                    object_type="cell",
                    name=cell.name,
                    object_id=cell.id,
                    context=f"Cell type: {cell.cell_type}",
                    match_quality=0.8
                ))

        # 3. Contains matches (quality = 0.5) - scan all cells
        if len(results) < 20:  # Only if we don't have many results
            for cell in self._design.cells.values():
                if query in cell.name and cell.name not in [r.name for r in results]:
                    results.append(SearchResult(
                        object_type="cell",
                        name=cell.name,
                        object_id=cell.id,
                        context=f"Cell type: {cell.cell_type}",
                        match_quality=0.5
                    ))
                    if len(results) >= 50:
                        break

        return results

    def _search_nets_literal(self, query: str) -> List[SearchResult]:
        """Search nets using exact + prefix + contains"""
        results = []

        # Exact match
        exact_net = self._net_trie.search_exact(query)
        if exact_net:
            num_pins = len(exact_net.connected_pins)
            results.append(SearchResult(
                object_type="net",
                name=exact_net.name,
                object_id=exact_net.id,
                context=f"Net with {num_pins} connections",
                match_quality=1.0
            ))

        # Prefix matches
        prefix_matches = self._net_trie.search_prefix(query, max_results=50)
        for name, net in prefix_matches:
            if name != query:
                num_pins = len(net.connected_pins)
                results.append(SearchResult(
                    object_type="net",
                    name=net.name,
                    object_id=net.id,
                    context=f"Net with {num_pins} connections",
                    match_quality=0.8
                ))

        # Contains matches
        if len(results) < 20:
            for net in self._design.nets.values():
                if query in net.name and net.name not in [r.name for r in results]:
                    num_pins = len(net.connected_pins)
                    results.append(SearchResult(
                        object_type="net",
                        name=net.name,
                        object_id=net.id,
                        context=f"Net with {num_pins} connections",
                        match_quality=0.5
                    ))
                    if len(results) >= 50:
                        break

        return results

    def _search_ports_literal(self, query: str) -> List[SearchResult]:
        """Search ports using exact + prefix"""
        results = []

        exact_port = self._port_trie.search_exact(query)
        if exact_port:
            results.append(SearchResult(
                object_type="port",
                name=exact_port.name,
                object_id=exact_port.id,
                context=f"Port ({exact_port.direction.value})",
                match_quality=1.0
            ))

        prefix_matches = self._port_trie.search_prefix(query, max_results=50)
        for name, port in prefix_matches:
            if name != query:
                results.append(SearchResult(
                    object_type="port",
                    name=port.name,
                    object_id=port.id,
                    context=f"Port ({port.direction.value})",
                    match_quality=0.8
                ))

        return results

    def _search_pins_literal(self, query: str) -> List[SearchResult]:
        """Search pins by pin name (multiple cells may have same pin name)"""
        results = []

        # Exact pin name match
        if query in self._pin_index:
            for pin in self._pin_index[query]:
                results.append(SearchResult(
                    object_type="pin",
                    name=pin.name,
                    object_id=f"{pin.parent_cell.id}:{pin.name}",
                    context=f"Pin of {pin.parent_cell.name}",
                    match_quality=1.0
                ))

        # Prefix match on pin names
        for pin_name, pins in self._pin_index.items():
            if pin_name.startswith(query) and pin_name != query:
                for pin in pins[:5]:  # Limit pins per name
                    results.append(SearchResult(
                        object_type="pin",
                        name=pin.name,
                        object_id=f"{pin.parent_cell.id}:{pin.name}",
                        context=f"Pin of {pin.parent_cell.name}",
                        match_quality=0.8
                    ))

        return results

    def _search_pattern(self, query: str, filters: SearchFilters) -> List[SearchResult]:
        """Search using wildcard pattern matching"""
        pattern = parse_pattern(query)
        results = []

        # Pattern matching requires scanning (no index optimization)
        if filters.include_cells:
            for cell in self._design.cells.values():
                if pattern.matches(cell.name):
                    results.append(SearchResult(
                        object_type="cell",
                        name=cell.name,
                        object_id=cell.id,
                        context=f"Cell type: {cell.cell_type}",
                        match_quality=0.3  # Pattern matches ranked lowest
                    ))

        if filters.include_nets:
            for net in self._design.nets.values():
                if pattern.matches(net.name):
                    num_pins = len(net.connected_pins)
                    results.append(SearchResult(
                        object_type="net",
                        name=net.name,
                        object_id=net.id,
                        context=f"Net with {num_pins} connections",
                        match_quality=0.3
                    ))

        if filters.include_ports:
            for port in self._design.ports.values():
                if pattern.matches(port.name):
                    results.append(SearchResult(
                        object_type="port",
                        name=port.name,
                        object_id=port.id,
                        context=f"Port ({port.direction.value})",
                        match_quality=0.3
                    ))

        if filters.include_pins:
            for pin_name, pins in self._pin_index.items():
                if pattern.matches(pin_name):
                    for pin in pins[:5]:
                        results.append(SearchResult(
                            object_type="pin",
                            name=pin.name,
                            object_id=f"{pin.parent_cell.id}:{pin.name}",
                            context=f"Pin of {pin.parent_cell.name}",
                            match_quality=0.3
                        ))

        return results
```

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `/home/joohan/dev/project-ink/ink/tests/unit/application/services/test_search_service.py`

```python
import pytest
from ink.application.services.search_service import SearchService, SearchFilters, SearchResult
from ink.domain.model.design import Design
from ink.domain.model.cell import Cell
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.domain.value_objects.pin_direction import PinDirection

@pytest.fixture
def sample_design():
    """Create sample design for testing"""
    design = Design(name="test_design")

    # Add cells
    design.add_cell(Cell(name="clk_buf_0", cell_type="BUF_X1"))
    design.add_cell(Cell(name="clk_buf_1", cell_type="BUF_X1"))
    design.add_cell(Cell(name="data_reg_0", cell_type="DFF_X1"))
    design.add_cell(Cell(name="data_reg_1", cell_type="DFF_X1"))
    design.add_cell(Cell(name="mem_ctrl", cell_type="CTRL"))

    # Add nets
    design.add_net(Net(name="clk"))
    design.add_net(Net(name="clk_div2"))
    design.add_net(Net(name="data_bus_0"))
    design.add_net(Net(name="data_bus_1"))

    # Add ports
    design.add_port(Port(name="clk_in", direction=PinDirection.INPUT))
    design.add_port(Port(name="data_out", direction=PinDirection.OUTPUT))

    return design

class TestSearchService:
    def test_exact_match_cell(self, sample_design):
        service = SearchService(sample_design)
        results = service.search("clk_buf_0")

        assert len(results) >= 1
        assert results[0].name == "clk_buf_0"
        assert results[0].object_type == "cell"
        assert results[0].match_quality == 1.0

    def test_prefix_match_cells(self, sample_design):
        service = SearchService(sample_design)
        results = service.search("clk_")

        cell_results = [r for r in results if r.object_type == "cell"]
        assert len(cell_results) == 2  # clk_buf_0, clk_buf_1
        assert all(r.name.startswith("clk_") for r in cell_results)

    def test_wildcard_pattern(self, sample_design):
        service = SearchService(sample_design)
        results = service.search("*_reg_*")

        assert len(results) == 2  # data_reg_0, data_reg_1
        assert all("reg" in r.name for r in results)

    def test_type_filtering(self, sample_design):
        service = SearchService(sample_design)

        # Only cells
        filters = SearchFilters(include_cells=True, include_nets=False,
                              include_ports=False, include_pins=False)
        results = service.search("clk", filters)
        assert all(r.object_type == "cell" for r in results)

        # Only nets
        filters = SearchFilters(include_cells=False, include_nets=True,
                              include_ports=False, include_pins=False)
        results = service.search("clk", filters)
        assert all(r.object_type == "net" for r in results)

    def test_max_results_limit(self, sample_design):
        service = SearchService(sample_design)
        filters = SearchFilters(max_results=2)
        results = service.search("d", filters)  # Matches data_reg_*, data_bus_*, data_out

        assert len(results) <= 2

    def test_minimum_query_length(self, sample_design):
        service = SearchService(sample_design)

        results = service.search("c")  # Only 1 char
        assert len(results) == 0

        results = service.search("cl")  # 2 chars
        assert len(results) > 0

    def test_result_sorting_by_relevance(self, sample_design):
        service = SearchService(sample_design)
        results = service.search("clk")

        # Exact matches should come first
        exact_matches = [r for r in results if r.match_quality == 1.0]
        prefix_matches = [r for r in results if r.match_quality == 0.8]

        # Verify ordering
        if exact_matches and prefix_matches:
            assert results.index(exact_matches[0]) < results.index(prefix_matches[0])

    def test_empty_query(self, sample_design):
        service = SearchService(sample_design)
        results = service.search("")
        assert len(results) == 0
```

### 3.2 Test Coverage Target
- Minimum 85% code coverage
- All search strategies tested (literal, prefix, pattern)
- Filter combinations verified
- Result ranking validated

---

## 4. Dependencies

- **Upstream**:
  - E01 (Domain Model - Design, Cell, Net, Port, Pin)
  - E05-F02-T01 (Trie Index)
  - E05-F02-T02 (Pattern Matcher)
- **Downstream**:
  - E05-F01 (Search Panel consumes SearchService)
  - E05-F04 (Navigation uses object_id from SearchResult)

---

## 5. Acceptance Criteria

- [ ] `SearchService` initializes and indexes `Design` model
- [ ] Indexes built in < 2s for 100K objects
- [ ] Search returns results in < 100ms
- [ ] Exact matches ranked with quality 1.0
- [ ] Prefix matches ranked with quality 0.8
- [ ] Contains matches ranked with quality 0.5
- [ ] Pattern matches ranked with quality 0.3
- [ ] Results sorted by `match_quality` descending
- [ ] Type filters correctly include/exclude object types
- [ ] `max_results` limit enforced
- [ ] Minimum 2 character query length enforced
- [ ] Pin results include parent cell context
- [ ] All unit tests passing with > 85% coverage

---

## 6. Implementation Notes

### 6.1 Performance Optimizations
- Trie indexes enable O(m) prefix search
- Contains matches limited to prevent full scan overhead
- Pattern matching requires full scan (acceptable for wildcards)

### 6.2 Architecture Compliance
- Application layer service (uses domain model)
- Depends on infrastructure (Trie, PatternMatcher)
- No UI dependencies (presentation layer consumes this)

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F02 split |
