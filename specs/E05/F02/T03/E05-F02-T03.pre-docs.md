# E05-F02-T03: Search Service Implementation - Pre-Implementation Documentation

## Document Metadata
- **Task**: E05-F02-T03 - Search Service Implementation
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

Implement the application-layer SearchService that orchestrates trie indexing, pattern matching, and result ranking to provide fast, relevant search results across the entire Design domain model. This is the core search engine that powers the Search Panel UI.

### 1.2 Problem Context

The UI needs to search across thousands of design objects (cells, nets, ports, pins) with sub-100ms response time. Users enter partial queries expecting intelligent autocomplete and relevance ranking. The SearchService bridges domain models (Cell, Net) with infrastructure (Trie, PatternMatcher) while maintaining clean architecture boundaries.

**Challenges**:
- **Multi-type search**: Cells, nets, ports, pins have different schemas
- **Relevance ranking**: Exact match should rank higher than prefix
- **Performance**: Must index 100K+ objects and search in < 100ms
- **Flexibility**: Support both literal and wildcard queries

### 1.3 Success Criteria

- Index 100K objects in < 2 seconds
- Search returns results in < 100ms
- Exact matches ranked higher than prefix matches
- Type filtering works correctly
- Integration with domain model maintains clean architecture

---

## 2. Technical Approach

### 2.1 Architecture Overview

**Layer Positioning**:
```
Presentation (SearchPanel)
      ↓
Application (SearchService) ← This task
      ↓                ↓
Domain (Design)    Infrastructure (Trie, PatternMatcher)
```

**Responsibilities**:
- **Application Layer (SearchService)**:
  - Orchestrate search across multiple indexes
  - Rank results by relevance
  - Convert domain objects to SearchResult DTOs
  - Apply filters and limits

- **Not Responsible For**:
  - UI rendering (Presentation)
  - Domain logic (Domain)
  - Data structures (Infrastructure)

### 2.2 Index Strategy

**Multi-Index Design**:
```python
class SearchService:
    _cell_trie: Trie[Cell]           # Cell name → Cell object
    _net_trie: Trie[Net]             # Net name → Net object
    _port_trie: Trie[Port]           # Port name → Port object
    _pin_index: dict[str, list[Pin]] # Pin name → List[Pin] (multi-value)
```

**Why Separate Indexes**:
- **Type filtering**: Easy to include/exclude entire categories
- **Schema differences**: Pins need multi-value index (same pin name on different cells)
- **Performance**: Smaller tries are faster than one giant trie
- **Maintenance**: Independent index updates

**Pin Index Design Decision**:
- **Why not Trie[list[Pin]]**: Trie stores single values, pins have many cells with same pin name
- **Why dict**: Simple, fast O(1) lookup, supports multi-value naturally
- **Tradeoff**: No prefix search optimization for pins (acceptable, pin names are short)

### 2.3 Search Strategies

**Strategy Selection**:
```python
def search(query: str):
    if is_wildcard(query):
        return _search_pattern(query)  # Full scan with regex
    else:
        return _search_literal(query)  # Trie-optimized
```

**Literal Search (Fast Path)**:
1. Exact match check (O(1) via trie)
2. Prefix search (O(m + n) via trie)
3. Contains search (O(k) full scan, limited)

**Pattern Search (Slow Path)**:
1. Compile wildcard pattern
2. Full scan across all objects
3. Filter by pattern.matches()

**Why Three Levels for Literal**:
- **Exact**: User knows full name, highest relevance
- **Prefix**: Most common autocomplete case
- **Contains**: Catch "forgot the prefix" searches

### 2.4 Relevance Ranking

**Match Quality Scores**:
```
1.0 - Exact match (query == name)
0.8 - Prefix match (name.startswith(query))
0.5 - Contains match (query in name)
0.3 - Pattern match (wildcard/regex)
```

**Why These Values**:
- Clear separation between levels (0.2-0.5 gaps)
- Sorts correctly with simple comparison
- Leaves room for future refinements (e.g., 0.9 for case-insensitive exact)

**Sorting Strategy**:
```python
results.sort(key=lambda r: (-r.match_quality, r.name))
# Primary: quality descending
# Secondary: name alphabetical
```

### 2.5 Result DTO Design

**SearchResult Dataclass**:
```python
@dataclass
class SearchResult:
    object_type: str     # "cell", "pin", "net", "port"
    name: str            # Display name
    object_id: str       # Unique ID for navigation
    context: str         # Additional info (e.g., "Pin of cell XI123")
    match_quality: float # Relevance score
```

**Why DTO (not domain objects)**:
- **Decoupling**: UI doesn't need full domain knowledge
- **Performance**: Lighter weight than full objects
- **Flexibility**: Can add UI-specific fields without changing domain
- **Security**: Don't expose domain internals to presentation

**object_id Design**:
- **Cells**: Use `cell.id` directly
- **Nets**: Use `net.id` directly
- **Ports**: Use `port.id` directly
- **Pins**: Use composite `{cell_id}:{pin_name}` (pins don't have standalone IDs)

---

## 3. Implementation Strategy

### 3.1 Development Phases

#### Phase 1: Index Construction (2 hours)
**Deliverables**:
- `SearchService.__init__()` builds all indexes
- `_build_indexes()` populates tries and pin index
- Unit tests for index integrity

**Success Check**:
- All cells/nets/ports indexed correctly
- Pin index has all unique pin names
- Index build time < 2s for 10K objects

#### Phase 2: Literal Search (2 hours)
**Deliverables**:
- `_search_literal()` method
- `_search_cells_literal()`, `_search_nets_literal()`, etc.
- Exact + prefix + contains logic
- Unit tests for all match types

**Success Check**:
- Exact matches return correct objects
- Prefix search works
- Contains search limited to prevent performance issues

#### Phase 3: Pattern Search (1.5 hours)
**Deliverables**:
- `_search_pattern()` method
- Integration with PatternMatcher
- Full scan with filtering
- Unit tests for wildcard queries

**Success Check**:
- Wildcards `*` and `?` work correctly
- Pattern matching performance acceptable

#### Phase 4: Filtering & Ranking (1.5 hours)
**Deliverables**:
- `SearchFilters` dataclass
- Result ranking and sorting
- `max_results` limit enforcement
- Type filtering

**Success Check**:
- Results sorted by quality
- Type filters work
- Result limit enforced

#### Phase 5: Integration & Performance (1 hour)
**Deliverables**:
- SearchResult DTO construction
- Context string generation
- Performance benchmarks
- Integration tests

**Success Check**:
- Search completes in < 100ms
- Results have all required fields
- Integration with domain model clean

### 3.2 File Organization

```
src/ink/application/services/
├── __init__.py
└── search_service.py          # SearchService, SearchFilters, SearchResult

tests/unit/application/services/
├── __init__.py
└── test_search_service.py     # Comprehensive unit tests

tests/integration/
└── test_search_integration.py # End-to-end search tests
```

---

## 4. Design Decisions

### 4.1 Where to Draw Architecture Boundaries

**Decision**: SearchService in Application layer, depends on Domain and Infrastructure

**Architecture Flow**:
```
Domain (Design, Cell, Net)
   ↓ (provides)
Application (SearchService)
   ↓ (uses)
Infrastructure (Trie, PatternMatcher)
```

**Why This Layering**:
- SearchService is a **use case** (application logic)
- Depends on domain models (Design aggregate)
- Depends on infrastructure tools (Trie, PatternMatcher)
- Presentation depends on SearchService (not domain directly)

**Alternative Considered**: Put SearchService in Domain layer
- **Rejected**: Search is a use case, not core domain logic
- Domain should be pure business rules (Cell, Net connectivity)
- Search is an application feature built on domain

### 4.2 Index Rebuild Strategy

**Decision**: Build indexes once in `__init__`, rebuild on design reload

**Alternatives**:
1. **Lazy indexing**: Build on first search
   - Pro: Faster startup
   - Con: First search slow, unpredictable latency
2. **Incremental updates**: Update index on design changes
   - Pro: Always in sync
   - Con: Complex, error-prone, requires hooks
3. **Periodic rebuild**: Background thread rebuilds
   - Pro: Handles changes
   - Con: Out-of-sync window, thread complexity

**Rationale**: Design rarely changes during session (load once, explore). Simplicity wins for MVP.

**Post-MVP**: If dynamic design editing added, implement incremental updates

### 4.3 Contains Search Limitation

**Decision**: Only run contains search if few prefix results (< 20)

**Why Limit**:
- Contains requires full scan (O(k) where k = total objects)
- Expensive for 100K+ objects
- Usually unnecessary if prefix search finds results

**Implementation**:
```python
if len(prefix_results) < 20:
    # User probably wants broader search
    contains_results = [obj for obj in all_objects if query in obj.name]
```

**Tradeoff**: Some valid results may be missed, but performance is priority

### 4.4 Pin Multi-Value Handling

**Decision**: Return up to 5 pins per unique pin name

**Problem**: Standard pin names (A, B, Y, Q) appear on thousands of cells

**Alternatives**:
1. **Return all pins**: 10K results for "A"
   - Rejected: Overwhelming, slow
2. **Return first 5**: Sample bias
   - Rejected: Arbitrary, confusing
3. **Group by pin name**: "Pin A (1000 instances)"
   - Better UX but complex for MVP

**MVP Approach**: Limit to 5 per pin name, add grouping in P1

---

## 5. Testing Strategy

### 5.1 Unit Test Structure

**Test Fixture**:
```python
@pytest.fixture
def sample_design():
    design = Design(name="test")

    # Add diverse object types
    design.add_cell(Cell(name="clk_buf_0", cell_type="BUF_X1"))
    design.add_cell(Cell(name="clk_buf_1", cell_type="BUF_X1"))
    design.add_cell(Cell(name="data_reg_0", cell_type="DFF_X1"))

    design.add_net(Net(name="clk"))
    design.add_net(Net(name="clk_div2"))

    design.add_port(Port(name="clk_in", direction=INPUT))
    design.add_port(Port(name="data_out", direction=OUTPUT))

    return design
```

**Test Categories**:

1. **Index Construction Tests**:
   - All cells indexed
   - All nets indexed
   - All ports indexed
   - Pin index has unique names
   - Index build time acceptable

2. **Exact Match Tests**:
   - Find exact cell name
   - Find exact net name
   - Find exact port name
   - Exact match quality = 1.0

3. **Prefix Match Tests**:
   - Prefix finds all matching cells
   - Prefix finds all matching nets
   - Prefix quality = 0.8

4. **Contains Match Tests**:
   - Substring finds cells
   - Contains quality = 0.5
   - Limited when many prefix results

5. **Pattern Match Tests**:
   - Wildcard `*` works
   - Wildcard `?` works
   - Pattern quality = 0.3

6. **Filtering Tests**:
   - Include only cells
   - Include only nets
   - Multiple types combined
   - max_results limit enforced

7. **Ranking Tests**:
   - Exact ranked above prefix
   - Prefix ranked above contains
   - Alphabetical tiebreaker

### 5.2 Integration Tests

**End-to-End Search Flow**:
```python
def test_search_integration(realistic_design):
    """Test complete search flow with realistic design"""

    service = SearchService(realistic_design)

    # Test autocomplete scenario
    results = service.search("clk")

    # Should find:
    # - Exact: net "clk" (quality 1.0)
    # - Prefix: "clk_buf_0", "clk_div2" (quality 0.8)
    # - Contains: (if any, quality 0.5)

    assert len(results) > 0
    assert results[0].name == "clk"  # Exact match first
    assert results[0].match_quality == 1.0

    # Verify sorted by quality
    qualities = [r.match_quality for r in results]
    assert qualities == sorted(qualities, reverse=True)
```

### 5.3 Performance Tests

**Benchmarks**:
```python
@pytest.fixture
def large_design():
    """Generate design with 100K objects"""
    design = Design(name="large")

    for i in range(100000):
        design.add_cell(Cell(name=f"cell_{i:06d}", cell_type="INV_X1"))

    return design

def test_index_build_time(benchmark, large_design):
    """Verify indexing completes in < 2s"""
    result = benchmark(SearchService, large_design)
    assert benchmark.stats.mean < 2.0

def test_search_performance(benchmark, search_service_large):
    """Verify search completes in < 100ms"""
    result = benchmark(search_service_large.search, "cell_1")
    assert benchmark.stats.mean < 0.1
```

**Memory Profiling**:
```python
def test_index_memory_overhead():
    """Measure memory overhead of indexes"""
    import tracemalloc

    design = generate_large_design(100000)

    tracemalloc.start()
    service = SearchService(design)
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    # Index overhead should be < 100MB for 100K objects
    assert peak < 100 * 1024 * 1024
```

---

## 6. Integration Points

### 6.1 Upstream Dependencies

**Domain Model (E01)**:
```python
from ink.domain.model.design import Design
from ink.domain.model.cell import Cell
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.domain.model.pin import Pin
```

**Expected API**:
```python
design.cells: dict[str, Cell]
design.nets: dict[str, Net]
design.ports: dict[str, Port]

cell.name: str
cell.id: str
cell.cell_type: str
cell.pins: list[Pin]

pin.name: str
pin.parent_cell: Cell
```

**Risk**: If domain API changes, SearchService breaks
**Mitigation**: Integration tests catch breaking changes early

### 6.2 Infrastructure Dependencies

**Trie Index (E05-F02-T01)**:
```python
from ink.infrastructure.search.trie_index import Trie

trie = Trie[Cell]()
trie.insert(name, cell)
cell = trie.search_exact(name)
matches = trie.search_prefix(prefix)
```

**Pattern Matcher (E05-F02-T02)**:
```python
from ink.infrastructure.search.pattern_matcher import parse_pattern, is_wildcard

pattern = parse_pattern("clk_*")
if pattern.matches(cell.name):
    results.append(cell)
```

### 6.3 Downstream Consumers

**Search Panel UI (E05-F01)**:
```python
class SearchPanel:
    def __init__(self, search_service: SearchService):
        self._search_service = search_service

    def on_search_input_changed(self, query: str):
        results = self._search_service.search(query)
        self._display_results(results)
```

**Navigation (E05-F04)**:
```python
def navigate_to_object(result: SearchResult):
    """Jump to object in schematic using object_id"""
    if result.object_type == "cell":
        canvas.select_cell(result.object_id)
    elif result.object_type == "pin":
        cell_id, pin_name = result.object_id.split(":")
        canvas.select_pin(cell_id, pin_name)
```

---

## 7. Risk Analysis

### 7.1 Performance Risks

#### Risk 1: Index Build Time > 2s for 100K Objects
**Impact**: High (slow startup, poor UX)
**Probability**: Medium (depends on trie performance)

**Mitigation**:
- Benchmark trie performance early (T01)
- Profile index build to find bottlenecks
- Optimize hot paths (interning, bulk inserts)

**Contingency**:
- Background indexing with progress bar
- Lazy indexing (build on first search)
- Pre-computed index cache

#### Risk 2: Search Latency > 100ms
**Impact**: Medium (sluggish autocomplete, but usable)
**Probability**: Low (trie is fast)

**Mitigation**:
- Aggressive max_results limiting
- Skip contains search for large result sets
- Early termination in DFS

**Contingency**:
- Reduce max_results to 50
- Add debouncing in UI (handled by T04)
- Cache common queries

#### Risk 3: Memory Overhead Too High
**Impact**: Medium (OOM on large designs)
**Probability**: Low (trie is memory-efficient)

**Mitigation**:
- Memory profiling in Phase 5
- String interning for cell types
- Limit index size (e.g., only index top 100K objects)

**Contingency**:
- External index (SQLite FTS)
- Compressed trie
- On-demand index loading

### 7.2 Integration Risks

#### Risk 4: Domain API Instability
**Impact**: Medium (SearchService breaks on domain changes)
**Probability**: Medium (domain model still evolving)

**Mitigation**:
- Integration tests with real domain objects
- Define stable interface contract
- Adapter layer if domain changes frequently

**Contingency**:
- Abstract domain access behind repository
- Use adapter pattern to isolate changes

#### Risk 5: Pin Index Complexity
**Impact**: Low (multi-value handling edge cases)
**Probability**: Low (simple dict structure)

**Mitigation**:
- Comprehensive tests for pin search
- Limit results per pin name
- Clear documentation on multi-value semantics

**Contingency**:
- Simplify to "first 10 pins" if grouping complex
- Defer pin search to P1 if problematic

---

## 8. Future Enhancements (Post-MVP)

### 8.1 Advanced Search Features

**Multi-Field Search**:
```python
# Search by cell type, pin count, net fanout
service.search("cell_type:INV_X1 pins:>10")
```

**Path Search**:
```python
# Find paths between two objects
service.find_path(from_cell="XI1", to_cell="XI100")
```

**Boolean Operators**:
```python
# AND, OR, NOT queries
service.search("clk* AND *buf NOT *test")
```

### 8.2 Relevance Improvements

**Frequency-Based Ranking**:
- Track query history
- Popular results ranked higher
- Learning from user behavior

**Fuzzy Matching**:
- Typo tolerance (Levenshtein distance)
- "clk_buf" matches "clk_buf_0" even if user typed "clk buf"

**Semantic Search**:
- Search by function: "all flip-flops"
- Search by connectivity: "drivers of net X"

### 8.3 Performance Optimizations

**Query Caching**:
```python
@lru_cache(maxsize=100)
def search(query: str, filters: SearchFilters):
    # Cache recent searches
```

**Incremental Indexing**:
```python
def update_index(added_cells, removed_cells):
    # Update index without full rebuild
```

**Parallel Search**:
```python
# Search cells, nets, ports in parallel threads
with ThreadPoolExecutor() as executor:
    cell_results = executor.submit(search_cells, query)
    net_results = executor.submit(search_nets, query)
```

---

## 9. Acceptance Checklist

### 9.1 Code Completeness

- [ ] `SearchService` class implemented
- [ ] `SearchFilters` dataclass defined
- [ ] `SearchResult` dataclass defined
- [ ] `_build_indexes()` populates all tries
- [ ] `search()` public method
- [ ] `_search_literal()` with exact/prefix/contains
- [ ] `_search_pattern()` with wildcard support
- [ ] Type filtering works for all object types
- [ ] Result ranking by match_quality
- [ ] Type hints on all public methods
- [ ] Comprehensive docstrings

### 9.2 Testing

- [ ] Unit tests for index construction
- [ ] Unit tests for exact/prefix/contains search
- [ ] Unit tests for pattern search
- [ ] Unit tests for filtering
- [ ] Unit tests for ranking
- [ ] Integration tests with realistic design
- [ ] Performance benchmarks
- [ ] Memory profiling
- [ ] Test coverage > 85%

### 9.3 Performance

- [ ] Index build < 2s for 100K objects
- [ ] Search < 100ms
- [ ] Memory overhead acceptable
- [ ] Benchmarks pass in CI

### 9.4 Architecture

- [ ] Application layer boundaries respected
- [ ] No direct domain-to-infrastructure dependencies
- [ ] Clean separation of concerns
- [ ] SearchResult DTO decouples layers

---

## 10. Open Questions

### 10.1 Design Questions

**Q1**: Should SearchService be singleton or per-Design instance?
- **Context**: Multiple designs may be open simultaneously
- **Options**:
  - A) Singleton with current design reference
  - B) Instance per design (current approach)
  - C) Factory that manages multiple instances
- **Recommendation**: Option B (simpler, more testable)

**Q2**: How to handle very large result sets (10K+ matches)?
- **Context**: Query "a" may match thousands of objects
- **Options**:
  - A) Return all, let UI paginate
  - B) Limit to max_results, warn if truncated
  - C) Prompt user to refine query
- **Recommendation**: Option B for MVP, Option C for UX improvement

**Q3**: Should search be case-sensitive?
- **Context**: HDL names are usually case-sensitive
- **Options**:
  - A) Always case-sensitive (match domain)
  - B) Always case-insensitive (user-friendly)
  - C) Configurable per search
- **Recommendation**: Option A for MVP, toggle in UI for P1

### 10.2 Integration Questions

**Q4**: Who creates SearchService - Application or Presentation?
- **Recommendation**: Presentation creates and owns (SearchPanel owns SearchService instance)

**Q5**: Should SearchService emit events for long operations?
- **Context**: Indexing may take 1-2 seconds
- **Recommendation**: Yes, emit progress events for UI feedback

---

## Appendix A: API Reference

### SearchService

```python
class SearchService:
    """
    Application service for searching design objects.

    Provides fast, ranked search across cells, nets, ports, and pins
    with support for exact, prefix, contains, and wildcard matching.
    """

    def __init__(self, design: Design):
        """Initialize and build indexes from design"""

    def search(
        self,
        query: str,
        filters: Optional[SearchFilters] = None
    ) -> List[SearchResult]:
        """
        Execute search query.

        Args:
            query: Search string (literal or wildcard)
            filters: Type filters and result limits

        Returns:
            Sorted list of search results by relevance
        """

    def clear_cache(self):
        """Clear any internal caches (if implemented)"""
```

### SearchFilters

```python
@dataclass
class SearchFilters:
    """Search filtering configuration"""
    include_cells: bool = True
    include_pins: bool = True
    include_nets: bool = True
    include_ports: bool = True
    max_results: int = 100
```

### SearchResult

```python
@dataclass
class SearchResult:
    """Single search result with metadata"""
    object_type: str        # "cell", "pin", "net", "port"
    name: str               # Display name
    object_id: str          # Unique ID for navigation
    context: str            # Additional context
    match_quality: float    # Relevance: 1.0=exact, 0.8=prefix, 0.5=contains, 0.3=pattern

    def __lt__(self, other) -> bool:
        """Sort by quality desc, then name asc"""
```

---

## Appendix B: Example Usage

### Basic Search

```python
design = Design.from_file("design.ckt")
service = SearchService(design)

# Autocomplete search
results = service.search("clk")

for result in results[:5]:
    print(f"{result.object_type}: {result.name} (quality: {result.match_quality})")
# Output:
# net: clk (quality: 1.0)
# cell: clk_buf_0 (quality: 0.8)
# cell: clk_buf_1 (quality: 0.8)
# net: clk_div2 (quality: 0.8)
# port: clk_in (quality: 0.8)
```

### Filtered Search

```python
# Search only cells
filters = SearchFilters(
    include_cells=True,
    include_nets=False,
    include_ports=False,
    include_pins=False,
    max_results=10
)

results = service.search("data_*", filters)
# Only cell results, max 10
```

### Wildcard Search

```python
# Find all registers
results = service.search("*_reg_?")

# Results:
# cell: data_reg_0 (quality: 0.3)
# cell: data_reg_1 (quality: 0.3)
# cell: addr_reg_0 (quality: 0.3)
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
