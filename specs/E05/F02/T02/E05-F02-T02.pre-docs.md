# E05-F02-T02: Wildcard Pattern Matching - Pre-Implementation Documentation

## Document Metadata
- **Task**: E05-F02-T02 - Wildcard Pattern Matching
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

Implement a pattern matching system that converts user-friendly wildcard syntax (`*`, `?`) to compiled regex patterns. This enables intuitive search queries like `clk_*`, `*_reg`, or `mem?_data` without requiring users to learn regex syntax.

### 1.2 Problem Context

Users expect familiar wildcard syntax from Unix shells and file explorers. Direct regex forces users to escape special characters and understand complex syntax, creating friction. A wildcard-to-regex translator bridges this gap while leveraging Python's efficient `re` module for matching.

**Why Wildcards vs Full Regex**:
- **User Experience**: `clk_*` is intuitive, `^clk_.*$` is not
- **Safety**: Wildcards prevent regex injection (e.g., catastrophic backtracking)
- **Performance**: Pre-compiled patterns are fast
- **Simplicity**: Only two metacharacters to explain

### 1.3 Success Criteria

- Convert wildcard patterns to correct regex in < 1ms
- Match performance acceptable for incremental search (< 10ms per 1000 tests)
- Handle all regex special characters correctly (escaping)
- Support edge cases (empty patterns, unicode, special chars)

---

## 2. Technical Approach

### 2.1 Pattern Conversion Algorithm

**Input**: User wildcard pattern (e.g., `clk_*_buf?`)
**Output**: Compiled regex pattern with metadata

**Conversion Steps**:
```
1. Identify wildcards in pattern
2. Escape regex special characters (except * and ?)
3. Replace * with .* (zero or more chars)
4. Replace ? with . (exactly one char)
5. Anchor with ^ and $ for full match
6. Compile regex pattern
7. Detect pattern type (literal, prefix, general)
```

**Example Conversions**:
```
Input: "clk_*"
→ Escape: "clk_*" (no special chars)
→ Replace: "clk_.*"
→ Anchor: "^clk_.*$"
→ Type: PREFIX

Input: "net[0]"
→ Escape: "net\\[0\\]"
→ Replace: "net\\[0\\]" (no wildcards)
→ Anchor: "^net\\[0\\]$"
→ Type: LITERAL

Input: "*_reg_?"
→ Escape: "*_reg_?"
→ Replace: ".*_reg_."
→ Anchor: "^.*_reg_.$"
→ Type: GENERAL
```

### 2.2 Pattern Metadata Design

**Why Store Metadata**:
- **Optimization**: Literal patterns can use hash lookup instead of regex
- **Prefix Optimization**: `clk_*` can use trie prefix search instead of full scan
- **User Feedback**: Display pattern type in UI for debugging

**WildcardPattern Dataclass**:
```python
@dataclass(frozen=True)
class WildcardPattern:
    original: str           # User input for error messages
    regex: Pattern[str]     # Compiled regex
    is_literal: bool        # True if no wildcards (optimization flag)
    is_prefix: bool         # True if "prefix*" form (trie optimization)
```

**Immutability Rationale**: Thread-safe, cacheable, hashable for LRU cache

### 2.3 Special Character Escaping

**Regex Special Characters** (must escape):
```
. ^ $ + * ? [ ] { } ( ) | \
```

**Wildcard Characters** (do NOT escape):
```
* ?
```

**Escaping Strategy**:
```python
SPECIAL_CHARS = r'\.^$+[]{}()|'  # Backslash excluded (needs special handling)

for char in pattern:
    if char in SPECIAL_CHARS:
        escaped += "\\" + char
    elif char == '\\':
        escaped += "\\\\"  # Escape backslashes
    else:
        escaped += char
```

**Edge Case**: User input `a\.b` (literal backslash-dot)
- Expected match: `a\.b` (the string with backslash)
- Regex needed: `a\\\.b` (escape both backslash and dot)

### 2.4 Pattern Type Detection

**Literal Pattern**:
- Contains no `*` or `?`
- Can use exact match or hash lookup
- Example: `clk_main`

**Prefix Pattern**:
- Ends with `*` and has no other wildcards
- Can use trie prefix search
- Example: `clk_*`

**General Pattern**:
- Contains wildcards in middle or multiple wildcards
- Requires full regex matching
- Example: `*_reg_?`, `clk*div?`

**Optimization Strategy**:
```python
def search(pattern: WildcardPattern):
    if pattern.is_literal:
        return exact_lookup(pattern.original)  # O(1) hash
    elif pattern.is_prefix:
        prefix = pattern.original[:-1]  # Remove trailing *
        return trie.search_prefix(prefix)  # O(m + n)
    else:
        return regex_scan(pattern.regex)  # O(k) where k = dataset size
```

---

## 3. Implementation Strategy

### 3.1 Development Phases

#### Phase 1: Core Pattern Parser (1.5 hours)
**Deliverables**:
- `PatternParser` class with `parse()` method
- `_convert_to_regex()` internal method
- Special character escaping logic
- Unit tests for basic conversion

**Success Check**:
- `parse("clk_*")` returns correct regex
- Special chars escaped properly
- No wildcards = literal flag set

#### Phase 2: WildcardPattern Dataclass (1 hour)
**Deliverables**:
- `WildcardPattern` frozen dataclass
- `matches()` method using compiled regex
- Pattern type detection (is_literal, is_prefix)
- `__repr__()` for debugging

**Success Check**:
- Pattern matching works correctly
- Metadata flags accurate
- Immutability enforced

#### Phase 3: Edge Cases & Validation (1 hour)
**Deliverables**:
- Empty pattern handling
- Unicode support
- Very long pattern testing
- Consecutive wildcards (`**`, `??`)

**Success Check**:
- All edge cases pass
- No regex compilation errors
- Performance acceptable

#### Phase 4: Convenience Functions (0.5 hours)
**Deliverables**:
- `parse_pattern()` function
- `is_wildcard()` function
- Comprehensive docstrings

**Success Check**:
- API easy to use
- Type hints work in IDE

### 3.2 File Organization

```
src/ink/infrastructure/search/
├── __init__.py
└── pattern_matcher.py     # PatternParser, WildcardPattern, helpers

tests/unit/infrastructure/search/
├── __init__.py
└── test_pattern_matcher.py  # Comprehensive unit tests
```

---

## 4. Design Decisions

### 4.1 Why Immutable WildcardPattern?

**Decision**: Use `@dataclass(frozen=True)`

**Alternatives**:
1. **Mutable dataclass**: Simpler but not thread-safe
2. **Named tuple**: Less readable, no type safety
3. **Regular class**: More boilerplate

**Rationale**: Immutability enables:
- Thread-safe caching in SearchService
- Hashable for LRU cache keys
- No accidental mutations during matching

### 4.2 Full Match vs Partial Match

**Decision**: Use `fullmatch()` instead of `match()` or `search()`

**Comparison**:
```python
pattern = r"^clk.*"

# match() - anchors at start only
re.match(pattern, "clk_main")      # ✓ matches
re.match(pattern, "clk_main_foo")  # ✓ matches (partial!)

# search() - finds anywhere
re.search(pattern, "main_clk")     # ✓ matches (wrong!)

# fullmatch() - entire string must match
re.fullmatch(pattern, "clk_main")  # ✓ matches
re.fullmatch(pattern, "clk_m")     # ✓ matches
re.fullmatch(pattern, "main_clk")  # ✗ no match (correct)
```

**Rationale**: Users expect wildcards to match the entire name, not substrings.

### 4.3 Pattern Compilation Timing

**Decision**: Compile regex during `parse()`, not during `matches()`

**Why**:
- Pattern compiled once, matched many times
- Compilation is expensive (~0.1-1ms)
- Matching is fast (~0.001ms per test)
- Pre-compilation enables caching

**Memory Tradeoff**: Each compiled pattern uses ~2KB, acceptable for <100 unique patterns

### 4.4 Error Handling Strategy

**Decision**: Permissive - always succeed, never raise exceptions

**Approach**:
- Invalid patterns: Treat as literal match
- Empty pattern: Match empty string only
- Very long pattern: Allow (Python regex handles it)

**Rationale**: Search should always return results (even if empty), never crash

---

## 5. Testing Strategy

### 5.1 Unit Test Categories

**Basic Wildcard Tests**:
- `*` matches zero or more chars
- `?` matches exactly one char
- Combined wildcards work correctly
- No wildcards = literal match

**Special Character Escaping**:
- Brackets: `net[0]` should match literally
- Dots: `a.b` should match literally (not `a<any>b`)
- Operators: `x+y`, `x*y` (literal multiplication)
- Parentheses: `func(a, b)`
- Backslashes: `path\to\file`

**Edge Cases**:
- Empty string pattern
- Single character pattern
- Only wildcards: `*`, `?`, `**`, `*?*`
- Very long pattern (1000+ chars)
- Unicode characters
- Consecutive wildcards

**Pattern Type Detection**:
- Literal: `cell_123`, `net[5]`, `a.b`
- Prefix: `clk_*`, `data_*`, `a*`
- General: `*_reg`, `mem?`, `*clk*div?`

### 5.2 Test Data

**Realistic Pattern Examples**:
```python
COMMON_PATTERNS = [
    ("clk_*", ["clk_main", "clk_div2"], ["clk", "main_clk"]),
    ("*_reg", ["data_reg", "addr_reg"], ["reg", "register"]),
    ("mem?_data", ["mem0_data", "memA_data"], ["mem_data", "mem12_data"]),
    ("net[?]", ["net[0]", "net[5]"], ["net0", "net[]"]),
]
```

**Performance Test Data**:
```python
# Generate 10K cell names for matching speed test
def generate_test_names():
    return [
        f"cell_{i:05d}" for i in range(5000)
    ] + [
        f"clk_buf_{i:03d}" for i in range(2500)
    ] + [
        f"data_reg_{i:03d}" for i in range(2500)
    ]
```

### 5.3 Performance Benchmarks

**Compilation Speed**:
```python
def test_pattern_compilation_speed(benchmark):
    result = benchmark(parse_pattern, "clk_*_buf?")
    assert benchmark.stats.mean < 0.001  # < 1ms
```

**Matching Speed**:
```python
def test_pattern_matching_speed(benchmark, large_dataset):
    pattern = parse_pattern("clk_*")

    def match_all():
        return [name for name in large_dataset if pattern.matches(name)]

    result = benchmark(match_all)
    assert benchmark.stats.mean < 0.01  # < 10ms for 1000 names
```

---

## 6. Integration Points

### 6.1 Downstream Consumers

**SearchService (E05-F02-T03)**:
```python
class SearchService:
    def search(self, query: str) -> List[SearchResult]:
        if is_wildcard(query):
            pattern = parse_pattern(query)
            return self._search_pattern(pattern)
        else:
            return self._search_literal(query)

    def _search_pattern(self, pattern: WildcardPattern):
        results = []

        # Optimization: use trie for prefix patterns
        if pattern.is_prefix:
            prefix = pattern.original[:-1]
            return self._cell_trie.search_prefix(prefix)

        # Full scan for general patterns
        for cell in self._design.cells.values():
            if pattern.matches(cell.name):
                results.append(...)
        return results
```

### 6.2 Dependencies

**Upstream**: Python standard library `re` module only

**No External Dependencies**: Intentionally kept simple for reliability

---

## 7. Risk Analysis

### 7.1 Technical Risks

#### Risk 1: Regex Injection / Catastrophic Backtracking
**Impact**: High (DoS via slow regex, or unexpected matches)
**Probability**: Low (controlled conversion, no user regex)

**Mitigation**:
- Only allow `*` and `?`, not full regex syntax
- Escape all special chars before wildcards
- Use simple `.*` and `.` replacements (no backtracking)
- No user-provided regex (wildcards only)

**Validation**:
```python
# Safe: .*_reg_.
# Unsafe: (.*)*(.*)*(.*)* (catastrophic backtracking)
# Our conversion never generates unsafe patterns
```

#### Risk 2: Unicode Handling Issues
**Impact**: Medium (non-ASCII names fail to match)
**Probability**: Low (Python 3 handles unicode well)

**Mitigation**:
- Test with unicode characters (Chinese, Arabic, emoji)
- Use Python's default unicode mode for regex
- No ASCII-only assumptions

**Test Cases**:
```python
assert parse_pattern("测试*").matches("测试_cell")
assert parse_pattern("Müller*").matches("Müller_123")
```

#### Risk 3: Special Character Escaping Bugs
**Impact**: Medium (incorrect matches, user confusion)
**Probability**: Medium (edge cases are tricky)

**Mitigation**:
- Comprehensive test suite for all regex special chars
- Test combinations (e.g., `[*]`, `(?)`)
- Validation against known-good patterns

**Tricky Cases**:
```python
# User wants to match literal "data[0]" (with brackets)
pattern = parse_pattern("data[0]")
assert pattern.matches("data[0]")
assert not pattern.matches("data0")  # Would match if [ not escaped
```

### 7.2 Performance Risks

#### Risk 4: Slow Regex Compilation
**Impact**: Low (slight delay, but one-time cost)
**Probability**: Low (Python regex compiler is fast)

**Mitigation**:
- Pre-compile patterns in SearchService
- Cache compiled patterns (LRU cache in IncrementalSearchHandler)
- Benchmark shows < 1ms compilation

**Contingency**: If compilation is slow, cache WildcardPattern objects

---

## 8. Future Enhancements (Post-MVP)

### 8.1 Advanced Pattern Syntax

**Brace Expansion** (bash-style):
```
Input: "clk_{main,div2,buf}"
Matches: "clk_main", "clk_div2", "clk_buf"
```

**Character Classes**:
```
Input: "net[0-9]"
Matches: "net0", "net1", ..., "net9"
```

**Negation**:
```
Input: "!*_test"
Matches: everything except names ending in "_test"
```

### 8.2 Regex Mode

**Escape Hatch for Power Users**:
```python
# Detect regex by leading/trailing slash
if query.startswith('/') and query.endswith('/'):
    regex_pattern = query[1:-1]
    return WildcardPattern(
        original=query,
        regex=re.compile(regex_pattern),
        is_literal=False,
        is_prefix=False
    )
```

**Safety**: Validate regex before compiling (timeout, complexity check)

### 8.3 Performance Optimizations

**Pattern Caching**:
```python
@lru_cache(maxsize=100)
def parse_pattern_cached(pattern: str) -> WildcardPattern:
    return PatternParser.parse(pattern)
```

**Lazy Compilation**:
- Store regex string, compile on first match
- Saves memory for unused patterns
- Complexity vs benefit tradeoff (probably not worth it)

---

## 9. Acceptance Checklist

### 9.1 Code Completeness

- [ ] `PatternParser` class with `parse()` and `_convert_to_regex()`
- [ ] `WildcardPattern` frozen dataclass
- [ ] `matches()` method using `fullmatch()`
- [ ] Special character escaping for all regex chars
- [ ] `is_literal` and `is_prefix` detection
- [ ] `is_wildcard()` helper function
- [ ] Type hints on all public methods
- [ ] Comprehensive docstrings with examples

### 9.2 Testing

- [ ] Basic wildcard tests (`*`, `?`)
- [ ] Special character escaping tests
- [ ] Edge cases (empty, unicode, long patterns)
- [ ] Pattern type detection tests
- [ ] Performance benchmark (< 1ms compilation)
- [ ] Test coverage > 95%

### 9.3 Performance

- [ ] Pattern compilation < 1ms
- [ ] Pattern matching < 10ms per 1000 tests
- [ ] No catastrophic backtracking patterns

### 9.4 Documentation

- [ ] Docstrings explain wildcard syntax
- [ ] Examples for all pattern types
- [ ] Type hints enable IDE autocomplete
- [ ] Clear error messages (if any)

---

## 10. Open Questions

### 10.1 Design Questions

**Q1**: Should `*` match empty string?
- **Context**: Unix `*` matches zero or more
- **Example**: `clk_*` matches `clk_` (yes) or `clk` (no)?
- **Recommendation**: Yes (standard wildcard semantics)

**Q2**: Should patterns be case-sensitive by default?
- **Context**: File systems vary (Windows=no, Linux=yes)
- **Options**:
  - A) Case-sensitive (matches most HDL tools)
  - B) Case-insensitive (user-friendly)
  - C) Configurable per pattern
- **Recommendation**: Option A for MVP, configurable in P1

**Q3**: How to handle pattern errors (invalid syntax)?
- **Context**: Wildcards are simple, but future extensions may fail
- **Options**:
  - A) Treat as literal (never fail)
  - B) Raise ValueError
  - C) Return empty results with warning
- **Recommendation**: Option A (robustness over strictness)

### 10.2 Integration Questions

**Q4**: Should PatternMatcher know about SearchService optimizations?
- **Current**: PatternMatcher is pure transformation (wildcards→regex)
- **Alternative**: Include optimization hints in WildcardPattern
- **Recommendation**: Keep separation, SearchService handles optimization

**Q5**: Should we expose regex compilation errors to users?
- **Context**: Invalid patterns could cause `re.error`
- **Recommendation**: Catch and log, treat as non-matching pattern

---

## Appendix A: Regex Escaping Reference

### Python Regex Special Characters

| Character | Meaning | Must Escape? | Example |
|-----------|---------|--------------|---------|
| `.` | Any character | Yes | `a.b` → `a\.b` |
| `^` | Start anchor | Yes | `^data` → `\^data` |
| `$` | End anchor | Yes | `data$` → `data\$` |
| `*` | Zero or more (wildcard) | No | `clk*` → `clk.*` |
| `+` | One or more | Yes | `x+y` → `x\+y` |
| `?` | Zero or one (wildcard) | No | `mem?` → `mem.` |
| `[` | Character class start | Yes | `net[0]` → `net\[0\]` |
| `]` | Character class end | Yes | `net]` → `net\]` |
| `{` | Quantifier start | Yes | `a{2}` → `a\{2\}` |
| `}` | Quantifier end | Yes | `a}` → `a\}` |
| `(` | Group start | Yes | `f(x)` → `f\(x\)` |
| `)` | Group end | Yes | `f)` → `f\)` |
| `\|` | Alternation | Yes | `a\|b` → `a\\\|b` |
| `\` | Escape | Yes | `a\b` → `a\\b` |

### Escaping Algorithm

```python
def escape_regex_chars(text: str) -> str:
    """Escape all regex special chars except * and ?"""
    result = []
    for char in text:
        if char in r'\.^$+[]{}()|':
            result.append('\\')
        elif char == '\\':
            result.append('\\')  # Double-escape backslash
        result.append(char)
    return ''.join(result)
```

---

## Appendix B: Pattern Examples

### Example Conversions

| User Input | Escaped | With Wildcards | Anchored | Type |
|------------|---------|----------------|----------|------|
| `clk_*` | `clk_*` | `clk_.*` | `^clk_.*$` | PREFIX |
| `*_reg` | `*_reg` | `.*_reg` | `^.*_reg$` | GENERAL |
| `mem?_data` | `mem?_data` | `mem._data` | `^mem._data$` | GENERAL |
| `net[0]` | `net\[0\]` | `net\[0\]` | `^net\[0\]$` | LITERAL |
| `a.b` | `a\.b` | `a\.b` | `^a\.b$` | LITERAL |
| `*` | `*` | `.*` | `^.*$` | GENERAL |
| `cell_123` | `cell_123` | `cell_123` | `^cell_123$` | LITERAL |

### Match Examples

**Pattern**: `clk_*`
- ✓ `clk_`
- ✓ `clk_main`
- ✓ `clk_div_2_buf`
- ✗ `clk` (no underscore)
- ✗ `main_clk` (doesn't start with clk_)

**Pattern**: `mem?_data`
- ✓ `mem0_data`
- ✓ `memA_data`
- ✓ `mem_data` (? matches underscore)
- ✗ `mem_data` (wait, this should NOT match - one char required)
- ✗ `mem12_data` (two chars, not one)

**Pattern**: `*clk*`
- ✓ `clk`
- ✓ `main_clk`
- ✓ `clk_buf`
- ✓ `main_clk_buf`
- ✗ `clock` (different chars)

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
