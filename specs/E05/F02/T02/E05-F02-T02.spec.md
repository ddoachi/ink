---
id: E05-F02-T02
title: Wildcard Pattern Matching
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F02
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Small
tags:
  - infrastructure
  - pattern-matching
clickup_task_id: ''
---

# Spec: E05-F02-T02 - Wildcard Pattern Matching

## 1. Overview

### 1.1 Problem Statement
Users need to search for objects using wildcard patterns like `clk_*`, `*_reg`, or `mem?_data`. Converting user-friendly wildcards to regex patterns enables efficient matching while maintaining intuitive search syntax.

### 1.2 Goals
- Convert wildcard patterns (`*`, `?`) to regex patterns
- Support literal string matching (no wildcards)
- Escape special regex characters in user input
- Provide compiled regex for efficient matching
- Handle edge cases (empty patterns, special characters)

---

## 2. Technical Requirements

### 2.1 Pattern Parser Implementation

**Location**: `/home/joohan/dev/project-ink/ink/infrastructure/search/pattern_matcher.py`

```python
import re
from dataclasses import dataclass
from typing import Pattern

@dataclass(frozen=True)
class WildcardPattern:
    """
    Represents a compiled wildcard pattern.

    Attributes:
        original: Original user input string
        regex: Compiled regex pattern
        is_literal: True if pattern contains no wildcards
        is_prefix: True if pattern is "prefix*" form
    """
    original: str
    regex: Pattern[str]
    is_literal: bool
    is_prefix: bool

    def matches(self, text: str) -> bool:
        """Test if text matches this pattern"""
        return self.regex.fullmatch(text) is not None

    def __repr__(self) -> str:
        return f"WildcardPattern({self.original!r})"

class PatternParser:
    """Converts wildcard patterns to regex patterns"""

    # Regex special characters that need escaping (except * and ?)
    SPECIAL_CHARS = r'\.^$+[]{}()|'

    @classmethod
    def parse(cls, pattern: str) -> WildcardPattern:
        """
        Convert wildcard pattern to compiled regex.

        Wildcard syntax:
            * - Matches zero or more characters
            ? - Matches exactly one character
            All other characters are treated literally

        Args:
            pattern: User input pattern string

        Returns:
            Compiled WildcardPattern object

        Examples:
            "clk_*"     -> matches "clk_", "clk_main", "clk_div2"
            "*_reg"     -> matches "data_reg", "addr_reg"
            "mem?_data" -> matches "mem0_data", "mem1_data"
            "cell_123"  -> matches only "cell_123" (literal)
        """
        if not pattern:
            # Empty pattern matches empty string only
            return WildcardPattern(
                original=pattern,
                regex=re.compile(r'^$'),
                is_literal=True,
                is_prefix=False
            )

        # Check if pattern is literal (no wildcards)
        has_wildcards = '*' in pattern or '?' in pattern

        # Check if pattern is simple prefix (ends with * only)
        is_prefix = pattern.endswith('*') and pattern.count('*') == 1 and '?' not in pattern

        # Build regex pattern
        regex_pattern = cls._convert_to_regex(pattern)

        return WildcardPattern(
            original=pattern,
            regex=re.compile(regex_pattern),
            is_literal=not has_wildcards,
            is_prefix=is_prefix
        )

    @classmethod
    def _convert_to_regex(cls, pattern: str) -> str:
        """
        Convert wildcard pattern to regex string.

        Process:
            1. Escape regex special characters
            2. Replace * with .*
            3. Replace ? with .
            4. Anchor with ^ and $ for full match
        """
        # Escape special regex characters except * and ?
        escaped = ""
        for char in pattern:
            if char in cls.SPECIAL_CHARS:
                escaped += "\\" + char
            else:
                escaped += char

        # Convert wildcards to regex
        regex = escaped.replace('*', '.*').replace('?', '.')

        # Anchor for full string match
        return f"^{regex}$"

    @classmethod
    def is_wildcard_pattern(cls, pattern: str) -> bool:
        """Check if pattern contains wildcards"""
        return '*' in pattern or '?' in pattern

# Convenience functions
def parse_pattern(pattern: str) -> WildcardPattern:
    """Shorthand for PatternParser.parse()"""
    return PatternParser.parse(pattern)

def is_wildcard(pattern: str) -> bool:
    """Shorthand for PatternParser.is_wildcard_pattern()"""
    return PatternParser.is_wildcard_pattern(pattern)
```

### 2.2 Usage Examples

```python
# Literal match
pattern = parse_pattern("cell_123")
assert pattern.matches("cell_123")
assert not pattern.matches("cell_1234")
assert pattern.is_literal

# Prefix match
pattern = parse_pattern("clk_*")
assert pattern.matches("clk_main")
assert pattern.matches("clk_")
assert not pattern.matches("clk")
assert pattern.is_prefix

# Suffix match
pattern = parse_pattern("*_reg")
assert pattern.matches("data_reg")
assert pattern.matches("_reg")
assert not pattern.matches("reg")

# Single character wildcard
pattern = parse_pattern("mem?_data")
assert pattern.matches("mem0_data")
assert pattern.matches("memA_data")
assert not pattern.matches("mem12_data")

# Complex pattern
pattern = parse_pattern("*clk*div?")
assert pattern.matches("main_clk_div2")
assert pattern.matches("clk_div0")
assert not pattern.matches("clk_div")

# Special characters in pattern
pattern = parse_pattern("net[0]")
assert pattern.matches("net[0]")
assert not pattern.matches("net0")
```

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `/home/joohan/dev/project-ink/ink/tests/unit/infrastructure/search/test_pattern_matcher.py`

```python
import pytest
from ink.infrastructure.search.pattern_matcher import (
    PatternParser, WildcardPattern, parse_pattern, is_wildcard
)

class TestPatternParser:
    def test_literal_pattern(self):
        pattern = parse_pattern("cell_123")
        assert pattern.is_literal
        assert not pattern.is_prefix
        assert pattern.matches("cell_123")
        assert not pattern.matches("cell_1234")
        assert not pattern.matches("cell_12")

    def test_prefix_wildcard(self):
        pattern = parse_pattern("clk_*")
        assert not pattern.is_literal
        assert pattern.is_prefix
        assert pattern.matches("clk_")
        assert pattern.matches("clk_main")
        assert pattern.matches("clk_div_2")
        assert not pattern.matches("clk")

    def test_suffix_wildcard(self):
        pattern = parse_pattern("*_reg")
        assert not pattern.is_literal
        assert not pattern.is_prefix
        assert pattern.matches("data_reg")
        assert pattern.matches("_reg")
        assert not pattern.matches("reg")

    def test_middle_wildcard(self):
        pattern = parse_pattern("net_*_out")
        assert pattern.matches("net_main_out")
        assert pattern.matches("net__out")
        assert not pattern.matches("net_main_in")

    def test_single_char_wildcard(self):
        pattern = parse_pattern("mem?_data")
        assert pattern.matches("mem0_data")
        assert pattern.matches("memA_data")
        assert not pattern.matches("mem_data")
        assert not pattern.matches("mem12_data")

    def test_combined_wildcards(self):
        pattern = parse_pattern("*clk*div?")
        assert pattern.matches("main_clk_div2")
        assert pattern.matches("clkdiv0")
        assert not pattern.matches("clk_div")

    def test_special_char_escaping(self):
        # Regex special chars should be escaped
        pattern = parse_pattern("net[0]")
        assert pattern.matches("net[0]")
        assert not pattern.matches("net0")

        pattern = parse_pattern("a.b")
        assert pattern.matches("a.b")
        assert not pattern.matches("aXb")

        pattern = parse_pattern("x+y")
        assert pattern.matches("x+y")
        assert not pattern.matches("x++y")

    def test_empty_pattern(self):
        pattern = parse_pattern("")
        assert pattern.is_literal
        assert pattern.matches("")
        assert not pattern.matches("anything")

    def test_only_wildcards(self):
        pattern = parse_pattern("*")
        assert pattern.matches("")
        assert pattern.matches("anything")
        assert pattern.matches("multiple words")

        pattern = parse_pattern("?")
        assert pattern.matches("a")
        assert not pattern.matches("")
        assert not pattern.matches("ab")

    def test_is_wildcard_detection(self):
        assert is_wildcard("clk_*")
        assert is_wildcard("*_reg")
        assert is_wildcard("mem?")
        assert is_wildcard("*?*")
        assert not is_wildcard("cell_123")
        assert not is_wildcard("")

    def test_pattern_repr(self):
        pattern = parse_pattern("test*")
        assert "test*" in repr(pattern)

    def test_case_sensitive_matching(self):
        pattern = parse_pattern("Cell*")
        assert pattern.matches("Cell_123")
        assert not pattern.matches("cell_123")

class TestWildcardPatternEdgeCases:
    def test_multiple_consecutive_wildcards(self):
        pattern = parse_pattern("a**b")
        assert pattern.matches("ab")
        assert pattern.matches("aXb")
        assert pattern.matches("aXYZb")

    def test_backslash_in_pattern(self):
        pattern = parse_pattern(r"path\to\file")
        assert pattern.matches(r"path\to\file")

    def test_unicode_characters(self):
        pattern = parse_pattern("测试*")
        assert pattern.matches("测试_123")
        assert not pattern.matches("test_123")

    def test_very_long_pattern(self):
        long_pattern = "a" * 1000 + "*"
        pattern = parse_pattern(long_pattern)
        assert pattern.matches("a" * 1000 + "suffix")
```

### 3.2 Test Coverage Target
- Minimum 95% code coverage
- All wildcard combinations tested
- Regex special character escaping verified
- Edge cases: empty patterns, unicode, special chars

---

## 4. Dependencies

- **Upstream**:
  - None (uses Python standard library `re` module)
- **Downstream**:
  - E05-F02-T03 (Search Service uses pattern matching for wildcard queries)

---

## 5. Acceptance Criteria

- [ ] `PatternParser` class converts wildcards to regex
- [ ] `*` wildcard matches zero or more characters
- [ ] `?` wildcard matches exactly one character
- [ ] Regex special characters properly escaped
- [ ] `WildcardPattern.matches()` tests string matching
- [ ] `is_literal` flag correctly identifies non-wildcard patterns
- [ ] `is_prefix` flag correctly identifies "prefix*" patterns
- [ ] All unit tests passing with > 95% coverage
- [ ] Pattern compilation time < 1ms
- [ ] Matching performance acceptable for incremental search

---

## 6. Implementation Notes

### 6.1 Design Decisions
- Use `fullmatch()` instead of `match()` to ensure entire string matches
- Pre-compile regex patterns for performance
- Immutable `WildcardPattern` dataclass for caching and thread safety

### 6.2 Future Enhancements (Post-MVP)
- Regular expression support (escape syntax like `/regex/`)
- Case-insensitive matching option
- Character class support (`[a-z]`, `[0-9]`)
- Negation support (`!pattern`)

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F02 split |
