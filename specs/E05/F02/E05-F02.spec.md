# Spec: E05-F02 - Search Engine

## Metadata
- **ID**: E05-F02
- **Type**: Feature
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E05](../E05.spec.md)
- **Created**: 2025-12-26

---

## 1. Overview

### 1.1 Problem Statement
Searching through hundreds of thousands of cells, pins, and nets requires an efficient indexing and query system. The search engine must provide real-time results within 100ms while supporting filtering and pattern matching.

### 1.2 Goals
- Build pre-indexed data structures for fast object lookup
- Execute searches with configurable filters (type, max results)
- Provide incremental search with sub-100ms response time
- Support prefix matching and exact name matching
- Return structured search results with context information

---

## 2. User Stories

### US-E05-02: Incremental Search
**As a** circuit designer
**I want to** see results as I type
**So that** I can find objects without typing full names

**Acceptance Criteria:**
- [ ] Results update after each keystroke
- [ ] Minimum 2 characters to start search
- [ ] Results show within 100ms of typing
- [ ] Results limited to prevent overwhelming list

---

## 3. Technical Requirements

### 3.1 Search Engine Interface

```python
class SearchEngine:
    """Core search engine for netlist objects"""

    def __init__(self, design: Design):
        """Initialize with design and build indexes"""
        self._index = SearchIndex.build_from_design(design)

    def search(self, query: str, filters: SearchFilters) -> List[SearchResult]:
        """
        Execute search with query and filters

        Args:
            query: Search string (plain text or pattern)
            filters: Type filters and result limits

        Returns:
            List of matching results sorted by relevance
        """

    def parse_pattern(self, query: str) -> Pattern:
        """Convert wildcard query to regex pattern"""

    def get_history(self) -> List[str]:
        """Get recent search queries (managed separately)"""
```

### 3.2 Data Structures

```python
@dataclass
class SearchFilters:
    """Search filtering and limits"""
    include_cells: bool = True
    include_pins: bool = True
    include_nets: bool = True
    include_ports: bool = True
    max_results: int = 100

@dataclass
class SearchResult:
    """Single search result"""
    object_type: str        # "cell", "pin", "net", "port"
    name: str               # Object name
    object_id: str          # Unique identifier for navigation
    context: str            # Additional context (e.g., "Pin of XI123")
    match_quality: float    # Relevance score (0.0-1.0)
```

### 3.3 Search Index

```python
class SearchIndex:
    """Pre-built index for fast search"""

    cell_names: Dict[str, Cell]      # name -> cell
    pin_names: Dict[str, List[Pin]]  # name -> pins (multiple cells)
    net_names: Dict[str, Net]        # name -> net
    port_names: Dict[str, Port]      # name -> port

    # Trie structures for prefix search
    cell_trie: Trie
    net_trie: Trie

    @classmethod
    def build_from_design(cls, design: Design) -> 'SearchIndex':
        """Build indexes from design model"""

    def prefix_search(self, prefix: str, object_type: str) -> List[str]:
        """Find all names starting with prefix"""
```

### 3.4 Search Algorithm

```python
def search(self, query: str, filters: SearchFilters) -> List[SearchResult]:
    results = []

    # Minimum query length
    if len(query) < 2:
        return results

    # Search each object type based on filters
    if filters.include_cells:
        results.extend(self._search_cells(query))
    if filters.include_pins:
        results.extend(self._search_pins(query))
    if filters.include_nets:
        results.extend(self._search_nets(query))
    if filters.include_ports:
        results.extend(self._search_ports(query))

    # Sort by relevance (exact match > prefix match > contains)
    results.sort(key=lambda r: r.match_quality, reverse=True)

    # Limit results
    return results[:filters.max_results]
```

### 3.5 Performance Requirements

| Operation | Target | Notes |
|-----------|--------|-------|
| Index build time | < 2s for 100K objects | One-time cost on design load |
| Search latency | < 100ms | Real-time incremental search |
| Memory overhead | < 50MB for 100K objects | Trie + hash maps |
| Prefix search | < 50ms | Used for autocomplete |

---

## 4. Dependencies

- **Upstream**:
  - E01 (Data Model - Design, Cell, Pin, Net, Port entities)
- **Downstream**:
  - E05-F01 (Search Panel UI - consumes search results)
  - E05-F03 (Wildcard Matching - pattern parsing)
  - E05-F04 (Navigation - provides object_id for navigation)

---

## 5. Acceptance Criteria

- [ ] Search index builds from `Design` model in < 2s for 100K objects
- [ ] Search returns results in < 100ms
- [ ] Exact name matches ranked highest
- [ ] Prefix matches ranked second
- [ ] Contains matches ranked lowest
- [ ] Filters correctly include/exclude object types
- [ ] Results limited to `max_results` configuration
- [ ] Pin results include parent cell context
- [ ] Results sorted by relevance score
- [ ] Minimum 2 characters required to trigger search

---

## 6. Child Specs
*To be created via `/spec_work E05-F02 --split tasks`*

| ID | Task | Status |
|----|------|--------|

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial feature creation from E05 split |
