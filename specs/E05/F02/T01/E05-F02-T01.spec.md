---
id: E05-F02-T01
title: Trie Index Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F02
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - infrastructure
  - data-structures
clickup_task_id: '86evzm30a'
---

# Spec: E05-F02-T01 - Trie Index Implementation

## 1. Overview

### 1.1 Problem Statement
Fast prefix-based search requires an efficient data structure. A trie (prefix tree) provides O(m) lookup time where m is the query length, enabling sub-50ms prefix search for autocomplete and incremental search.

### 1.2 Goals
- Implement a generic `Trie` class for prefix-based string indexing
- Support insertion of strings with associated values
- Provide prefix search returning all matching strings
- Optimize memory usage through character node sharing
- Achieve < 50ms prefix search for 100K entries

---

## 2. Technical Requirements

### 2.1 Trie Implementation

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/infrastructure/search/trie_index.py`

```python
from typing import Dict, List, Generic, TypeVar, Optional

T = TypeVar('T')

class TrieNode(Generic[T]):
    """Node in a trie structure"""

    def __init__(self):
        self.children: Dict[str, TrieNode[T]] = {}
        self.is_end_of_word: bool = False
        self.value: Optional[T] = None  # Associated value at word end

class Trie(Generic[T]):
    """
    Prefix tree for fast string lookup and prefix search.

    Generic type T allows associating values with strings.
    """

    def __init__(self):
        self.root: TrieNode[T] = TrieNode()
        self._size: int = 0

    def insert(self, word: str, value: T) -> None:
        """
        Insert a word into the trie with associated value.

        Args:
            word: String to insert (case-sensitive)
            value: Associated value to store
        """
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]

        if not node.is_end_of_word:
            self._size += 1

        node.is_end_of_word = True
        node.value = value

    def search_exact(self, word: str) -> Optional[T]:
        """
        Search for exact word match.

        Args:
            word: String to search for

        Returns:
            Associated value if found, None otherwise
        """
        node = self._find_node(word)
        if node and node.is_end_of_word:
            return node.value
        return None

    def search_prefix(self, prefix: str, max_results: int = 100) -> List[tuple[str, T]]:
        """
        Find all words starting with prefix.

        Args:
            prefix: Prefix to search for
            max_results: Maximum number of results to return

        Returns:
            List of (word, value) tuples matching the prefix
        """
        node = self._find_node(prefix)
        if not node:
            return []

        results = []
        self._collect_words(node, prefix, results, max_results)
        return results

    def _find_node(self, word: str) -> Optional[TrieNode[T]]:
        """Navigate to node representing the word/prefix"""
        node = self.root
        for char in word:
            if char not in node.children:
                return None
            node = node.children[char]
        return node

    def _collect_words(
        self,
        node: TrieNode[T],
        current_word: str,
        results: List[tuple[str, T]],
        max_results: int
    ) -> None:
        """
        Recursively collect all words from a node.

        DFS traversal collecting words until max_results reached.
        """
        if len(results) >= max_results:
            return

        if node.is_end_of_word:
            results.append((current_word, node.value))

        for char, child_node in sorted(node.children.items()):
            if len(results) >= max_results:
                break
            self._collect_words(child_node, current_word + char, results, max_results)

    def __len__(self) -> int:
        """Return number of words in trie"""
        return self._size

    def __contains__(self, word: str) -> bool:
        """Check if word exists in trie"""
        return self.search_exact(word) is not None
```

### 2.2 Case-Insensitive Variant

```python
class CaseInsensitiveTrie(Trie[T]):
    """Trie that normalizes input to lowercase for case-insensitive search"""

    def insert(self, word: str, value: T) -> None:
        """Insert word in lowercase"""
        super().insert(word.lower(), value)

    def search_exact(self, word: str) -> Optional[T]:
        """Search with case-insensitive matching"""
        return super().search_exact(word.lower())

    def search_prefix(self, prefix: str, max_results: int = 100) -> List[tuple[str, T]]:
        """Search prefix case-insensitively"""
        return super().search_prefix(prefix.lower(), max_results)
```

### 2.3 Performance Requirements

| Operation | Complexity | Target Performance |
|-----------|-----------|-------------------|
| Insert | O(m) where m = word length | < 1ms per word |
| Exact search | O(m) | < 1ms |
| Prefix search | O(m + n) where n = results | < 50ms for 100 results |
| Memory | O(k * m) where k = num words | < 30MB for 100K words |

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `/home/joohan/dev/project-ink/ink/tests/unit/infrastructure/search/test_trie_index.py`

```python
import pytest
from ink.infrastructure.search.trie_index import Trie, CaseInsensitiveTrie

class TestTrie:
    def test_insert_and_search_exact(self):
        trie = Trie[str]()
        trie.insert("hello", "value1")
        trie.insert("world", "value2")

        assert trie.search_exact("hello") == "value1"
        assert trie.search_exact("world") == "value2"
        assert trie.search_exact("hell") is None

    def test_prefix_search(self):
        trie = Trie[int]()
        trie.insert("car", 1)
        trie.insert("card", 2)
        trie.insert("care", 3)
        trie.insert("careful", 4)
        trie.insert("cat", 5)

        results = trie.search_prefix("car")
        assert len(results) == 4
        assert ("car", 1) in results
        assert ("card", 2) in results
        assert ("care", 3) in results
        assert ("careful", 4) in results

    def test_prefix_search_max_results(self):
        trie = Trie[int]()
        for i in range(100):
            trie.insert(f"test{i}", i)

        results = trie.search_prefix("test", max_results=10)
        assert len(results) == 10

    def test_empty_prefix(self):
        trie = Trie[str]()
        trie.insert("hello", "val")

        results = trie.search_prefix("")
        assert len(results) >= 1

    def test_case_sensitive(self):
        trie = Trie[str]()
        trie.insert("Hello", "val1")
        trie.insert("hello", "val2")

        assert trie.search_exact("Hello") == "val1"
        assert trie.search_exact("hello") == "val2"

    def test_case_insensitive_variant(self):
        trie = CaseInsensitiveTrie[str]()
        trie.insert("Hello", "val")

        assert trie.search_exact("hello") == "val"
        assert trie.search_exact("HELLO") == "val"
        assert trie.search_exact("HeLLo") == "val"

    def test_size_tracking(self):
        trie = Trie[str]()
        assert len(trie) == 0

        trie.insert("hello", "val")
        assert len(trie) == 1

        trie.insert("hello", "val2")  # Overwrite
        assert len(trie) == 1

        trie.insert("world", "val3")
        assert len(trie) == 2

    def test_contains(self):
        trie = Trie[str]()
        trie.insert("hello", "val")

        assert "hello" in trie
        assert "hell" not in trie
        assert "hello world" not in trie

class TestTriePerformance:
    def test_large_dataset_prefix_search(self, benchmark):
        """Benchmark prefix search on 100K entries"""
        trie = Trie[int]()

        # Insert 100K entries
        for i in range(100000):
            trie.insert(f"cell_{i:06d}", i)

        # Benchmark prefix search
        def search():
            return trie.search_prefix("cell_1", max_results=100)

        results = benchmark(search)
        assert len(results) <= 100
```

### 3.2 Test Coverage Target
- Minimum 90% code coverage
- All public methods tested
- Edge cases: empty strings, non-existent prefixes, max_results limits
- Performance: verify < 50ms for prefix search on 100K entries

---

## 4. Dependencies

- **Upstream**:
  - None (pure Python data structure)
- **Downstream**:
  - E05-F02-T03 (Search Service uses Trie for indexing)

---

## 5. Acceptance Criteria

- [ ] `Trie` class implemented with generic type support
- [ ] `insert()` method stores word with associated value
- [ ] `search_exact()` returns value for exact matches
- [ ] `search_prefix()` returns all words starting with prefix
- [ ] Results limited by `max_results` parameter
- [ ] `CaseInsensitiveTrie` variant implemented
- [ ] `__len__()` and `__contains__()` magic methods implemented
- [ ] All unit tests passing with > 90% coverage
- [ ] Prefix search completes in < 50ms for 100K entries
- [ ] Memory usage < 30MB for 100K words

---

## 6. Implementation Notes

### 6.1 Optimization Considerations
- Use sorted traversal for deterministic result ordering
- Stop DFS early when `max_results` reached
- Consider memory pooling for nodes if profiling shows benefit

### 6.2 Future Enhancements (Post-MVP)
- Fuzzy matching support (Levenshtein distance)
- Deletion support (currently insert-only)
- Compressed trie (PATRICIA/radix tree) for memory optimization
- Serialization for persistent caching

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F02 split |
