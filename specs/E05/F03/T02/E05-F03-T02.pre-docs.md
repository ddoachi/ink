# E05-F03-T02 - Pattern Matching Service: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F03-T02 - Pattern Matching Service
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements a pattern matching service that efficiently matches circuit objects (cells, nets, pins, ports) against compiled wildcard patterns. The service must iterate through indexed objects, apply pattern matching, and return sorted results within strict performance constraints. Results are sorted by match position (relevance) and limited to prevent UI overload.

### 1.2 Core Capabilities

The task delivers two primary components:

1. **SearchResult Data Structure**: Extended with match position and metadata for relevance sorting
2. **PatternMatcher Service**: Matches objects against compiled patterns with type filtering and result limiting

### 1.3 Success Metrics

- Search 10,000 cells in < 50ms
- Search 50,000 nets in < 100ms
- Combined search (all types) in < 100ms
- Early termination when `max_results` reached
- Results sorted by match position (relevance)

---

## 2. Architecture Decisions

### 2.1 Match Position for Relevance Sorting

**Decision**: Sort results by match position (start index of match), then alphabetically by name.

**Rationale**:
- Earlier matches are typically more relevant (e.g., `clk` better than `my_clk` for `*clk*`)
- Provides consistent, predictable ordering
- Helps users find exact matches faster
- Simple to implement and understand

**Example**:
```python
# Pattern: "*clk*"
# Unsorted results: ["system_clk", "clk", "clk_buffer", "my_clk"]
# After sorting:    ["clk", "clk_buffer", "my_clk", "system_clk"]
#                     ^0     ^0           ^3        ^7
```

**Alternatives Considered**:
- **Alphabetical only**: Rejected - less useful, `aaa_clk` would rank above `clk`
- **String length**: Rejected - doesn't correlate with relevance
- **Fuzzy scoring**: Over-engineered for MVP, patterns already provide specificity

**Implementation**:
```python
@dataclass
class SearchResult:
    name: str
    result_type: SearchResultType
    object_id: str
    match_position: int = 0

    def __lt__(self, other: 'SearchResult') -> bool:
        if self.match_position != other.match_position:
            return self.match_position < other.match_position
        return self.name < other.name
```

### 2.2 Separate Methods Per Object Type

**Decision**: Implement separate `match_cells()`, `match_nets()`, `match_ports()`, `match_pins()` methods.

**Rationale**:
- Allows selective searching based on user filters (cells only, nets only, etc.)
- Easier to test each type independently
- Clear `max_results` semantics per type
- Flexibility for future type-specific ranking or optimization

**Alternatives Considered**:
- **Single generic `match()` method**: Rejected - harder to apply filters, less testable
- **Iterator-based approach**: Deferred - adds complexity without clear benefit for MVP

**Trade-offs**:
- **Pro**: Type safety, easier testing, clearer semantics
- **Pro**: Enables independent optimization per type
- **Con**: More code (acceptable - methods are simple and similar)

### 2.3 Pin Qualified Name Format

**Decision**: Search pins using `CELL.PIN` qualified name format.

**Rationale**:
- Thousands of pins share same name across cells (e.g., `D`, `Q`, `CLK`)
- Qualified names provide context and enable specific searches
- Matches user mental model (hierarchical naming)
- Enables searching for specific pin on specific cell (e.g., `U_ALU_1.D`)

**Example**:
```python
# Cell: U_ALU_1, Pin: D   -> Search name: "U_ALU_1.D"
# Cell: U_ALU_2, Pin: D   -> Search name: "U_ALU_2.D"
# Pattern: "U_ALU_*.D"    -> Matches both
# Pattern: "*.D"          -> Matches all D pins
```

**Alternatives Considered**:
- **Pin name only**: Rejected - too many duplicates, not useful
- **Hierarchical path**: Over-engineered - gate-level has flat hierarchy
- **Cell + Pin separate fields**: Rejected - harder to search, users think in qualified names

### 2.4 Pins Disabled by Default

**Decision**: Set `include_pins=False` as default in `match_all()`.

**Rationale**:
- Pin count >> cell/net count (100x larger in typical designs)
- Most searches target cells and nets
- Pin searches can overwhelm UI with thousands of results
- Users can explicitly enable when needed

**Performance Impact**:
```
Design: 10,000 cells, 50,000 nets, 500,000 pins
- Search cells+nets: ~100ms
- Search cells+nets+pins: ~5000ms (50x slower)
```

**Mitigation**:
- UI provides checkbox to enable pin search
- Clear labeling: "Include Pins (slow for large designs)"
- Consider showing pin count and estimated time

### 2.5 Early Termination Strategy

**Decision**: Stop iterating when `max_results` reached.

**Rationale**:
- Prevents wasted computation for large result sets
- Bounds worst-case execution time
- Essential for maintaining responsiveness with large designs

**Implementation**:
```python
for cell in self.design.cells.values():
    match = pattern.search(cell.name)
    if match:
        results.append(SearchResult(...))
        if len(results) >= max_results:
            break  # Early termination
```

**Trade-offs**:
- **Pro**: Guaranteed performance bound
- **Pro**: Simple to implement
- **Con**: May miss "better" results that appear later in iteration
- **Mitigation**: Iteration order is stable (dict insertion order), so results are deterministic

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: Data Structures (30 minutes)**
- Extend `SearchResult` with `match_position` field
- Add `SearchResultType` enum
- Implement `__lt__()` for sorting
- Unit tests for sorting behavior

**Phase 2: Pattern Matcher - Cells and Nets (1 hour)**
- Implement `PatternMatcher` class with `Design` dependency
- Implement `match_cells()` method
- Implement `match_nets()` method
- Unit tests with mock design

**Phase 3: Pattern Matcher - Ports and Pins (1 hour)**
- Implement `match_ports()` method
- Implement `match_pins()` with qualified names
- Handle early termination in nested loops
- Unit tests for each method

**Phase 4: Combined Matching (30 minutes)**
- Implement `match_all()` with type filters
- Combine results and apply overall `max_results` limit
- Unit tests for combined matching

**Phase 5: Performance Testing (30 minutes)**
- Create large test designs (10K cells, 50K nets)
- Benchmark each method
- Verify < 100ms performance target
- Profile and optimize if needed

### 3.2 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/search/test_pattern_matcher.py`):

```python
class TestPatternMatcher:
    @pytest.fixture
    def mock_design(self):
        """Create mock design with known test data"""
        design = Mock(spec=Design)

        # Add test cells
        design.cells = {
            "clk": Mock(name="clk", id="cell_1"),
            "clk_buffer": Mock(name="clk_buffer", id="cell_2"),
            "my_clk": Mock(name="my_clk", id="cell_3"),
            "system_clk": Mock(name="system_clk", id="cell_4"),
            "data_reg": Mock(name="data_reg", id="cell_5"),
        }

        # Add test nets
        design.nets = {
            "n_clk": Mock(name="n_clk", id="net_1"),
            "n_data": Mock(name="n_data", id="net_2"),
        }

        return design

    def test_match_cells_basic(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*clk.*", re.IGNORECASE)

        results = matcher.match_cells(pattern, max_results=100)

        assert len(results) == 4
        assert all(r.result_type == SearchResultType.CELL for r in results)
        assert [r.name for r in results] == ["clk", "clk_buffer", "my_clk", "system_clk"]

    def test_match_cells_sorted_by_position(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*clk.*", re.IGNORECASE)

        results = matcher.match_cells(pattern, max_results=100)

        # Results should be sorted by match position
        assert results[0].name == "clk"  # Match at position 0
        assert results[0].match_position == 0
        assert results[-1].name == "system_clk"  # Match at position 7
        assert results[-1].match_position == 7

    def test_match_cells_max_results(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*clk.*", re.IGNORECASE)

        results = matcher.match_cells(pattern, max_results=2)

        assert len(results) == 2

    def test_match_cells_no_matches(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile("^xyz$", re.IGNORECASE)

        results = matcher.match_cells(pattern, max_results=100)

        assert len(results) == 0

    def test_match_nets(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*data.*", re.IGNORECASE)

        results = matcher.match_nets(pattern, max_results=100)

        assert len(results) == 1
        assert results[0].name == "n_data"
        assert results[0].result_type == SearchResultType.NET

    def test_match_pins_qualified_names(self, mock_design):
        # Add pins to cells
        cell1 = mock_design.cells["clk_buffer"]
        cell1.pins = [
            Mock(name="A", id="pin_1"),
            Mock(name="Y", id="pin_2"),
        ]

        cell2 = mock_design.cells["my_clk"]
        cell2.pins = [
            Mock(name="Q", id="pin_3"),
        ]

        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*buffer.*", re.IGNORECASE)

        results = matcher.match_pins(pattern, max_results=100)

        # Should match "clk_buffer.A" and "clk_buffer.Y"
        assert len(results) == 2
        assert results[0].name == "clk_buffer.A"
        assert results[1].name == "clk_buffer.Y"
        assert all(r.result_type == SearchResultType.PIN for r in results)
        assert results[0].parent_name == "clk_buffer"

    def test_match_all_combined(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*clk.*", re.IGNORECASE)

        results = matcher.match_all(
            pattern,
            include_cells=True,
            include_nets=True,
            include_ports=False,
            include_pins=False,
            max_results=100
        )

        # Should include cells and nets matching pattern
        assert len(results) == 5  # 4 cells + 1 net
        assert any(r.result_type == SearchResultType.CELL for r in results)
        assert any(r.result_type == SearchResultType.NET for r in results)

    def test_match_all_max_results_across_types(self, mock_design):
        matcher = PatternMatcher(mock_design)
        pattern = re.compile(".*", re.IGNORECASE)  # Match everything

        results = matcher.match_all(
            pattern,
            include_cells=True,
            include_nets=True,
            max_results=3  # Limit total results
        )

        assert len(results) <= 3
```

**Performance Tests** (`tests/performance/test_pattern_matcher_perf.py`):

```python
import time

def create_large_design(cell_count=10000, net_count=50000):
    """Create design with specified object counts"""
    design = Mock(spec=Design)

    design.cells = {
        f"cell_{i}": Mock(name=f"cell_{i}", id=f"cell_{i}")
        for i in range(cell_count)
    }

    design.nets = {
        f"net_{i}": Mock(name=f"net_{i}", id=f"net_{i}")
        for i in range(net_count)
    }

    design.ports = {}

    return design

def test_match_cells_performance():
    design = create_large_design(cell_count=10000)
    matcher = PatternMatcher(design)
    pattern = re.compile(".*cell_1.*", re.IGNORECASE)

    start = time.perf_counter()
    results = matcher.match_cells(pattern, max_results=100)
    duration = time.perf_counter() - start

    print(f"Matched {len(results)} cells in {duration*1000:.2f}ms")
    assert duration < 0.05  # <50ms

def test_match_nets_performance():
    design = create_large_design(net_count=50000)
    matcher = PatternMatcher(design)
    pattern = re.compile(".*net_1.*", re.IGNORECASE)

    start = time.perf_counter()
    results = matcher.match_nets(pattern, max_results=100)
    duration = time.perf_counter() - start

    print(f"Matched {len(results)} nets in {duration*1000:.2f}ms")
    assert duration < 0.1  # <100ms

def test_match_all_performance():
    design = create_large_design(cell_count=10000, net_count=50000)
    matcher = PatternMatcher(design)
    pattern = re.compile(".*_1.*", re.IGNORECASE)

    start = time.perf_counter()
    results = matcher.match_all(pattern, max_results=100)
    duration = time.perf_counter() - start

    print(f"Matched {len(results)} objects in {duration*1000:.2f}ms")
    assert duration < 0.1  # <100ms
```

### 3.3 Integration Points

**With E05-F03-T01 (Wildcard Parser)**:
- Receives compiled `Pattern[str]` objects from parser
- Uses `pattern.search()` to get match position
- Relies on case-insensitive and anchored pattern behavior

**With E05-F03-T03 (Search Service)**:
- Search service creates `PatternMatcher` instance with `Design`
- Calls `match_all()` with filters from UI
- Returns `List[SearchResult]` for display

**With Domain Model (E01)**:
- Depends on `Design` aggregate with collections: `cells`, `nets`, `ports`
- Cells must have `pins` collection
- All objects must have `name` and `id` attributes

---

## 4. Technical Deep Dive

### 4.1 Match Position Calculation

**Using `pattern.search()`**:

```python
pattern = re.compile("^.*clk.*$", re.IGNORECASE)

# "clk" - match at position 0
match = pattern.search("clk")
assert match.start() == 0

# "my_clk" - match at position 3
match = pattern.search("my_clk")
assert match.start() == 3

# "system_clk_div" - match at position 7
match = pattern.search("system_clk_div")
assert match.start() == 7
```

**Note**: With anchored patterns (`^...$`), `search()` behaves like `match()` but provides `.start()` method needed for relevance sorting.

### 4.2 Early Termination in Nested Loops

**Challenge**: Pin matching involves nested loops (cells → pins), need early termination at both levels.

**Implementation**:

```python
def match_pins(self, pattern: Pattern[str], max_results: int = 100) -> List[SearchResult]:
    results = []

    for cell in self.design.cells.values():
        for pin in cell.pins:
            qualified_name = f"{cell.name}.{pin.name}"
            match = pattern.search(qualified_name)
            if match:
                results.append(SearchResult(...))

                if len(results) >= max_results:
                    break  # Inner loop break

            if len(results) >= max_results:
                break  # Outer loop break

    return sorted(results)
```

**Alternative - Use exception for early exit**:

```python
class MaxResultsReached(Exception):
    pass

try:
    for cell in self.design.cells.values():
        for pin in cell.pins:
            # ... matching logic ...
            if len(results) >= max_results:
                raise MaxResultsReached()
except MaxResultsReached:
    pass

return sorted(results)
```

**Decision**: Use double break for MVP (clearer, simpler). Exception approach is more elegant but adds complexity.

### 4.3 Result Sorting Performance

**Challenge**: Sorting results adds overhead, especially for large result sets.

**Analysis**:

```python
# Worst case: max_results = 1000
# Sorting complexity: O(n log n) = O(1000 log 1000) ≈ 10,000 operations
# At ~100ns per comparison: 10,000 * 100ns = 1ms
```

**Conclusion**: Sorting overhead is negligible (< 1ms) for typical `max_results` values (100-1000).

**Future Optimization**: Use heap for top-K results if `max_results` << total matches.

### 4.4 Pin Count Estimation

**Typical Design Ratios**:

```
Design size: 10,000 cells
- Cells: 10,000
- Nets: ~30,000 (3x cells)
- Pins: ~100,000 (10x cells, avg 10 pins/cell)
- Ports: ~100 (fixed, design I/O)

Large design: 100,000 cells
- Cells: 100,000
- Nets: ~300,000
- Pins: ~1,000,000
- Ports: ~500
```

**Implication**: Pin searches are 10-100x more expensive than cell searches. Disabling by default is critical for performance.

---

## 5. Risk Analysis

### 5.1 Performance Degradation with Large Designs

**Risk**: Pattern matching on 100K+ cells/nets exceeds 100ms target.

**Impact**: High - Poor search responsiveness
**Probability**: Medium - Large designs are common in industry
**Mitigation**:
- Early termination with `max_results`
- Profile and optimize hot paths
- Consider background search with incremental results (P1)
- Add progress indicator for slow searches

**Monitoring**:
```python
@timed
def match_all(self, pattern, **kwargs):
    if len(self.design.cells) > 50000:
        logger.warning(f"Large design search: {len(self.design.cells)} cells")
    # ... matching logic ...
```

### 5.2 Pin Search Performance

**Risk**: Pin searches on large designs cause UI freeze.

**Impact**: High - Application unresponsive
**Probability**: High - Users may enable pin search without understanding cost
**Mitigation**:
- Pins disabled by default
- UI warning when enabling: "Pin search may be slow for large designs"
- Show estimated time based on pin count
- Consider limiting pin `max_results` to smaller value (e.g., 50)

### 5.3 Match Position Sorting Inconsistency

**Risk**: Ties in match position may produce inconsistent ordering.

**Impact**: Low - Confusing but not breaking
**Probability**: High - Many patterns match at position 0
**Mitigation**:
- Secondary sort by name (alphabetical)
- Ensures deterministic ordering
- Document sorting behavior

**Example**:
```python
# Pattern: "*clk*"
# Both "clk" and "clk_buf" match at position 0
# Sort by name: ["clk", "clk_buf"] (deterministic)
```

### 5.4 Qualified Pin Name Ambiguity

**Risk**: Cell or pin names containing `.` could cause confusion.

**Impact**: Low - Rare in practice
**Probability**: Low - Circuit naming conventions avoid `.` in names
**Mitigation**:
- Document qualified name format
- Consider escaping `.` in cell/pin names (future enhancement)
- For MVP, assume `.` is not used in names

**Example of Edge Case**:
```python
# Cell: "U.ALU", Pin: "D"
# Qualified: "U.ALU.D"
# Ambiguous: Could be cell "U" with pin "ALU.D"
# Solution: Escape dots -> "U\.ALU.D" (deferred to P1)
```

### 5.5 Memory Usage for Result Lists

**Risk**: Large result lists consume excessive memory.

**Impact**: Low - Bounded by `max_results`
**Probability**: Low - `max_results=100` limits memory
**Mitigation**:
- Hard limit on `max_results` (e.g., 1000 max)
- Early termination prevents unbounded growth
- Results are lightweight dataclasses

---

## 6. Definition of Done

### 6.1 Functionality Criteria

- [ ] `SearchResult` dataclass includes `match_position` field
- [ ] `SearchResult` implements `__lt__()` for sorting
- [ ] `SearchResultType` enum includes CELL, NET, PIN, PORT
- [ ] `PatternMatcher` class instantiated with `Design`
- [ ] `match_cells()` matches cells against pattern
- [ ] `match_nets()` matches nets against pattern
- [ ] `match_ports()` matches ports against pattern
- [ ] `match_pins()` matches pins with qualified names
- [ ] All methods return sorted results
- [ ] All methods respect `max_results` limit
- [ ] `match_all()` combines results from multiple types
- [ ] `match_all()` applies overall `max_results` limit
- [ ] Empty results handled correctly (return empty list)

### 6.2 Performance Criteria

- [ ] Search 10,000 cells in < 50ms
- [ ] Search 50,000 nets in < 100ms
- [ ] Combined search (all types) in < 100ms
- [ ] Early termination when `max_results` reached
- [ ] Sorting overhead < 1ms for `max_results=100`

### 6.3 Quality Criteria

**Test Coverage**:
- [ ] Unit test coverage >90% for `pattern_matcher.py`
- [ ] All methods tested independently
- [ ] Sorting behavior tested
- [ ] `max_results` limiting tested
- [ ] Combined matching tested
- [ ] Performance tests pass

**Code Quality**:
- [ ] Type hints on all methods
- [ ] Docstrings for all public methods
- [ ] No mypy errors
- [ ] No ruff linting errors

### 6.4 Integration Criteria

- [ ] Works with `Design` from domain model
- [ ] Accepts `Pattern[str]` from wildcard parser
- [ ] Returns `SearchResult` list usable by search service
- [ ] Compatible with search panel filters

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should `match_all()` interleave results from different types or concatenate?
**Answer**: Concatenate then sort. Simpler implementation, equivalent outcome after sorting.

**Q2**: Should we return total match count in addition to limited results?
**Answer**: Not for MVP. Can add `total_count` field in P1 if needed for "showing X of Y results" UI.

**Q3**: How to handle cells/nets with identical names?
**Answer**: Shouldn't happen (IDs are unique), but if it does, both are returned. Deduplication not needed.

**Q4**: Should pin search use separate `max_results` limit?
**Answer**: No for MVP. Use same limit but disable pins by default. Can add separate limit in P1.

### 7.2 UX Questions

**Q1**: How to communicate that results are limited?
**Answer**: Search panel shows "Showing 100 results (may be more)". Implementation in T03.

**Q2**: Should we highlight the matched portion of names?
**Answer**: Deferred to P1. Search panel can use `match_position` to highlight in future.

---

## 8. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/T02/E05-F03-T02.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/E05-F03.spec.md`
- **Upstream Task**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/T01/E05-F03-T01.spec.md`
- **Python dataclasses**: https://docs.python.org/3/library/dataclasses.html
- **Python sorting**: https://docs.python.org/3/howto/sorting.html

---

## 9. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
