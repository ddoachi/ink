---
id: E05-F03-T02
title: Pattern Matching Service
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F03
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Medium
tags:
  - search
  - application
  - pattern-matching
clickup_task_id: ''
---

# Spec: E05-F03-T02 - Pattern Matching Service

## 1. Overview

### 1.1 Problem Statement
Implement a pattern matching service that efficiently matches circuit objects (cells, nets, pins, ports) against compiled wildcard patterns. The service must iterate through indexed objects, apply pattern matching, and return sorted results within performance constraints.

### 1.2 Goals
- Match objects against compiled regex patterns efficiently
- Support filtering by object type (cells, nets, pins, ports)
- Sort results by relevance (match position in string)
- Apply result limits to prevent UI overload
- Maintain sub-100ms performance for pattern queries
- Provide clear result metadata (object type, match position)

---

## 2. Technical Requirements

### 2.1 SearchResult Data Structure

**Location**: `src/ink/application/queries/search_query.py`

**Extended Structure**:
```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional


class SearchResultType(Enum):
    """Type of search result object"""
    CELL = "CELL"
    NET = "NET"
    PIN = "PIN"
    PORT = "PORT"


@dataclass
class SearchResult:
    """Single search result with metadata"""
    name: str
    result_type: SearchResultType
    object_id: str  # Domain object identifier (CellId, NetId, etc.)
    match_position: int = 0  # Position of match (for relevance sorting)
    parent_name: Optional[str] = None  # For pins: parent cell name

    def __lt__(self, other: 'SearchResult') -> bool:
        """Sort by match position, then name"""
        if self.match_position != other.match_position:
            return self.match_position < other.match_position
        return self.name < other.name
```

### 2.2 Pattern Matcher Implementation

**Location**: `src/ink/infrastructure/search/pattern_matcher.py`

**Class Structure**:
```python
from typing import List, Pattern
import re

from ink.application.queries.search_query import SearchResult, SearchResultType
from ink.domain.model.design import Design


class PatternMatcher:
    """Match circuit objects against wildcard patterns"""

    def __init__(self, design: Design):
        """
        Initialize pattern matcher with design model.

        Args:
            design: Design aggregate root containing all circuit objects
        """
        self.design = design

    def match_cells(self, pattern: Pattern[str], max_results: int = 100) -> List[SearchResult]:
        """
        Match cells against pattern.

        Args:
            pattern: Compiled regex pattern
            max_results: Maximum number of results to return

        Returns:
            List of SearchResult objects sorted by match position
        """
        results = []

        for cell in self.design.cells.values():
            match = pattern.search(cell.name)
            if match:
                results.append(SearchResult(
                    name=cell.name,
                    result_type=SearchResultType.CELL,
                    object_id=str(cell.id),
                    match_position=match.start()
                ))

                if len(results) >= max_results:
                    break

        return sorted(results)

    def match_nets(self, pattern: Pattern[str], max_results: int = 100) -> List[SearchResult]:
        """
        Match nets against pattern.

        Args:
            pattern: Compiled regex pattern
            max_results: Maximum number of results to return

        Returns:
            List of SearchResult objects sorted by match position
        """
        results = []

        for net in self.design.nets.values():
            match = pattern.search(net.name)
            if match:
                results.append(SearchResult(
                    name=net.name,
                    result_type=SearchResultType.NET,
                    object_id=str(net.id),
                    match_position=match.start()
                ))

                if len(results) >= max_results:
                    break

        return sorted(results)

    def match_ports(self, pattern: Pattern[str], max_results: int = 100) -> List[SearchResult]:
        """
        Match ports against pattern.

        Args:
            pattern: Compiled regex pattern
            max_results: Maximum number of results to return

        Returns:
            List of SearchResult objects sorted by match position
        """
        results = []

        for port in self.design.ports.values():
            match = pattern.search(port.name)
            if match:
                results.append(SearchResult(
                    name=port.name,
                    result_type=SearchResultType.PORT,
                    object_id=str(port.id),
                    match_position=match.start()
                ))

                if len(results) >= max_results:
                    break

        return sorted(results)

    def match_pins(self, pattern: Pattern[str], max_results: int = 100) -> List[SearchResult]:
        """
        Match pins against pattern.

        Note: Pins are searched as "CELL.PIN" format for user convenience.

        Args:
            pattern: Compiled regex pattern
            max_results: Maximum number of results to return

        Returns:
            List of SearchResult objects sorted by match position
        """
        results = []

        for cell in self.design.cells.values():
            for pin in cell.pins:
                # Search in "CELL.PIN" format
                qualified_name = f"{cell.name}.{pin.name}"
                match = pattern.search(qualified_name)
                if match:
                    results.append(SearchResult(
                        name=qualified_name,
                        result_type=SearchResultType.PIN,
                        object_id=str(pin.id),
                        match_position=match.start(),
                        parent_name=cell.name
                    ))

                    if len(results) >= max_results:
                        break

            if len(results) >= max_results:
                break

        return sorted(results)

    def match_all(
        self,
        pattern: Pattern[str],
        include_cells: bool = True,
        include_nets: bool = True,
        include_ports: bool = True,
        include_pins: bool = False,  # Pins off by default (large result sets)
        max_results: int = 100
    ) -> List[SearchResult]:
        """
        Match all enabled object types against pattern.

        Args:
            pattern: Compiled regex pattern
            include_cells: Include cells in search
            include_nets: Include nets in search
            include_ports: Include ports in search
            include_pins: Include pins in search
            max_results: Maximum total results across all types

        Returns:
            Combined list of SearchResult objects sorted by match position
        """
        all_results = []

        if include_cells:
            all_results.extend(self.match_cells(pattern, max_results))

        if include_nets:
            all_results.extend(self.match_nets(pattern, max_results))

        if include_ports:
            all_results.extend(self.match_ports(pattern, max_results))

        if include_pins:
            all_results.extend(self.match_pins(pattern, max_results))

        # Sort combined results and apply limit
        sorted_results = sorted(all_results)
        return sorted_results[:max_results]
```

### 2.3 Match Position Relevance

**Why match position matters:**
- Earlier matches are more relevant (e.g., `clk_buf` better than `system_clk` for `*clk*`)
- Provides consistent ordering for identical patterns
- Helps users find exact matches faster

**Example sorting:**
```python
# Pattern: "*clk*"
# Unsorted results:
["system_clk", "clk", "clk_buffer", "my_clk"]

# After sorting by match_position:
["clk", "clk_buffer", "my_clk", "system_clk"]
#  ^0    ^0            ^3        ^7
```

---

## 3. Dependencies

### 3.1 Upstream
- Task E05-F03-T01: Uses compiled patterns from `WildcardParser`
- Domain model: `Design` aggregate with cells, nets, pins, ports

### 3.2 Downstream
- Task E05-F03-T03: Search service integrates pattern matcher

### 3.3 External Dependencies
- Python standard library: `re`, `typing`, `dataclasses`, `enum`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] Match cells by name against pattern
- [ ] Match nets by name against pattern
- [ ] Match ports by name against pattern
- [ ] Match pins by qualified name (`CELL.PIN` format)
- [ ] Sort results by match position (ascending)
- [ ] Apply max_results limit per object type
- [ ] Combine results from multiple types respecting overall limit
- [ ] Return empty list when no matches found

### 4.2 Result Quality
- [ ] Results include all required metadata (name, type, id, position)
- [ ] Match position is accurate (start index of match)
- [ ] Results are deterministic (same pattern â†’ same order)
- [ ] Pin results include parent cell name
- [ ] No duplicate results in combined searches

### 4.3 Performance
- [ ] Search 10,000 cells in < 50ms
- [ ] Search 50,000 nets in < 100ms
- [ ] Combined search (all types) in < 100ms
- [ ] Early termination when max_results reached

### 4.4 Testing
- [ ] Unit tests for each `match_*()` method
- [ ] Test result sorting by match position
- [ ] Test max_results limiting per type
- [ ] Test combined search with multiple types
- [ ] Test empty result cases
- [ ] Test pin qualified name matching
- [ ] Performance tests with large datasets
- [ ] 90%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why use `pattern.search()` instead of `pattern.match()`?**
- Pattern already anchored with `^` and `$` in T01
- `search()` provides match position via `match.start()`
- Match position needed for relevance sorting

**Why separate methods per object type?**
- Allows selective searching (user filters)
- Easier to test each type independently
- Clear max_results semantics per type
- Flexibility for future enhancements (type-specific ranking)

**Why qualified names for pins?**
- Thousands of pins share same name across cells
- `CELL.PIN` format provides context
- Matches user mental model (hierarchical)
- Enables searching for specific pin on specific cell

**Why pins disabled by default?**
- Pin count >> cell/net count (100x larger)
- Most searches target cells/nets
- Users can explicitly enable when needed
- Prevents UI overload from massive result sets

### 5.2 Performance Optimization

**Early termination:**
- Stop iterating when max_results reached
- Reduces unnecessary pattern matching
- Critical for large designs with millions of objects

**Linear iteration:**
- No index needed for wildcard patterns (can't optimize)
- Must check every object name
- max_results limit bounds worst-case time

**Future optimizations:**
- Prefix index for patterns like `U_ALU_*` (starts with literal)
- Suffix index for patterns like `*_clk` (ends with literal)
- Not needed for MVP (sub-100ms sufficient)

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/search/test_pattern_matcher.py`):
- Mock `Design` object with known test data
- Verify correct matches for various patterns
- Test result sorting
- Test max_results limiting

**Performance Tests**:
```python
def test_performance_large_design():
    # Create design with 10,000 cells
    design = create_test_design(cell_count=10000)
    matcher = PatternMatcher(design)

    pattern = re.compile(".*clk.*", re.IGNORECASE)
    start = time.perf_counter()
    results = matcher.match_cells(pattern, max_results=100)
    duration = time.perf_counter() - start

    assert duration < 0.05  # 50ms
    assert len(results) <= 100
```

**Integration Tests**:
- Test with real design loaded from CDL
- Verify all object types searchable
- End-to-end pattern matching workflow

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F03 split |
