# Spec: E05-F03-T01 - Wildcard Pattern Parser

## Metadata
- **ID**: E05-F03-T01
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E05-F03](../E05-F03.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Medium
- **Tags**: [search, infrastructure, pattern-matching]

---

## 1. Overview

### 1.1 Problem Statement
Implement a wildcard pattern parser that converts user-friendly wildcard patterns (using `*` and `?`) into compiled regex patterns for efficient matching. The parser must handle special regex characters, validate patterns, and provide clear error messages for invalid inputs.

### 1.2 Goals
- Convert wildcard `*` to regex `.*` (match any characters)
- Convert wildcard `?` to regex `.` (match single character)
- Escape regex special characters in literal text
- Compile patterns with case-insensitive flag
- Validate patterns and raise clear errors
- Cache compiled patterns for performance

---

## 2. Technical Requirements

### 2.1 WildcardParser Implementation

**Location**: `src/ink/infrastructure/search/wildcard_parser.py`

**Class Structure**:
```python
import re
from typing import Pattern


class PatternError(Exception):
    """Exception raised when wildcard pattern is invalid"""
    pass


class WildcardParser:
    """Convert wildcard patterns to compiled regex patterns"""

    # Regex special chars that need escaping (except * and ?)
    REGEX_SPECIAL_CHARS = r'\.[]{}()+^$|'

    @staticmethod
    def is_wildcard_pattern(query: str) -> bool:
        """
        Check if query contains wildcard characters.

        Args:
            query: User search query

        Returns:
            True if query contains * or ? wildcards
        """
        return '*' in query or '?' in query

    @staticmethod
    def parse(pattern: str) -> Pattern[str]:
        """
        Convert wildcard pattern to compiled regex.

        Algorithm:
        1. Validate pattern is not empty
        2. Escape regex special characters (except * and ?)
        3. Convert * to .* (any characters)
        4. Convert ? to . (single character)
        5. Compile with case-insensitive and anchored flags
        6. Return compiled pattern

        Args:
            pattern: User query with * and ? wildcards

        Returns:
            Compiled regex pattern (case-insensitive, anchored)

        Raises:
            PatternError: If pattern is invalid
        """
        # Validate pattern
        if not pattern:
            raise PatternError("Pattern cannot be empty")

        if pattern.strip() == '':
            raise PatternError("Pattern cannot be whitespace only")

        # Minimum length check for overly generic patterns
        if len(pattern.replace('*', '').replace('?', '').strip()) == 0:
            raise PatternError("Pattern must contain at least one literal character")

        # Escape special regex characters
        escaped = WildcardParser._escape_special_chars(pattern)

        # Convert wildcards to regex
        regex_pattern = escaped.replace(r'\*', '.*').replace(r'\?', '.')

        # Anchor pattern to match full string
        anchored_pattern = f'^{regex_pattern}$'

        # Compile with case-insensitive flag
        try:
            return re.compile(anchored_pattern, re.IGNORECASE)
        except re.error as e:
            raise PatternError(f"Invalid regex pattern: {e}") from e

    @staticmethod
    def _escape_special_chars(pattern: str) -> str:
        """
        Escape regex special characters except * and ?.

        This allows * and ? to be converted to wildcards while
        ensuring literal characters like . [ ] { } + etc. are escaped.

        Args:
            pattern: Raw user pattern

        Returns:
            Pattern with special regex chars escaped
        """
        result = []
        for char in pattern:
            if char in WildcardParser.REGEX_SPECIAL_CHARS:
                result.append('\\' + char)
            elif char in ('*', '?'):
                # Temporarily escape wildcards to prevent re.escape from touching them
                result.append('\\' + char)
            else:
                result.append(char)
        return ''.join(result)
```

### 2.2 Pattern Cache Implementation

**Location**: `src/ink/infrastructure/search/pattern_cache.py`

**Class Structure**:
```python
from typing import Dict, Pattern
from ink.infrastructure.search.wildcard_parser import WildcardParser


class PatternCache:
    """Cache compiled regex patterns for performance"""

    _cache: Dict[str, Pattern[str]] = {}
    _max_cache_size: int = 100

    @classmethod
    def get_pattern(cls, wildcard: str) -> Pattern[str]:
        """
        Get cached pattern or compile new one.

        Args:
            wildcard: Wildcard pattern string

        Returns:
            Compiled regex pattern

        Raises:
            PatternError: If pattern is invalid
        """
        if wildcard not in cls._cache:
            # Check cache size limit
            if len(cls._cache) >= cls._max_cache_size:
                # Clear oldest half of cache (simple LRU approximation)
                cls._cache.clear()

            cls._cache[wildcard] = WildcardParser.parse(wildcard)

        return cls._cache[wildcard]

    @classmethod
    def clear(cls) -> None:
        """Clear all cached patterns"""
        cls._cache.clear()

    @classmethod
    def size(cls) -> int:
        """Get current cache size"""
        return len(cls._cache)
```

### 2.3 Pattern Conversion Examples

| Wildcard Pattern | Escaped | Regex | Matches | Doesn't Match |
|-----------------|---------|-------|---------|---------------|
| `*clk*` | `\*clk\*` | `^.*clk.*$` | `clk`, `clk_buf`, `my_clk` | `CLK2` (no) |
| `U_ALU_*` | `U_ALU_\*` | `^U_ALU_.*$` | `U_ALU_1`, `U_ALU_reg` | `U_MEM_1` |
| `data_?` | `data_\?` | `^data_.$` | `data_0`, `data_a` | `data_10` (too long) |
| `data_??` | `data_\?\?` | `^data_..$` | `data_00`, `data_ab` | `data_0` (too short) |
| `net[0]` | `net\[0\]` | `^net\[0\]$` | `net[0]` | `net0` |
| `net.0` | `net\.0` | `^net\.0$` | `net.0` | `net_0` |
| `*_?_*` | `\*_\?_\*` | `^.*_..*$` | `a_b_c`, `clk_1_buf` | `a_b` |

### 2.4 Error Cases

```python
# Invalid patterns that should raise PatternError
""                  # Empty string
"   "               # Whitespace only
"***"               # No literal characters
"???"               # No literal characters
"*?*"               # No literal characters
```

---

## 3. Dependencies

### 3.1 Upstream
- Python standard library: `re`, `typing`

### 3.2 Downstream
- Task E05-F03-T02: Pattern matcher uses compiled patterns from parser
- Task E05-F03-T03: Search integration uses pattern cache

### 3.3 External Dependencies
- None (standard library only)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `*` wildcard converts to `.*` regex
- [ ] `?` wildcard converts to `.` regex
- [ ] Regex special characters are escaped (`.`, `[`, `]`, `{`, `}`, `+`, `^`, `$`, `|`)
- [ ] Patterns are anchored with `^` and `$` for full-string matching
- [ ] Case-insensitive matching is enabled via `re.IGNORECASE`
- [ ] Empty patterns raise `PatternError`
- [ ] Patterns with only wildcards (no literals) raise `PatternError`
- [ ] Pattern cache stores and retrieves compiled patterns correctly

### 4.2 Pattern Examples Work
- [ ] `*clk*` matches `clk`, `my_clk`, `system_clk_div`
- [ ] `U_*_?` matches `U_ALU_1`, `U_MEM_A`
- [ ] `net[0]` matches literal `net[0]` (brackets escaped)
- [ ] `data.0` matches literal `data.0` (dot escaped)

### 4.3 Error Handling
- [ ] Empty string raises `PatternError` with message "Pattern cannot be empty"
- [ ] Whitespace-only raises `PatternError` with message "Pattern cannot be whitespace only"
- [ ] No literal chars raises `PatternError` with message "Pattern must contain at least one literal character"
- [ ] Invalid regex raises `PatternError` with underlying `re.error` message

### 4.4 Performance
- [ ] Pattern compilation completes in < 1ms
- [ ] Cache retrieval completes in < 0.1ms
- [ ] Cache handles 100+ unique patterns without memory issues
- [ ] Cache clearing works correctly

### 4.5 Testing
- [ ] Unit tests for `is_wildcard_pattern()` with various inputs
- [ ] Unit tests for `parse()` with valid patterns
- [ ] Unit tests for `_escape_special_chars()` with special characters
- [ ] Error handling tests for each error condition
- [ ] Pattern matching tests with compiled patterns
- [ ] Cache hit/miss tests
- [ ] 95%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why anchor patterns with `^` and `$`?**
- Full-string matching prevents unexpected partial matches
- `*clk*` should match `my_clk` but searching for `my_clk` should find exact match
- Consistent with user expectations for search

**Why case-insensitive matching?**
- Circuit names often use mixed case conventions
- Users shouldn't need to remember exact casing
- Consistent with typical search behavior

**Why escape wildcards then convert?**
- Prevents `re.escape()` from escaping wildcards
- Gives precise control over what gets escaped
- Makes code intent clearer

**Why cache patterns?**
- Regex compilation has overhead
- Users often repeat similar searches
- Simple dict cache is sufficient (no need for LRU library)

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/search/test_wildcard_parser.py`):
- Test each method in isolation
- Verify correct regex output for known patterns
- Test all error conditions
- Test edge cases (empty, whitespace, special chars)

**Pattern Matching Tests**:
```python
def test_pattern_matching():
    pattern = WildcardParser.parse("*clk*")
    assert pattern.match("clk")
    assert pattern.match("my_clk")
    assert pattern.match("system_clk_div")
    assert not pattern.match("clock")  # No 'clk' substring
```

**Cache Tests** (`tests/unit/infrastructure/search/test_pattern_cache.py`):
- Test cache hit/miss
- Test cache size limit
- Test cache clearing
- Verify same pattern returns same compiled object (identity check)

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F03 split |
