# E05-F03-T01 - Wildcard Pattern Parser: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F03-T01 - Wildcard Pattern Parser
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements a wildcard pattern parser that converts user-friendly wildcard patterns (using `*` and `?`) into compiled regex patterns for efficient matching against circuit object names. The parser must handle special regex characters, validate patterns, and provide clear error messages for invalid inputs. Additionally, a pattern cache will be implemented to avoid recompiling frequently used patterns.

### 1.2 Core Capabilities

The task delivers two primary components:

1. **WildcardParser**: Converts wildcard patterns to compiled regex patterns with proper escaping and validation
2. **PatternCache**: Caches compiled patterns for performance optimization

### 1.3 Success Metrics

- Pattern compilation completes in < 1ms
- Cache retrieval completes in < 0.1ms
- All special regex characters properly escaped
- Clear error messages for invalid patterns
- 95%+ code coverage

---

## 2. Architecture Decisions

### 2.1 Pattern Anchoring Strategy

**Decision**: Anchor all patterns with `^` and `$` for full-string matching.

**Rationale**:
- Prevents unexpected partial matches (e.g., `*clk*` shouldn't match `clock`)
- Provides predictable search behavior consistent with user expectations
- Aligns with how circuit names are typically searched (exact object identification)

**Alternatives Considered**:
- **Unanchored patterns**: Rejected - would cause confusion when `*clk*` matches within longer strings
- **Optional anchoring**: Rejected - adds complexity without clear benefit for MVP

**Trade-offs**:
- **Pro**: Predictable, consistent behavior
- **Pro**: Easier to explain to users
- **Con**: Requires users to explicitly add `*` for substring matching
- **Mitigation**: Document this behavior and provide examples

### 2.2 Case Sensitivity

**Decision**: All patterns are case-insensitive (`re.IGNORECASE` flag).

**Rationale**:
- Circuit names often use mixed case conventions (e.g., `U_ALU_1`, `u_alu_1`)
- Users shouldn't need to remember exact casing
- Consistent with typical search behavior in engineering tools
- Simplifies user experience

**Alternatives Considered**:
- **Case-sensitive by default**: Rejected - too restrictive for typical use cases
- **User-configurable**: Deferred to P1 - adds UI complexity for minimal benefit

**Implementation**:
```python
return re.compile(anchored_pattern, re.IGNORECASE)
```

### 2.3 Special Character Escaping

**Decision**: Escape all regex special characters except `*` and `?`, then convert wildcards to regex.

**Rationale**:
- Prevents regex metacharacters in circuit names from breaking patterns
- Circuit names often contain special characters like `.`, `[`, `]`, `{`, `}` (e.g., `net[0]`, `clk.div`)
- Two-phase approach (escape â†’ convert) is clearer than trying to do both simultaneously

**Algorithm**:
```python
def _escape_special_chars(pattern: str) -> str:
    """Escape special regex chars except * and ?"""
    result = []
    for char in pattern:
        if char in r'\.[]{}()+^$|':
            result.append('\\' + char)
        elif char in ('*', '?'):
            result.append('\\' + char)  # Temporarily escape
        else:
            result.append(char)
    return ''.join(result)

# Then convert: escaped.replace(r'\*', '.*').replace(r'\?', '.')
```

**Alternatives Considered**:
- **Use `re.escape()` then un-escape wildcards**: Rejected - less clear, potential bugs
- **Custom regex parser**: Over-engineered for MVP

### 2.4 Pattern Validation

**Decision**: Reject patterns with no literal characters (e.g., `***`, `???`, `*?*`).

**Rationale**:
- Patterns with no literals would match everything
- Forces users to provide meaningful search constraints
- Prevents performance issues from overly broad queries
- Improves result quality

**Validation Rules**:
1. Pattern cannot be empty string
2. Pattern cannot be whitespace only
3. Pattern must contain at least one non-wildcard character

**Error Messages**:
```python
if not pattern:
    raise PatternError("Pattern cannot be empty")

if pattern.strip() == '':
    raise PatternError("Pattern cannot be whitespace only")

if len(pattern.replace('*', '').replace('?', '').strip()) == 0:
    raise PatternError("Pattern must contain at least one literal character")
```

### 2.5 Pattern Caching Strategy

**Decision**: Implement class-based cache with simple dictionary and size limit.

**Rationale**:
- Regex compilation has measurable overhead (~0.1-1ms)
- Users often repeat similar searches during analysis sessions
- Simple dict-based LRU approximation is sufficient for MVP
- Avoids dependency on external caching libraries

**Cache Design**:
- Class variable stores cache dictionary
- Max cache size of 100 patterns (configurable)
- Simple eviction: clear entire cache when limit reached
- No need for true LRU tracking (overkill for MVP)

**Implementation**:
```python
class PatternCache:
    _cache: Dict[str, Pattern[str]] = {}
    _max_cache_size: int = 100

    @classmethod
    def get_pattern(cls, wildcard: str) -> Pattern[str]:
        if wildcard not in cls._cache:
            if len(cls._cache) >= cls._max_cache_size:
                cls._cache.clear()  # Simple eviction
            cls._cache[wildcard] = WildcardParser.parse(wildcard)
        return cls._cache[wildcard]
```

**Alternatives Considered**:
- **functools.lru_cache**: Rejected - harder to test, less control
- **True LRU with access tracking**: Over-engineered for MVP
- **No caching**: Rejected - measurable performance impact

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: Core Parser (2 hours)**
- Implement `WildcardParser` class
- Implement `is_wildcard_pattern()` detection method
- Implement `_escape_special_chars()` helper
- Implement `parse()` method with basic validation
- Unit tests for each method

**Phase 2: Validation and Errors (1 hour)**
- Add comprehensive pattern validation
- Implement `PatternError` exception
- Add error messages for all validation failures
- Unit tests for error cases

**Phase 3: Pattern Cache (1 hour)**
- Implement `PatternCache` class
- Add cache hit/miss logic
- Add cache clearing and size management
- Unit tests for cache behavior

**Phase 4: Integration Testing (30 minutes)**
- Test pattern matching with compiled patterns
- Test all example patterns from spec
- Performance testing
- Edge case testing

### 3.2 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/search/test_wildcard_parser.py`):

```python
class TestWildcardParser:
    def test_is_wildcard_pattern_with_asterisk(self):
        assert WildcardParser.is_wildcard_pattern("*clk*")
        assert WildcardParser.is_wildcard_pattern("net*")

    def test_is_wildcard_pattern_with_question_mark(self):
        assert WildcardParser.is_wildcard_pattern("data_?")
        assert WildcardParser.is_wildcard_pattern("u_???_1")

    def test_is_wildcard_pattern_without_wildcards(self):
        assert not WildcardParser.is_wildcard_pattern("my_net")
        assert not WildcardParser.is_wildcard_pattern("U_ALU_1")

    def test_parse_asterisk_wildcard(self):
        pattern = WildcardParser.parse("*clk*")
        assert pattern.match("clk")
        assert pattern.match("my_clk")
        assert pattern.match("system_clk_div")
        assert not pattern.match("clock")

    def test_parse_question_mark_wildcard(self):
        pattern = WildcardParser.parse("data_?")
        assert pattern.match("data_0")
        assert pattern.match("data_a")
        assert not pattern.match("data_10")  # Too long

    def test_parse_escapes_special_chars(self):
        pattern = WildcardParser.parse("net[0]")
        assert pattern.match("net[0]")
        assert not pattern.match("net0")

        pattern = WildcardParser.parse("clk.div")
        assert pattern.match("clk.div")
        assert not pattern.match("clk_div")

    def test_parse_case_insensitive(self):
        pattern = WildcardParser.parse("*CLK*")
        assert pattern.match("clk")
        assert pattern.match("CLK")
        assert pattern.match("Clk")
        assert pattern.match("my_clk_buf")

    def test_parse_empty_pattern_raises_error(self):
        with pytest.raises(PatternError, match="Pattern cannot be empty"):
            WildcardParser.parse("")

    def test_parse_whitespace_pattern_raises_error(self):
        with pytest.raises(PatternError, match="Pattern cannot be whitespace only"):
            WildcardParser.parse("   ")

    def test_parse_no_literals_raises_error(self):
        with pytest.raises(PatternError, match="Pattern must contain at least one literal character"):
            WildcardParser.parse("***")

        with pytest.raises(PatternError, match="Pattern must contain at least one literal character"):
            WildcardParser.parse("???")

        with pytest.raises(PatternError, match="Pattern must contain at least one literal character"):
            WildcardParser.parse("*?*")

    def test_escape_special_chars(self):
        result = WildcardParser._escape_special_chars("net[0].value")
        assert r"\[" in result
        assert r"\." in result
        assert r"\]" in result
```

**Cache Tests** (`tests/unit/infrastructure/search/test_pattern_cache.py`):

```python
class TestPatternCache:
    def setup_method(self):
        PatternCache.clear()

    def test_cache_stores_patterns(self):
        pattern1 = PatternCache.get_pattern("*clk*")
        pattern2 = PatternCache.get_pattern("*clk*")
        assert pattern1 is pattern2  # Same object

    def test_cache_size(self):
        assert PatternCache.size() == 0
        PatternCache.get_pattern("*clk*")
        assert PatternCache.size() == 1

    def test_cache_clear(self):
        PatternCache.get_pattern("*clk*")
        PatternCache.get_pattern("*data*")
        assert PatternCache.size() == 2

        PatternCache.clear()
        assert PatternCache.size() == 0

    def test_cache_eviction_at_limit(self):
        # Fill cache to limit
        for i in range(100):
            PatternCache.get_pattern(f"*pattern_{i}*")

        assert PatternCache.size() == 100

        # Adding one more should clear cache
        PatternCache.get_pattern("*new_pattern*")
        assert PatternCache.size() == 1  # Only new pattern remains
```

**Pattern Matching Tests**:

```python
def test_pattern_matching_examples():
    """Test all examples from spec"""

    # *clk*
    pattern = WildcardParser.parse("*clk*")
    assert pattern.match("clk")
    assert pattern.match("clk_buf")
    assert pattern.match("my_clk")
    assert pattern.match("system_clk_div")

    # U_ALU_*
    pattern = WildcardParser.parse("U_ALU_*")
    assert pattern.match("U_ALU_1")
    assert pattern.match("U_ALU_reg")
    assert not pattern.match("U_MEM_1")

    # data_?
    pattern = WildcardParser.parse("data_?")
    assert pattern.match("data_0")
    assert pattern.match("data_a")
    assert not pattern.match("data_10")

    # data_??
    pattern = WildcardParser.parse("data_??")
    assert pattern.match("data_00")
    assert pattern.match("data_ab")
    assert not pattern.match("data_0")

    # net[0]
    pattern = WildcardParser.parse("net[0]")
    assert pattern.match("net[0]")
    assert not pattern.match("net0")

    # net.0
    pattern = WildcardParser.parse("net.0")
    assert pattern.match("net.0")
    assert not pattern.match("net_0")

    # *_?_*
    pattern = WildcardParser.parse("*_?_*")
    assert pattern.match("a_b_c")
    assert pattern.match("clk_1_buf")
    assert not pattern.match("a_b")
```

**Performance Tests**:

```python
import time

def test_parse_performance():
    """Pattern compilation should be fast"""
    patterns = ["*clk*", "U_*_?", "data_??", "net[*]"]

    start = time.perf_counter()
    for pattern in patterns * 100:
        WildcardParser.parse(pattern)
    duration = time.perf_counter() - start

    avg_time = duration / (len(patterns) * 100)
    assert avg_time < 0.001  # <1ms per pattern

def test_cache_performance():
    """Cache retrieval should be very fast"""
    pattern = "*clk*"
    PatternCache.get_pattern(pattern)  # Warm cache

    start = time.perf_counter()
    for _ in range(1000):
        PatternCache.get_pattern(pattern)
    duration = time.perf_counter() - start

    avg_time = duration / 1000
    assert avg_time < 0.0001  # <0.1ms per retrieval
```

### 3.3 Integration Points

**With E05-F03-T02 (Pattern Matcher)**:
- Pattern matcher receives compiled patterns from `WildcardParser.parse()`
- Uses `Pattern[str]` interface for matching
- Relies on case-insensitive and anchored behavior

**With E05-F03-T03 (Search Service)**:
- Search service uses `WildcardParser.is_wildcard_pattern()` for query routing
- Search service uses `PatternCache.get_pattern()` for compilation
- `PatternError` propagates as `SearchError` with user-friendly message

---

## 4. Technical Deep Dive

### 4.1 Regex Pattern Construction

**Two-Phase Approach**:

Phase 1 - Escape special characters:
```python
# Input:  "net[0]*"
# Output: "net\[0\]\*"
#              ^  ^ ^  <- escaped characters
```

Phase 2 - Convert wildcards:
```python
# Input:  "net\[0\]\*"
# Output: "net\[0\].*"
#                  ^^  <- wildcard converted
```

Phase 3 - Anchor and compile:
```python
# Input:  "net\[0\].*"
# Output: "^net\[0\].*$"
# Compile with re.IGNORECASE
```

**Character Classification**:

```python
REGEX_SPECIAL_CHARS = r'\.[]{}()+^$|'  # Must escape
WILDCARD_CHARS = '*?'                   # Convert to regex
LITERAL_CHARS = everything else         # No change
```

### 4.2 Edge Case Handling

**Empty Patterns**:
```python
# Input: ""
# Error: PatternError("Pattern cannot be empty")
```

**Whitespace-Only Patterns**:
```python
# Input: "   "
# Error: PatternError("Pattern cannot be whitespace only")
```

**No Literal Characters**:
```python
# Input: "***", "???", "*?*", "  *  "
# All fail with: PatternError("Pattern must contain at least one literal character")
```

**Special Character Combinations**:
```python
# Input: "net[*]"  -> matches net[anything]
# Regex: ^net\[.*\]$

# Input: "clk.?"   -> matches clk.X (single char after dot)
# Regex: ^clk\..$
```

### 4.3 Cache Eviction Strategy

**Simple Eviction (MVP)**:
```python
if len(cls._cache) >= cls._max_cache_size:
    cls._cache.clear()  # Clear entire cache
```

**Why This Works**:
- Cache typically stays well below limit (users search 10-20 unique patterns per session)
- When limit is reached, clearing entire cache is acceptable (rare event)
- Next searches will repopulate cache with current patterns
- Avoids complexity of tracking access order

**Future Optimization (Post-MVP)**:
```python
# True LRU: track access order, evict least recently used
from collections import OrderedDict

class PatternCache:
    _cache: OrderedDict[str, Pattern[str]] = OrderedDict()

    @classmethod
    def get_pattern(cls, wildcard: str) -> Pattern[str]:
        if wildcard in cls._cache:
            cls._cache.move_to_end(wildcard)  # Mark as recently used
            return cls._cache[wildcard]

        if len(cls._cache) >= cls._max_cache_size:
            cls._cache.popitem(last=False)  # Evict oldest

        cls._cache[wildcard] = WildcardParser.parse(wildcard)
        return cls._cache[wildcard]
```

---

## 5. Risk Analysis

### 5.1 Regex Compilation Performance

**Risk**: Complex patterns or large cache could impact performance.

**Impact**: Medium - Slow search responsiveness
**Probability**: Low - Patterns are simple, cache is small
**Mitigation**:
- Performance tests enforce < 1ms compilation time
- Cache limits memory usage
- Monitor cache hit rate in production

### 5.2 Wildcard Interpretation Confusion

**Risk**: Users may not understand wildcard behavior (especially anchoring).

**Impact**: Low - User confusion, unexpected results
**Probability**: Medium - Common UX issue with pattern matching
**Mitigation**:
- Clear documentation with examples
- Error messages include examples of valid patterns
- Search panel includes wildcard syntax help tooltip

### 5.3 Special Character Escaping Bugs

**Risk**: Missing or incorrect escaping of regex special characters.

**Impact**: High - Pattern matching failures, potential regex injection
**Probability**: Low - Well-tested implementation
**Mitigation**:
- Comprehensive unit tests for all special characters
- Test with real circuit names containing special chars
- Code review focusing on escaping logic

### 5.4 Cache Memory Growth

**Risk**: Cache grows unbounded, consuming memory.

**Impact**: Medium - Memory exhaustion in long sessions
**Probability**: Low - Cache limited to 100 patterns
**Mitigation**:
- Hard limit enforced (100 patterns)
- Cache clearing functionality
- Monitor cache size in tests

---

## 6. Definition of Done

### 6.1 Functionality Criteria

- [ ] `WildcardParser.is_wildcard_pattern()` detects `*` and `?` correctly
- [ ] `WildcardParser.parse()` converts wildcards to regex
- [ ] `*` converts to `.*` (match any characters)
- [ ] `?` converts to `.` (match single character)
- [ ] All regex special characters escaped correctly
- [ ] Patterns anchored with `^` and `$`
- [ ] Case-insensitive matching enabled
- [ ] Empty patterns raise `PatternError`
- [ ] Whitespace-only patterns raise `PatternError`
- [ ] No-literal-character patterns raise `PatternError`
- [ ] `PatternCache.get_pattern()` stores and retrieves patterns
- [ ] Cache eviction works at size limit
- [ ] Cache clearing works

### 6.2 Performance Criteria

- [ ] Pattern compilation completes in < 1ms
- [ ] Cache retrieval completes in < 0.1ms
- [ ] Cache handles 100+ unique patterns
- [ ] No memory leaks detected

### 6.3 Quality Criteria

**Test Coverage**:
- [ ] Unit test coverage >95% for `wildcard_parser.py`
- [ ] Unit test coverage >95% for `pattern_cache.py`
- [ ] All example patterns from spec tested
- [ ] All error cases tested
- [ ] Performance tests pass

**Code Quality**:
- [ ] Type hints on all methods
- [ ] Docstrings for all public methods
- [ ] No mypy errors
- [ ] No ruff linting errors

### 6.4 Documentation Criteria

- [ ] Docstrings explain pattern syntax
- [ ] Error messages are clear and actionable
- [ ] Code comments explain escaping logic
- [ ] Examples in docstrings

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should cache be global (class variable) or instance-based?
**Answer**: Global class variable is simpler and sufficient for MVP. Single search service instance doesn't benefit from instance-level caching.

**Q2**: Should we support escaping wildcards (literal `*` or `?`)?
**Answer**: Not for MVP. Circuit names rarely contain literal `*` or `?`. Can add in P1 with backslash escaping if needed.

**Q3**: What's the max reasonable pattern length?
**Answer**: No explicit limit for MVP. Regex compilation will fail naturally for pathological cases. Can add length validation if issues arise.

### 7.2 UX Questions

**Q1**: Should we warn users about very broad patterns?
**Answer**: No warning at parsing stage. Pattern matcher (T02) will handle result limiting.

**Q2**: Should error messages include examples?
**Answer**: Yes, for empty pattern error: "Pattern cannot be empty. Example: `*clk*`, `U_ALU_*`"

---

## 8. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/T01/E05-F03-T01.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/E05-F03.spec.md`
- **Python re module**: https://docs.python.org/3/library/re.html
- **Regex escaping**: https://docs.python.org/3/library/re.html#re.escape

---

## 9. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
