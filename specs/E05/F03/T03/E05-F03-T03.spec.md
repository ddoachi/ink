# Spec: E05-F03-T03 - Search Service Integration

## Metadata
- **ID**: E05-F03-T03
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E05-F03](../E05-F03.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 3
- **Actual Hours**:
- **Effort**: Low
- **Tags**: [search, application, integration]

---

## 1. Overview

### 1.1 Problem Statement
Integrate wildcard pattern matching into the existing search service to provide unified search functionality supporting both exact matches and wildcard patterns. The service must automatically detect pattern queries, route to appropriate matching logic, and maintain consistent API for search panel UI.

### 1.2 Goals
- Extend `SearchService` to support wildcard patterns
- Auto-detect wildcard queries vs exact matches
- Route to pattern matcher or exact search based on query type
- Use pattern cache for performance
- Maintain backward compatibility with existing search API
- Provide consistent error handling across search types

---

## 2. Technical Requirements

### 2.1 SearchFilters Extension

**Location**: `src/ink/application/queries/search_query.py`

**Extended Structure**:
```python
from dataclasses import dataclass


@dataclass
class SearchFilters:
    """Filters for search queries"""
    include_cells: bool = True
    include_nets: bool = True
    include_ports: bool = True
    include_pins: bool = False
    max_results: int = 100
    case_sensitive: bool = False  # Wildcard patterns always case-insensitive
```

### 2.2 SearchService Integration

**Location**: `src/ink/application/services/search_service.py`

**Enhanced Implementation**:
```python
from typing import List

from ink.application.queries.search_query import SearchResult, SearchFilters
from ink.domain.model.design import Design
from ink.infrastructure.search.wildcard_parser import WildcardParser, PatternError
from ink.infrastructure.search.pattern_cache import PatternCache
from ink.infrastructure.search.pattern_matcher import PatternMatcher


class SearchError(Exception):
    """Exception raised when search fails"""
    pass


class SearchService:
    """Application service for searching circuit objects"""

    def __init__(self, design: Design):
        """
        Initialize search service.

        Args:
            design: Design aggregate root
        """
        self.design = design
        self.pattern_matcher = PatternMatcher(design)
        # self.exact_matcher = ExactMatcher(design)  # From E05-F02

    def search(self, query: str, filters: SearchFilters) -> List[SearchResult]:
        """
        Execute search query with automatic pattern detection.

        This is the main entry point for all search operations.
        Automatically detects wildcard patterns and routes to
        appropriate matching strategy.

        Args:
            query: Search query string (may contain wildcards)
            filters: Search filters for result filtering

        Returns:
            List of SearchResult objects sorted by relevance

        Raises:
            SearchError: If search fails or pattern is invalid
        """
        # Validate query
        if not query:
            raise SearchError("Search query cannot be empty")

        query = query.strip()
        if not query:
            raise SearchError("Search query cannot be whitespace only")

        # Detect query type and route to appropriate matcher
        if WildcardParser.is_wildcard_pattern(query):
            return self._search_with_pattern(query, filters)
        else:
            return self._search_exact(query, filters)

    def _search_with_pattern(self, pattern: str, filters: SearchFilters) -> List[SearchResult]:
        """
        Execute wildcard pattern search.

        Args:
            pattern: Wildcard pattern string
            filters: Search filters

        Returns:
            List of SearchResult objects sorted by match position

        Raises:
            SearchError: If pattern is invalid
        """
        try:
            # Get cached compiled pattern
            compiled_pattern = PatternCache.get_pattern(pattern)

            # Execute pattern matching
            results = self.pattern_matcher.match_all(
                pattern=compiled_pattern,
                include_cells=filters.include_cells,
                include_nets=filters.include_nets,
                include_ports=filters.include_ports,
                include_pins=filters.include_pins,
                max_results=filters.max_results
            )

            return results

        except PatternError as e:
            raise SearchError(f"Invalid search pattern: {e}") from e

    def _search_exact(self, query: str, filters: SearchFilters) -> List[SearchResult]:
        """
        Execute exact match search.

        This method will be implemented in E05-F02 (Search Engine).
        For now, provide a placeholder implementation.

        Args:
            query: Exact search query
            filters: Search filters

        Returns:
            List of SearchResult objects

        Raises:
            NotImplementedError: Until E05-F02 is implemented
        """
        # TODO: Implement exact search in E05-F02
        # return self.exact_matcher.search(query, filters)
        raise NotImplementedError("Exact search not yet implemented (see E05-F02)")

    def clear_cache(self) -> None:
        """Clear pattern cache (useful for testing or memory management)"""
        PatternCache.clear()
```

### 2.3 Search API Usage Examples

```python
# Example 1: Wildcard pattern search
search_service = SearchService(design)
filters = SearchFilters(include_cells=True, include_nets=True, max_results=50)

# Auto-detected as pattern search
results = search_service.search("*clk*", filters)
for result in results:
    print(f"{result.result_type.value}: {result.name}")

# Example 2: Exact search (when implemented)
results = search_service.search("U_ALU_1", filters)

# Example 3: Pin search with wildcard
pin_filters = SearchFilters(include_pins=True, include_cells=False, include_nets=False)
results = search_service.search("U_ALU_*.D", pin_filters)

# Example 4: Error handling
try:
    results = search_service.search("***", filters)  # Invalid pattern
except SearchError as e:
    print(f"Search failed: {e}")
```

### 2.4 Integration with Search Panel UI

**Location**: `src/ink/presentation/panels/search_panel.py` (from E05-F01)

**Integration Points**:
```python
class SearchPanel(QWidget):
    """Search panel UI component"""

    def _execute_search(self):
        """Execute search when user presses Enter or clicks search button"""
        query = self.search_input.text().strip()

        if not query:
            self._clear_results()
            return

        try:
            # Build filters from UI checkboxes
            filters = SearchFilters(
                include_cells=self.cells_checkbox.isChecked(),
                include_nets=self.nets_checkbox.isChecked(),
                include_ports=self.ports_checkbox.isChecked(),
                include_pins=self.pins_checkbox.isChecked(),
                max_results=100
            )

            # Execute search via service
            results = self.search_service.search(query, filters)

            # Display results in UI
            self._display_results(results)

        except SearchError as e:
            # Show error message to user
            self._show_error(str(e))
```

---

## 3. Dependencies

### 3.1 Upstream
- Task E05-F03-T01: Uses `WildcardParser` and `PatternCache`
- Task E05-F03-T02: Uses `PatternMatcher` for object matching
- E05-F02: Will provide exact search implementation (placeholder for now)

### 3.2 Downstream
- E05-F01: Search panel UI uses `SearchService.search()` API
- E05-F04: Search result navigation uses `SearchResult` objects

### 3.3 External Dependencies
- None (uses components from T01 and T02)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `search()` method automatically detects wildcard patterns
- [ ] Wildcard patterns route to `_search_with_pattern()`
- [ ] Non-wildcard queries route to `_search_exact()` (placeholder)
- [ ] Pattern cache used for compiled patterns
- [ ] Search filters applied correctly to pattern matching
- [ ] Empty query raises `SearchError`
- [ ] Invalid pattern raises `SearchError` with clear message
- [ ] Results returned in sorted order (by match position)

### 4.2 API Consistency
- [ ] Same `search()` signature for both exact and pattern searches
- [ ] Same `SearchResult` structure returned for all search types
- [ ] Same error handling (`SearchError`) for all search failures
- [ ] Filters applied consistently across search types

### 4.3 Performance
- [ ] Pattern search completes in < 100ms for typical queries
- [ ] Cache hit avoids recompilation overhead
- [ ] No performance regression vs future exact search

### 4.4 Integration
- [ ] Search panel UI calls `SearchService.search()` successfully
- [ ] Results display correctly in search panel
- [ ] Error messages shown to user via UI
- [ ] Filter checkboxes control result types

### 4.5 Testing
- [ ] Unit tests for `search()` routing logic
- [ ] Unit tests for `_search_with_pattern()`
- [ ] Error handling tests for invalid patterns
- [ ] Integration tests with search panel UI
- [ ] End-to-end search workflow tests
- [ ] 90%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why auto-detect pattern vs exact search?**
- Simplifies UI (no mode toggle needed)
- Natural user experience (just type wildcards)
- Single entry point for all searches
- Easy to extend with other query types (regex, fuzzy)

**Why route in `SearchService` vs in UI?**
- Keeps UI layer thin (presentation only)
- Search logic belongs in application layer
- Easier to test search routing independently
- Consistent with DDD/Clean Architecture

**Why use `PatternCache` instead of caching in service?**
- Separation of concerns (cache is infrastructure)
- Reusable across multiple services if needed
- Testable in isolation
- Clear responsibility boundary

**Why placeholder for exact search?**
- E05-F03 focuses on wildcard patterns only
- E05-F02 will implement exact/prefix search
- Placeholder makes dependency explicit
- Allows testing wildcard integration independently

### 5.2 Error Handling Strategy

**SearchError hierarchy:**
```python
SearchError                 # Base exception
├── PatternError           # Invalid wildcard pattern (from T01)
├── EmptyQueryError        # Empty query (optional subclass)
└── NotImplementedError    # Exact search placeholder
```

**User-facing error messages:**
- Invalid pattern: "Invalid search pattern: Pattern must contain at least one literal character"
- Empty query: "Search query cannot be empty"
- Not implemented: "Exact search not yet implemented (see E05-F02)"

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/application/services/test_search_service.py`):
- Mock `Design` and `PatternMatcher`
- Test routing logic (wildcard detected → pattern search)
- Test error handling for invalid patterns
- Verify filters passed correctly to matcher

**Integration Tests** (`tests/integration/application/test_search_integration.py`):
- Real `Design` object with test data
- Real `PatternMatcher` and `WildcardParser`
- End-to-end search workflow
- Verify results correctness

**UI Integration Tests** (`tests/ui/panels/test_search_panel.py`):
- Qt widget test with `SearchPanel`
- Simulate user input and button clicks
- Verify results displayed in UI
- Verify error messages shown

**Performance Tests**:
```python
def test_search_performance():
    design = create_large_test_design(cells=10000, nets=50000)
    service = SearchService(design)
    filters = SearchFilters(max_results=100)

    start = time.perf_counter()
    results = service.search("*clk*", filters)
    duration = time.perf_counter() - start

    assert duration < 0.1  # 100ms
    assert len(results) <= 100
```

### 5.4 Future Enhancements

**Post-MVP features:**
- Fuzzy search support (Levenshtein distance)
- Regular expression search (advanced users)
- Search history and suggestions
- Saved searches
- Search result export

**Performance optimizations:**
- Prefix/suffix indexing for bounded wildcards
- Parallel search across object types
- Incremental result streaming for large result sets

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F03 split |
