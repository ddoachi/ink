# E05-F03-T03 - Search Service Integration: Pre-Implementation Documentation

## Document Information
- **Task**: E05-F03-T03 - Search Service Integration
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task integrates wildcard pattern matching into the existing search service to provide unified search functionality supporting both exact matches and wildcard patterns. The service automatically detects pattern queries, routes to appropriate matching logic, maintains consistent API for the search panel UI, and uses pattern caching for performance optimization.

### 1.2 Core Capabilities

The task delivers:

1. **Unified Search API**: Single `search()` method supporting both exact and wildcard queries
2. **Automatic Query Detection**: Detect wildcards and route to appropriate matcher
3. **Pattern Caching Integration**: Use `PatternCache` for performance
4. **Error Handling**: Consistent error messages across search types
5. **Filter Support**: Apply search filters (object types, result limits) uniformly

### 1.3 Success Metrics

- Pattern search completes in < 100ms for typical queries
- Cache hit avoids recompilation overhead
- Seamless integration with search panel UI
- Backward compatible with existing search API
- Clear error messages for invalid patterns

---

## 2. Architecture Decisions

### 2.1 Automatic Query Type Detection

**Decision**: Auto-detect wildcard patterns in `search()` method and route to appropriate matcher.

**Rationale**:
- Simplifies UI - no mode toggle required
- Natural user experience - just type wildcards
- Single entry point for all searches
- Easy to extend with other query types (regex, fuzzy) in future

**Detection Logic**:
```python
if WildcardParser.is_wildcard_pattern(query):
    return self._search_with_pattern(query, filters)
else:
    return self._search_exact(query, filters)
```

**Alternatives Considered**:
- **Explicit mode toggle in UI**: Rejected - adds friction, users must switch modes
- **Separate methods (`search_pattern()`, `search_exact()`)**: Rejected - splits API, complicates UI
- **Always try pattern first**: Rejected - inefficient for non-pattern queries

**Trade-offs**:
- **Pro**: Seamless UX, no mode switching
- **Pro**: Single API entry point
- **Con**: Slight overhead for detection (negligible - simple string check)

### 2.2 Routing in Service Layer

**Decision**: Implement query routing in `SearchService` (application layer), not in UI.

**Rationale**:
- Keeps UI layer thin (presentation only)
- Search logic belongs in application layer (DDD principle)
- Easier to test routing independently of UI
- Consistent with Clean Architecture dependency rules
- Enables reuse of search service in other contexts (TCL, tests, etc.)

**Layer Responsibilities**:
```
Presentation Layer (SearchPanel):
  - Collect user input (query, filters)
  - Call SearchService.search()
  - Display results

Application Layer (SearchService):
  - Detect query type
  - Route to appropriate matcher
  - Handle errors
  - Return results

Infrastructure Layer (PatternMatcher, ExactMatcher):
  - Execute specific matching strategies
  - Access design model
```

**Alternatives Considered**:
- **Route in UI**: Rejected - violates separation of concerns, harder to test
- **Route in infrastructure**: Rejected - wrong layer, service should orchestrate

### 2.3 Pattern Cache Usage

**Decision**: Use `PatternCache.get_pattern()` instead of service-level caching.

**Rationale**:
- Separation of concerns - cache is infrastructure concern
- Reusable across multiple services if needed
- Testable in isolation
- Clear responsibility boundary
- Follows DDD infrastructure pattern

**Integration**:
```python
def _search_with_pattern(self, pattern: str, filters: SearchFilters):
    compiled_pattern = PatternCache.get_pattern(pattern)  # Cache lookup
    results = self.pattern_matcher.match_all(compiled_pattern, ...)
    return results
```

**Alternatives Considered**:
- **`@lru_cache` decorator on service method**: Rejected - harder to clear, couples cache to method
- **Service-level cache dict**: Rejected - duplicates infrastructure concern in application layer

### 2.4 Error Handling Strategy

**Decision**: Wrap infrastructure errors in `SearchError` with user-friendly messages.

**Rationale**:
- UI should display application-level errors, not infrastructure details
- Consistent error handling across search types
- Easier to internationalize error messages (future)
- Allows logging infrastructure errors while showing simple messages to users

**Error Translation**:
```python
try:
    compiled_pattern = PatternCache.get_pattern(pattern)
    # ... matching logic ...
except PatternError as e:
    raise SearchError(f"Invalid search pattern: {e}") from e
```

**Error Hierarchy**:
```
SearchError (base)
  ‚îú‚îÄ‚îÄ Invalid pattern (from PatternError)
  ‚îú‚îÄ‚îÄ Empty query
  ‚îî‚îÄ‚îÄ Not implemented (exact search placeholder)
```

**Alternatives Considered**:
- **Let infrastructure errors bubble up**: Rejected - exposes implementation details to UI
- **Catch all exceptions**: Rejected - too broad, hides real bugs

### 2.5 Placeholder for Exact Search

**Decision**: Provide `_search_exact()` placeholder raising `NotImplementedError` until E05-F02 is complete.

**Rationale**:
- Makes dependency on E05-F02 explicit
- Allows testing wildcard integration independently
- Fails fast with clear message if exact search attempted
- Simplifies incremental development

**Implementation**:
```python
def _search_exact(self, query: str, filters: SearchFilters):
    raise NotImplementedError("Exact search not yet implemented (see E05-F02)")
```

**Integration Path**:
```python
# Future implementation when E05-F02 is complete:
def _search_exact(self, query: str, filters: SearchFilters):
    return self.exact_matcher.search(query, filters)
```

**Alternatives Considered**:
- **Stub returning empty results**: Rejected - hides missing functionality
- **Route all non-pattern queries to pattern matcher**: Rejected - inefficient, not semantically correct

---

## 3. Implementation Strategy

### 3.1 Development Phases

**Phase 1: SearchFilters Extension (15 minutes)**
- Verify `SearchFilters` dataclass exists (may be from E05-F02)
- Add any missing fields needed for pattern matching
- Unit tests for filter validation

**Phase 2: SearchService Core (1 hour)**
- Implement `SearchService.__init__()` with `Design` dependency
- Create `PatternMatcher` instance
- Implement `search()` method with query detection
- Implement `_search_with_pattern()` integration
- Implement `_search_exact()` placeholder
- Unit tests with mocked dependencies

**Phase 3: Error Handling (30 minutes)**
- Define `SearchError` exception
- Add error wrapping in `_search_with_pattern()`
- Add validation in `search()` (empty query, etc.)
- Unit tests for all error cases

**Phase 4: Cache Integration (30 minutes)**
- Integrate `PatternCache.get_pattern()` in `_search_with_pattern()`
- Implement `clear_cache()` method
- Unit tests for cache interaction

**Phase 5: Integration Testing (1 hour)**
- Integration tests with real `Design` and `PatternMatcher`
- End-to-end search workflow tests
- UI integration tests with `SearchPanel`
- Performance testing

### 3.2 Testing Strategy

**Unit Tests** (`tests/unit/application/services/test_search_service.py`):

```python
class TestSearchService:
    @pytest.fixture
    def mock_design(self):
        return Mock(spec=Design)

    @pytest.fixture
    def search_service(self, mock_design):
        return SearchService(mock_design)

    def test_init_creates_pattern_matcher(self, search_service):
        assert search_service.pattern_matcher is not None
        assert isinstance(search_service.pattern_matcher, PatternMatcher)

    def test_search_detects_wildcard_pattern(self, search_service, mocker):
        mock_pattern_search = mocker.patch.object(
            search_service, '_search_with_pattern', return_value=[]
        )

        search_service.search("*clk*", SearchFilters())

        mock_pattern_search.assert_called_once()

    def test_search_detects_exact_query(self, search_service, mocker):
        mock_exact_search = mocker.patch.object(
            search_service, '_search_exact', return_value=[]
        )

        try:
            search_service.search("my_net", SearchFilters())
        except NotImplementedError:
            pass  # Expected until E05-F02

        mock_exact_search.assert_called_once()

    def test_search_empty_query_raises_error(self, search_service):
        with pytest.raises(SearchError, match="Search query cannot be empty"):
            search_service.search("", SearchFilters())

    def test_search_whitespace_query_raises_error(self, search_service):
        with pytest.raises(SearchError, match="Search query cannot be whitespace only"):
            search_service.search("   ", SearchFilters())

    def test_search_with_pattern_uses_cache(self, search_service, mocker):
        mock_cache = mocker.patch('ink.infrastructure.search.pattern_cache.PatternCache.get_pattern')
        mock_pattern = Mock(spec=Pattern)
        mock_cache.return_value = mock_pattern

        mocker.patch.object(search_service.pattern_matcher, 'match_all', return_value=[])

        search_service.search("*clk*", SearchFilters())

        mock_cache.assert_called_once_with("*clk*")

    def test_search_with_pattern_invalid_pattern_raises_error(self, search_service, mocker):
        mocker.patch(
            'ink.infrastructure.search.pattern_cache.PatternCache.get_pattern',
            side_effect=PatternError("Pattern must contain at least one literal character")
        )

        with pytest.raises(SearchError, match="Invalid search pattern"):
            search_service.search("***", SearchFilters())

    def test_search_with_pattern_applies_filters(self, search_service, mocker):
        mock_match_all = mocker.patch.object(
            search_service.pattern_matcher, 'match_all', return_value=[]
        )

        filters = SearchFilters(
            include_cells=True,
            include_nets=False,
            include_ports=True,
            include_pins=False,
            max_results=50
        )

        search_service.search("*clk*", filters)

        mock_match_all.assert_called_once()
        call_kwargs = mock_match_all.call_args.kwargs
        assert call_kwargs['include_cells'] == True
        assert call_kwargs['include_nets'] == False
        assert call_kwargs['max_results'] == 50

    def test_clear_cache(self, search_service, mocker):
        mock_cache_clear = mocker.patch(
            'ink.infrastructure.search.pattern_cache.PatternCache.clear'
        )

        search_service.clear_cache()

        mock_cache_clear.assert_called_once()
```

**Integration Tests** (`tests/integration/application/test_search_integration.py`):

```python
class TestSearchIntegration:
    @pytest.fixture
    def test_design(self):
        """Create real design with test data"""
        design = Design(name="test_design")

        # Add test cells
        design.add_cell(Cell(id="c1", name="clk_buffer"))
        design.add_cell(Cell(id="c2", name="my_clk"))
        design.add_cell(Cell(id="c3", name="data_reg"))

        # Add test nets
        design.add_net(Net(id="n1", name="n_clk"))
        design.add_net(Net(id="n2", name="n_data"))

        return design

    def test_search_wildcard_end_to_end(self, test_design):
        service = SearchService(test_design)
        filters = SearchFilters(include_cells=True, include_nets=True)

        results = service.search("*clk*", filters)

        assert len(results) == 3  # clk_buffer, my_clk, n_clk
        assert all(isinstance(r, SearchResult) for r in results)
        assert results[0].name == "clk_buffer"  # Sorted by match position

    def test_search_filters_by_type(self, test_design):
        service = SearchService(test_design)

        # Only cells
        filters = SearchFilters(include_cells=True, include_nets=False)
        results = service.search("*clk*", filters)
        assert len(results) == 2  # clk_buffer, my_clk
        assert all(r.result_type == SearchResultType.CELL for r in results)

        # Only nets
        filters = SearchFilters(include_cells=False, include_nets=True)
        results = service.search("*clk*", filters)
        assert len(results) == 1  # n_clk
        assert all(r.result_type == SearchResultType.NET for r in results)

    def test_search_cache_performance(self, test_design):
        service = SearchService(test_design)
        filters = SearchFilters()

        # First search - compiles pattern
        start1 = time.perf_counter()
        results1 = service.search("*clk*", filters)
        duration1 = time.perf_counter() - start1

        # Second search - uses cached pattern
        start2 = time.perf_counter()
        results2 = service.search("*clk*", filters)
        duration2 = time.perf_counter() - start2

        assert results1 == results2
        assert duration2 < duration1  # Cache should be faster
```

**UI Integration Tests** (`tests/ui/panels/test_search_panel_integration.py`):

```python
class TestSearchPanelIntegration:
    @pytest.fixture
    def search_panel(self, qtbot, test_design):
        service = SearchService(test_design)
        panel = SearchPanel(search_service=service)
        qtbot.addWidget(panel)
        return panel

    def test_user_searches_with_wildcard(self, search_panel, qtbot):
        # User enters wildcard query
        search_panel.search_input.setText("*clk*")

        # User clicks search button
        qtbot.mouseClick(search_panel.search_button, Qt.LeftButton)

        # Results should appear
        assert search_panel.results_list.count() > 0

    def test_user_sees_error_for_invalid_pattern(self, search_panel, qtbot):
        # User enters invalid pattern
        search_panel.search_input.setText("***")

        # User clicks search button
        qtbot.mouseClick(search_panel.search_button, Qt.LeftButton)

        # Error message should be shown
        # (Implementation depends on error display mechanism)
        assert search_panel.error_label.text() != ""

    def test_filter_checkboxes_control_results(self, search_panel, qtbot):
        # Uncheck nets
        search_panel.nets_checkbox.setChecked(False)

        # Search
        search_panel.search_input.setText("*clk*")
        qtbot.mouseClick(search_panel.search_button, Qt.LeftButton)

        # Results should only include cells
        for i in range(search_panel.results_list.count()):
            item = search_panel.results_list.item(i)
            result = item.data(Qt.UserRole)
            assert result.result_type == SearchResultType.CELL
```

### 3.3 Integration Points

**With E05-F03-T01 (Wildcard Parser)**:
- Uses `WildcardParser.is_wildcard_pattern()` for query detection
- Uses `PatternCache.get_pattern()` for pattern compilation
- Catches `PatternError` and wraps in `SearchError`

**With E05-F03-T02 (Pattern Matcher)**:
- Creates `PatternMatcher` instance with `Design`
- Calls `match_all()` with compiled pattern and filters
- Receives `List[SearchResult]` for return to UI

**With E05-F01 (Search Panel UI)**:
- Search panel calls `SearchService.search()` with query and filters
- Receives `List[SearchResult]` for display
- Shows error messages from `SearchError`

**With E05-F02 (Exact Search - Future)**:
- Will implement `_search_exact()` method
- Will create `ExactMatcher` instance in `__init__()`
- Same return type (`List[SearchResult]`) ensures compatibility

---

## 4. Technical Deep Dive

### 4.1 Query Routing Flow

**Sequence Diagram**:

```
User ‚Üí SearchPanel ‚Üí SearchService ‚Üí PatternCache ‚Üí PatternMatcher ‚Üí Design
                                   ‚Üì
                              WildcardParser

Flow:
1. User enters "*clk*" and clicks search
2. SearchPanel calls service.search("*clk*", filters)
3. SearchService calls WildcardParser.is_wildcard_pattern("*clk*")
4. Returns True ‚Üí route to _search_with_pattern()
5. _search_with_pattern() calls PatternCache.get_pattern("*clk*")
6. PatternCache checks cache:
   - Hit: return cached pattern
   - Miss: call WildcardParser.parse(), store, return
7. _search_with_pattern() calls pattern_matcher.match_all(pattern, filters)
8. PatternMatcher iterates design objects, matches, returns results
9. SearchService returns results to SearchPanel
10. SearchPanel displays results
```

### 4.2 Error Propagation

**Error Flow**:

```
PatternError ‚Üí SearchError ‚Üí SearchPanel ‚Üí User

Example:
1. User enters "***"
2. SearchService calls PatternCache.get_pattern("***")
3. PatternCache calls WildcardParser.parse("***")
4. WildcardParser raises PatternError("Pattern must contain at least one literal character")
5. SearchService catches PatternError, raises SearchError("Invalid search pattern: ...")
6. SearchPanel catches SearchError, displays message in UI
```

**Implementation**:

```python
def _search_with_pattern(self, pattern: str, filters: SearchFilters):
    try:
        compiled_pattern = PatternCache.get_pattern(pattern)
        results = self.pattern_matcher.match_all(...)
        return results
    except PatternError as e:
        # Wrap infrastructure error in application error
        raise SearchError(f"Invalid search pattern: {e}") from e
```

### 4.3 Filter Translation

**UI Filters ‚Üí Search Filters ‚Üí Matcher Parameters**:

```python
# UI (SearchPanel):
cells_checked = self.cells_checkbox.isChecked()
nets_checked = self.nets_checkbox.isChecked()
pins_checked = self.pins_checkbox.isChecked()

filters = SearchFilters(
    include_cells=cells_checked,
    include_nets=nets_checked,
    include_pins=pins_checked,
    max_results=100
)

# Service (SearchService):
results = self.pattern_matcher.match_all(
    pattern=compiled_pattern,
    include_cells=filters.include_cells,
    include_nets=filters.include_nets,
    include_pins=filters.include_pins,
    max_results=filters.max_results
)
```

### 4.4 Cache Lifecycle

**Cache Management**:

```python
# Initialization: cache is empty
PatternCache._cache = {}

# First search: "*clk*"
# Cache miss ‚Üí compile ‚Üí store
PatternCache._cache = {"*clk*": <compiled_pattern_1>}

# Second search: "*clk*"
# Cache hit ‚Üí return cached

# Third search: "*data*"
# Cache miss ‚Üí compile ‚Üí store
PatternCache._cache = {"*clk*": <compiled_pattern_1>, "*data*": <compiled_pattern_2>}

# ... many searches ...
# Cache reaches 100 patterns

# 101st unique pattern: "*new*"
# Cache full ‚Üí clear all ‚Üí compile new ‚Üí store
PatternCache._cache = {"*new*": <compiled_pattern_101>}
```

**When to Clear Cache**:
- Automatically when size limit reached
- Manually via `service.clear_cache()` for testing
- On design reload (future enhancement)

---

## 5. Risk Analysis

### 5.1 Confusion Between Exact and Pattern Search

**Risk**: Users don't understand when patterns are used vs exact match.

**Impact**: Medium - Unexpected results, user confusion
**Probability**: Medium - Common UX issue with auto-detection
**Mitigation**:
- Document wildcard syntax clearly
- Show visual indicator in UI when pattern detected (e.g., icon)
- Help tooltip explaining wildcards
- Example queries in placeholder text

**Example UI**:
```
[Search: *clk*     ] [üîç] [?]
         ^^^^^^^^
         Wildcard pattern detected (*)
```

### 5.2 Placeholder NotImplementedError in Production

**Risk**: Users trigger exact search before E05-F02 is complete.

**Impact**: High - Application error, poor UX
**Probability**: High - No wildcards = exact search route
**Mitigation**:
- Clear error message: "Exact search not yet implemented (see E05-F02)"
- Consider treating all searches as patterns initially (add `*...*` automatically)
- Prioritize E05-F02 implementation
- Feature flag to disable exact search until ready

**Alternative - Fallback to Pattern**:
```python
def search(self, query: str, filters: SearchFilters):
    if WildcardParser.is_wildcard_pattern(query):
        return self._search_with_pattern(query, filters)
    else:
        # Fallback: wrap in wildcards
        logger.info(f"Exact search not implemented, using pattern: *{query}*")
        return self._search_with_pattern(f"*{query}*", filters)
```

### 5.3 Cache Invalidation After Design Changes

**Risk**: Cached patterns used after design is reloaded, causing stale results.

**Impact**: Low - Results are computed fresh each time (only pattern is cached)
**Probability**: Low - Pattern cache doesn't store results, only compiled regex
**Mitigation**:
- Pattern cache is independent of design state
- No invalidation needed (patterns are design-agnostic)
- Document this behavior

### 5.4 Performance Regression from Detection Overhead

**Risk**: Query type detection adds latency.

**Impact**: Low - Minimal overhead
**Probability**: Low - Detection is simple string check
**Mitigation**:
- `is_wildcard_pattern()` is O(n) where n = query length (typically < 50 chars)
- Overhead < 0.01ms
- Performance tests verify no regression

**Measurement**:
```python
def test_detection_overhead():
    queries = ["my_net", "*clk*", "U_ALU_?", "data_reg"]

    start = time.perf_counter()
    for query in queries * 1000:
        WildcardParser.is_wildcard_pattern(query)
    duration = time.perf_counter() - start

    avg_time = duration / (len(queries) * 1000)
    assert avg_time < 0.00001  # <0.01ms
```

---

## 6. Definition of Done

### 6.1 Functionality Criteria

- [ ] `SearchService.__init__()` creates `PatternMatcher` instance
- [ ] `search()` method validates query (non-empty, non-whitespace)
- [ ] `search()` detects wildcard patterns using `WildcardParser.is_wildcard_pattern()`
- [ ] Wildcard queries route to `_search_with_pattern()`
- [ ] Non-wildcard queries route to `_search_exact()` (placeholder)
- [ ] `_search_with_pattern()` uses `PatternCache.get_pattern()`
- [ ] `_search_with_pattern()` calls `pattern_matcher.match_all()` with filters
- [ ] `_search_with_pattern()` returns `List[SearchResult]`
- [ ] `_search_exact()` raises `NotImplementedError` with clear message
- [ ] `SearchError` raised for invalid patterns with user-friendly message
- [ ] `SearchError` raised for empty/whitespace queries
- [ ] `clear_cache()` method clears pattern cache

### 6.2 Performance Criteria

- [ ] Pattern search completes in < 100ms for typical queries
- [ ] Cache hit avoids recompilation overhead
- [ ] Query detection overhead < 0.01ms
- [ ] No performance regression vs direct pattern matcher usage

### 6.3 Quality Criteria

**Test Coverage**:
- [ ] Unit test coverage >90% for `search_service.py`
- [ ] All routing paths tested
- [ ] All error cases tested
- [ ] Cache integration tested
- [ ] Integration tests pass
- [ ] UI integration tests pass

**Code Quality**:
- [ ] Type hints on all methods
- [ ] Docstrings for all public methods
- [ ] No mypy errors
- [ ] No ruff linting errors

### 6.4 Integration Criteria

- [ ] Works with `SearchPanel` from E05-F01
- [ ] Uses `WildcardParser` and `PatternCache` from E05-F03-T01
- [ ] Uses `PatternMatcher` from E05-F03-T02
- [ ] Returns `SearchResult` objects compatible with UI
- [ ] Applies `SearchFilters` correctly

### 6.5 Documentation Criteria

- [ ] Docstring explains query detection logic
- [ ] Error messages are clear and actionable
- [ ] Code comments explain routing decisions
- [ ] Integration with E05-F02 documented

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should we log searches for analytics?
**Answer**: Deferred to P1. Can add logging middleware if needed for usage analysis.

**Q2**: Should cache be shared across multiple `SearchService` instances?
**Answer**: Yes (class-level cache). Single application instance means one service, so sharing is moot. If multiple services needed in future, class-level cache is still beneficial.

**Q3**: Should we support query history?
**Answer**: Deferred to P1. Would require separate persistence mechanism, not critical for MVP.

### 7.2 UX Questions

**Q1**: Should we show "Searching..." indicator during search?
**Answer**: Yes, but implementation in SearchPanel (E05-F01). Service just needs to be fast enough that indicator rarely shows.

**Q2**: How to communicate result limits to users?
**Answer**: SearchPanel shows "Showing X results (may be more)" when `len(results) == max_results`.

**Q3**: Should we support search shortcuts (e.g., Ctrl+F)?
**Answer**: Yes, but implementation in MainWindow, not SearchService.

### 7.3 Product Questions

**Q1**: Priority of exact search (E05-F02) vs wildcard (E05-F03)?
**Answer**: Both P0, but wildcard can ship first with fallback. Exact search completes integration.

**Q2**: Should we support boolean operators (AND, OR, NOT)?
**Answer**: Deferred to P1. Wildcard patterns sufficient for MVP.

---

## 8. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/T03/E05-F03-T03.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E05/F03/E05-F03.spec.md`
- **Upstream Tasks**:
  - `/home/joohan/dev/project-ink/ink/specs/E05/F03/T01/E05-F03-T01.spec.md`
  - `/home/joohan/dev/project-ink/ink/specs/E05/F03/T02/E05-F03-T02.spec.md`
- **Related Features**:
  - E05-F01: Search Panel UI
  - E05-F02: Exact Search (future integration)
- **DDD Patterns**: Application Service pattern
- **Clean Architecture**: Application layer orchestration

---

## 9. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
