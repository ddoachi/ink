# Spec: E05-F03 - Wildcard Matching

## Metadata
- **ID**: E05-F03
- **Type**: Feature
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E05](../E05.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**:
- **Actual Hours**:
- **Effort**:
- **Tags**: []

---

## 1. Overview

### 1.1 Problem Statement
Engineers often search for groups of related objects using patterns like `*clk*`, `U_ALU_*`, or `data_?`. The search engine must support wildcard pattern matching with `*` (any characters) and `?` (single character) while maintaining fast performance.

### 1.2 Goals
- Support `*` wildcard for matching any sequence of characters
- Support `?` wildcard for matching single character
- Provide case-insensitive matching
- Convert wildcard patterns to regex for efficient matching
- Display clear error messages for invalid patterns
- Maintain sub-100ms search performance for pattern queries

---

## 2. User Stories

### US-E05-03: Wildcard Patterns
**As a** circuit designer
**I want to** use wildcards in search
**So that** I can find groups of related objects

**Acceptance Criteria:**
- [ ] `*` matches any characters (e.g., `*clk*`)
- [ ] `?` matches single character (e.g., `data_?`)
- [ ] Pattern matching is case-insensitive
- [ ] Invalid patterns show error message

---

## 3. Technical Requirements

### 3.1 Pattern Parser

```python
class WildcardParser:
    """Convert wildcard patterns to regex"""

    @staticmethod
    def parse(pattern: str) -> re.Pattern:
        """
        Convert wildcard pattern to compiled regex

        Args:
            pattern: User query with * and ? wildcards

        Returns:
            Compiled regex pattern (case-insensitive)

        Raises:
            PatternError: If pattern is invalid
        """

    @staticmethod
    def is_wildcard_pattern(query: str) -> bool:
        """Check if query contains wildcard characters"""
        return '*' in query or '?' in query

    @staticmethod
    def escape_special_chars(pattern: str) -> str:
        """Escape regex special chars except * and ?"""
```

### 3.2 Pattern Conversion Rules

| Wildcard | Regex | Example | Matches |
|----------|-------|---------|---------|
| `*` | `.*` | `*clk*` | `clk_buffer`, `my_clk`, `clk` |
| `?` | `.` | `data_?` | `data_0`, `data_1`, `data_A` |
| Combined | Combined | `U_*_?` | `U_ALU_1`, `U_MEM_A` |
| Literal chars | Escaped | `net[0]` | `net[0]` (brackets escaped) |

### 3.3 Pattern Matching Algorithm

```python
def search_with_pattern(self, pattern: str, filters: SearchFilters) -> List[SearchResult]:
    """
    Execute pattern-based search

    Algorithm:
    1. Detect if query contains wildcards
    2. If yes, parse to regex pattern
    3. Iterate through indexed names matching pattern
    4. Apply type filters
    5. Build and return results
    """

    # Check for wildcards
    if not WildcardParser.is_wildcard_pattern(pattern):
        return self._exact_search(pattern, filters)

    # Parse pattern
    try:
        regex = WildcardParser.parse(pattern)
    except PatternError as e:
        raise SearchError(f"Invalid pattern: {e}")

    # Search each type
    results = []
    if filters.include_cells:
        results.extend(self._match_cells(regex))
    # ... similar for pins, nets, ports

    return results[:filters.max_results]
```

### 3.4 Wildcard Examples

```python
# Example patterns
"*clk*"         # Matches: clk, clk_buf, system_clk, clk_div_2
"U_ALU_*"       # Matches: U_ALU_1, U_ALU_reg, U_ALU_output
"data_?"        # Matches: data_0, data_1, data_a (single char)
"data_??"       # Matches: data_00, data_ab, data_FF (two chars)
"*_clk_?"       # Combined: any_clk_0, system_clk_1
```

### 3.5 Error Handling

```python
class PatternError(Exception):
    """Raised when wildcard pattern is invalid"""

# Invalid patterns
"***"           # Too many wildcards (optimization)
""              # Empty pattern
"?"             # Single char (too short, min 2 chars)
```

### 3.6 Performance Optimization

```python
class PatternCache:
    """Cache compiled regex patterns"""

    _cache: Dict[str, re.Pattern] = {}

    @classmethod
    def get_pattern(cls, wildcard: str) -> re.Pattern:
        """Get cached pattern or compile new one"""
        if wildcard not in cls._cache:
            cls._cache[wildcard] = WildcardParser.parse(wildcard)
        return cls._cache[wildcard]
```

---

## 4. Dependencies

- **Upstream**:
  - E05-F02 (Search Engine - integrates pattern matching)
- **Downstream**:
  - E05-F01 (Search Panel UI - displays pattern results)

---

## 5. Acceptance Criteria

- [ ] `*` wildcard matches any sequence of characters
- [ ] `?` wildcard matches exactly one character
- [ ] Pattern matching is case-insensitive
- [ ] Multiple wildcards in single query work correctly
- [ ] Regex special characters (`.`, `[`, `]`, etc.) are escaped
- [ ] Invalid patterns raise `PatternError` with clear message
- [ ] Compiled patterns are cached for performance
- [ ] Pattern search completes in < 100ms
- [ ] Results sorted by relevance (earlier match position ranked higher)
- [ ] Empty results returned for overly broad patterns (> max_results)

---

## 6. Child Specs

| ID | Task | Status | Estimated Hours |
|----|------|--------|-----------------|
| [E05-F03-T01](T01/E05-F03-T01.spec.md) | Wildcard Pattern Parser | Draft | 4h |
| [E05-F03-T02](T02/E05-F03-T02.spec.md) | Pattern Matching Service | Draft | 3h |
| [E05-F03-T03](T03/E05-F03-T03.spec.md) | Search Service Integration | Draft | 3h |

**Total Estimated**: 10 hours

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial feature creation from E05 split |
