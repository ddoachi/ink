# Pre-Implementation Documentation: E05-F01-T04 - Search History Dropdown

## Overview

### Problem Context
Users frequently search for the same objects or patterns during schematic exploration sessions. Retyping common queries is tedious and slows down workflow. A search history dropdown provides one-click access to recent searches, improving productivity and user experience.

### Goals
- Add history dropdown next to search input for quick access to recent queries
- Store last 10 search queries in memory during session
- Automatically populate search input when history item selected
- Remove duplicate entries (keep most recent occurrence)
- Optionally persist history across application sessions using `QSettings`

### Scope
**In Scope:**
- `QComboBox` dropdown widget next to search input
- In-memory history storage using `OrderedDict` (max 10 items)
- Automatic history population on search execution
- Duplicate removal and move-to-front logic
- Public API for history management (`get_search_history`, `load_history`, `clear_history`)
- Optional: Cross-session persistence using `QSettings` (if time permits)

**Out of Scope:**
- History search/filtering (P1 enhancement)
- History item deletion (context menu in P1)
- Search frequency counter (P1 enhancement)
- History export/import (P1 enhancement)
- Server-side history synchronization (future feature)

## Implementation Approach

### Architecture Pattern
History management is implemented entirely within `SearchPanel`:
- History stored as instance variable (`_search_history: OrderedDict`)
- Dropdown widget updated whenever history changes
- No external persistence for MVP (optional `QSettings` integration)
- Loose coupling: main window can load/save history but panel owns data

### Component Design

#### Data Structure: OrderedDict
```python
from collections import OrderedDict

self._search_history: OrderedDict[str, None] = OrderedDict()
```

**Design Rationale:**
- `OrderedDict` preserves insertion order (Python 3.7+ guarantees this for `dict` too, but explicit)
- O(1) duplicate detection: `if query in self._search_history`
- O(1) duplicate removal: `del self._search_history[query]`
- O(1) move to front: delete then re-insert
- Values are `None` (we only need keys; set-like behavior)

**Alternative Considered:** List
- Rejected: O(n) duplicate detection, slower for repeated searches

**Alternative Considered:** `deque`
- Rejected: No efficient duplicate detection (still O(n))

#### Updated Panel Layout
```
SearchPanel (QWidget)
├── Search Input Row (QHBoxLayout)
│   ├── Label: "Search:"
│   ├── QLineEdit (search_input) [stretch=1]
│   └── QComboBox (history_dropdown) [min width=100px]  ← NEW
├── Filter Buttons Row
├── Results List
└── Status Label
```

#### History State Machine
```
Initial State: Empty history, dropdown shows placeholder "History"

User searches "clk_buffer"
  ↓
_add_to_history("clk_buffer")
  ↓
History: ["clk_buffer"]
Dropdown: ["clk_buffer"]

User searches "net_clk"
  ↓
_add_to_history("net_clk")
  ↓
History: ["net_clk", "clk_buffer"]  (most recent first)
Dropdown: ["net_clk", "clk_buffer"]

User searches "clk_buffer" again
  ↓
_add_to_history("clk_buffer")
  ↓
Remove existing "clk_buffer"
Re-add to front
  ↓
History: ["clk_buffer", "net_clk"]  (moved to front)
Dropdown: ["clk_buffer", "net_clk"]

User searches 10 more unique queries
  ↓
History: [most recent 10 queries]  (oldest removed)
Dropdown: [most recent 10 queries]
```

### Signal Flow
```
User Action                    Internal Method           UI Update
──────────────────────────────────────────────────────────────────────
Enter in search input  →       _on_search_triggered()
                         →     _add_to_history(query)
                         →     _update_history_dropdown()
                         →     dropdown populated

Select from dropdown   →       _on_history_selected(text)
                         →     search_input.setText(text)
```

**Note:** Selecting history does NOT auto-execute search (user may want to edit query first).

### Integration Points

#### Main Window Integration (Optional Persistence)
```python
# In main_window.py
def _save_search_history(self):
    settings = QSettings("Ink", "SchematicViewer")
    history = self.search_panel.get_search_history()
    settings.setValue("search/history", history)

def _load_search_history(self):
    settings = QSettings("Ink", "SchematicViewer")
    history = settings.value("search/history", [])
    if history:
        self.search_panel.load_history(history)

def closeEvent(self, event):
    self._save_search_history()
    super().closeEvent(event)
```

**Rationale for Optional:**
- Core functionality works without persistence (in-memory history)
- Persistence is UX enhancement, not critical for MVP
- Can be added in 30 minutes if time permits, skipped if not

## Key Design Decisions

### 1. OrderedDict vs List vs Deque
**Decision:** Use `OrderedDict[str, None]` for history storage

**Rationale:**
- O(1) duplicate detection and removal
- Preserves insertion order
- Efficient move-to-front operation (delete + re-insert)
- Cleaner than manual list searching

**Performance Comparison (for 10 items):**
| Operation | OrderedDict | List | Deque |
|-----------|-------------|------|-------|
| Add to front | O(1) | O(n) | O(1) |
| Check duplicate | O(1) | O(n) | O(n) |
| Remove duplicate | O(1) | O(n) | O(n) |

**Alternative Considered:** Plain list with linear search
- Rejected: O(n) duplicate checks, inefficient

### 2. History Size Limit
**Decision:** Hard-coded limit of 10 items

**Rationale:**
- Keeps dropdown manageable (no scrolling needed for most cases)
- Most users only need recent 5-10 searches
- Larger history rarely accessed (not worth UI clutter)
- Can be made configurable in P1 if users request it

**Alternative Considered:** 20 items
- Rejected: Dropdown becomes too long, harder to scan visually

**Alternative Considered:** Unlimited history
- Rejected: Unbounded memory growth, dropdown becomes unusable

### 3. Auto-Execute Search on History Selection
**Decision:** Do NOT auto-execute search when history item selected

**Rationale:**
- User may want to edit query after selecting (e.g., "clk_buffer_1" → "clk_buffer_2")
- Explicit search execution (Enter key) gives user control
- Avoids unintended searches (accidental dropdown click)

**Alternative Considered:** Auto-execute on selection
- Rejected: Less flexible, surprising behavior

### 4. Duplicate Handling: Move to Front vs Ignore
**Decision:** Move duplicate to front (most recent position)

**Rationale:**
- Indicates recent usage (more relevant)
- Standard history behavior (browsers, shells)
- Keeps history size stable (no new entry added)

**Alternative Considered:** Ignore duplicate (keep original position)
- Rejected: Less useful, doesn't reflect recency

### 5. History Order: Most Recent First vs Last
**Decision:** Display most recent first (top of dropdown)

**Rationale:**
- User most likely wants recent search
- Faster access (less scrolling)
- Standard pattern (browser history, IDE recent files)

**Alternative Considered:** Most recent last
- Rejected: Backwards from user expectations

### 6. Persistence: QSettings vs JSON File
**Decision:** Use `QSettings` for cross-session persistence (optional)

**Rationale:**
- Qt built-in, platform-agnostic (registry on Windows, config file on Linux)
- Automatic serialization of lists
- Respects user preferences location
- No need for manual file I/O

**Alternative Considered:** JSON file in user config directory
- Rejected: More code, manual file handling, platform-specific paths

### 7. Dropdown Reset After Selection
**Decision:** Reset dropdown to placeholder after selection

**Rationale:**
- Cleaner UI (dropdown doesn't show "stuck" selection)
- Ready for next history access
- Dropdown is transient control (not a state display)

**Implementation:** `self.history_dropdown.setCurrentIndex(-1)` after update

## Dependencies and Integration Points

### Upstream Dependencies
1. **E05-F01-T01 (SearchPanel Widget)**: Extends search input row layout
2. **Python Standard Library**: `collections.OrderedDict`
3. **PySide6 Components**: `QComboBox`, `QSettings` (optional)

### Downstream Consumers
1. **Main Window (Optional)**: May call `get_search_history()` and `load_history()` for persistence
2. **Future Features**:
   - History export/import (P1)
   - History search frequency analytics (P1)
   - Cloud sync of history (future)

### Interface Contracts

#### SearchPanel Extensions
```python
class SearchPanel(QWidget):
    # New UI components
    self.history_dropdown: QComboBox

    # New instance variables
    self._search_history: OrderedDict[str, None]

    # New methods
    def get_search_history(self) -> list[str]
    def load_history(self, history: list[str]) -> None
    def clear_history(self) -> None

    # Modified methods
    def _on_search_triggered(self):
        # Now calls _add_to_history()

    # Private methods
    def _add_to_history(self, query: str) -> None
    def _update_history_dropdown(self) -> None
    def _on_history_selected(self, text: str) -> None
```

#### MainWindow Extensions (Optional)
```python
class MainWindow(QMainWindow):
    def _save_search_history(self) -> None
    def _load_search_history(self) -> None

    # Modified method
    def closeEvent(self, event):
        # Now calls _save_search_history()
```

## Testing Strategy

### Unit Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py` (extend existing)

**Test Categories:**
1. **Initialization Tests**: Verify history starts empty
2. **Addition Tests**: Verify searches added to history
3. **Duplicate Tests**: Verify duplicates moved to front
4. **Limit Tests**: Verify history capped at 10 items
5. **Selection Tests**: Verify dropdown selection populates input
6. **Order Tests**: Verify most recent first ordering
7. **API Tests**: Verify `get_search_history()`, `load_history()`, `clear_history()`

**New Test Cases:**
- `test_history_dropdown_initialization`: Verify empty with placeholder
- `test_add_to_history`: Verify search added to history and dropdown
- `test_history_duplicates_removed`: Verify duplicate moves to front
- `test_history_max_items`: Verify 15 searches → keep most recent 10
- `test_history_selection_populates_input`: Verify dropdown selection fills input
- `test_load_history`: Verify `load_history()` populates correctly
- `test_clear_history`: Verify `clear_history()` empties dropdown
- `test_history_order_most_recent_first`: Verify dropdown order

**Edge Cases:**
- Empty string in search input (should not add to history)
- Whitespace-only query (should not add to history)
- Loading history with >10 items (should truncate)
- Selecting history when input already has text (should replace)
- Rapid duplicate searches (should only keep one entry)

### Integration Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/integration/test_search_persistence.py` (optional)

**Test Scenarios (if persistence implemented):**
- History saved on application close
- History restored on application start
- Empty history doesn't create settings entry
- Corrupted settings gracefully handled (empty history)

### Manual Testing Checklist
- [ ] History dropdown visible next to search input
- [ ] Dropdown shows "History" placeholder when empty
- [ ] Searches added to dropdown automatically
- [ ] Dropdown shows most recent search first
- [ ] Selecting history item fills search input
- [ ] Selecting history does NOT auto-execute search
- [ ] Duplicate searches move to front
- [ ] History limited to 10 items (oldest removed)
- [ ] Dropdown visually consistent with Qt theme
- [ ] Dropdown accessible via keyboard (Tab, arrow keys)

## Risks and Considerations

### Risk 1: QSettings Platform Differences
**Risk Level:** Low (only if persistence implemented)

**Description:** `QSettings` storage location differs by platform (registry on Windows, config file on Linux/Mac).

**Mitigation:**
1. Use organization ("Ink") and application ("SchematicViewer") names in `QSettings` constructor
2. Test on all target platforms (Linux priority for MVP)
3. Add error handling for settings read/write failures
4. Document settings location in user documentation

**Contingency:** If `QSettings` causes issues, skip persistence for MVP and add as P1 task.

### Risk 2: History Corruption
**Risk Level:** Very Low

**Description:** If history data in `QSettings` is corrupted, could cause startup crash.

**Mitigation:**
1. Wrap `settings.value()` in try-except block
2. Validate loaded history (must be list of strings)
3. Gracefully fall back to empty history on error
4. Log warning if history load fails

```python
def _load_search_history(self):
    try:
        settings = QSettings("Ink", "SchematicViewer")
        history = settings.value("search/history", [])
        if isinstance(history, list) and all(isinstance(q, str) for q in history):
            self.search_panel.load_history(history)
        else:
            logging.warning("Invalid search history format, using empty history")
    except Exception as e:
        logging.error(f"Failed to load search history: {e}")
```

**Contingency:** Clear corrupted settings and start fresh.

### Risk 3: Dropdown Width Issues
**Risk Level:** Low

**Description:** History items with very long queries may cause dropdown to overflow or wrap awkwardly.

**Mitigation:**
1. Set `minWidth` to reasonable value (100px in spec)
2. Use `AdjustToContents` size policy for dynamic width
3. Dropdown will truncate long items with ellipsis (Qt default behavior)
4. Consider max query length (e.g., 100 chars) if issues persist

**Contingency:** Set `maxWidth` or truncate queries in history storage.

### Risk 4: Memory Leak in OrderedDict
**Risk Level:** Very Low

**Description:** If history is never cleared, could accumulate over long sessions.

**Mitigation:**
- History limited to 10 items (bounded memory)
- Each entry is just a string (negligible memory)
- History cleared when panel destroyed (on app close)

**Contingency:** Not a real risk with 10-item limit.

### Risk 5: Signal Loop on History Selection
**Risk Level:** Low

**Description:** If selecting history triggers `textChanged` signal, could cause unintended behavior.

**Mitigation:**
- Use `currentTextChanged` signal on dropdown (only emits on user action)
- Do NOT connect to `search_input.textChanged` (only `returnPressed`)
- Test that selecting history doesn't trigger search execution

**Contingency:** Disconnect signals temporarily during history selection.

## Implementation Checklist

### Pre-Implementation
- [ ] Verify T01 (SearchPanel Widget) is completed
- [ ] Decide if persistence will be implemented (time permitting)
- [ ] Review Qt documentation for `QComboBox` and `QSettings`

### Implementation
- [ ] Import `OrderedDict` from `collections`
- [ ] Import `QComboBox` from `PySide6.QtWidgets`
- [ ] Add `MAX_HISTORY_ITEMS = 10` class constant
- [ ] Add `_search_history: OrderedDict[str, None]` instance variable in `__init__()`
- [ ] Add `history_dropdown` (`QComboBox`) to search input row in `_init_ui()`
- [ ] Set dropdown placeholder text: "History"
- [ ] Set dropdown minimum width: 100px
- [ ] Set dropdown size policy: `AdjustToContents`
- [ ] Connect `currentTextChanged` signal to `_on_history_selected()`
- [ ] Modify `_on_search_triggered()` to call `_add_to_history()`
- [ ] Implement `_add_to_history(query: str)` method
  - [ ] Skip empty/whitespace queries
  - [ ] Remove duplicate if exists
  - [ ] Add to front (newest)
  - [ ] Trim to `MAX_HISTORY_ITEMS`
  - [ ] Call `_update_history_dropdown()`
- [ ] Implement `_update_history_dropdown()` method
  - [ ] Clear dropdown
  - [ ] Add items in reverse order (most recent first)
  - [ ] Reset to placeholder (`setCurrentIndex(-1)`)
- [ ] Implement `_on_history_selected(text: str)` method
  - [ ] Populate search input with selected text
  - [ ] Do NOT trigger search
- [ ] Implement `get_search_history() -> list[str]` method
- [ ] Implement `load_history(history: list[str])` method
- [ ] Implement `clear_history()` method

### Optional: Persistence (if time permits)
- [ ] Import `QSettings` from `PySide6.QtCore`
- [ ] Add `_save_search_history()` to `MainWindow`
- [ ] Add `_load_search_history()` to `MainWindow`
- [ ] Call `_load_search_history()` in `MainWindow.__init__()`
- [ ] Override `closeEvent()` to call `_save_search_history()`
- [ ] Add error handling for settings read/write
- [ ] Test persistence across app restarts

### Testing
- [ ] Add test cases to `test_search_panel.py` (8 new tests)
- [ ] Test history initialization (empty)
- [ ] Test adding searches to history
- [ ] Test duplicate removal and move-to-front
- [ ] Test history size limit (10 items)
- [ ] Test dropdown selection populates input
- [ ] Test history order (most recent first)
- [ ] Test `load_history()` method
- [ ] Test `clear_history()` method
- [ ] Run tests: `uv run pytest tests/ui/panels/test_search_panel.py::test_history* -v`
- [ ] If persistence implemented, test settings save/load

### Validation
- [ ] All acceptance criteria met (11 items from spec)
- [ ] All new tests passing
- [ ] Existing tests still passing (T01-T03)
- [ ] No linting errors
- [ ] Type hints correct (mypy passes)
- [ ] Manual testing checklist completed
- [ ] Dropdown visually integrated with search panel

## Open Questions

1. **Persistence Implementation**: Should cross-session persistence be included in MVP?
   - **Recommendation**: Optional (implement if time permits)
   - **Decision Criteria**: If T04 implementation takes <2 hours, add persistence; otherwise defer to P1

2. **History Item Truncation**: Should long queries be truncated in dropdown display?
   - **Recommendation**: No manual truncation; rely on Qt's ellipsis
   - **Action**: Test with long queries (100+ chars) and adjust if needed

3. **Clear History Button**: Should there be a "Clear History" button in UI?
   - **Recommendation**: Not in MVP (API exists, can be called programmatically)
   - **Future**: Add context menu with "Clear History" option in P1

4. **History Across Designs**: Should history be per-design or global?
   - **Recommendation**: Global for MVP (simpler, queries often reusable)
   - **Future**: Consider per-design history in P1 if users request it

5. **Case Sensitivity**: Should history be case-sensitive?
   - **Recommendation**: Yes (case-sensitive, exact match)
   - **Rationale**: Object names may differ only by case (e.g., "clk" vs "CLK")

## Success Criteria

### Functional Requirements
- [ ] History dropdown visible next to search input
- [ ] Dropdown shows last 10 searches (most recent first)
- [ ] Selecting history item populates search input (does NOT execute search)
- [ ] New searches added to history automatically
- [ ] Duplicate searches moved to front
- [ ] History limited to 10 items (oldest removed)
- [ ] `get_search_history()` returns history list
- [ ] `load_history()` loads history from external source
- [ ] `clear_history()` clears all history
- [ ] Dropdown shows "History" placeholder when empty
- [ ] (Optional) History persists across sessions

### Quality Requirements
- [ ] All unit tests passing (100% coverage of history logic)
- [ ] No type checking errors
- [ ] No linting warnings
- [ ] Consistent with existing SearchPanel implementation
- [ ] UI visually consistent with Qt theme

### Documentation Requirements
- [ ] Docstrings for all new methods
- [ ] Comments explaining `OrderedDict` usage
- [ ] Comments for future enhancements (frequency counter, etc.)
- [ ] If persistence implemented, document settings location

## Future Considerations

### P1 Enhancements
- **Clear History Button**: Right-click context menu with "Clear History" option
- **History Item Deletion**: Right-click individual item to remove
- **Search Frequency Counter**: Sort by frequency, not just recency
- **History Search/Filter**: Filter dropdown list as user types
- **History Export/Import**: Save/load history to file
- **Per-Design History**: Separate history for each opened design

### Technical Debt
- Consider extracting history logic to separate class if complexity grows
- May need more sophisticated data structure if frequency counting added
- Persistence layer could be abstracted (interface for settings storage)

### Performance
- Current implementation is synchronous and fast (10 items)
- No performance concerns for MVP
- If history grows to 100+ items (future), consider lazy loading

### Accessibility
- Verify keyboard navigation works (Tab to dropdown, arrow keys to select)
- Ensure dropdown items readable by screen readers
- Consider adding tooltips showing full query text for long items

### UX Refinements
- Consider showing search timestamp in dropdown (e.g., "clk_buffer (2 min ago)")
- Consider grouping history by session or date
- Consider highlighting matching portion of history items as user types

## Related Documentation

- **Parent Feature**: [E05-F01 - Search Panel UI](../E05-F01.spec.md)
- **Previous Task**: [E05-F01-T03 - Results List Widget](../T03/E05-F01-T03.spec.md)
- **Next Task**: [E05-F01-T05 - Keyboard Shortcuts Integration](../T05/E05-F01-T05.spec.md)
- **Python OrderedDict**: https://docs.python.org/3/library/collections.html#collections.OrderedDict
- **Qt QComboBox**: https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QComboBox.html
- **Qt QSettings**: https://doc.qt.io/qtforpython-6/PySide6/QtCore/QSettings.html
- **Qt Settings Location**: https://doc.qt.io/qt-6/qsettings.html#platform-specific-notes
