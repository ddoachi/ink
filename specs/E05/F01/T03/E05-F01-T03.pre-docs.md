# Pre-Implementation Documentation: E05-F01-T03 - Results List Widget

## Overview

### Problem Context
After users execute a search, they need to view matching results in a clear, scannable list format. Each result should show enough information to distinguish between objects (name, type, context) while remaining compact. Users should be able to click results to navigate to objects in the schematic view. Large result sets must be handled gracefully to prevent UI slowdown.

### Goals
- Display search results in a scrollable, readable list format
- Show object name, type, and optional context for each result
- Enable single-click and double-click selection for navigation
- Support keyboard navigation (Up/Down arrows, Enter key)
- Limit result display to prevent performance degradation
- Provide empty state feedback when no results found

### Scope
**In Scope:**
- `QListWidget` integration into search panel
- `SearchResultItem` data class for result representation
- Result population and clearing methods
- Result selection signal emission
- Result truncation at 100 items with user notification
- Icon placeholder infrastructure (actual icons not required for MVP)

**Out of Scope:**
- Actual search execution logic (E05-F02)
- Search result ranking/sorting (basic list order from search engine)
- Multi-selection support (P1 enhancement)
- Context menu for result actions (P1 enhancement)
- Result previews on hover (P1 enhancement)

## Implementation Approach

### Architecture Pattern
The results list extends `SearchPanel` with a `QListWidget` component:
- Results stored in Qt's list widget (no separate data model for MVP)
- Each list item stores `object_id` in `Qt.UserRole` for signal emission
- `SearchResultItem` data class provides abstraction over raw search results
- Signal-based navigation (panel emits, main window handles)

### Component Design

#### SearchResultItem Data Class
```python
class SearchResultItem:
    """Data class representing a single search result."""

    object_id: str       # Unique identifier (e.g., "cell_123", "net_456")
    object_name: str     # Display name (e.g., "clk_buffer_1", "net_clk")
    object_type: str     # Type name (e.g., "Cell", "Pin", "Net", "Port")
    context: str = ""    # Optional context (e.g., "Module: top.cpu", "Fanout: 25")

    def display_text(self) -> str:
        """Format display text for list widget."""
        # "clk_buffer_1 (Cell) - Module: top.cpu"
        # "net_clk (Net)"
```

**Design Rationale:**
- Simple data class, not a full domain entity (presentation layer only)
- `object_id` used for navigation (unique, stable identifier)
- `object_name` used for display (human-readable)
- `object_type` used for icons and filtering
- `context` provides additional disambiguation (optional)

#### Updated Panel Layout
```
SearchPanel (QWidget)
├── Search Input Row
├── Filter Buttons Row
├── Results List (QListWidget)  ← NEW
│   ├── QListWidgetItem: "clk_buffer_1 (Cell) - top.cpu"
│   ├── QListWidgetItem: "clk_buffer_2 (Cell) - top.cpu"
│   ├── QListWidgetItem: "net_clk (Net) - Fanout: 25"
│   └── ...
└── Status Label
```

#### Signal Flow
```
User Action                    SearchPanel Signal         Handler
──────────────────────────────────────────────────────────────────────
Click result item      →       result_selected(str)   →   _navigate_to_object()
Double-click item      →       result_selected(str)   →   _navigate_to_object()
Enter on selected item →       result_selected(str)   →   _navigate_to_object()
```

### Result Population Flow
```
Search Service                 SearchPanel
────────────────────────────────────────────────────────
execute_search(query)
  ↓
[Search logic...]
  ↓
results: list[SearchResultItem]  →  populate_results(results)
                                       ↓
                                     Clear existing items
                                       ↓
                                     Truncate to MAX_RESULTS (100)
                                       ↓
                                     Create QListWidgetItem for each
                                       ↓
                                     Store object_id in Qt.UserRole
                                       ↓
                                     Set icon based on object_type
                                       ↓
                                     Update status label
```

### Performance Optimization

#### Result Truncation Strategy
**Problem:** Displaying 1000+ results causes UI lag and excessive memory usage.

**Solution:** Limit display to 100 results, show truncation message
```python
MAX_RESULTS = 100  # Class constant

display_results = results[:self.MAX_RESULTS]
truncated = len(results) > self.MAX_RESULTS

if truncated:
    status = f"{len(results)} results found (showing first {self.MAX_RESULTS})"
```

**Rationale:**
- 100 items is scrollable without performance impact
- Most users refine search if too many results
- Truncation message encourages more specific queries
- Alternative (pagination) adds complexity not needed for MVP

## Key Design Decisions

### 1. QListWidget vs QListView + Model
**Decision:** Use `QListWidget` (convenience class) instead of `QListView` + custom model

**Rationale:**
- Simpler implementation for MVP (less boilerplate)
- Results are flat list (no tree structure needed)
- No need for advanced model features (sorting, filtering handled elsewhere)
- Performance adequate for 100 items

**Alternative Considered:** `QListView` + `QAbstractListModel`
- Rejected: Over-engineering for MVP, can refactor later if needed
- Future: Switch to model/view if need lazy loading or virtual scrolling

### 2. Result Item Data Storage
**Decision:** Store `object_id` in `Qt.UserRole`, not in custom item class

**Rationale:**
- Qt built-in mechanism, no custom subclass needed
- `UserRole` designed for application data storage
- Easy to retrieve in signal handlers: `item.data(Qt.UserRole)`

**Alternative Considered:** Subclass `QListWidgetItem` with `object_id` property
- Rejected: Unnecessary complexity, Qt provides built-in solution

### 3. Single-Click vs Double-Click Activation
**Decision:** Emit `result_selected` signal on both single-click AND double-click/Enter

**Rationale:**
- Single-click provides immediate feedback (faster workflow)
- Double-click/Enter for users who prefer traditional activation
- Aligns with modern UX (browsers, IDEs)
- Main window can always ignore duplicate signals if needed

**Alternative Considered:** Double-click only (traditional file browser style)
- Rejected: Slower workflow, not aligned with modern search UX

### 4. Icon Implementation Strategy
**Decision:** Add icon infrastructure (`_get_type_icon()` method) but return `None` for MVP

**Rationale:**
- Prepares codebase for future icon integration (P1)
- No delay waiting for icon assets
- Method stub makes it easy to add icons later

**Alternative Considered:** Skip icon code entirely
- Rejected: Would require more changes later to add icons

### 5. Context Information Display
**Decision:** Include optional `context` field in `SearchResultItem`, display in parentheses

**Rationale:**
- Helps disambiguate results with similar names
- Useful context examples: module hierarchy, fanout count, pin direction
- Optional (empty string if no context), doesn't clutter UI
- Can be extended with more context in future

**Alternative Considered:** Separate columns for different attributes
- Rejected: More complex layout, harder to read in compact list

### 6. Empty State Handling
**Decision:** Show "No results" in status label when list is empty

**Rationale:**
- Clear feedback to user (search completed, no matches)
- Status label already used for result count (consistent location)
- No need for placeholder widget in list area

**Alternative Considered:** Show placeholder text inside empty list widget
- Rejected: Status label provides sufficient feedback

## Dependencies and Integration Points

### Upstream Dependencies
1. **E05-F01-T01 (SearchPanel Widget)**: Extends existing panel layout
2. **E05-F01-T02 (Type Filter Buttons)**: Filter affects which results are displayed
3. **E05-F02 (Search Engine)**: Provides `SearchResultItem` objects
4. **PySide6 Components**: `QListWidget`, `QListWidgetItem`, `Qt.UserRole`

### Downstream Consumers
1. **E05-F04 (Navigation Integration)**: Connects to `result_selected` signal
   - Main window handler receives `object_id`
   - Navigates schematic canvas to selected object
   - Highlights object in schematic view

2. **E05-F01-T05 (Keyboard Shortcuts)**: Uses keyboard navigation features
   - Up/Down arrow navigation (native `QListWidget` behavior)
   - Enter key activation (handled by `itemActivated` signal)
   - `select_first_result()` method called after search execution

3. **Future Enhancements**:
   - Context menu integration (P1)
   - Multi-selection for batch operations (P1)
   - Result preview on hover (P1)

### Interface Contracts

#### SearchResultItem API
```python
class SearchResultItem:
    object_id: str
    object_name: str
    object_type: str
    context: str = ""

    def display_text(self) -> str
```

#### SearchPanel Extensions
```python
class SearchPanel(QWidget):
    # New UI components
    self.results_list: QListWidget

    # New methods
    def populate_results(self, results: list[SearchResultItem]) -> None
    def clear_results(self) -> None
    def select_first_result(self) -> None
    def _get_type_icon(self, object_type: str) -> QIcon | None

    # New signals (connected to list widget)
    # result_selected already defined in T01
```

#### Module Exports
```python
__all__ = ['SearchPanel', 'SearchFilterType', 'SearchResultItem']
```

## Testing Strategy

### Unit Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py` (extend existing)

**Test Categories:**
1. **Data Class Tests**: Verify `SearchResultItem.display_text()` formatting
2. **Population Tests**: Verify `populate_results()` populates list correctly
3. **Truncation Tests**: Verify results limited to `MAX_RESULTS`
4. **Clearing Tests**: Verify `clear_results()` clears list and status
5. **Signal Tests**: Verify `result_selected` emits on clicks
6. **Selection Tests**: Verify `select_first_result()` navigates correctly
7. **Empty State Tests**: Verify empty list shows correct status

**New Test Cases:**
- `test_result_item_display_text`: Verify formatting with and without context
- `test_populate_results`: Verify list populated with correct items
- `test_populate_results_truncation`: Verify 150 results → 100 displayed
- `test_clear_results`: Verify list cleared and status reset
- `test_result_selected_signal`: Verify signal emits with correct `object_id`
- `test_select_first_result`: Verify first item selected and signal emitted
- `test_empty_results`: Verify empty list shows "No results"

**Edge Cases:**
- Empty results list
- Single result
- Exactly 100 results (no truncation)
- 101 results (truncation triggers)
- Results with empty context field
- Results with very long names/context (test text wrapping)

### Integration Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/integration/test_search_flow.py` (future)

**Test Scenarios:**
- End-to-end: Search → Populate → Click → Navigate
- Filter change updates results list
- Search history updates results list

### Manual Testing Checklist
- [ ] Results list displays with correct formatting
- [ ] Alternating row colors visible (improves readability)
- [ ] Single-click selects and emits signal
- [ ] Double-click emits signal
- [ ] Enter key on selected item emits signal
- [ ] Up/Down arrows navigate results
- [ ] Scrollbar appears when >10 results
- [ ] Truncation message appears when >100 results
- [ ] Empty state shows "No results"
- [ ] Long names/context don't break layout
- [ ] List updates correctly when filter changes

## Risks and Considerations

### Risk 1: Performance with Large Result Sets
**Risk Level:** Low (mitigated by truncation)

**Description:** Displaying 1000+ results could cause UI lag.

**Mitigation:**
1. Hard limit to 100 results (already in design)
2. `QListWidget` uses efficient rendering for visible items only
3. Status label warns user about truncation
4. Search engine should return results quickly (E05-F02 responsibility)

**Contingency:** If performance issues persist, implement virtual scrolling or pagination.

### Risk 2: Object ID Uniqueness
**Risk Level:** Low

**Description:** `object_id` must be unique across all object types for navigation.

**Mitigation:**
1. Verify domain model uses unique IDs (e.g., prefixed by type: "cell_123", "net_456")
2. Document ID format requirements for search engine integration
3. Test navigation with duplicate names but different IDs

**Contingency:** If IDs are not unique, use composite key (type + ID) for navigation.

### Risk 3: Icon Asset Availability
**Risk Level:** Very Low (icons optional for MVP)

**Description:** Icon files may not exist for object types.

**Rationale:**
- Icon infrastructure is placeholder only
- `_get_type_icon()` returns `None` for MVP
- No visual impact (text-only results are acceptable)

**Mitigation:**
- Stub method returns `None` (no errors)
- Add TODO comment for future icon integration
- Document icon requirements in P1 task

**Contingency:** Use Qt standard icons as fallback if basic icons needed.

### Risk 4: Result Context Formatting
**Risk Level:** Low

**Description:** Different object types need different context information.

**Mitigation:**
1. Context field is free-form string (search engine decides format)
2. Display logic is simple: append " - {context}" if non-empty
3. Document recommended context formats in search engine integration guide

**Contingency:** If context becomes complex, add structured context object with formatting methods.

### Risk 5: Memory Usage with Many Results
**Risk Level:** Very Low

**Description:** Storing 100 `QListWidgetItem` objects in memory.

**Mitigation:**
- 100 items is negligible memory (<1MB typically)
- Items are lightweight (just text and data)
- Cleared on next search (no accumulation)

**Contingency:** If memory issues arise, implement lazy loading or virtual list.

## Implementation Checklist

### Pre-Implementation
- [ ] Verify T01 (SearchPanel Widget) is completed
- [ ] Review domain model object types and ID format
- [ ] Check for existing icon assets in project resources

### Implementation
- [ ] Add `SearchResultItem` data class to `search_panel.py`
- [ ] Implement `display_text()` method with context formatting
- [ ] Add `MAX_RESULTS` class constant to `SearchPanel`
- [ ] Add `results_list` (`QListWidget`) to panel layout in `_init_ui()`
- [ ] Configure list widget (alternating colors, single selection)
- [ ] Connect `itemClicked` signal to `_on_result_clicked()`
- [ ] Connect `itemActivated` signal to `_on_result_activated()`
- [ ] Implement `_on_result_clicked()` handler (emit `result_selected`)
- [ ] Implement `_on_result_activated()` handler (emit `result_selected`)
- [ ] Implement `populate_results()` method
  - [ ] Clear existing items
  - [ ] Truncate to `MAX_RESULTS`
  - [ ] Create list items with `object_id` in `UserRole`
  - [ ] Call `_get_type_icon()` for each item
  - [ ] Update status label (with truncation message if needed)
- [ ] Implement `clear_results()` method
- [ ] Implement `select_first_result()` method
- [ ] Implement `_get_type_icon()` stub method (returns `None`)
- [ ] Update module `__all__` to export `SearchResultItem`

### Testing
- [ ] Add test cases to `test_search_panel.py` (8 new tests)
- [ ] Test `SearchResultItem.display_text()` formatting
- [ ] Test `populate_results()` with various result counts
- [ ] Test result truncation at 100 items
- [ ] Test `clear_results()` method
- [ ] Test signal emissions with `qtbot`
- [ ] Test `select_first_result()` method
- [ ] Test empty results state
- [ ] Run tests: `uv run pytest tests/ui/panels/test_search_panel.py::test_result* -v`

### Validation
- [ ] All acceptance criteria met (12 items from spec)
- [ ] All new tests passing
- [ ] Existing tests still passing (T01, T02)
- [ ] No linting errors
- [ ] Type hints correct (mypy passes)
- [ ] Manual testing checklist completed
- [ ] Results list visually consistent with Qt theme

## Open Questions

1. **Object ID Format**: What is the format of `object_id` in the domain model?
   - **Action Required**: Check domain model files (`cell.py`, `net.py`, etc.)
   - **Expected**: UUIDs or prefixed IDs (e.g., "cell_abc123", "net_xyz789")

2. **Context Information Source**: What context should be shown for each object type?
   - **Recommendation**:
     - Cell: Module hierarchy (e.g., "top.cpu.alu")
     - Net: Fanout count (e.g., "Fanout: 15 pins")
     - Pin: Parent cell + direction (e.g., "cell_buf1.OUT")
     - Port: Direction (e.g., "INPUT")
   - **Action Required**: Document in search engine integration guide

3. **Icon Asset Location**: Where should icons be stored if added in P1?
   - **Recommendation**: `/src/ink/presentation/resources/icons/`
   - **Formats**: SVG (scalable) or PNG (16x16, 24x24)

4. **Truncation Threshold**: Is 100 the right limit, or should it be configurable?
   - **Recommendation**: Hard-coded 100 for MVP, make configurable in P1
   - **Rationale**: Prevents over-engineering for MVP

5. **Result Sorting**: Should results be sorted by relevance, name, or type?
   - **Recommendation**: Use search engine's default order for MVP
   - **Future**: Add sort dropdown in P1

## Success Criteria

### Functional Requirements
- [ ] `QListWidget` visible in search panel
- [ ] `populate_results()` displays results correctly
- [ ] Result items show name, type, and context
- [ ] Single-click emits `result_selected` signal
- [ ] Double-click/Enter emits `result_selected` signal
- [ ] Up/Down arrow keys navigate results (native)
- [ ] Results limited to 100 items with truncation message
- [ ] `clear_results()` clears list and status
- [ ] `select_first_result()` navigates to first item
- [ ] Empty state shows "No results"

### Quality Requirements
- [ ] All unit tests passing (100% coverage of results logic)
- [ ] No type checking errors
- [ ] No linting warnings
- [ ] Consistent with existing SearchPanel implementation
- [ ] UI visually polished (spacing, colors, fonts)

### Documentation Requirements
- [ ] Docstrings for `SearchResultItem` class
- [ ] Docstrings for all new methods
- [ ] Comments explaining truncation logic
- [ ] TODO comment in `_get_type_icon()` for future implementation

## Future Considerations

### P1 Enhancements
- **Actual Icons**: Load type-specific icons from resources
- **Result Preview**: Show object properties on hover
- **Context Menu**: Right-click for actions (Copy ID, Expand, Add to Watchlist)
- **Multi-Selection**: Ctrl+Click for batch operations
- **Sorting Options**: Dropdown to sort by name, type, relevance
- **Pagination**: "Load More" button instead of truncation
- **Rich Formatting**: Bold object name, gray context text

### Technical Debt
- Consider switching to `QListView` + model if performance becomes issue
- May need virtual scrolling for very large datasets (>1000 items)
- Icon loading should be async if icons are large files

### Performance
- Current implementation is synchronous (acceptable for 100 items)
- If network-based search, add loading spinner during populate
- Consider caching rendered items if re-population is slow

### Accessibility
- Verify keyboard navigation works without mouse
- Add ARIA labels for screen readers (future)
- Ensure color contrast meets WCAG standards
- Add focus indicators for selected items

## Related Documentation

- **Parent Feature**: [E05-F01 - Search Panel UI](../E05-F01.spec.md)
- **Previous Task**: [E05-F01-T02 - Type Filter Buttons](../T02/E05-F01-T02.spec.md)
- **Next Task**: [E05-F01-T04 - Search History Dropdown](../T04/E05-F01-T04.spec.md)
- **Search Engine**: [E05-F02 - Search Engine Implementation](../../F02/E05-F02.spec.md)
- **Navigation**: [E05-F04 - Navigation Integration](../../F04/E05-F04.spec.md)
- **Qt List Widgets**: https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QListWidget.html
- **Qt Item Data Roles**: https://doc.qt.io/qt-6/qt.html#ItemDataRole-enum
