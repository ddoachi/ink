---
id: E05-F01-T02
title: Type Filter Buttons
type: Task
priority: P0 (MVP)
status: Draft
parent: E05-F01
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - ui
  - filter
  - presentation-layer
clickup_task_id: ''
---

# Spec: E05-F01-T02 - Type Filter Buttons

## 1. Overview

### 1.1 Problem Statement
Users need to filter search results by object type (Cells, Pins, Nets, Ports) to narrow down large result sets. The filter buttons must be mutually exclusive, with "All" as the default option, and the selected filter should persist across searches.

### 1.2 Goals
- Add radio button group for type filtering
- Support filter options: All, Cells, Pins, Nets, Ports
- Emit filter change events when selection changes
- Persist filter selection across searches
- Display filter buttons in a horizontal row below search input

---

## 2. Technical Requirements

### 2.1 Filter Button Integration

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/panels/search_panel.py`

```python
from PySide6.QtWidgets import QRadioButton, QButtonGroup, QHBoxLayout
from enum import Enum


class SearchFilterType(Enum):
    """Search filter types."""
    ALL = "All"
    CELLS = "Cells"
    PINS = "Pins"
    NETS = "Nets"
    PORTS = "Ports"


class SearchPanel(QWidget):
    """Search panel widget for object search and navigation."""

    # Signals (add to existing)
    filter_changed = Signal(str)      # Emits filter type when changed

    def __init__(self, parent=None):
        super().__init__(parent)
        self._current_filter = SearchFilterType.ALL
        self._init_ui()
        self._connect_signals()

    def _init_ui(self):
        """Initialize UI components."""
        layout = QVBoxLayout(self)

        # ... existing search input row ...

        # Filter buttons row
        filter_row = QHBoxLayout()
        filter_label = QLabel("Filters:")
        filter_row.addWidget(filter_label)

        self.filter_group = QButtonGroup(self)
        self.filter_buttons = {}

        for filter_type in SearchFilterType:
            btn = QRadioButton(filter_type.value)
            btn.setProperty("filter_type", filter_type)
            self.filter_group.addButton(btn)
            self.filter_buttons[filter_type] = btn
            filter_row.addWidget(btn)

        # Set "All" as default
        self.filter_buttons[SearchFilterType.ALL].setChecked(True)

        filter_row.addStretch()
        layout.addLayout(filter_row)

        # ... existing status label ...

    def _connect_signals(self):
        """Connect internal signals."""
        # ... existing connections ...
        self.filter_group.buttonClicked.connect(self._on_filter_changed)

    def _on_filter_changed(self, button):
        """Handle filter button selection change."""
        filter_type = button.property("filter_type")
        self._current_filter = filter_type
        self.filter_changed.emit(filter_type.value)

        # Re-execute search with new filter if query exists
        query = self.search_input.text().strip()
        if query:
            self.search_executed.emit(query)

    def get_current_filter(self) -> SearchFilterType:
        """Get currently selected filter type."""
        return self._current_filter

    def set_filter(self, filter_type: SearchFilterType):
        """Programmatically set filter type."""
        if filter_type in self.filter_buttons:
            self.filter_buttons[filter_type].setChecked(True)
            self._current_filter = filter_type
```

### 2.2 Filter Type Enum

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/panels/search_panel.py`

Export `SearchFilterType` enum for use by search service integration:

```python
__all__ = ['SearchPanel', 'SearchFilterType']
```

---

## 3. Dependencies

- **Upstream**:
  - E05-F01-T01 (SearchPanel Widget) - must be completed first
- **Downstream**:
  - E05-F02 (Search Engine) - will use filter type to narrow results
  - E05-F03 (Results List) - will display filtered results only

---

## 4. Acceptance Criteria

- [ ] Filter button row added below search input
- [ ] Five radio buttons: All, Cells, Pins, Nets, Ports
- [ ] "All" filter selected by default
- [ ] Only one filter can be active at a time (radio button behavior)
- [ ] `filter_changed` signal emits when selection changes
- [ ] `get_current_filter()` returns currently selected filter
- [ ] `set_filter()` method programmatically sets filter
- [ ] Filter selection persists across searches
- [ ] Changing filter re-executes search if query exists
- [ ] Filter buttons styled consistently with Qt theme

---

## 5. Testing Requirements

### 5.1 Unit Tests

**Location**: `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py`

```python
def test_filter_buttons_initialization(search_panel):
    """Test filter buttons initialize with All selected."""
    assert search_panel.get_current_filter() == SearchFilterType.ALL
    assert search_panel.filter_buttons[SearchFilterType.ALL].isChecked()


def test_filter_changed_signal(search_panel, qtbot):
    """Test filter_changed signal emits on button click."""
    with qtbot.waitSignal(search_panel.filter_changed, timeout=1000) as blocker:
        search_panel.filter_buttons[SearchFilterType.CELLS].click()

    assert blocker.args[0] == "Cells"
    assert search_panel.get_current_filter() == SearchFilterType.CELLS


def test_filter_exclusive_selection(search_panel):
    """Test only one filter can be selected at a time."""
    search_panel.filter_buttons[SearchFilterType.PINS].setChecked(True)
    assert search_panel.filter_buttons[SearchFilterType.PINS].isChecked()
    assert not search_panel.filter_buttons[SearchFilterType.ALL].isChecked()

    search_panel.filter_buttons[SearchFilterType.NETS].setChecked(True)
    assert search_panel.filter_buttons[SearchFilterType.NETS].isChecked()
    assert not search_panel.filter_buttons[SearchFilterType.PINS].isChecked()


def test_set_filter_programmatically(search_panel):
    """Test set_filter method."""
    search_panel.set_filter(SearchFilterType.PORTS)
    assert search_panel.get_current_filter() == SearchFilterType.PORTS
    assert search_panel.filter_buttons[SearchFilterType.PORTS].isChecked()


def test_filter_change_retriggers_search(search_panel, qtbot):
    """Test changing filter re-executes search if query exists."""
    search_panel.search_input.setText("test_query")

    with qtbot.waitSignal(search_panel.search_executed, timeout=1000) as blocker:
        search_panel.filter_buttons[SearchFilterType.CELLS].click()

    assert blocker.args[0] == "test_query"


def test_filter_persistence(search_panel):
    """Test filter selection persists across searches."""
    search_panel.set_filter(SearchFilterType.NETS)
    search_panel.search_input.setText("net_clk")
    search_panel.search_input.returnPressed.emit()

    # Filter should still be NETS
    assert search_panel.get_current_filter() == SearchFilterType.NETS
```

---

## 6. Implementation Notes

### 6.1 Design Decisions

1. **Radio Buttons**: Use `QRadioButton` in `QButtonGroup` for exclusive selection
2. **Filter Persistence**: Store `_current_filter` as instance variable
3. **Auto Re-search**: Changing filter re-executes search if query exists (UX improvement)
4. **Enum Pattern**: Use `SearchFilterType` enum for type safety

### 6.2 UI Layout

```
┌─ Search Panel ─────────────────────────────────┐
│  Search: [___________] [History ▼]             │
│  Filters: (•All) ( Cells ) ( Pins ) ( Nets )  │  ← NEW ROW
│  ...                                            │
└────────────────────────────────────────────────┘
```

### 6.3 Future Enhancements

- Add result count per filter type (e.g., "Cells (15)")
- Add filter presets (e.g., "Sequential Only", "Combinational")
- Add custom filter expressions

---

## 7. Related Files

**Modified**:
- `/home/joohan/dev/project-ink/ink/src/ink/presentation/panels/search_panel.py`
- `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py`

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E05-F01 split |
