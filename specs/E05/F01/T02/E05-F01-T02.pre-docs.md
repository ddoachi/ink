# Pre-Implementation Documentation: E05-F01-T02 - Type Filter Buttons

## Overview

### Problem Context
Search results in gate-level netlists can return hundreds of matches across different object types (Cells, Pins, Nets, Ports). Users need a quick way to filter results by type to narrow down large result sets and find relevant objects faster. This task adds mutually exclusive radio button filters to the search panel UI.

### Goals
- Add type filter UI (radio buttons) to search panel
- Support five filter options: All, Cells, Pins, Nets, Ports
- Implement filter state management and persistence across searches
- Emit filter change events for search service integration
- Automatically re-execute search when filter changes (UX optimization)

### Scope
**In Scope:**
- `SearchFilterType` enum definition
- Radio button group UI with five filter options
- Filter state management and persistence
- Signal emission on filter change
- Automatic search re-execution when filter changes

**Out of Scope:**
- Actual result filtering logic (handled by search engine in E05-F02)
- Result count per filter type (P1 enhancement)
- Custom filter expressions (P1 enhancement)
- Filter presets (P1 enhancement)

## Implementation Approach

### Architecture Pattern
This task extends the `SearchPanel` widget with additional UI components and state management:
- Filter state stored in panel instance variable (`_current_filter`)
- Filter UI integrated into existing panel layout
- Signal-based communication for filter changes
- No direct dependency on search engine (loose coupling)

### Component Design

#### SearchFilterType Enum
```python
class SearchFilterType(Enum):
    """Search filter types matching domain model."""
    ALL = "All"        # No filtering
    CELLS = "Cells"    # Cell instances only
    PINS = "Pins"      # Pin objects only
    NETS = "Nets"      # Net objects only
    PORTS = "Ports"    # Port objects only
```

**Design Rationale:**
- Enum provides type safety and IDE autocomplete
- String values match UI display text
- Extensible for future filter types without breaking changes
- Exported from module for use by search service

#### Updated Panel Layout
```
SearchPanel (QWidget)
├── Search Input Row (QHBoxLayout)
│   ├── Label: "Search:"
│   ├── QLineEdit (search_input)
│   └── QComboBox (history_dropdown) [T04]
├── Filter Buttons Row (QHBoxLayout)  ← NEW
│   ├── Label: "Filters:"
│   ├── QRadioButton ("All") [checked by default]
│   ├── QRadioButton ("Cells")
│   ├── QRadioButton ("Pins")
│   ├── QRadioButton ("Nets")
│   ├── QRadioButton ("Ports")
│   └── Stretch (push buttons left)
├── Results List [T03]
└── Status Label
```

#### Signal Flow
```
User Action                  SearchPanel Signal         Handler
──────────────────────────────────────────────────────────────────
Click filter button  →       filter_changed(str)    →   [Optional listener]
                     →       search_executed(str)   →   _execute_search()
                                                           (with new filter)
```

### State Management

#### Filter State Storage
```python
self._current_filter: SearchFilterType = SearchFilterType.ALL
```

**Rationale:**
- Simple instance variable, no need for complex state management
- Persists across searches within same panel instance
- Cleared when panel is destroyed (acceptable for MVP)
- Future: Can be saved to QSettings for cross-session persistence

#### Filter Change Behavior
When user clicks a different filter button:
1. Update `_current_filter` instance variable
2. Emit `filter_changed` signal with filter type string
3. If search query exists, re-execute search with new filter

**UX Rationale:** Auto re-search provides immediate feedback and saves user a keystroke.

### Integration Points

#### Filter Data Flow
```
SearchPanel                  Application Service         Domain Service
────────────────────────────────────────────────────────────────────────
User selects "Cells"
  ↓
_on_filter_changed()
  ↓
self._current_filter = CELLS
  ↓
emit filter_changed("Cells")
  ↓
emit search_executed(query)  →  execute_search(query)  →  search(query, filter_type)
                                                             ↓
                                 populate_results()  ←  filtered results
```

#### Export for Search Integration
```python
# In search_panel.py
__all__ = ['SearchPanel', 'SearchFilterType']

# In search service integration
from ink.presentation.panels.search_panel import SearchFilterType

def _execute_search(self, query: str):
    filter_type = self.search_panel.get_current_filter()
    results = self.search_service.search(query, filter_type.value)
    self.search_panel.populate_results(results)
```

## Key Design Decisions

### 1. Radio Buttons vs Checkboxes
**Decision:** Use `QRadioButton` in `QButtonGroup` for mutually exclusive selection

**Rationale:**
- Enforces single active filter (clearer UX)
- Aligns with common search UI patterns (e.g., file explorers)
- Simpler state management (single enum value vs bitmask)
- "All" option provides clear way to disable filtering

**Alternative Considered:** Checkboxes for multi-select filtering
- Rejected: Complexity of combining multiple filters, unclear UX ("Cells AND Nets" vs "Cells OR Nets")
- Future: Could add as advanced filter option in P1

### 2. Auto Re-search on Filter Change
**Decision:** Automatically re-execute search when filter changes if query exists

**Rationale:**
- Immediate feedback improves UX
- Expected behavior (similar to filter in file browsers)
- Saves user from pressing Enter again
- Low performance cost (search is already cached/optimized in E05-F02)

**Alternative Considered:** Require manual search re-execution
- Rejected: Extra user action, less intuitive

### 3. Filter Persistence Across Searches
**Decision:** Maintain filter selection across multiple searches within same session

**Rationale:**
- User likely searching for similar object types
- Reduces repetitive filter selection
- Standard search UI behavior

**Alternative Considered:** Reset to "All" after each search
- Rejected: Annoying for users searching multiple objects of same type

### 4. Enum Pattern for Filter Types
**Decision:** Use Python `Enum` instead of string constants

**Rationale:**
- Type safety (mypy will catch invalid filter types)
- IDE autocomplete and refactoring support
- Centralized definition (single source of truth)
- Extensible (easy to add new filter types)

**Alternative Considered:** String constants
- Rejected: No type safety, error-prone

### 5. QButtonGroup for Radio Button Management
**Decision:** Use `QButtonGroup` to manage radio button exclusivity

**Rationale:**
- Automatic mutual exclusivity (Qt handles state)
- Single signal connection point (`buttonClicked`)
- Cleaner code than manual button state management

**Alternative Considered:** Manual button state management with signal connections
- Rejected: More code, error-prone, reinvents Qt functionality

## Dependencies and Integration Points

### Upstream Dependencies
1. **E05-F01-T01 (SearchPanel Widget)**: Must be completed first
   - Extends existing `SearchPanel` class
   - Inserts filter row into existing layout
   - Uses existing `search_executed` signal

2. **PySide6 Components**:
   - `QRadioButton` for filter buttons
   - `QButtonGroup` for mutual exclusivity
   - `QHBoxLayout` for horizontal filter row

### Downstream Consumers
1. **E05-F02 (Search Engine)**: Will use `SearchFilterType` enum
   - Search service receives filter type via signal connection
   - Filters results based on enum value before returning

2. **E05-F03 (Results List - T03)**: Will display only filtered results
   - No direct dependency, but results list shows filtered data
   - Status label shows count of filtered results

3. **Future Enhancements**:
   - Result count per filter type (P1)
   - Filter presets (P1)
   - Custom filter expressions (P1)

### Interface Contracts

#### SearchPanel Extensions
```python
class SearchPanel(QWidget):
    # New signal
    filter_changed: Signal[str]  # Emits filter type name

    # New methods
    def get_current_filter(self) -> SearchFilterType
    def set_filter(self, filter_type: SearchFilterType) -> None

    # New instance variable
    self._current_filter: SearchFilterType

    # New UI components
    self.filter_group: QButtonGroup
    self.filter_buttons: dict[SearchFilterType, QRadioButton]
```

#### Module Exports
```python
__all__ = ['SearchPanel', 'SearchFilterType']
```

## Testing Strategy

### Unit Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py` (extend existing)

**Test Categories:**
1. **Initialization Tests**: Verify default filter state ("All" selected)
2. **Signal Tests**: Verify `filter_changed` signal emits with correct value
3. **Exclusivity Tests**: Verify only one filter can be active at a time
4. **Persistence Tests**: Verify filter selection persists across searches
5. **Re-search Tests**: Verify changing filter re-executes search if query exists
6. **Programmatic Tests**: Verify `set_filter()` method works correctly

**New Test Cases:**
- `test_filter_buttons_initialization`: Verify "All" is default
- `test_filter_changed_signal`: Use `qtbot.waitSignal()` to verify emission
- `test_filter_exclusive_selection`: Verify mutual exclusivity
- `test_set_filter_programmatically`: Verify `set_filter()` method
- `test_filter_change_retriggers_search`: Verify auto re-search behavior
- `test_filter_persistence`: Verify filter doesn't reset after search

**Edge Cases to Test:**
- Changing filter when search input is empty (should not trigger search)
- Selecting already-selected filter (should be no-op)
- Programmatic filter change should not trigger re-search

### Integration Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/integration/test_search_integration.py` (future task)

**Test Scenarios:**
- Filter selection properly filters search results
- Changing filter updates result count correctly
- Filter state passed correctly to search service

### Manual Testing Checklist
- [ ] All five filter buttons visible and labeled correctly
- [ ] "All" filter selected by default
- [ ] Clicking filter buttons changes selection (visual feedback)
- [ ] Only one filter active at a time
- [ ] Changing filter with query re-executes search
- [ ] Changing filter without query does nothing
- [ ] Filter buttons styled consistently with Qt theme
- [ ] Filter buttons accessible via keyboard (Tab navigation)

## Risks and Considerations

### Risk 1: Layout Space Constraints
**Risk Level:** Low

**Description:** Adding a new horizontal row may cause vertical space issues on small screens.

**Mitigation:**
1. Use minimal vertical spacing between rows
2. Filter buttons are small (radio buttons are compact)
3. Use `addStretch()` to prevent horizontal expansion
4. Test on different screen sizes

**Contingency:** If space is tight, could move filters to dropdown or toolbar (deviates from spec, would need approval).

### Risk 2: Filter Type Mismatch with Domain Model
**Risk Level:** Low

**Description:** Filter enum values must match domain object types exactly.

**Mitigation:**
1. Verify object type names in domain layer before implementation
2. Use string matching in search service, not object type comparison
3. Document mapping between filter enum and domain types

**Contingency:** If domain types differ, add mapping dictionary in search service.

### Risk 3: Signal Connection Ordering
**Risk Level:** Low

**Description:** `filter_changed` and `search_executed` signals emit in sequence; handlers must be connected properly.

**Mitigation:**
1. Document signal emission order in code comments
2. Make signals independent (handlers shouldn't depend on order)
3. Test with multiple signal connections

**Contingency:** If order matters, combine into single signal with filter parameter.

### Risk 4: Performance on Filter Change
**Risk Level:** Very Low

**Description:** Auto re-search on filter change could cause UI lag on large result sets.

**Mitigation:**
1. Search engine should be optimized for quick filtering (E05-F02)
2. Results are already limited to 100 items (T03)
3. Could add debouncing if needed (unlikely for single click)

**Contingency:** Add loading indicator or async search execution if performance issues occur.

## Implementation Checklist

### Pre-Implementation
- [ ] Verify T01 (SearchPanel Widget) is completed and tested
- [ ] Review domain model object types (Cell, Pin, Net, Port) for naming consistency
- [ ] Check existing Qt theme for radio button styling

### Implementation
- [ ] Add `SearchFilterType` enum to `search_panel.py`
- [ ] Add `filter_changed` signal to `SearchPanel` class
- [ ] Add `_current_filter` instance variable in `__init__()`
- [ ] Create filter row layout in `_init_ui()`
- [ ] Create `QButtonGroup` and five `QRadioButton` instances
- [ ] Set "All" button as checked by default
- [ ] Store button references in `filter_buttons` dictionary
- [ ] Connect `buttonClicked` signal to `_on_filter_changed()` handler
- [ ] Implement `_on_filter_changed()` method (update state, emit signals)
- [ ] Implement `get_current_filter()` method
- [ ] Implement `set_filter()` method
- [ ] Update `_on_search_triggered()` to add query to history (prep for T04)
- [ ] Update module `__all__` to export `SearchFilterType`

### Testing
- [ ] Add test cases to `test_search_panel.py` (6 new tests)
- [ ] Test filter initialization
- [ ] Test signal emissions with `qtbot.waitSignal()`
- [ ] Test filter exclusivity
- [ ] Test filter persistence
- [ ] Test auto re-search behavior
- [ ] Test programmatic filter setting
- [ ] Run tests: `uv run pytest tests/ui/panels/test_search_panel.py::test_filter* -v`

### Validation
- [ ] All acceptance criteria met (10 items from spec)
- [ ] All new tests passing
- [ ] Existing T01 tests still passing (regression check)
- [ ] No linting errors
- [ ] Type hints correct (mypy passes)
- [ ] Manual testing checklist completed
- [ ] Code follows existing panel patterns

## Open Questions

1. **Domain Object Type Names**: Are object types in domain model exactly "Cell", "Pin", "Net", "Port"?
   - **Action Required**: Verify in `src/ink/domain/model/` before implementation
   - **Fallback**: Use string matching with case-insensitive comparison

2. **Filter Icon Integration**: Should filter buttons have icons in addition to text?
   - **Recommendation**: Text-only for MVP (consistent with spec)
   - **Future**: Add icons in P1 for visual clarity

3. **Filter Button Spacing**: What spacing should be used between filter buttons?
   - **Recommendation**: Use Qt default spacing (6px)
   - **Action**: Test visually and adjust if needed

4. **Keyboard Shortcuts for Filters**: Should there be shortcuts like `Alt+1` for "All", `Alt+2` for "Cells", etc.?
   - **Recommendation**: Not in MVP (T05 handles search-level shortcuts only)
   - **Future**: Consider for P1 power-user features

## Success Criteria

### Functional Requirements
- [ ] Five radio buttons visible and operational
- [ ] "All" filter selected by default
- [ ] Filter selection is mutually exclusive
- [ ] `filter_changed` signal emits on selection change
- [ ] Changing filter re-executes search if query exists
- [ ] Filter persists across multiple searches
- [ ] `get_current_filter()` returns correct filter type
- [ ] `set_filter()` updates UI and state correctly

### Quality Requirements
- [ ] All unit tests passing (100% coverage of filter logic)
- [ ] No type checking errors
- [ ] No linting warnings
- [ ] Consistent with existing SearchPanel implementation
- [ ] UI visually consistent with Qt theme

### Documentation Requirements
- [ ] Docstrings for `SearchFilterType` enum
- [ ] Docstrings for new methods
- [ ] Inline comments explaining filter state management
- [ ] Comments for future integration points (result count per filter)

## Future Considerations

### P1 Enhancements
- **Result Count per Filter**: Show "(15)" next to "Cells" button
- **Filter Presets**: "Sequential Only", "Combinational Only"
- **Custom Expressions**: Text-based filter expressions (e.g., "type:Cell AND name:clk*")
- **Filter Icons**: Add type icons to radio buttons
- **Keyboard Shortcuts**: `Alt+1` through `Alt+5` for quick filter switching

### Technical Debt
- Consider extracting filter logic to separate class if complexity grows
- May need refactoring if many filter types added (dropdown instead of buttons)

### Performance
- Current implementation is synchronous and lightweight
- No performance concerns for MVP (simple radio button state)
- Auto re-search performance depends on search engine optimization (E05-F02)

### Accessibility
- Verify keyboard navigation works (Tab between buttons, Space to select)
- Consider adding ARIA labels for screen readers (future)
- Ensure visual feedback for selected state meets accessibility standards

## Related Documentation

- **Parent Feature**: [E05-F01 - Search Panel UI](../E05-F01.spec.md)
- **Previous Task**: [E05-F01-T01 - SearchPanel Widget Foundation](../T01/E05-F01-T01.spec.md)
- **Next Task**: [E05-F01-T03 - Results List Widget](../T03/E05-F01-T03.spec.md)
- **Search Engine**: [E05-F02 - Search Engine Implementation](../../F02/E05-F02.spec.md)
- **Qt Radio Buttons**: https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QRadioButton.html
- **Qt Button Groups**: https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QButtonGroup.html
- **Python Enums**: https://docs.python.org/3/library/enum.html
