# Pre-Implementation Documentation: E05-F01-T05 - Keyboard Shortcuts Integration

## Overview

### Problem Context
Power users rely on keyboard-driven workflows for efficiency. The search panel needs keyboard-first access to enable fast search without reaching for the mouse. Standard shortcuts like `Ctrl+F` for search and `Escape` to close are essential for a professional developer tool. Additionally, keyboard navigation within search results (arrow keys, Enter) must work seamlessly.

### Goals
- Implement global `Ctrl+F` shortcut to open search panel and focus input
- Implement `Escape` key to close search panel and return focus to canvas
- Support `Enter` key in search input to execute search
- Support `Enter` key in results list to navigate to selected result
- Leverage native `QListWidget` keyboard navigation (Up/Down arrows)
- Prevent shortcut conflicts with existing application shortcuts
- Provide focus management for smooth user experience

### Scope
**In Scope:**
- `Ctrl+F` shortcut registration at main window level
- `Escape` key handling in search panel
- `Enter` key behavior in search input (execute search)
- `Enter` key behavior in results list (navigate to result)
- Focus management (canvas → search → canvas)
- Integration with existing keyboard navigation (Up/Down in results list)

**Out of Scope:**
- Advanced search shortcuts (`Ctrl+Shift+F` for advanced search - P1)
- Next/Previous result navigation (`F3`/`Shift+F3` - P1)
- Alternative search shortcuts (`Ctrl+K` - P1)
- Configurable shortcuts (settings panel - P1)
- Keyboard shortcut hints in UI (tooltips - P1)

## Implementation Approach

### Architecture Pattern
Keyboard shortcuts are implemented at two levels:
1. **Global Shortcuts (Main Window)**: `Ctrl+F` registered as `QAction`
2. **Local Shortcuts (Search Panel)**: `Escape` handled via `keyPressEvent()` override

**Rationale:**
- Global shortcuts work regardless of focus context
- Local shortcuts allow context-specific behavior
- Separates concerns (main window owns global shortcuts, panel owns panel-specific shortcuts)

### Component Design

#### Main Window Shortcut Registration
```python
class MainWindow(QMainWindow):
    def _setup_shortcuts(self):
        """Register application-wide keyboard shortcuts."""
        # Search panel shortcuts
        self.search_shortcut = QAction("Open Search", self)
        self.search_shortcut.setShortcut(QKeySequence("Ctrl+F"))
        self.search_shortcut.triggered.connect(self._open_search_panel)
        self.addAction(self.search_shortcut)

        # Future: Other global shortcuts (Ctrl+Z, Ctrl+Y, etc.)
```

**Design Rationale:**
- `QAction` is Qt's standard mechanism for shortcuts
- `QKeySequence` provides cross-platform key mapping
- `addAction()` registers shortcut globally within window
- `triggered` signal provides clean separation

#### Search Panel Key Handling
```python
class SearchPanel(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._init_ui()
        self._connect_signals()
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)  # Enable key events

    def keyPressEvent(self, event: QEvent):
        """Handle key press events."""
        if event.key() == Qt.Key.Key_Escape:
            self._on_close_requested()
            event.accept()  # Mark event as handled
        else:
            super().keyPressEvent(event)  # Pass to parent
```

**Design Rationale:**
- Override `keyPressEvent()` for context-specific handling
- `setFocusPolicy(StrongFocus)` ensures widget receives key events
- `event.accept()` prevents event propagation
- `super().keyPressEvent()` maintains default behavior for other keys

#### Focus Flow Diagram
```
Initial State: Canvas has focus
    ↓
User presses Ctrl+F
    ↓
main_window._open_search_panel()
    ↓
search_panel.setVisible(True)
search_panel.focus_search_input()
    ↓
search_input.setFocus()
search_input.selectAll()
    ↓
State: Search input has focus, text selected
    ↓
User types query, presses Enter
    ↓
search_executed signal emitted
Results populated
    ↓
User presses Escape
    ↓
search_panel._on_close_requested()
    ↓
search_closed signal emitted
search_panel.setVisible(False)
    ↓
main_window._on_search_closed()
    ↓
canvas.setFocus()
    ↓
State: Canvas has focus (ready for next action)
```

### Signal Flow
```
Keyboard Event              Handler                     Action
──────────────────────────────────────────────────────────────────────
Ctrl+F (global)     →      main_window._open_search_panel()
                      →    search_panel.setVisible(True)
                      →    search_panel.focus_search_input()
                      →    search_input.setFocus()
                      →    search_input.selectAll()

Escape (in panel)   →      search_panel.keyPressEvent()
                      →    search_panel._on_close_requested()
                      →    emit search_closed
                      →    main_window._on_search_closed()
                      →    search_panel.setVisible(False)
                      →    canvas.setFocus()

Enter (in input)    →      search_input.returnPressed
                      →    search_panel._on_enter_pressed()
                      →    emit search_executed(query)

Enter (in results)  →      results_list.itemActivated
                      →    search_panel._on_result_activated()
                      →    emit result_selected(object_id)

Up/Down (in results)→      QListWidget native behavior
                      →    Selection changes (no custom code needed)
```

## Key Design Decisions

### 1. Global vs Application-Wide Shortcuts
**Decision:** Use `QAction` added to main window, not application-level shortcuts

**Rationale:**
- Window-level shortcuts sufficient for single-window app
- Cleaner lifecycle management (shortcuts destroyed with window)
- Easier to test (can create isolated window instances)
- Follows Qt best practices

**Alternative Considered:** `QShortcut` widget
- Rejected: `QAction` is more flexible, can be reused in menus/toolbars

**Alternative Considered:** Application-level global shortcuts
- Rejected: Overkill for single-window app, harder to manage

### 2. Escape Key Handling Location
**Decision:** Handle `Escape` in `SearchPanel.keyPressEvent()`, not global shortcut

**Rationale:**
- Context-specific (only close when panel has focus)
- Doesn't interfere with other widgets' Escape handling
- More predictable behavior (only works when panel active)

**Alternative Considered:** Global `Escape` shortcut
- Rejected: Would close panel even when user is editing other widgets

### 3. Enter Key Behavior in Search Input
**Decision:** Execute search on Enter (already implemented in T01), don't navigate to first result automatically

**Rationale:**
- User may want to review results before navigating
- Clear separation: Enter = search, clicking/Enter in results = navigate
- Allows user to refine search before acting on results

**Alternative Considered:** Auto-navigate to first result on Enter
- Rejected: Too aggressive, removes user control

### 4. Focus Return on Close
**Decision:** Return focus to canvas when search panel closes

**Rationale:**
- Canvas is primary interaction area
- Smooth workflow: search → navigate → continue exploring
- Prevents "lost focus" state (no widget has focus)

**Alternative Considered:** Return focus to previously focused widget
- Rejected: More complex to track, canvas is safe default

### 5. Text Selection on Open
**Decision:** Select all text in search input when panel opens

**Rationale:**
- User can immediately type new query (replaces old query)
- Standard search UX (browsers, IDEs)
- Fast workflow: `Ctrl+F`, type, Enter

**Alternative Considered:** Place cursor at end without selection
- Rejected: Requires additional keystrokes to clear old query

### 6. Native List Navigation
**Decision:** Rely on `QListWidget` built-in keyboard navigation, no custom code

**Rationale:**
- Qt already provides robust keyboard navigation
- Up/Down arrows, Page Up/Down, Home/End all work automatically
- Reduces code complexity and maintenance
- Users already familiar with Qt list behavior

**Alternative Considered:** Custom arrow key handling
- Rejected: Reinvents wheel, error-prone

## Dependencies and Integration Points

### Upstream Dependencies
1. **E05-F01-T01 (SearchPanel Widget)**: Extends with focus management
2. **E05-F01-T03 (Results List)**: Uses `itemActivated` signal for Enter key
3. **Main Window Implementation**: Must have canvas widget with `setFocus()` method
4. **PySide6 Components**: `QAction`, `QKeySequence`, `Qt.Key`, `QEvent`

### Downstream Consumers
1. **End Users**: Primary beneficiaries of keyboard shortcuts
2. **Future Shortcuts**: Establishes pattern for other shortcuts
   - Undo/Redo: `Ctrl+Z`, `Ctrl+Y`
   - Zoom: `Ctrl++`, `Ctrl+-`
   - Expand/Collapse: `E`, `C`

### Interface Contracts

#### MainWindow Extensions
```python
class MainWindow(QMainWindow):
    # New methods
    def _setup_shortcuts(self) -> None
    def _open_search_panel(self) -> None
    def _on_search_closed(self) -> None

    # New instance variables
    self.search_shortcut: QAction

    # Existing methods used
    self.show_search_panel() -> None  # From T01
    self.hide_search_panel() -> None  # From T01
```

#### SearchPanel Extensions
```python
class SearchPanel(QWidget):
    # Overridden methods
    def keyPressEvent(self, event: QEvent) -> None

    # New private methods
    def _on_close_requested(self) -> None
    def _on_enter_pressed(self) -> None

    # Existing methods used
    def focus_search_input(self) -> None  # From T01

    # Existing signals used
    search_executed: Signal[str]  # From T01
    search_closed: Signal[]  # From T01
    result_selected: Signal[str]  # From T01
```

## Testing Strategy

### Unit Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/ui/panels/test_search_panel.py` (extend existing)

**Test Categories:**
1. **Escape Key Tests**: Verify Escape closes panel and emits signal
2. **Enter Key Tests**: Verify Enter executes search in input
3. **Focus Tests**: Verify focus management (input selection)

**New Test Cases:**
- `test_escape_key_closes_panel`: Use `QTest.keyPress()` to simulate Escape
- `test_enter_key_executes_search`: Verify signal emission
- `test_focus_search_input_selects_text`: Verify text selection

**Testing Pattern:**
```python
from PySide6.QtCore import Qt
from PySide6.QtTest import QTest

def test_escape_key_closes_panel(search_panel, qtbot):
    search_panel.setVisible(True)

    with qtbot.waitSignal(search_panel.search_closed, timeout=1000):
        QTest.keyPress(search_panel, Qt.Key.Key_Escape)

    assert not search_panel.isVisible()
```

### Integration Tests
**File:** `/home/joohan/dev/project-ink/ink/tests/ui/test_main_window.py` (extend or create)

**Test Categories:**
1. **Global Shortcut Tests**: Verify `Ctrl+F` opens panel
2. **Focus Flow Tests**: Verify focus transitions
3. **Signal Connection Tests**: Verify main window responds to panel signals

**New Test Cases:**
- `test_ctrl_f_opens_search_panel`: Simulate `Ctrl+F` keypress
- `test_escape_closes_search_panel`: Verify panel closes and focus returns
- `test_search_panel_close_returns_focus`: Verify canvas gets focus

**Testing Pattern:**
```python
from PySide6.QtGui import QKeySequence
from PySide6.QtTest import QTest

def test_ctrl_f_opens_search_panel(main_window, qtbot):
    assert not main_window.search_panel.isVisible()

    QTest.keySequence(main_window, QKeySequence("Ctrl+F"))
    qtbot.wait(100)  # Allow event processing

    assert main_window.search_panel.isVisible()
    assert main_window.search_panel.search_input.hasFocus()
```

### Manual Testing Checklist
- [ ] `Ctrl+F` opens search panel from any focused widget
- [ ] Search input receives focus and text is selected
- [ ] Typing immediately replaces selected text
- [ ] `Escape` closes search panel
- [ ] Focus returns to canvas after close
- [ ] `Enter` in search input executes search
- [ ] `Enter` in results list navigates to result
- [ ] `Up/Down` arrows navigate results list
- [ ] `Page Up/Down` work in results list
- [ ] `Home/End` keys work in results list
- [ ] Shortcuts don't conflict with browser shortcuts (if embedded)
- [ ] Shortcuts work consistently across Linux window managers

## Risks and Considerations

### Risk 1: Shortcut Conflicts
**Risk Level:** Medium

**Description:** `Ctrl+F` may conflict with browser shortcuts if app is embedded in web view, or with window manager shortcuts.

**Mitigation:**
1. Test on target platforms (Linux focus for MVP)
2. Document known conflicts in user guide
3. For MVP, assume standalone Qt application (no browser embedding)
4. Future: Make shortcuts configurable (P1)

**Contingency:** If conflicts occur, provide alternative shortcuts (e.g., `Ctrl+Shift+F`) or make configurable.

### Risk 2: Focus Management Edge Cases
**Risk Level:** Low

**Description:** Focus may not return correctly if canvas widget doesn't exist or is disabled.

**Mitigation:**
1. Verify canvas widget exists in `_on_search_closed()` before calling `setFocus()`
2. Add defensive check: `if self.canvas and self.canvas.isEnabled()`
3. Test with canvas in various states (disabled, hidden, etc.)

**Contingency:** Fall back to main window focus if canvas unavailable.

### Risk 3: Escape Key Event Propagation
**Risk Level:** Low

**Description:** Escape key may propagate to parent widgets if not properly handled.

**Mitigation:**
1. Call `event.accept()` in `keyPressEvent()` to mark event as handled
2. Test that Escape doesn't trigger other behaviors (e.g., dialog close)
3. Verify `setFocusPolicy(StrongFocus)` is set on panel

**Contingency:** Use `event.ignore()` selectively if some events need propagation.

### Risk 4: Platform-Specific Key Behavior
**Risk Level:** Low

**Description:** Key sequences may differ across platforms (Linux vs Windows vs Mac).

**Mitigation:**
1. Use `QKeySequence` class for cross-platform key mapping
2. Qt automatically maps `Ctrl` to `Cmd` on Mac
3. Test on all target platforms if possible
4. Primary platform is Linux (MVP), defer other platforms to P1

**Contingency:** Provide platform-specific shortcuts if needed.

### Risk 5: Search Input Already Has Focus
**Risk Level:** Very Low

**Description:** If search panel is already open and user presses `Ctrl+F`, behavior may be unexpected.

**Mitigation:**
1. `focus_search_input()` will select all text (user can immediately type new query)
2. This is actually desirable behavior (refresh search)
3. No special handling needed

**Contingency:** None needed (current behavior is correct).

## Implementation Checklist

### Pre-Implementation
- [ ] Verify T01 (SearchPanel Widget) is completed
- [ ] Verify T03 (Results List) is completed
- [ ] Review existing main window code for shortcut registration patterns
- [ ] Check if canvas widget has `setFocus()` method

### Main Window Implementation
- [ ] Import `QAction`, `QKeySequence` from `PySide6.QtGui`
- [ ] Add `_setup_shortcuts()` method to `MainWindow`
- [ ] Create `self.search_shortcut` as `QAction`
- [ ] Set shortcut to `Ctrl+F` using `QKeySequence`
- [ ] Connect `triggered` signal to `_open_search_panel()`
- [ ] Add action to main window with `addAction()`
- [ ] Implement `_open_search_panel()` method
  - [ ] Call `show_search_panel()`
  - [ ] Call `search_panel.focus_search_input()`
- [ ] Implement `_on_search_closed()` method
  - [ ] Call `hide_search_panel()`
  - [ ] Call `canvas.setFocus()` (with defensive check)
- [ ] Connect `search_panel.search_closed` signal to `_on_search_closed()`
- [ ] Call `_setup_shortcuts()` in `__init__()` after UI initialization

### Search Panel Implementation
- [ ] Import `Qt`, `QEvent` from `PySide6.QtCore`
- [ ] Set `FocusPolicy` to `StrongFocus` in `__init__()`
- [ ] Override `keyPressEvent(event: QEvent)` method
  - [ ] Check if `event.key() == Qt.Key.Key_Escape`
  - [ ] If yes, call `_on_close_requested()` and `event.accept()`
  - [ ] Else, call `super().keyPressEvent(event)`
- [ ] Implement `_on_close_requested()` method
  - [ ] Emit `search_closed` signal
  - [ ] Call `setVisible(False)`
- [ ] Modify `_connect_signals()` to connect `returnPressed` to `_on_enter_pressed()`
- [ ] Implement `_on_enter_pressed()` method
  - [ ] Get query from search input
  - [ ] If non-empty, emit `search_executed` signal
- [ ] Verify `itemActivated` signal already connected (from T03)

### Testing
- [ ] Add test cases to `test_search_panel.py` (3 new tests)
  - [ ] Test Escape key closes panel
  - [ ] Test Enter key executes search
  - [ ] Test focus input selects text
- [ ] Create or extend `test_main_window.py` (3 new tests)
  - [ ] Test `Ctrl+F` opens panel
  - [ ] Test Escape closes panel
  - [ ] Test focus returns to canvas
- [ ] Run unit tests: `uv run pytest tests/ui/panels/test_search_panel.py::test_escape* -v`
- [ ] Run integration tests: `uv run pytest tests/ui/test_main_window.py -v`

### Validation
- [ ] All acceptance criteria met (10 items from spec)
- [ ] All new tests passing
- [ ] All existing tests passing (T01-T04)
- [ ] No linting errors
- [ ] Type hints correct (mypy passes)
- [ ] Manual testing checklist completed
- [ ] Shortcuts documented in code comments

## Open Questions

1. **Canvas Widget Existence**: Does main window always have a canvas widget? What is its variable name?
   - **Action Required**: Inspect `main_window.py` implementation
   - **Expected**: `self.canvas` or `self.schematic_canvas`

2. **Other Shortcuts**: Are there existing keyboard shortcuts that could conflict?
   - **Action Required**: Review main window for existing `QAction` registrations
   - **Expected**: Likely none for MVP, but verify

3. **Embedded Browser**: Will app be embedded in a web view?
   - **Assumption**: No (standalone Qt app for MVP)
   - **Action**: Confirm with project requirements

4. **Mac Testing**: Should keyboard shortcuts be tested on Mac?
   - **Recommendation**: Linux priority for MVP, Mac testing in P1
   - **Rationale**: Qt handles `Ctrl`/`Cmd` mapping automatically

5. **Shortcut Documentation**: Where should shortcuts be documented for users?
   - **Recommendation**: Add to user documentation (separate from code)
   - **Future**: Add keyboard shortcut cheat sheet (Help menu or dialog)

## Success Criteria

### Functional Requirements
- [ ] `Ctrl+F` shortcut opens search panel and focuses input
- [ ] Search input text is selected when panel opens
- [ ] `Escape` key closes search panel
- [ ] Focus returns to canvas when panel closes
- [ ] `Enter` in search input executes search
- [ ] `Enter` in results list navigates to selected result
- [ ] Up/Down arrows navigate results (native behavior)
- [ ] Shortcuts work regardless of currently focused widget
- [ ] No conflicts with existing application shortcuts

### Quality Requirements
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] No type checking errors
- [ ] No linting warnings
- [ ] Keyboard navigation feels natural and responsive
- [ ] Shortcuts work consistently across Linux window managers

### Documentation Requirements
- [ ] Docstrings for new methods
- [ ] Inline comments explaining shortcut registration
- [ ] Comments documenting keyboard shortcuts summary
- [ ] TODO comments for future enhancements (configurable shortcuts)

## Future Considerations

### P1 Enhancements
- **Advanced Search Dialog**: `Ctrl+Shift+F` opens dialog with advanced options
- **Next/Previous Result**: `F3`/`Shift+F3` for result navigation (browser-style)
- **Alternative Shortcuts**: `Ctrl+K` for command palette style (VS Code)
- **Configurable Shortcuts**: Settings panel to customize key bindings
- **Keyboard Hints**: Tooltip hints showing available shortcuts
- **Cheat Sheet**: Help dialog listing all shortcuts (`F1` or `Ctrl+?`)

### Technical Debt
- Consider centralizing shortcut management if many shortcuts added
- May need shortcut conflict resolution system
- Consider creating shortcut configuration file

### Accessibility
- Ensure all keyboard shortcuts work with screen readers
- Provide keyboard-only workflow (no mouse required)
- Test with accessibility tools (AccProbe, Orca)
- Document keyboard navigation in accessibility guide

### UX Refinements
- Add visual feedback when shortcuts triggered (subtle animation)
- Show active shortcuts in status bar or tooltip
- Add "Quick Search" mode (type without Ctrl+F if canvas focused)
- Consider vim-style key bindings for power users (future)

## Related Documentation

- **Parent Feature**: [E05-F01 - Search Panel UI](../E05-F01.spec.md)
- **Previous Task**: [E05-F01-T04 - Search History Dropdown](../T04/E05-F01-T04.spec.md)
- **Related Features**:
  - [E05-F02 - Search Engine Implementation](../../F02/E05-F02.spec.md)
  - [E05-F04 - Navigation Integration](../../F04/E05-F04.spec.md)
- **Qt Documentation**:
  - QAction: https://doc.qt.io/qtforpython-6/PySide6/QtGui/QAction.html
  - QKeySequence: https://doc.qt.io/qtforpython-6/PySide6/QtGui/QKeySequence.html
  - Key Events: https://doc.qt.io/qtforpython-6/PySide6/QtCore/QEvent.html
  - QTest: https://doc.qt.io/qtforpython-6/PySide6/QtTest/QTest.html
- **Testing**:
  - pytest-qt: https://pytest-qt.readthedocs.io/en/latest/reference.html#qtbot
