# E06-F01-T03 - Dock Widget Setup: Pre-Implementation Planning

**Task**: E06-F01-T03 - Dock Widget Setup
**Date**: 2025-12-26
**Status**: Pre-Implementation
**Author**: Claude
**Estimated Hours**: 4

---

## 1. Overview

### 1.1 Purpose

This pre-implementation document provides comprehensive planning for creating three dockable panels (Hierarchy, Properties, Messages) using Qt's `QDockWidget` system. These panels provide supporting functionality around the central schematic canvas and must support standard EDA tool behaviors: docking, undocking, floating, resizing, and closing.

### 1.2 Task Summary

Create and configure three dock widgets with placeholder content:
- **Hierarchy Panel** (left): Future object tree navigation
- **Property Panel** (right): Future property inspector
- **Message Panel** (bottom): Future search results and logs

Each dock widget must:
- Be dockable in appropriate areas
- Support floating as independent window
- Support closing and re-showing
- Have resizable splitter handles
- Contain placeholder content indicating future implementation

### 1.3 Success Metrics

- All three docks created and positioned correctly
- Docks can be closed, floated, and re-docked without errors
- Splitter handles are visible and draggable
- Initial size ratios approximately match specification
- Zero Qt warnings during docking operations
- Professional appearance with clear panel identification

---

## 2. Architecture Decisions

### 2.1 Dock System: QDockWidget vs Custom Implementation

**Decision**: Use Qt's `QDockWidget` system

**Rationale**:
- **Industry Standard**: All professional EDA tools use dockable panels
- **Feature Complete**: Provides docking, floating, tabbing, resizing automatically
- **Zero Implementation Cost**: Qt handles all complex dock behavior
- **State Persistence**: Integrates with `QMainWindow.saveState()`/`restoreState()`
- **Native Look**: Matches platform window decorations

**Alternatives Considered**:
- **Manual QSplitter**: Would need to implement undocking, floating, tabbing manually
- **Custom Docking System**: Thousands of lines of complex code, bug-prone
- **Fixed Layout**: Non-resizable, inflexible (unacceptable UX)

**Trade-offs**:
- Slightly complex API (acceptable learning curve)
- Layout calculations can be approximate (Qt handles details)
- Some platform differences in appearance (acceptable variation)

### 2.2 Panel Content Strategy: Placeholders vs Partial Implementation

**Decision**: Create minimal placeholder widgets with clear labeling

**Rationale**:
- **Separation of Concerns**: Main window structure independent of panel logic
- **Parallel Development**: Other epics can implement panels simultaneously
- **Clear Expectations**: Placeholders indicate "not yet implemented"
- **Incremental Testing**: Can test dock behavior without complex content

**Placeholder Design**:
```python
class HierarchyPanel(QWidget):
    """Placeholder with centered label"""
    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout(self)
        label = QLabel("Hierarchy Panel\n(Implementation: E04-F01)", self)
        label.setAlignment(Qt.AlignCenter)
        layout.addWidget(label)
```

**Future Replacement**:
- E04-F01: Replace `HierarchyPanel` with full `QTreeView`
- E04-F04: Replace `PropertyPanel` with full property editor
- E04-F03: Replace `MessagePanel` with full search/log view

### 2.3 Dock Area Restrictions

**Decision**: Restrict each dock to logical areas only

**Configuration**:
- **Hierarchy**: Left or Right only
- **Property**: Left or Right only
- **Message**: Bottom only

**Rationale**:
- **Hierarchy/Property**: Vertical lists fit better on sides
- **Message**: Horizontal log/search results fit better on bottom
- **Prevents Awkward Layouts**: Message panel on side would waste vertical space
- **Follows Conventions**: Matches other EDA tools (Cadence, Synopsys)

**Implementation**:
```python
hierarchy_dock.setAllowedAreas(
    Qt.DockWidgetArea.LeftDockWidgetArea |
    Qt.DockWidgetArea.RightDockWidgetArea
)

message_dock.setAllowedAreas(
    Qt.DockWidgetArea.BottomDockWidgetArea
)
```

### 2.4 Initial Size Ratios

**Decision**: Use minimum sizes to guide layout, accept Qt's approximation

**Target Ratios** (from spec):
- Left hierarchy: 15% width (~240px at 1600px)
- Right property: 25% width (~400px at 1600px)
- Central canvas: 60% width (~960px at 1600px)
- Bottom message: 20% height (~180px at 900px)

**Implementation Strategy**:
```python
# Set minimum sizes to prevent unusable panels
hierarchy_dock.setMinimumWidth(150)
property_dock.setMinimumWidth(200)
message_dock.setMinimumHeight(100)

# Let Qt distribute remaining space
# Exact sizing in E06-F05 with geometry persistence
```

**Rationale**:
- **Qt's Layout is Complex**: Exact pixel-perfect ratios difficult without post-show adjustments
- **Acceptable Approximation**: Users will resize to preference anyway
- **Future Enhancement**: E06-F05 will save/restore exact sizes
- **MVP Goal**: Functional and usable, not pixel-perfect

**Trade-offs**:
- Initial layout may not match exact percentages (acceptable)
- User cannot set preferred defaults yet (P1 feature)
- Different screen sizes will have different distributions (acceptable)

---

## 3. Implementation Strategy

### 3.1 Implementation Steps

#### Step 1: Create Panel Widgets (30 minutes)

**Create package structure**:
```bash
src/ink/presentation/panels/
├── __init__.py
├── hierarchy_panel.py
├── property_panel.py
└── message_panel.py
```

**Hierarchy Panel** (`hierarchy_panel.py`):
```python
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtCore import Qt


class HierarchyPanel(QWidget):
    """
    Design hierarchy and object tree panel.

    Placeholder for MVP main window setup.
    Full implementation in E04-F01 (Object Tree).

    This placeholder displays centered text indicating the panel
    purpose and referencing the epic where full implementation will occur.

    Attributes:
        None (placeholder has no state)

    Notes:
        - Will be replaced with QTreeView in E04-F01
        - Should support expansion/collapse of hierarchy
        - Will show cells, nets, ports in tree structure
    """

    def __init__(self, parent=None):
        """
        Initialize hierarchy panel placeholder.

        Args:
            parent: Parent widget (typically InkMainWindow)
        """
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        """Setup placeholder UI."""
        layout = QVBoxLayout(self)

        placeholder = QLabel("Hierarchy Panel\n(Implementation: E04-F01)", self)
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("QLabel { color: #666; padding: 10px; }")

        layout.addWidget(placeholder)
```

**Property Panel** (`property_panel.py`):
```python
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtCore import Qt


class PropertyPanel(QWidget):
    """
    Object property inspector panel.

    Placeholder for MVP main window setup.
    Full implementation in E04-F04 (Property Inspector).
    """

    def __init__(self, parent=None):
        """Initialize property panel placeholder."""
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        """Setup placeholder UI."""
        layout = QVBoxLayout(self)

        placeholder = QLabel("Property Panel\n(Implementation: E04-F04)", self)
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("QLabel { color: #666; padding: 10px; }")

        layout.addWidget(placeholder)
```

**Message Panel** (`message_panel.py`):
```python
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtCore import Qt


class MessagePanel(QWidget):
    """
    Message log and search results panel.

    Placeholder for MVP main window setup.
    Full implementation in E04-F03 (Search Panel).
    """

    def __init__(self, parent=None):
        """Initialize message panel placeholder."""
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        """Setup placeholder UI."""
        layout = QVBoxLayout(self)

        placeholder = QLabel("Message Panel\n(Implementation: E04-F03)", self)
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("QLabel { color: #666; padding: 10px; }")

        layout.addWidget(placeholder)
```

**Package Init** (`panels/__init__.py`):
```python
"""Panel widgets for supporting UI areas."""

from ink.presentation.panels.hierarchy_panel import HierarchyPanel
from ink.presentation.panels.property_panel import PropertyPanel
from ink.presentation.panels.message_panel import MessagePanel

__all__ = ["HierarchyPanel", "PropertyPanel", "MessagePanel"]
```

#### Step 2: Integrate Dock Widgets with Main Window (45 minutes)

**Modify** `src/ink/presentation/main_window.py`:

```python
from PySide6.QtWidgets import QMainWindow, QDockWidget  # Add QDockWidget
from PySide6.QtCore import Qt, QSize
from ink.presentation.canvas.schematic_canvas import SchematicCanvas
from ink.presentation.panels.hierarchy_panel import HierarchyPanel  # NEW
from ink.presentation.panels.property_panel import PropertyPanel    # NEW
from ink.presentation.panels.message_panel import MessagePanel      # NEW


class InkMainWindow(QMainWindow):
    """Main application window shell for Ink schematic viewer."""

    def __init__(self):
        """Initialize the main window."""
        super().__init__()
        self._setup_window()
        self._setup_central_widget()
        self._setup_dock_widgets()  # NEW

    def _setup_window(self):
        """Configure main window properties."""
        self.setWindowTitle("Ink - Incremental Schematic Viewer")
        self.resize(1600, 900)
        self.setMinimumSize(QSize(1024, 768))

        # Enable dock nesting (allows complex layouts)
        self.setDockNestingEnabled(True)

    def _setup_central_widget(self):
        """Create and set central schematic canvas."""
        self.schematic_canvas = SchematicCanvas(self)
        self.setCentralWidget(self.schematic_canvas)

    def _setup_dock_widgets(self):  # NEW METHOD
        """
        Create and configure dockable panels.

        Creates three dock widgets with placeholder content:
        - Hierarchy panel (left): Design object tree
        - Property panel (right): Object property inspector
        - Message panel (bottom): Search results and logs

        Each dock is configured with:
        - Appropriate allowed areas (prevents awkward layouts)
        - Initial position
        - Minimum size (prevents unusable panels)
        - Placeholder widget content
        """
        # Left: Hierarchy panel
        self.hierarchy_panel = HierarchyPanel(self)
        self.hierarchy_dock = QDockWidget("Hierarchy", self)
        self.hierarchy_dock.setObjectName("HierarchyDock")  # For state persistence
        self.hierarchy_dock.setWidget(self.hierarchy_panel)
        self.hierarchy_dock.setAllowedAreas(
            Qt.DockWidgetArea.LeftDockWidgetArea |
            Qt.DockWidgetArea.RightDockWidgetArea
        )
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.hierarchy_dock)

        # Right: Property panel
        self.property_panel = PropertyPanel(self)
        self.property_dock = QDockWidget("Properties", self)
        self.property_dock.setObjectName("PropertyDock")
        self.property_dock.setWidget(self.property_panel)
        self.property_dock.setAllowedAreas(
            Qt.DockWidgetArea.LeftDockWidgetArea |
            Qt.DockWidgetArea.RightDockWidgetArea
        )
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.property_dock)

        # Bottom: Message panel
        self.message_panel = MessagePanel(self)
        self.message_dock = QDockWidget("Messages", self)
        self.message_dock.setObjectName("MessageDock")
        self.message_dock.setWidget(self.message_panel)
        self.message_dock.setAllowedAreas(Qt.DockWidgetArea.BottomDockWidgetArea)
        self.addDockWidget(Qt.DockWidgetArea.BottomDockWidgetArea, self.message_dock)

        # Set initial dock sizes using minimum sizes
        self._set_initial_dock_sizes()

    def _set_initial_dock_sizes(self):
        """
        Set initial size hints for dock widgets.

        Uses minimum sizes to guide Qt's layout system toward desired
        proportions. Exact sizing is approximate due to Qt's complex
        dock layout algorithm.

        Target ratios (for 1600x900 window):
        - Hierarchy (left): ~15% width (240px)
        - Property (right): ~25% width (400px)
        - Message (bottom): ~20% height (180px)
        """
        # Hierarchy (left): minimum usable width for tree
        self.hierarchy_dock.setMinimumWidth(150)
        self.hierarchy_panel.setMinimumSize(150, 200)

        # Property (right): wider for property names/values
        self.property_dock.setMinimumWidth(200)
        self.property_panel.setMinimumSize(200, 200)

        # Message (bottom): minimum for log viewing
        self.message_dock.setMinimumHeight(100)
        self.message_panel.setMinimumSize(300, 100)
```

#### Step 3: Create Unit Tests (30 minutes)

**Panel Tests** (`tests/unit/presentation/panels/test_panels.py`):

```python
import pytest
from PySide6.QtWidgets import QApplication
from ink.presentation.panels.hierarchy_panel import HierarchyPanel
from ink.presentation.panels.property_panel import PropertyPanel
from ink.presentation.panels.message_panel import MessagePanel


@pytest.fixture(scope="module")
def qapp():
    app = QApplication.instance() or QApplication([])
    yield app


def test_hierarchy_panel_creation(qapp):
    """Test hierarchy panel can be created."""
    panel = HierarchyPanel()
    assert panel is not None


def test_hierarchy_panel_with_parent(qapp):
    """Test hierarchy panel accepts parent."""
    from PySide6.QtWidgets import QWidget
    parent = QWidget()
    panel = HierarchyPanel(parent)
    assert panel.parent() == parent


def test_property_panel_creation(qapp):
    """Test property panel can be created."""
    panel = PropertyPanel()
    assert panel is not None


def test_message_panel_creation(qapp):
    """Test message panel can be created."""
    panel = MessagePanel()
    assert panel is not None
```

**Integration Tests** (`tests/integration/presentation/test_main_window_docks.py`):

```python
import pytest
from PySide6.QtWidgets import QApplication, QDockWidget
from PySide6.QtCore import Qt
from ink.presentation.main_window import InkMainWindow


@pytest.fixture(scope="module")
def qapp():
    app = QApplication.instance() or QApplication([])
    yield app


@pytest.fixture
def window(qapp):
    """Create main window for each test."""
    win = InkMainWindow()
    yield win
    win.close()


class TestDockWidgetCreation:
    """Test dock widgets are created correctly."""

    def test_hierarchy_dock_exists(self, window):
        """Test hierarchy dock is created."""
        assert hasattr(window, 'hierarchy_dock')
        assert isinstance(window.hierarchy_dock, QDockWidget)
        assert window.hierarchy_dock.windowTitle() == "Hierarchy"

    def test_property_dock_exists(self, window):
        """Test property dock is created."""
        assert hasattr(window, 'property_dock')
        assert isinstance(window.property_dock, QDockWidget)
        assert window.property_dock.windowTitle() == "Properties"

    def test_message_dock_exists(self, window):
        """Test message dock is created."""
        assert hasattr(window, 'message_dock')
        assert isinstance(window.message_dock, QDockWidget)
        assert window.message_dock.windowTitle() == "Messages"


class TestDockWidgetPositions:
    """Test docks are positioned correctly."""

    def test_hierarchy_on_left(self, window):
        """Test hierarchy dock is on left by default."""
        assert window.dockWidgetArea(window.hierarchy_dock) == \
               Qt.DockWidgetArea.LeftDockWidgetArea

    def test_property_on_right(self, window):
        """Test property dock is on right by default."""
        assert window.dockWidgetArea(window.property_dock) == \
               Qt.DockWidgetArea.RightDockWidgetArea

    def test_message_on_bottom(self, window):
        """Test message dock is on bottom by default."""
        assert window.dockWidgetArea(window.message_dock) == \
               Qt.DockWidgetArea.BottomDockWidgetArea


class TestDockWidgetBehavior:
    """Test dock widget operations."""

    def test_docks_visible_by_default(self, window):
        """Test all docks are visible initially."""
        assert window.hierarchy_dock.isVisible()
        assert window.property_dock.isVisible()
        assert window.message_dock.isVisible()

    def test_dock_can_be_closed(self, window):
        """Test dock can be closed and made visible again."""
        # Close hierarchy dock
        window.hierarchy_dock.close()
        assert not window.hierarchy_dock.isVisible()

        # Show again
        window.hierarchy_dock.show()
        assert window.hierarchy_dock.isVisible()

    def test_dock_object_names_set(self, window):
        """Test docks have object names for state persistence."""
        assert window.hierarchy_dock.objectName() == "HierarchyDock"
        assert window.property_dock.objectName() == "PropertyDock"
        assert window.message_dock.objectName() == "MessageDock"
```

#### Step 4: Manual Testing (30 minutes)

**Test Script** (`test_docks_display.py`):
```python
import sys
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


def main():
    app = QApplication(sys.argv)
    window = InkMainWindow()
    window.show()

    print("=== Manual Test Checklist ===")
    print("\nVisual Appearance:")
    print("  1. Three panels visible: Hierarchy (left), Properties (right), Messages (bottom)")
    print("  2. Each panel has clear title in title bar")
    print("  3. Each panel shows placeholder text")
    print("  4. Canvas in center is still visible")
    print("\nDock Operations:")
    print("  5. Click close button on hierarchy panel -> it hides")
    print("  6. Drag hierarchy panel title -> it undocks and floats")
    print("  7. Drag floating panel back to left -> it redocks")
    print("  8. Drag panel splitters -> panels resize")
    print("  9. All operations smooth, no glitches")

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
```

**Manual Test Checklist**:

**Visual Appearance**:
- [ ] Hierarchy panel visible on left
- [ ] Property panel visible on right
- [ ] Message panel visible on bottom
- [ ] Central canvas visible in middle
- [ ] All panel titles visible in title bars
- [ ] Placeholder text visible in each panel
- [ ] Professional appearance, no visual glitches

**Dock Operations**:
- [ ] Each panel has close button (X) in title bar
- [ ] Clicking close button hides panel
- [ ] Dragging panel title bar undocks panel (becomes floating window)
- [ ] Floating panel has its own window decorations
- [ ] Dragging floating panel to allowed area redocks it
- [ ] Redocking shows highlight to indicate drop zone
- [ ] Splitter handles visible between panels
- [ ] Dragging splitters resizes panels smoothly

**Sizing**:
- [ ] Hierarchy panel reasonable width (~200-250px)
- [ ] Property panel reasonable width (~300-400px)
- [ ] Message panel reasonable height (~150-200px)
- [ ] Panels don't take excessive space
- [ ] Canvas still has majority of area

### 3.2 Estimated Effort

| Step | Duration | Notes |
|------|----------|-------|
| Panel placeholder widgets | 30 min | Three simple similar widgets |
| Main window dock setup | 45 min | Dock creation and configuration |
| Unit tests (panels) | 15 min | Simple widget creation tests |
| Integration tests (docks) | 15 min | Dock position and behavior tests |
| Manual testing | 30 min | Thorough dock operation testing |
| Documentation | 25 min | Docstrings and comments |
| **Total** | **160 min** | **~2.7 hours (under 4-hour estimate)** |

### 3.3 Dependencies

**Upstream Dependencies**:
- Task T01: `InkMainWindow` class with `_setup_window()`
- Task T02: Central widget already set (canvas in place)

**Downstream Dependencies**:
- Task T04: Will show window with docks
- Epic E04-F01: Will replace `HierarchyPanel` placeholder
- Epic E04-F03: Will replace `MessagePanel` placeholder
- Epic E04-F04: Will replace `PropertyPanel` placeholder
- Feature E06-F05: Will add panel visibility toggling via View menu

**Critical Path**:
```
T01 → T02 → T03 → T04
```

---

## 4. Technical Deep Dive

### 4.1 QDockWidget Architecture

#### 4.1.1 Dock Widget Structure

```
QMainWindow
    ├─ Menu Bar (optional)
    ├─ Toolbar (optional)
    ├─ Left Dock Area
    │   └─ QDockWidget (Hierarchy)
    │       └─ QWidget (HierarchyPanel)
    ├─ Central Widget (SchematicCanvas)
    ├─ Right Dock Area
    │   └─ QDockWidget (Properties)
    │       └─ QWidget (PropertyPanel)
    ├─ Bottom Dock Area
    │   └─ QDockWidget (Messages)
    │       └─ QWidget (MessagePanel)
    └─ Status Bar (optional)
```

**Key Relationships**:
- `QDockWidget` is the container providing docking behavior
- `QWidget` (panel) is the content inside the dock
- `QMainWindow` manages dock positions and sizes

#### 4.1.2 Dock Widget Features

**Features Provided by Qt**:
1. **Docking**: Snap to window edges
2. **Floating**: Detach as independent window
3. **Closing**: Hide via close button
4. **Resizing**: Splitter handles between docks
5. **Tabbing**: Multiple docks in same area stack as tabs
6. **Nesting**: Docks can be arranged in complex layouts

**All Features Automatic**: No custom implementation needed.

### 4.2 Object Names and State Persistence

```python
self.hierarchy_dock.setObjectName("HierarchyDock")
```

**Purpose**:
- Required for `saveState()`/`restoreState()` to work
- Qt uses object names to identify docks across sessions
- Without object names, dock positions won't persist

**Naming Convention**:
- Use descriptive names: "HierarchyDock", not "dock1"
- Must be unique within window
- CamelCase matches Qt convention

**State Persistence** (E06-F05):
```python
# Save on close
settings.setValue("window/state", self.saveState())

# Restore on init
state = settings.value("window/state")
if state:
    self.restoreState(state)
```

### 4.3 Allowed Areas Configuration

```python
Qt.DockWidgetArea.LeftDockWidgetArea |
Qt.DockWidgetArea.RightDockWidgetArea
```

**Dock Areas**:
- `LeftDockWidgetArea`: Left edge
- `RightDockWidgetArea`: Right edge
- `TopDockWidgetArea`: Top edge
- `BottomDockWidgetArea`: Bottom edge
- `AllDockWidgetAreas`: Any edge (default)
- `NoDockWidgetArea`: Cannot be docked (always floating)

**Why Restrict Areas?**:
- **Hierarchy/Property**: Vertical panels fit better on sides
- **Message**: Horizontal log view fits better on bottom
- **Prevents Awkward Layouts**: Message on side wastes vertical space
- **User Guidance**: Restrictions guide users to sensible layouts

**Can Still Float**: Even with restricted areas, docks can still be undocked and floated.

### 4.4 Dock Sizing Challenges

**Why Sizing is Complex**:
- Qt's dock layout algorithm is non-trivial
- Multiple docks compete for space
- Window size affects distribution
- User's previous adjustments (if saved) override defaults

**Approaches**:

**Approach 1: Minimum Sizes** (Our Choice)
```python
dock.setMinimumWidth(150)
panel.setMinimumSize(150, 200)
```
- Pros: Simple, prevents unusable panels
- Cons: Doesn't control exact initial size

**Approach 2: Size Policies**
```python
panel.setSizePolicy(
    QSizePolicy.Policy.Preferred,
    QSizePolicy.Policy.Expanding
)
```
- Pros: More control over expansion behavior
- Cons: Still approximate, complex interactions

**Approach 3: Post-Show Resizing**
```python
def showEvent(self, event):
    super().showEvent(event)
    # After layout, manually resize docks
    self.resizeDocks(
        [self.hierarchy_dock, self.property_dock],
        [240, 400],
        Qt.Orientation.Horizontal
    )
```
- Pros: Exact initial sizes
- Cons: Requires `showEvent` override, more complex

**Approach 4: QSplitter** (Not Recommended)
- Pros: Exact size control
- Cons: Loses docking behavior, must implement manually

**Decision**: Use Approach 1 (minimum sizes) for MVP. E06-F05 will add Approach 3 for precise defaults plus persistence.

### 4.5 Dock Widget Features Control

**Features Available**:
```python
dock.setFeatures(
    QDockWidget.DockWidgetFeature.DockWidgetClosable |    # Close button
    QDockWidget.DockWidgetFeature.DockWidgetMovable |     # Can drag
    QDockWidget.DockWidgetFeature.DockWidgetFloatable     # Can undock
)
```

**Default** (if not set): All features enabled.

**For This Task**: Use defaults (all features enabled).

**Future Customization**:
- Disable close on critical panels
- Disable floating for panels that should stay docked
- Disable moving for fixed layouts

---

## 5. Risk Analysis

### 5.1 Technical Risks

#### Risk 1: Docks Don't Appear in Correct Positions

**Impact**: Medium (poor initial UX but still functional)
**Probability**: Low
**Description**: Docks appear in wrong areas or stacked incorrectly

**Root Causes**:
- `addDockWidget()` called with wrong area
- Docks added in wrong order
- Allowed areas too restrictive

**Mitigation**:
- Carefully specify `Qt.DockWidgetArea` in `addDockWidget()`
- Test immediately after implementation
- Verify with `dockWidgetArea()` in tests

**Contingency**:
```python
# If positioning issues
# Force specific layout after adding all docks
self.splitDockWidget(
    self.hierarchy_dock,
    self.property_dock,
    Qt.Orientation.Horizontal
)
```

#### Risk 2: Splitter Handles Not Visible

**Impact**: Low (functionality works but discoverability poor)
**Probability**: Low
**Description**: Users don't see resize handles between panels

**Root Causes**:
- Qt theme doesn't style splitters prominently
- High-DPI scaling makes handles too thin
- System theme overrides

**Mitigation**:
- Test on multiple themes
- Add custom splitter styling in T05 if needed
- Default Qt splitters usually visible enough

**Contingency** (in T05):
```python
self.setStyleSheet("""
    QSplitter::handle {
        background-color: #d0d0d0;
    }
    QSplitter::handle:hover {
        background-color: #b0b0b0;
    }
    QSplitter::handle:horizontal {
        width: 2px;
    }
    QSplitter::handle:vertical {
        height: 2px;
    }
""")
```

#### Risk 3: Initial Sizes Not Meeting Ratios

**Impact**: Low (cosmetic, user can resize)
**Probability**: Medium
**Description**: Docks too narrow/wide/tall on first launch

**Root Causes**:
- Qt's layout algorithm approximates
- Different screen sizes affect distribution
- Minimum sizes override ratios

**Mitigation**:
- Accept approximate sizing for MVP
- Document that E06-F05 will add precise defaults
- Test on multiple screen sizes
- Ensure panels are at least usable (minimum sizes)

**Contingency**:
- If panels too small, increase minimum sizes
- If panels too large, decrease minimum sizes
- Document workaround: user can resize and save in E06-F05

#### Risk 4: Memory Leak from Dock Ownership

**Impact**: Low (only in long sessions)
**Probability**: Very Low
**Description**: Panel widgets not deleted when dock closed

**Root Causes**:
- Panel widget parent not set correctly
- Dock widget doesn't own content widget

**Mitigation**:
- Always pass `parent=self` to panel constructors
- Verify panel parent is main window
- Test with repeated close/show cycles

**Verification**:
```python
# Check ownership
panel = HierarchyPanel(window)
assert panel.parent() == window

dock.setWidget(panel)
# Qt reparents to dock's internal container
# Panel still owned by hierarchy: window -> dock -> panel
```

### 5.2 Usability Risks

#### Risk 5: Users Accidentally Close Critical Panels

**Impact**: Low (panels can be re-shown via View menu in E06-F02)
**Probability**: Medium
**Description**: Users close panel and don't know how to restore

**Mitigation**:
- All panels closable by default (standard EDA behavior)
- E06-F02 will add View menu to toggle visibility
- Tooltips on close buttons (future)
- Panel remains in memory, just hidden

**Contingency**:
- If major issue, could disable close on some panels
- Better: Ensure View menu is obvious (E06-F02)

#### Risk 6: Confusing Dock States After Complex Operations

**Impact**: Low (user can reset layout)
**Probability**: Low
**Description**: After floating, tabbing, moving, layout becomes messy

**Root Causes**:
- User experimentation
- Accidental drag operations
- Multi-monitor complexity

**Mitigation**:
- Provide "Reset Layout" command (E06-F05)
- Good defaults reduce need to experiment
- Save layout state so user can recover their preferred setup

**Contingency**:
```python
# Reset Layout command (E06-F05)
def reset_layout(self):
    """Restore default dock layout."""
    # Remove all docks
    for dock in [self.hierarchy_dock, self.property_dock, self.message_dock]:
        self.removeDockWidget(dock)

    # Re-add in default positions
    self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.hierarchy_dock)
    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.property_dock)
    self.addDockWidget(Qt.DockWidgetArea.BottomDockWidgetArea, self.message_dock)
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Panel Tests** (`test_panels.py`):
- Panel instantiation (3 panels)
- Parent handling
- Basic widget properties

**Coverage Target**: 95%

### 6.2 Integration Testing

**Dock Widget Tests** (`test_main_window_docks.py`):
- Dock creation
- Dock positioning
- Dock visibility
- Dock object names
- Dock allowed areas

**Coverage Target**: 90%

### 6.3 Manual Testing

**Critical Test Cases**:

**TC-01: Initial Display**
- [ ] All three docks visible
- [ ] Correct positions (left, right, bottom)
- [ ] Reasonable sizes
- [ ] Canvas still visible in center

**TC-02: Closing Docks**
- [ ] Click close on hierarchy -> hides
- [ ] Click close on property -> hides
- [ ] Click close on message -> hides
- [ ] Canvas expands to fill space

**TC-03: Floating Docks**
- [ ] Drag hierarchy title -> undocks
- [ ] Floating hierarchy is separate window
- [ ] Floating hierarchy can be moved
- [ ] Floating hierarchy can be closed
- [ ] Drag floating hierarchy to left -> redocks

**TC-04: Resizing Docks**
- [ ] Splitter visible between hierarchy and canvas
- [ ] Drag splitter left/right -> hierarchy resizes
- [ ] Splitter visible between canvas and property
- [ ] Drag splitter left/right -> property resizes
- [ ] Splitter visible between canvas and message
- [ ] Drag splitter up/down -> message resizes

**TC-05: Tabbed Docks**
- [ ] Drag property to left area
- [ ] Property tabs with hierarchy
- [ ] Can switch between tabs
- [ ] Can drag tab back to right

**TC-06: Window Resize**
- [ ] Resize window larger -> docks scale proportionally
- [ ] Resize window smaller -> docks shrink
- [ ] Resize to minimum (1024x768) -> all docks still visible
- [ ] No layout corruption

### 6.4 Performance Testing

**Metrics**:
- Dock creation time: < 50ms (all three)
- Undock operation: < 100ms
- Redock operation: < 100ms
- Resize operation: < 16ms (60fps)

**Test Script**:
```python
import time
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


def test_dock_performance():
    app = QApplication([])
    window = InkMainWindow()

    # Measure undock
    start = time.perf_counter()
    window.hierarchy_dock.setFloating(True)
    elapsed = time.perf_counter() - start
    print(f"Undock time: {elapsed*1000:.2f}ms")
    assert elapsed < 0.1

    # Measure redock
    start = time.perf_counter()
    window.hierarchy_dock.setFloating(False)
    elapsed = time.perf_counter() - start
    print(f"Redock time: {elapsed*1000:.2f}ms")
    assert elapsed < 0.1


if __name__ == "__main__":
    test_dock_performance()
```

---

## 7. Definition of Done

### 7.1 Code Complete

- [ ] Three panel widgets implemented (`HierarchyPanel`, `PropertyPanel`, `MessagePanel`)
- [ ] Panel package `__init__.py` exports all panels
- [ ] `InkMainWindow._setup_dock_widgets()` method implemented
- [ ] Three dock widgets created with correct configuration
- [ ] Docks positioned in correct areas
- [ ] Docks have object names set
- [ ] Docks have allowed areas configured
- [ ] Initial sizes set via minimums
- [ ] All code follows PEP 8
- [ ] Type hints on all methods
- [ ] Comprehensive docstrings

### 7.2 Tests Complete

- [ ] Unit tests for all three panel widgets
- [ ] Integration tests for dock creation
- [ ] Integration tests for dock positioning
- [ ] Integration tests for dock visibility
- [ ] All tests passing
- [ ] Coverage > 90%

### 7.3 Documentation Complete

- [ ] Panel class docstrings with implementation references
- [ ] Dock setup method docstring with configuration details
- [ ] Inline comments explaining non-obvious choices
- [ ] Size setting rationale documented
- [ ] Architecture decisions in this pre-docs

### 7.4 Manual Testing Complete

- [ ] All manual test cases passed
- [ ] Tested on at least one window manager
- [ ] No visual glitches
- [ ] All dock operations smooth

### 7.5 Integration Ready

- [ ] T04 can show window with all docks
- [ ] E04 epics can replace panel placeholders
- [ ] E06-F02 can add View menu for panel toggling
- [ ] E06-F05 can add state persistence

---

## 8. Integration Points

### 8.1 For Task T04 (Application Entry Point)

**What T04 Needs**:
- Window with docks configured
- No additional setup required

**Integration**:
```python
# main.py
window = InkMainWindow()  # Creates window with docks
window.show()              # Displays window and docks
```

### 8.2 For Feature E06-F02 (Menu System)

**What E06-F02 Needs**:
- Access to dock widgets for View menu toggles

**Integration**:
```python
# In InkMainWindow (E06-F02 will add)
view_menu = menubar.addMenu("&View")

# Panels submenu
panels_menu = view_menu.addMenu("&Panels")

# Add toggle actions (Qt provides these automatically)
panels_menu.addAction(self.hierarchy_dock.toggleViewAction())
panels_menu.addAction(self.property_dock.toggleViewAction())
panels_menu.addAction(self.message_dock.toggleViewAction())
```

### 8.3 For Feature E06-F05 (Settings Persistence)

**What E06-F05 Needs**:
- Docks with object names (already set)
- Access to window state

**Integration**:
```python
# Save (E06-F05)
settings.setValue("window/state", self.saveState())

# Restore (E06-F05)
state = settings.value("window/state")
if state:
    self.restoreState(state)
```

### 8.4 For Epic E04 (Panel Implementations)

**What E04 Needs**:
- Placeholder panel widgets to replace

**Replacement Pattern**:
```python
# E04-F01 will replace HierarchyPanel
from ink.presentation.panels.hierarchy_panel import HierarchyPanel

class HierarchyPanel(QTreeView):  # Changed base class
    """Full hierarchy tree implementation."""
    # ... full implementation
```

**Main Window**: No changes needed, import path stays same.

---

## 9. Future Enhancements

### 9.1 E06-F02: View Menu Integration

**Panel Visibility Toggles**:
```python
view_menu.addAction(self.hierarchy_dock.toggleViewAction())
```

**Benefits**:
- Users can re-show closed panels
- Keyboard shortcuts for panel toggling
- Checkmarks show panel visibility state

### 9.2 E06-F05: State Persistence

**Save/Restore Layout**:
- Panel visibility (open/closed)
- Panel positions (docked/floating)
- Panel sizes (width/height)
- Floating panel geometry

**Reset Layout**:
- Restore default dock arrangement
- Clear saved state
- Useful after complex reorganization

### 9.3 Post-MVP: Advanced Dock Features

**Dock Customization**:
- Custom title bar widgets (buttons, indicators)
- Drag-and-drop between docks
- Synchronized scrolling (linked panels)

**Layout Presets**:
- Save multiple named layouts
- Switch between layouts
- Export/import layouts

**Not Recommended**: These add complexity without strong user demand.

---

## 10. Appendix

### 10.1 File Structure

**New Files**:
```
src/ink/presentation/panels/
├── __init__.py              (new)
├── hierarchy_panel.py       (new)
├── property_panel.py        (new)
└── message_panel.py         (new)

tests/unit/presentation/panels/
└── test_panels.py           (new)

tests/integration/presentation/
└── test_main_window_docks.py (new)
```

**Modified Files**:
```
src/ink/presentation/main_window.py  (add _setup_dock_widgets)
```

### 10.2 Qt Classes Used

- `PySide6.QtWidgets.QDockWidget`: Dockable container widget
- `PySide6.QtCore.Qt.DockWidgetArea`: Dock position enums
- `PySide6.QtWidgets.QWidget`: Base class for panel content
- `PySide6.QtWidgets.QVBoxLayout`: Panel layout
- `PySide6.QtWidgets.QLabel`: Placeholder text

### 10.3 Qt Documentation References

- [QDockWidget Class](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QDockWidget.html)
- [QMainWindow Docking](https://doc.qt.io/qt-6/qmainwindow.html#dock-widgets)
- [Qt Dock Widgets](https://doc.qt.io/qt-6/qdockwidget.html)

---

**Document Status**: Ready for Implementation
**Next Step**: Create `src/ink/presentation/panels/` directory and implement panel placeholders
