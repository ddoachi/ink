# E06-F01-T02 - Central Widget Setup: Pre-Implementation Planning

**Task**: E06-F01-T02 - Central Widget Setup
**Date**: 2025-12-26
**Status**: Pre-Implementation
**Author**: Claude

---

## 1. Overview

### 1.1 Purpose

This pre-implementation document provides comprehensive planning for creating a placeholder `SchematicCanvas` widget and setting it as the central widget of the main window. The central widget occupies the largest area of a `QMainWindow` and cannot be closed or moved, making it ideal for the primary schematic visualization workspace.

### 1.2 Task Summary

Create and integrate a placeholder canvas widget that:
- Provides a visual placeholder for the future schematic rendering area
- Is properly set as the central widget of `InkMainWindow`
- Uses correct Qt parent-child ownership for memory management
- Displays clearly identifying content indicating it's a placeholder
- Follows DDD architecture (presentation layer)

### 1.3 Success Metrics

- Canvas widget instantiates without errors
- Canvas fills entire central area with no gaps
- Placeholder content is clearly visible and readable
- Parent-child ownership is correctly established
- Zero Qt warnings during creation or display

---

## 2. Architecture Decisions

### 2.1 Widget Type: QWidget vs QGraphicsView

**Decision**: Use `QWidget` for placeholder, will be replaced with `QGraphicsView` in E02

**Rationale**:
- **Simplicity**: Placeholder only needs to show static text
- **Minimal Dependencies**: Don't need graphics framework yet
- **Clear Separation**: E02 (Rendering) will handle full implementation
- **Faster Development**: Can complete main window structure without rendering complexity

**Future Implementation** (E02):
```python
from PySide6.QtWidgets import QGraphicsView

class SchematicCanvas(QGraphicsView):
    """Full implementation with QGraphicsScene for schematic rendering."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        # ... rendering setup
```

**Trade-offs**:
- Need to replace entire class in E02 (acceptable)
- Placeholder cannot test rendering logic (intentional)
- Clear indication that rendering is not yet implemented (good UX)

### 2.2 Placeholder Content Strategy

**Decision**: Show centered text label with clear messaging

**Content**:
```
Schematic Canvas Area
(Rendering implementation: E02)
```

**Rationale**:
- **Clarity**: Immediately obvious what this area is for
- **Transparency**: Indicates this is a placeholder
- **Reference**: Points to implementation epic (E02)
- **Professional**: Clean appearance for testing/demos

**Alternatives Considered**:
- **Empty area**: Confusing, looks broken
- **Grid pattern**: Implies rendering capability that doesn't exist
- **Image mockup**: Misleading, suggests functionality present
- **Complex UI**: Wasted effort, will be replaced

### 2.3 Layout Strategy

**Decision**: Use `QVBoxLayout` with centered `QLabel`

**Rationale**:
- **Simplicity**: Single label centered in layout
- **Flexibility**: Easy to add more placeholder elements if needed
- **Standard Pattern**: Common Qt approach for placeholder content
- **Zero Margins**: `setContentsMargins(0, 0, 0, 0)` ensures canvas fills area

**Layout Configuration**:
```python
layout = QVBoxLayout(self)
layout.addWidget(placeholder_label)
layout.setContentsMargins(0, 0, 0, 0)
```

### 2.4 Styling Approach

**Decision**: Use inline QSS (Qt Style Sheets) for placeholder styling

**Style**:
```css
QLabel {
    background-color: #f0f0f0;  /* Light gray */
    color: #666666;              /* Dark gray text */
    font-size: 16px;
    padding: 20px;
}
```

**Rationale**:
- **Visual Distinction**: Light gray background clearly shows canvas bounds
- **Readability**: High contrast text on light background
- **Professional**: Neutral colors suitable for development/testing
- **Simple**: Inline styles sufficient for placeholder (no external .qss file needed)

---

## 3. Implementation Strategy

### 3.1 Implementation Steps

#### Step 1: Create Canvas Package Structure (5 minutes)

**Create directory structure**:
```bash
src/ink/presentation/canvas/
├── __init__.py
└── schematic_canvas.py
```

**Package initialization** (`canvas/__init__.py`):
```python
"""Canvas widgets for schematic visualization."""

from ink.presentation.canvas.schematic_canvas import SchematicCanvas

__all__ = ["SchematicCanvas"]
```

#### Step 2: Implement SchematicCanvas Placeholder (20 minutes)

**Create placeholder class**:

```python
# src/ink/presentation/canvas/schematic_canvas.py

from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtCore import Qt


class SchematicCanvas(QWidget):
    """
    Central canvas widget for schematic visualization.

    This is a placeholder implementation for the main window setup.
    Full rendering functionality will be implemented in E02 (Rendering).

    The placeholder displays centered text indicating the canvas area
    and referencing the epic where full implementation will occur.

    Attributes:
        None (placeholder has no state)

    Notes:
        - This class will be completely replaced in E02
        - E02 will use QGraphicsView instead of QWidget
        - Do not add rendering logic here
    """

    def __init__(self, parent=None):
        """
        Initialize the schematic canvas placeholder.

        Args:
            parent: Parent widget (typically InkMainWindow)
                   Setting parent enables Qt memory management.
        """
        super().__init__(parent)
        self._setup_ui()

    def _setup_ui(self):
        """Setup placeholder UI with centered label."""
        layout = QVBoxLayout(self)

        # Placeholder label
        placeholder = QLabel(
            "Schematic Canvas Area\n(Rendering implementation: E02)",
            self
        )
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("""
            QLabel {
                background-color: #f0f0f0;
                color: #666666;
                font-size: 16px;
                padding: 20px;
            }
        """)

        layout.addWidget(placeholder)

        # Remove margins so canvas fills entire area
        layout.setContentsMargins(0, 0, 0, 0)
```

#### Step 3: Integrate with Main Window (15 minutes)

**Modify** `src/ink/presentation/main_window.py`:

```python
from PySide6.QtWidgets import QMainWindow
from PySide6.QtCore import Qt, QSize
from ink.presentation.canvas.schematic_canvas import SchematicCanvas  # NEW


class InkMainWindow(QMainWindow):
    """Main application window shell for Ink schematic viewer."""

    def __init__(self):
        """Initialize the main window."""
        super().__init__()
        self._setup_window()
        self._setup_central_widget()  # NEW

    def _setup_window(self):
        """Configure main window properties."""
        self.setWindowTitle("Ink - Incremental Schematic Viewer")
        self.resize(1600, 900)
        self.setMinimumSize(QSize(1024, 768))

    def _setup_central_widget(self):  # NEW METHOD
        """
        Create and set central schematic canvas.

        Creates a SchematicCanvas widget and sets it as the central
        widget of the main window. The central widget occupies the
        main area and cannot be closed or moved.

        The canvas widget is stored as an instance attribute for
        future access by menu commands and other components.
        """
        self.schematic_canvas = SchematicCanvas(self)
        self.setCentralWidget(self.schematic_canvas)
```

#### Step 4: Create Unit Tests (30 minutes)

**Test file**: `tests/unit/presentation/canvas/test_schematic_canvas.py`

```python
import pytest
from PySide6.QtWidgets import QApplication, QWidget
from ink.presentation.canvas.schematic_canvas import SchematicCanvas


@pytest.fixture(scope="module")
def qapp():
    """Create QApplication for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app


def test_canvas_creation(qapp):
    """Test canvas can be created."""
    canvas = SchematicCanvas()
    assert canvas is not None
    assert isinstance(canvas, QWidget)


def test_canvas_with_parent(qapp):
    """Test canvas accepts parent widget."""
    parent = QWidget()
    canvas = SchematicCanvas(parent)
    assert canvas.parent() == parent


def test_canvas_no_parent(qapp):
    """Test canvas can be created without parent."""
    canvas = SchematicCanvas()
    assert canvas.parent() is None


def test_canvas_has_layout(qapp):
    """Test canvas has layout configured."""
    canvas = SchematicCanvas()
    assert canvas.layout() is not None


def test_canvas_layout_margins(qapp):
    """Test canvas layout has zero margins."""
    canvas = SchematicCanvas()
    margins = canvas.layout().contentsMargins()
    assert margins.left() == 0
    assert margins.top() == 0
    assert margins.right() == 0
    assert margins.bottom() == 0
```

**Integration test file**: `tests/integration/presentation/test_main_window_canvas.py`

```python
import pytest
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


@pytest.fixture(scope="module")
def qapp():
    """Create QApplication for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app


def test_main_window_has_central_widget(qapp):
    """Test main window has canvas as central widget."""
    window = InkMainWindow()
    assert window.centralWidget() is not None
    assert window.centralWidget() == window.schematic_canvas


def test_canvas_parent_is_main_window(qapp):
    """Test canvas parent is set to main window."""
    window = InkMainWindow()
    assert window.schematic_canvas.parent() == window


def test_canvas_fills_central_area(qapp):
    """Test canvas geometry matches central widget area."""
    window = InkMainWindow()
    window.show()

    central_geometry = window.centralWidget().geometry()

    # Canvas should fill entire central area
    assert central_geometry.width() > 0
    assert central_geometry.height() > 0

    window.close()
```

#### Step 5: Manual Testing (10 minutes)

**Test script**:
```python
# test_canvas_display.py

import sys
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


def main():
    app = QApplication(sys.argv)
    window = InkMainWindow()
    window.show()

    print("Manual Test Checklist:")
    print("1. Window displays with canvas in center")
    print("2. Canvas has light gray background")
    print("3. Placeholder text is centered and readable")
    print("4. No gaps around canvas edges")
    print("5. Canvas fills entire central area")

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
```

**Manual test checklist**:
- [ ] Canvas visible in window center
- [ ] Light gray background (#f0f0f0)
- [ ] Text "Schematic Canvas Area" visible
- [ ] Text "(Rendering implementation: E02)" visible
- [ ] Text is centered both horizontally and vertically
- [ ] Text is dark gray on light gray (readable)
- [ ] No white gaps between canvas and window edges
- [ ] Canvas resizes with window

### 3.2 Estimated Effort

| Step | Duration | Notes |
|------|----------|-------|
| Package structure | 5 min | Directory and `__init__.py` creation |
| Canvas implementation | 20 min | Simple widget with styled label |
| Main window integration | 15 min | Add method and import |
| Unit tests | 20 min | 5-6 test cases for canvas |
| Integration tests | 10 min | 3 tests for main window integration |
| Manual testing | 10 min | Visual verification |
| **Total** | **80 min** | **~1.5 hours (under 3-hour estimate)** |

### 3.3 Dependencies

**Upstream Dependencies**:
- Task T01: `InkMainWindow` class must exist
- `_setup_window()` method must be implemented

**Downstream Dependencies**:
- Task T03: Will add dock widgets around this central widget
- Task T04: Will show window with canvas
- Epic E02: Will replace placeholder with full `QGraphicsView` implementation

**Critical Path**:
```
T01 (Window Setup) → T02 (Central Widget) → T03 (Dock Widgets) → T04 (Entry Point)
```

---

## 4. Technical Deep Dive

### 4.1 Qt Central Widget Behavior

#### 4.1.1 What is a Central Widget?

In `QMainWindow` architecture:
```
┌─────────────────────────────────────┐
│         Menu Bar (optional)         │
├─────────────────────────────────────┤
│         Toolbar (optional)          │
├────┬────────────────────────────┬───┤
│    │                            │   │
│ D  │    CENTRAL WIDGET          │ D │
│ o  │    (SchematicCanvas)       │ o │
│ c  │                            │ c │
│ k  │    - Cannot be closed      │ k │
│    │    - Cannot be moved       │   │
│    │    - Always visible        │   │
│    │    - Largest area          │   │
├────┴────────────────────────────┴───┤
│         Status Bar (optional)       │
└─────────────────────────────────────┘
```

**Central Widget Properties**:
- Occupies all space not used by menus, toolbars, docks, status bar
- Exactly one central widget allowed
- Cannot be closed by user
- Cannot be moved or floated
- Automatically resizes with window
- Must be set via `setCentralWidget(widget)`

#### 4.1.2 Memory Management

**Parent-Child Ownership**:
```python
self.schematic_canvas = SchematicCanvas(self)
#                                        ^^^^
#                          Parent is InkMainWindow

self.setCentralWidget(self.schematic_canvas)
# Sets canvas as central widget (reparented to internal container)
```

**Ownership Chain**:
```
InkMainWindow (top-level)
    └─> Internal QWidget (central widget container - Qt internal)
            └─> SchematicCanvas (our widget)
                    └─> QVBoxLayout
                            └─> QLabel (placeholder text)
```

**Cleanup**:
- When `InkMainWindow` is deleted, Qt automatically deletes central widget
- When central widget is deleted, layout and label are deleted
- No manual cleanup needed
- No memory leaks

### 4.2 Layout System

#### 4.2.1 QVBoxLayout Behavior

```python
layout = QVBoxLayout(self)
# Creates vertical layout and assigns to widget

layout.addWidget(placeholder)
# Adds label to layout

layout.setContentsMargins(0, 0, 0, 0)
# Removes all margins (left, top, right, bottom)
```

**Why Zero Margins?**

With margins (default ~11px):
```
┌─────────────────────────────────┐
│ Main Window                     │
│ ┌─────────────────────────────┐ │
│ │ Canvas (light gray)         │ │  <- 11px gap
│ │   ┌─────────────────────┐   │ │
│ │   │ Placeholder Text    │   │ │
│ │   └─────────────────────┘   │ │
│ │                             │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

Without margins (our configuration):
```
┌─────────────────────────────────┐
│ Main Window                     │
│┌────────────────────────────────┐│
││ Canvas (light gray)            ││  <- No gap
││   ┌─────────────────────┐      ││
││   │ Placeholder Text    │      ││
││   └─────────────────────┘      ││
││                                ││
│└────────────────────────────────┘│
└─────────────────────────────────┘
```

**Result**: Canvas fills entire central area with no white gaps.

#### 4.2.2 Label Alignment

```python
placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
```

**Alignment Behavior**:
- `AlignCenter` = `AlignHCenter | AlignVCenter`
- Centers text both horizontally and vertically
- Text stays centered when window resizes
- Works with multi-line text (`\n`)

### 4.3 Styling Deep Dive

#### 4.3.1 Qt Style Sheets (QSS)

```css
QLabel {
    background-color: #f0f0f0;  /* RGB(240, 240, 240) */
    color: #666666;              /* RGB(102, 102, 102) */
    font-size: 16px;
    padding: 20px;
}
```

**Color Choices**:
- `#f0f0f0`: Very light gray (94% white)
  - Clearly visible as background
  - Not harsh white (easier on eyes)
  - Common in professional tools
- `#666666`: Medium gray (40% black)
  - High contrast on light background (AAA accessibility)
  - Not too dark (not distracting)
  - Professional appearance

**Font Size**: 16px
- Large enough to be clearly readable
- Not so large as to be obnoxious
- Scales well on high-DPI displays

**Padding**: 20px
- Prevents text from touching edges if label is small
- Creates visual breathing room
- Makes text more prominent

#### 4.3.2 Why Inline Styles?

**Pros of Inline**:
- Simple for single widget
- No external file management
- Easy to understand
- Placeholder will be deleted in E02 anyway

**Cons of Inline**:
- Not reusable
- Hard to maintain if complex

**Decision**: Inline is appropriate for placeholder. E02 will likely use separate `.qss` file for full theming.

### 4.4 Alternative Implementations Considered

#### Option 1: QGraphicsView Placeholder
```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        scene = QGraphicsScene(self)
        text = scene.addText("Placeholder")
        self.setScene(scene)
```

**Rejected**: More complex than needed, gives false impression of rendering capability.

#### Option 2: Custom Painted Widget
```python
class SchematicCanvas(QWidget):
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.drawText(self.rect(), Qt.AlignCenter, "Placeholder")
```

**Rejected**: Custom painting unnecessary for static text, `QLabel` simpler.

#### Option 3: Empty QWidget
```python
class SchematicCanvas(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Empty
```

**Rejected**: Looks broken, no indication of purpose.

**Selected**: Simple `QWidget` with `QLabel` is clearest, simplest, most maintainable.

---

## 5. Risk Analysis

### 5.1 Technical Risks

#### Risk 1: Canvas Doesn't Fill Central Area

**Impact**: Medium (cosmetic but noticeable)
**Probability**: Low
**Description**: White gaps appear around canvas edges

**Root Causes**:
- Layout margins not set to zero
- Canvas has non-zero content margins
- `QMainWindow` internal spacing

**Mitigation**:
- Set `layout.setContentsMargins(0, 0, 0, 0)`
- Set canvas widget's content margins if needed
- Test with window visible (geometry only valid after show)

**Contingency**:
```python
# If gaps persist
def _setup_ui(self):
    layout = QVBoxLayout(self)
    layout.addWidget(placeholder)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.setSpacing(0)  # Also remove item spacing

    # Set widget margins too
    self.setContentsMargins(0, 0, 0, 0)
```

#### Risk 2: Placeholder Text Not Centered

**Impact**: Low (cosmetic)
**Probability**: Very Low
**Description**: Text appears off-center when window resizes

**Root Causes**:
- Alignment not set correctly
- Layout stretch factors interfering

**Mitigation**:
- Use `Qt.AlignmentFlag.AlignCenter` explicitly
- Test at various window sizes
- Verify layout is `QVBoxLayout` (not Grid or other)

**Contingency**:
```python
# If centering issues
placeholder.setSizePolicy(
    QSizePolicy.Policy.Expanding,
    QSizePolicy.Policy.Expanding
)
```

#### Risk 3: Style Not Applied

**Impact**: Low (still readable, just not styled)
**Probability**: Very Low
**Description**: Background stays white, text stays black

**Root Causes**:
- QSS syntax error
- Qt style system override
- Platform style sheet interference

**Mitigation**:
- Validate QSS syntax (no errors in console)
- Test on clean Qt installation
- Use specific selector (`QLabel`) not generic

**Contingency**:
```python
# If QSS fails, use QPalette
from PySide6.QtGui import QPalette, QColor

palette = placeholder.palette()
palette.setColor(QPalette.ColorRole.Window, QColor("#f0f0f0"))
palette.setColor(QPalette.ColorRole.WindowText, QColor("#666666"))
placeholder.setAutoFillBackground(True)
placeholder.setPalette(palette)
```

### 5.2 Integration Risks

#### Risk 4: Main Window Integration Breaks T01 Tests

**Impact**: Medium (breaks existing tests)
**Probability**: Low
**Description**: Adding `_setup_central_widget()` causes T01 tests to fail

**Root Causes**:
- Canvas widget creation throws exception
- Import errors (missing module)
- T01 tests didn't expect central widget

**Mitigation**:
- Test canvas creation separately before integrating
- Ensure all imports work
- Update T01 tests if needed (acceptable evolution)

**Contingency**:
- If integration breaks tests, fix tests
- Tests should verify central widget exists (new expected behavior)

#### Risk 5: Memory Leak from Parent Ownership

**Impact**: Low (only in long-running sessions)
**Probability**: Very Low
**Description**: Canvas not properly deleted when window closes

**Root Causes**:
- Parent not set correctly
- Manual references preventing deletion

**Mitigation**:
- Always pass `parent=self` to canvas constructor
- Don't store extra references outside window
- Test with repeated create/delete cycles

**Verification**:
```python
# Memory leak test
import gc
for _ in range(1000):
    window = InkMainWindow()
    window.close()
    window.deleteLater()
    gc.collect()
# Check memory usage doesn't grow
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Canvas Tests** (`test_schematic_canvas.py`):

1. **Creation Tests**
   - Canvas instantiates without errors
   - Canvas is correct type (`QWidget`)
   - Canvas can be created with and without parent

2. **Parent Tests**
   - Parent is set correctly when provided
   - Parent is None when not provided

3. **Layout Tests**
   - Canvas has layout configured
   - Layout margins are zero
   - Layout has correct type (`QVBoxLayout`)

4. **Visual Tests** (limited in unit tests)
   - Cannot test actual rendering
   - Can verify widgets exist
   - Can verify properties set correctly

**Coverage Target**: 90% (some Qt internals not testable)

### 6.2 Integration Testing

**Main Window Integration** (`test_main_window_canvas.py`):

1. **Central Widget Tests**
   - Main window has central widget
   - Central widget is the canvas
   - Canvas parent is main window

2. **Geometry Tests**
   - Canvas fills central area
   - Canvas resizes with window
   - No gaps around canvas

3. **Lifecycle Tests**
   - Canvas created during window init
   - Canvas deleted when window deleted
   - No dangling references

**Coverage Target**: 95%

### 6.3 Manual Testing

**Visual Verification**:

**Test Case 1: Initial Display**
- [ ] Open application
- [ ] Canvas visible in center
- [ ] Light gray background
- [ ] Placeholder text centered
- [ ] Text is readable (high contrast)

**Test Case 2: Window Resize**
- [ ] Resize window to 1920x1080
- [ ] Canvas fills entire area
- [ ] Text stays centered
- [ ] No gaps around edges
- [ ] Resize to 1024x768
- [ ] Canvas still fills area
- [ ] Text still centered

**Test Case 3: Different Display Scales**
- [ ] Test on 100% DPI (1080p)
- [ ] Test on 150% DPI
- [ ] Test on 200% DPI (4K)
- [ ] Font size scales appropriately
- [ ] Layout remains intact

**Test Case 4: Theme Compatibility**
- [ ] Test with light system theme
- [ ] Test with dark system theme
- [ ] Placeholder remains visible in both
- [ ] Colors don't clash with theme

### 6.4 Performance Testing

**Metrics**:
- Canvas creation time: < 10ms
- Main window creation time: < 100ms (including canvas)
- Memory footprint: < 1MB (just canvas widget)

**Not Critical**: Canvas is extremely simple, performance should be non-issue.

---

## 7. Definition of Done

### 7.1 Code Complete

- [ ] `SchematicCanvas` class in `src/ink/presentation/canvas/schematic_canvas.py`
- [ ] Canvas `__init__` accepts optional parent parameter
- [ ] Canvas `_setup_ui()` creates placeholder label
- [ ] Label has correct text, alignment, and styling
- [ ] Layout has zero margins
- [ ] Package `__init__.py` exports `SchematicCanvas`
- [ ] `InkMainWindow._setup_central_widget()` method implemented
- [ ] Method creates canvas and sets as central widget
- [ ] Canvas stored as `self.schematic_canvas` instance variable
- [ ] All code follows PEP 8
- [ ] Type hints on all methods
- [ ] Comprehensive docstrings

### 7.2 Tests Complete

- [ ] Unit tests for canvas creation
- [ ] Unit tests for parent handling
- [ ] Unit tests for layout configuration
- [ ] Integration tests for main window
- [ ] Integration tests for central widget
- [ ] All tests passing
- [ ] Coverage > 90%

### 7.3 Documentation Complete

- [ ] Canvas class docstring with description and notes
- [ ] Method docstrings with parameters
- [ ] Comments explaining placeholder nature
- [ ] Reference to E02 for full implementation
- [ ] Architecture decisions in this pre-docs

### 7.4 Visual Quality

- [ ] Placeholder text clearly readable
- [ ] Background color visually distinct
- [ ] Professional appearance
- [ ] No visual glitches or artifacts
- [ ] Works on high-DPI displays

### 7.5 Integration Ready

- [ ] T03 can add dock widgets around canvas
- [ ] T04 can show window with canvas
- [ ] E02 can replace canvas with full implementation
- [ ] Clear replacement path documented

---

## 8. Integration Points

### 8.1 For Task T03 (Dock Widget Setup)

**What T03 Needs**:
- Central widget already set (canvas in place)
- Space around central widget for docks

**Integration**:
```python
# T03 will add dock widgets around the central widget
def _setup_dock_widgets(self):
    # ... dock creation ...
    # Central widget (canvas) remains in center
    # Docks arrange around it automatically
```

**No Changes Needed**: Central widget is already set, docks just add around it.

### 8.2 For Task T04 (Application Entry Point)

**What T04 Needs**:
- Window that can be shown
- Canvas visible when window shown

**Integration**:
```python
# main.py
window = InkMainWindow()  # Creates window with canvas
window.show()              # Displays window and canvas
```

**No Changes Needed**: Canvas is part of window, shows automatically.

### 8.3 For Epic E02 (Rendering)

**What E02 Will Do**:
- Replace `SchematicCanvas` class entirely
- Change base class from `QWidget` to `QGraphicsView`
- Add `QGraphicsScene` for rendering
- Keep same module path (`ink.presentation.canvas.schematic_canvas`)

**Replacement Strategy**:
```python
# E02 implementation (replaces entire class)
from PySide6.QtWidgets import QGraphicsView
from PySide6.QtWidgets import QGraphicsScene

class SchematicCanvas(QGraphicsView):  # Changed base class
    """Full schematic rendering canvas."""

    def __init__(self, parent=None):
        super().__init__(parent)

        # Create graphics scene
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)

        # Configure view
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setViewportUpdateMode(
            QGraphicsView.ViewportUpdateMode.FullViewportUpdate
        )

        # ... rest of rendering setup ...
```

**Main Window Changes**: None required, import path stays the same.

---

## 9. Future Enhancements

### 9.1 E02 Rendering Implementation

**Full Canvas Features**:
- `QGraphicsView` with `QGraphicsScene`
- Cell rendering with symbols
- Net routing visualization
- Zoom and pan controls
- Selection highlighting
- Hover tooltips

**Signals to Add**:
```python
class SchematicCanvas(QGraphicsView):
    # Signals for main window integration
    zoom_changed = Signal(float)      # Emits zoom percentage
    selection_changed = Signal(list)  # Emits selected cell IDs
    cell_count_changed = Signal(int)  # Emits visible cell count
```

### 9.2 Intermediate Placeholder Enhancements (Optional)

**Not Recommended**: These would be wasted effort since E02 replaces everything.

**If Needed for Demos**:
- Add simple grid background (static, not interactive)
- Add "Click to load netlist" text
- Add version/build info in corner

**Decision**: Keep current simple placeholder. Better to implement E02 sooner.

---

## 10. Appendix

### 10.1 File Structure

**New Files**:
```
src/ink/presentation/canvas/
├── __init__.py              (new)
└── schematic_canvas.py      (new)

tests/unit/presentation/canvas/
└── test_schematic_canvas.py (new)

tests/integration/presentation/
└── test_main_window_canvas.py (new)
```

**Modified Files**:
```
src/ink/presentation/main_window.py  (add _setup_central_widget method)
```

### 10.2 Qt Classes Used

- `PySide6.QtWidgets.QWidget`: Base class for placeholder
- `PySide6.QtWidgets.QVBoxLayout`: Layout for centering content
- `PySide6.QtWidgets.QLabel`: Placeholder text display
- `PySide6.QtCore.Qt.AlignmentFlag`: Text alignment constants

### 10.3 Related Documentation

- [QMainWindow Central Widget](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QMainWindow.html#PySide6.QtWidgets.QMainWindow.setCentralWidget)
- [QWidget Class](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QWidget.html)
- [QVBoxLayout](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QVBoxLayout.html)
- [Qt Style Sheets](https://doc.qt.io/qt-6/stylesheet-reference.html)

---

**Document Status**: Ready for Implementation
**Next Step**: Create `src/ink/presentation/canvas/` directory and implement `SchematicCanvas` placeholder
