---
id: E06-F01-T04
title: Application Entry Point
type: Task
priority: P0 (MVP)
status: Draft
parent: E06-F01
created: 2025-12-26
estimated_hours: 2
actual_hours:
effort: Low
tags:
  - entry-point
  - application
  - pyside6
---

# Spec: E06-F01-T04 - Application Entry Point

## 1. Overview

### 1.1 Problem Statement
Create the application entry point that initializes the Qt application instance, creates the main window, and starts the event loop. This module serves as the executable entry point for the Ink application and handles application lifecycle management.

### 1.2 Goals
- Implement `main()` function in `src/ink/main.py`
- Create `QApplication` instance with proper configuration
- Instantiate `InkMainWindow` and display it
- Handle graceful application startup and shutdown
- Enable execution via `python -m ink` or `uv run python -m ink`

---

## 2. Technical Requirements

### 2.1 Main Module Implementation

**Location**: `src/ink/main.py`

```python
"""
Ink - Incremental Schematic Viewer
Application entry point.
"""

import sys
import logging
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


def setup_logging():
    """Configure application logging."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def main():
    """
    Application entry point.

    Initializes Qt application, creates main window, and starts event loop.

    Returns:
        int: Application exit code (0 for success)
    """
    # Setup logging
    setup_logging()
    logger = logging.getLogger(__name__)

    logger.info("Starting Ink application")

    # Create Qt application instance
    app = QApplication(sys.argv)

    # Set application metadata
    app.setApplicationName("Ink")
    app.setApplicationVersion("0.1.0")
    app.setOrganizationName("InkProject")
    app.setOrganizationDomain("github.com/inkproject")

    # Create and show main window
    window = InkMainWindow()
    window.show()

    logger.info("Main window displayed")

    # Start event loop
    exit_code = app.exec()

    logger.info(f"Application exiting with code {exit_code}")
    return exit_code


if __name__ == "__main__":
    sys.exit(main())
```

### 2.2 Package Init Configuration

**Location**: `src/ink/__init__.py`

```python
"""
Ink - Incremental Schematic Viewer

A GUI tool for schematic exploration targeting gate-level netlists.
Uses incremental exploration model starting from user-selected points.
"""

__version__ = "0.1.0"
__author__ = "InkProject"

# Make main accessible for python -m ink
from ink.main import main

__all__ = ["main", "__version__"]
```

### 2.3 Module Main Entry Point

**Location**: `src/ink/__main__.py`

```python
"""
Entry point for executing Ink as a module.

Enables running with: python -m ink
"""

from ink.main import main
import sys

if __name__ == "__main__":
    sys.exit(main())
```

### 2.4 Application Metadata

| Property | Value | Purpose |
|----------|-------|---------|
| **Application Name** | "Ink" | Used by Qt for settings, resources |
| **Version** | "0.1.0" | Tracks MVP version |
| **Organization** | "InkProject" | Qt settings namespace |
| **Organization Domain** | "github.com/inkproject" | Settings uniqueness |

---

## 3. Dependencies

### 3.1 Upstream
- Task E06-F01-T01: `InkMainWindow` class
- Task E06-F01-T02: Central widget setup
- Task E06-F01-T03: Dock widgets setup

### 3.2 Downstream
- All user-facing features depend on application launching
- Enables manual testing of UI features

### 3.3 External Dependencies
- PySide6: `QApplication`
- Python standard library: `sys`, `logging`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] Application launches via `python -m ink`
- [ ] Application launches via `uv run python -m ink`
- [ ] Application launches via `python src/ink/main.py`
- [ ] Main window displays on screen
- [ ] Application runs without errors in console
- [ ] Application exits cleanly when window is closed
- [ ] Exit code is 0 for successful runs

### 4.2 Startup Performance
- [ ] Application launches in < 2 seconds on typical hardware
- [ ] No visible delay between command and window appearance
- [ ] Window appears in responsive state (not "not responding")

### 4.3 Logging Requirements
- [ ] Startup log message printed to console
- [ ] Main window display log message printed
- [ ] Exit log message with exit code printed
- [ ] Log level is INFO by default
- [ ] Log format includes timestamp, module, level, message

### 4.4 Error Handling
- [ ] Missing Qt libraries produce clear error message
- [ ] Import errors display module name and suggestion
- [ ] Uncaught exceptions logged before exit
- [ ] Window close doesn't leave zombie processes

### 4.5 Testing
- [ ] Integration test: Application starts and exits successfully
- [ ] Integration test: Exit code is 0 on normal exit
- [ ] Manual test: Launch and close application
- [ ] Manual test: Application shows in taskbar/window manager

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate `main()` function from module-level code?**
- Allows importing `main` without executing it
- Enables testing of application startup
- Standard Python entry point pattern
- Facilitates packaging (setuptools entry_points)

**Why `__main__.py`?**
- Enables `python -m ink` execution
- Standard Python module execution pattern
- Cleaner than checking `if __name__ == "__main__"` in `__init__.py`

**Why setup logging in entry point?**
- Logging available for all imports after
- Early error messages captured
- Centralized logging configuration
- Prevents duplicate handler setup

**Why set application metadata?**
- Qt uses metadata for settings file location (`~/.config/InkProject/Ink.conf`)
- Helps with desktop integration (window grouping)
- Future features: session state, recent files

**Why `sys.exit(app.exec())`?**
- `app.exec()` returns exit code from `QApplication`
- Propagates exit code to shell for scripting
- Standard Qt application pattern

### 5.2 Startup Sequence

```
1. User runs: python -m ink
2. Python executes: src/ink/__main__.py
3. __main__.py imports and calls: ink.main.main()
4. main() sets up logging
5. main() creates QApplication
6. main() sets application metadata
7. main() creates InkMainWindow
8. main() calls window.show()
9. main() calls app.exec() → starts event loop
10. User closes window → event loop exits
11. main() returns exit code
12. __main__.py calls sys.exit(exit_code)
```

### 5.3 Testing Strategy

**Integration Tests** (`tests/integration/test_application_startup.py`):
```python
import pytest
import subprocess
import sys
from pathlib import Path


def test_application_starts_via_module():
    """Test application can be started via python -m ink."""
    # Run application in subprocess, close immediately
    result = subprocess.run(
        [sys.executable, "-m", "ink", "--test-mode"],  # Future: add test mode
        capture_output=True,
        timeout=5,
        cwd=Path(__file__).parent.parent.parent / "src"
    )

    # Check it at least imports without error
    assert result.returncode in [0, -15]  # 0 or SIGTERM if timeout


def test_main_function_returns_exit_code():
    """Test main() function returns integer exit code."""
    from ink.main import main

    # This will block if window is shown, so we need test mode
    # For now, just test import
    assert callable(main)
```

**Manual Testing Checklist**:
1. Run `python -m ink` from project root
2. Verify window appears
3. Verify console shows startup logs
4. Close window via X button
5. Verify exit log printed
6. Verify terminal prompt returns (no hanging process)
7. Check exit code: `echo $?` should be 0

### 5.4 Future Enhancements

**Command-line arguments** (P1):
```python
import argparse

def parse_args():
    parser = argparse.ArgumentParser(description="Ink - Incremental Schematic Viewer")
    parser.add_argument("file", nargs="?", help="CDL file to open")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    parser.add_argument("--log-level", default="INFO", help="Logging level")
    return parser.parse_args()

def main():
    args = parse_args()
    setup_logging(args.log_level)
    # ... open args.file if provided
```

**Test mode** (for automated testing):
```python
def main(test_mode=False):
    # ...
    if not test_mode:
        window.show()
    else:
        # Schedule close after 1 second
        QTimer.singleShot(1000, app.quit)
    # ...
```

**Crash handler**:
```python
def exception_handler(exc_type, exc_value, exc_traceback):
    """Handle uncaught exceptions."""
    logger.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))
    sys.__excepthook__(exc_type, exc_value, exc_traceback)

sys.excepthook = exception_handler
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E06-F01 split |
