# E06-F01-T04 - Application Entry Point: Pre-Implementation Planning

**Task**: E06-F01-T04 - Application Entry Point
**Date**: 2025-12-26
**Status**: Pre-Implementation
**Author**: Claude
**Estimated Hours**: 2

---

## 1. Overview

### 1.1 Purpose

This pre-implementation document provides comprehensive planning for creating the application entry point that initializes the Qt application instance, creates the main window, and manages the application lifecycle. This module serves as the executable entry point for Ink and handles proper startup and shutdown.

### 1.2 Task Summary

Create the main entry point that:
- Initializes `QApplication` with proper configuration
- Sets application metadata (name, version, organization)
- Instantiates and displays the main window
- Starts the Qt event loop
- Handles graceful application shutdown
- Provides proper logging during lifecycle events
- Enables execution via `python -m ink`

### 1.3 Success Metrics

- Application launches in < 2 seconds
- Clean startup with no errors or warnings
- Window displays properly on first launch
- Clean shutdown with exit code 0
- Logs provide clear lifecycle information
- Works on all supported Linux distributions

---

## 2. Architecture Decisions

### 2.1 Entry Point Pattern: Module Main vs Direct Script

**Decision**: Use Python module execution pattern (`python -m ink`)

**Implementation**:
- `src/ink/__main__.py`: Module entry point
- `src/ink/main.py`: Application initialization logic
- `src/ink/__init__.py`: Package exports

**Rationale**:
- **Standard Pattern**: Python best practice for executable packages
- **Import Friendly**: Can import `main()` function for testing
- **Package Integration**: Works with setuptools entry_points
- **Clean Namespace**: Avoids polluting package `__init__.py`

**Alternatives Considered**:
- **Direct script**: `ink.py` in root → Non-standard, harder to package
- **`__init__.py` execution**: Code in `__init__.py` → Pollutes package namespace
- **Binary wrapper**: Shell script calling Python → Unnecessary complexity

**Execution Methods Supported**:
```bash
python -m ink               # Standard
uv run python -m ink        # With uv
python src/ink/main.py      # Direct (for development)
ink                         # Future: setuptools console_scripts
```

### 2.2 Application Metadata Configuration

**Decision**: Set comprehensive Qt application metadata

**Metadata**:
```python
app.setApplicationName("Ink")
app.setApplicationVersion("0.1.0")
app.setOrganizationName("InkProject")
app.setOrganizationDomain("github.com/inkproject")
```

**Rationale**:
- **Settings Location**: Qt uses metadata for config file path (`~/.config/InkProject/Ink.conf`)
- **Window Grouping**: Desktop environments group windows by app name
- **System Integration**: About dialogs, notifications use metadata
- **Future Features**: Recent files, session state depend on persistent storage

**Storage Location** (Linux):
```
~/.config/InkProject/Ink.conf  # Settings file
~/.local/share/InkProject/     # Application data (future)
```

### 2.3 Logging Configuration

**Decision**: Configure Python logging at application startup

**Configuration**:
```python
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
```

**Rationale**:
- **Early Visibility**: Errors during import/setup are logged
- **Consistent Format**: Timestamps help with debugging
- **Stdout Stream**: Visible in terminal during development
- **Standard Library**: No external dependencies

**Log Levels**:
- `INFO`: Lifecycle events (startup, shutdown)
- `WARNING`: Non-critical issues (missing config, deprecated features)
- `ERROR`: Errors that don't crash app (file load failures)
- `CRITICAL`: Fatal errors (Qt initialization failure)

**Future Enhancement** (P1):
- Log to file: `~/.local/share/InkProject/logs/ink.log`
- Rotating file handler
- User-configurable log level

### 2.4 High-DPI Display Support

**Decision**: Enable high-DPI scaling before creating `QApplication`

**Implementation**:
```python
# MUST be called before QApplication creation
QApplication.setHighDpiScaleFactorRoundingPolicy(
    Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
)

app = QApplication(sys.argv)

# Additional attributes
app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
```

**Rationale**:
- **Modern Displays**: 4K, 5K, HiDPI displays increasingly common
- **Qt Default**: Qt 6 has better defaults but explicit is better
- **PassThrough**: Most accurate scaling, avoids rounding artifacts
- **Icon Quality**: `AA_UseHighDpiPixmaps` ensures sharp icons

**Trade-offs**:
- Slightly higher memory usage (acceptable)
- More GPU load for scaling (negligible on modern hardware)
- Better user experience on HiDPI displays (worth it)

---

## 3. Implementation Strategy

### 3.1 Implementation Steps

#### Step 1: Create Main Module (30 minutes)

**File**: `src/ink/main.py`

```python
"""
Ink - Incremental Schematic Viewer
Application entry point.
"""

import sys
import logging
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt
from ink.presentation.main_window import InkMainWindow


def setup_logging():
    """
    Configure application logging.

    Sets up logging to stdout with INFO level and timestamp format.
    This should be called before any other imports to ensure early
    errors are captured.
    """
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )


def configure_high_dpi():
    """
    Configure high-DPI display support.

    Must be called BEFORE creating QApplication.
    Enables proper scaling on 4K, 5K, and other high-DPI displays.
    """
    # Set rounding policy for fractional scaling (1.5x, 1.25x)
    QApplication.setHighDpiScaleFactorRoundingPolicy(
        Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )


def main():
    """
    Application entry point.

    Initializes Qt application, creates main window, and starts event loop.

    The initialization sequence is:
    1. Setup logging
    2. Configure high-DPI support
    3. Create QApplication
    4. Set application metadata
    5. Create and show main window
    6. Start event loop
    7. Return exit code

    Returns:
        int: Application exit code (0 for success, non-zero for error)
    """
    # Step 1: Setup logging
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("Starting Ink application")

    # Step 2: Configure high-DPI (before QApplication)
    configure_high_dpi()

    # Step 3: Create Qt application instance
    app = QApplication(sys.argv)

    # Enable high-DPI pixmaps for sharp icons
    app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)

    # Step 4: Set application metadata
    app.setApplicationName("Ink")
    app.setApplicationVersion("0.1.0")
    app.setOrganizationName("InkProject")
    app.setOrganizationDomain("github.com/inkproject")

    logger.info(f"Ink version {app.applicationVersion()}")

    # Step 5: Create and show main window
    try:
        window = InkMainWindow()
        window.show()
        logger.info("Main window displayed")
    except Exception as e:
        logger.critical(f"Failed to create main window: {e}", exc_info=True)
        return 1

    # Step 6: Start event loop
    logger.info("Starting Qt event loop")
    exit_code = app.exec()

    # Step 7: Cleanup and exit
    logger.info(f"Application exiting with code {exit_code}")
    return exit_code


if __name__ == "__main__":
    sys.exit(main())
```

#### Step 2: Create Module Entry Point (5 minutes)

**File**: `src/ink/__main__.py`

```python
"""
Entry point for executing Ink as a module.

Enables running with: python -m ink
"""

from ink.main import main
import sys

if __name__ == "__main__":
    sys.exit(main())
```

#### Step 3: Update Package Init (10 minutes)

**File**: `src/ink/__init__.py`

```python
"""
Ink - Incremental Schematic Viewer

A GUI tool for schematic exploration targeting gate-level netlists.
Uses incremental exploration model starting from user-selected points.
"""

__version__ = "0.1.0"
__author__ = "InkProject"

# Make main accessible for testing and programmatic use
from ink.main import main

__all__ = ["main", "__version__", "__author__"]
```

#### Step 4: Create Integration Tests (30 minutes)

**File**: `tests/integration/test_application_startup.py`

```python
"""
Integration tests for application startup and lifecycle.

These tests verify the application can be launched and terminated
correctly, with proper logging and exit codes.
"""

import pytest
import subprocess
import sys
import logging
from pathlib import Path
from PySide6.QtWidgets import QApplication
from ink.main import main, setup_logging, configure_high_dpi


class TestApplicationEntryPoint:
    """Test application entry point and initialization."""

    def test_main_function_exists(self):
        """Test main function can be imported."""
        from ink.main import main
        assert callable(main)

    def test_main_function_in_package_init(self):
        """Test main is exported from package."""
        from ink import main
        assert callable(main)

    def test_version_in_package_init(self):
        """Test version is exported from package."""
        from ink import __version__
        assert __version__ == "0.1.0"


class TestLoggingSetup:
    """Test logging configuration."""

    def test_setup_logging_configures_logger(self):
        """Test setup_logging creates logger configuration."""
        setup_logging()

        logger = logging.getLogger("ink.main")
        assert logger.level <= logging.INFO

    def test_setup_logging_uses_stdout(self, capsys):
        """Test logging outputs to stdout."""
        setup_logging()
        logger = logging.getLogger("test_logger")
        logger.info("Test message")

        captured = capsys.readouterr()
        assert "Test message" in captured.out


class TestHighDPIConfiguration:
    """Test high-DPI display configuration."""

    def test_configure_high_dpi_before_qapplication(self):
        """Test high-DPI can be configured."""
        # This test just ensures function can be called
        # Actual effect requires QApplication
        configure_high_dpi()
        # No assertion, just verify no exception


class TestApplicationMetadata:
    """Test application metadata configuration."""

    def test_application_metadata_set(self):
        """Test application metadata is configured correctly."""
        from ink.main import main
        from PySide6.QtWidgets import QApplication
        from PySide6.QtCore import Qt
        import sys

        # Need to create QApplication to test metadata
        app = QApplication.instance()
        if app is None:
            configure_high_dpi()
            app = QApplication(sys.argv)
            app.setApplicationName("Ink")
            app.setApplicationVersion("0.1.0")
            app.setOrganizationName("InkProject")
            app.setOrganizationDomain("github.com/inkproject")

        assert app.applicationName() == "Ink"
        assert app.applicationVersion() == "0.1.0"
        assert app.organizationName() == "InkProject"
        assert app.organizationDomain() == "github.com/inkproject"


class TestModuleExecution:
    """Test module can be executed."""

    def test_module_execution_imports(self):
        """Test __main__.py can be imported."""
        import ink.__main__
        # No assertion, just verify import works

    @pytest.mark.skipif(
        sys.platform != "linux",
        reason="Test designed for Linux"
    )
    def test_module_help_execution(self):
        """Test module can be executed with --help (future)."""
        # This will fail until we add argparse, but tests the pattern
        # For now, just test import succeeds
        result = subprocess.run(
            [sys.executable, "-m", "ink", "--help"],
            capture_output=True,
            timeout=2,
            cwd=Path(__file__).parent.parent.parent
        )

        # Currently no --help, so may fail
        # But shouldn't crash with exception
        assert result.returncode in [0, 1, 2]  # 0=success, 1=no help, 2=arg error


# Manual test helper (not a pytest test)
def manual_test_application_launch():
    """
    Manual test: Launch application and verify it appears.

    This is not an automated test. Run manually:
        python -m ink

    Checklist:
    - [ ] Window appears on screen
    - [ ] No error messages in console
    - [ ] Startup log messages appear
    - [ ] Window has correct title
    - [ ] Window can be closed
    - [ ] Exit log message appears
    - [ ] Process terminates (no hanging)
    """
    pass
```

#### Step 5: Update Project Configuration (10 minutes)

**File**: `pyproject.toml` (add entry point for future)

```toml
[project]
name = "ink"
version = "0.1.0"
description = "Incremental Schematic Viewer for gate-level netlists"
authors = [{name = "InkProject"}]
requires-python = ">=3.10"
dependencies = [
    "PySide6>=6.6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-qt>=4.2.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.7.0",
]

# Future: Enable console script entry point
# [project.scripts]
# ink = "ink.main:main"
```

#### Step 6: Manual Testing (20 minutes)

**Test Script**: `test_launch.sh`

```bash
#!/bin/bash
# Manual test script for application launch

echo "=== Ink Application Launch Test ==="
echo ""

echo "Test 1: Module execution"
echo "Running: python -m ink"
echo "Expected: Window appears, startup logs visible"
echo "Action: Close window manually"
echo ""
python -m ink

if [ $? -eq 0 ]; then
    echo "✓ Module execution successful (exit code 0)"
else
    echo "✗ Module execution failed (exit code $?)"
fi

echo ""
echo "Test 2: Direct script execution"
echo "Running: python src/ink/main.py"
echo "Expected: Window appears, startup logs visible"
echo "Action: Close window manually"
echo ""
python src/ink/main.py

if [ $? -eq 0 ]; then
    echo "✓ Direct execution successful (exit code 0)"
else
    echo "✗ Direct execution failed (exit code $?)"
fi

echo ""
echo "=== Test Complete ==="
```

**Manual Test Checklist**:

**Startup Tests**:
- [ ] Run `python -m ink`
- [ ] Window appears within 2 seconds
- [ ] Console shows: "Starting Ink application"
- [ ] Console shows: "Ink version 0.1.0"
- [ ] Console shows: "Main window displayed"
- [ ] Console shows: "Starting Qt event loop"
- [ ] Window has correct title
- [ ] All panels visible (hierarchy, property, message)
- [ ] Canvas placeholder visible

**Shutdown Tests**:
- [ ] Click close button (X)
- [ ] Console shows: "Application exiting with code 0"
- [ ] Window closes immediately
- [ ] Process terminates (prompt returns)
- [ ] No zombie processes (`ps aux | grep ink`)

**Error Handling Tests**:
- [ ] Move `main_window.py` temporarily
- [ ] Run `python -m ink`
- [ ] Console shows critical error
- [ ] Application exits with code 1
- [ ] Restore `main_window.py`

**High-DPI Tests** (if available):
- [ ] Run on 1080p display (100% scaling)
- [ ] Run on 4K display (200% scaling)
- [ ] Window and fonts scale appropriately
- [ ] No blurry text or icons

### 3.2 Estimated Effort

| Step | Duration | Notes |
|------|----------|-------|
| Main module | 30 min | Entry point logic with logging |
| Module entry point | 5 min | Simple `__main__.py` |
| Package init | 10 min | Update exports and version |
| Integration tests | 30 min | Startup lifecycle tests |
| Project config | 10 min | Update `pyproject.toml` |
| Manual testing | 20 min | Comprehensive launch testing |
| Documentation | 15 min | Docstrings and comments |
| **Total** | **120 min** | **2 hours (matches estimate)** |

### 3.3 Dependencies

**Upstream Dependencies**:
- Task T01: `InkMainWindow` class must exist
- Task T02: Central widget must be set
- Task T03: Dock widgets must be configured

**Downstream Dependencies**:
- All future features depend on application launching
- E06-F02 (Menu): Will extend main window with menus
- E01 (Parsing): Will add file loading to entry point
- Future: Command-line argument parsing

**Critical Path**:
```
T01 → T02 → T03 → T04 → (Application Usable)
```

---

## 4. Technical Deep Dive

### 4.1 Python Module Execution Pattern

#### 4.1.1 Execution Flow

```
User runs: python -m ink
    ↓
Python finds: src/ink/__main__.py
    ↓
__main__.py imports: ink.main.main()
    ↓
main() executes initialization sequence
    ↓
QApplication.exec() starts event loop
    ↓
User closes window
    ↓
Event loop exits, returns code
    ↓
main() returns code to __main__.py
    ↓
__main__.py calls: sys.exit(code)
    ↓
Process terminates with exit code
```

#### 4.1.2 Import Paths

**Module execution** (`python -m ink`):
- Current directory NOT in `sys.path`
- `src/` directory added to `sys.path` by Python
- Imports use absolute paths: `from ink.presentation...`

**Direct execution** (`python src/ink/main.py`):
- `src/ink/` added to `sys.path`
- Imports still work if using `from ink.presentation...`
- May fail if using relative imports

**Best Practice**: Always use absolute imports from `ink` root.

### 4.2 QApplication Lifecycle

#### 4.2.1 Initialization Sequence

```python
# 1. Configure high-DPI BEFORE QApplication
QApplication.setHighDpiScaleFactorRoundingPolicy(...)

# 2. Create QApplication instance
app = QApplication(sys.argv)
# - Parses command-line args
# - Initializes Qt event system
# - Creates application object

# 3. Set attributes
app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)

# 4. Set metadata
app.setApplicationName("Ink")
app.setApplicationVersion("0.1.0")
# ...

# 5. Create UI
window = InkMainWindow()
window.show()

# 6. Start event loop
exit_code = app.exec()
# - Processes events (mouse, keyboard, timers, etc.)
# - Blocks until app.quit() called
# - Returns exit code

# 7. Cleanup (automatic)
# Qt deletes all QObjects
# Python garbage collects

return exit_code
```

#### 4.2.2 Event Loop

**What `app.exec()` does**:
1. Waits for events (mouse clicks, keyboard, timers, signals)
2. Dispatches events to appropriate widgets
3. Calls event handlers (`mousePressEvent`, `keyPressEvent`, etc.)
4. Repaints widgets when needed
5. Continues until `app.quit()` called

**How it exits**:
- User closes main window → `QMainWindow.closeEvent()`
- Close event accepted → `app.quit()` called
- Event loop exits → `app.exec()` returns
- Return value is exit code (default 0)

#### 4.2.3 Exit Codes

**Standard Codes**:
- `0`: Success (normal close)
- `1`: Generic error (exception during init)
- `2-127`: User-defined errors
- `128+`: Signals (e.g., 130 = SIGINT/Ctrl+C)

**Ink Usage**:
- `0`: Normal application exit
- `1`: Failed to create main window
- Future: Other error codes for specific failures

### 4.3 Logging Configuration

#### 4.3.1 Log Format

```
%(asctime)s - %(name)s - %(levelname)s - %(message)s
```

**Example Output**:
```
2025-12-26 10:30:15,234 - ink.main - INFO - Starting Ink application
2025-12-26 10:30:15,456 - ink.main - INFO - Ink version 0.1.0
2025-12-26 10:30:15,789 - ink.main - INFO - Main window displayed
2025-12-26 10:30:15,790 - ink.main - INFO - Starting Qt event loop
```

**Components**:
- `asctime`: Timestamp with milliseconds
- `name`: Logger name (module path)
- `levelname`: INFO, WARNING, ERROR, CRITICAL
- `message`: Actual log message

#### 4.3.2 Logger Hierarchy

```python
logger = logging.getLogger(__name__)
# __name__ is "ink.main"

# Creates hierarchy:
# root
#   └─ ink
#       └─ main

# Can configure parent logger:
ink_logger = logging.getLogger("ink")
ink_logger.setLevel(logging.DEBUG)  # All ink.* modules use DEBUG
```

**Future Enhancements**:
- Different log levels for different modules
- File handlers for persistent logs
- Rotating logs (size/time based)
- Syslog integration (Linux daemon mode)

### 4.4 High-DPI Display Support

#### 4.4.1 Scaling Policies

**RoundingPolicy Options**:
```python
# PassThrough: Most accurate, use exact fractional scaling
Qt.HighDpiScaleFactorRoundingPolicy.PassThrough

# Round: Round to nearest integer (1.7x → 2x)
Qt.HighDpiScaleFactorRoundingPolicy.Round

# Ceil: Round up (1.3x → 2x)
Qt.HighDpiScaleFactorRoundingPolicy.Ceil

# Floor: Round down (1.9x → 1x)
Qt.HighDpiScaleFactorRoundingPolicy.Floor
```

**Why PassThrough?**:
- Most accurate representation
- No rounding artifacts
- Better for professional tools (precision matters)
- May have slight rendering overhead (negligible)

#### 4.4.2 High-DPI Pixmaps

```python
app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
```

**Effect**:
- Icons rendered at higher resolution on HiDPI
- Prevents blurry icons
- Qt automatically selects `@2x` variants if available
- Slightly higher memory usage (acceptable)

**Icon Naming**:
```
icons/
  open.svg       # 1x version
  open@2x.svg    # 2x version (optional)
```

Qt automatically loads appropriate version.

### 4.5 Application Metadata

#### 4.5.1 Settings Location

**Linux (XDG Standard)**:
```
Config: ~/.config/InkProject/Ink.conf
Data:   ~/.local/share/InkProject/
Cache:  ~/.cache/InkProject/
```

**Generated by**:
```python
app.setOrganizationName("InkProject")  # Directory name
app.setApplicationName("Ink")          # File name
```

**File Format** (INI):
```ini
[General]
version=0.1.0

[window]
geometry=@ByteArray(...)
state=@ByteArray(...)

[recent_files]
1\path=/home/user/design1.ckt
2\path=/home/user/design2.ckt
size=2
```

#### 4.5.2 Desktop Integration

**Application Name**:
- Used by window managers for grouping
- Shows in taskbar
- Shows in Alt+Tab switcher
- Shows in top panel

**Organization Domain**:
- Uniqueness for settings (reverse DNS)
- Multiple apps from same org can share namespace
- `github.com/inkproject` → `com.github.inkproject` internally

---

## 5. Risk Analysis

### 5.1 Technical Risks

#### Risk 1: Application Doesn't Launch

**Impact**: Critical (blocker)
**Probability**: Low
**Description**: Application fails to start with exception

**Root Causes**:
- PySide6 not installed
- Import errors (missing modules)
- `InkMainWindow` creation fails
- Qt platform plugin not found

**Mitigation**:
- Comprehensive error handling with try/except
- Log critical errors before exit
- Clear error messages to user
- Test on clean environment

**Error Handling**:
```python
try:
    window = InkMainWindow()
    window.show()
except ImportError as e:
    logger.critical(f"Import error: {e}")
    logger.critical("Is PySide6 installed? Run: pip install PySide6")
    return 1
except Exception as e:
    logger.critical(f"Failed to create window: {e}", exc_info=True)
    return 1
```

#### Risk 2: Slow Startup Time

**Impact**: Medium (poor UX)
**Probability**: Low
**Description**: Application takes > 2 seconds to launch

**Root Causes**:
- Slow imports (large modules)
- Qt initialization overhead
- Settings restoration slow
- Many widgets created

**Mitigation**:
- Profile startup with `cProfile`
- Defer non-essential imports
- Lazy-load panel content
- Optimize settings loading

**Performance Budget**:
- Import time: < 200ms
- Qt initialization: < 500ms
- Window creation: < 500ms
- Event loop start: < 100ms
- **Total**: < 1300ms (buffer to 2s)

**Profiling**:
```bash
python -m cProfile -s cumtime -m ink > profile.txt
# Analyze top time consumers
```

#### Risk 3: Exit Code Not Propagated

**Impact**: Low (mainly affects scripts)
**Probability**: Very Low
**Description**: Application always returns 0 even on error

**Root Causes**:
- Missing `sys.exit()` call
- Exception caught but not re-raised
- Event loop doesn't return error code

**Mitigation**:
- Always use `sys.exit(main())`
- Return non-zero from `main()` on error
- Test exit codes in integration tests

**Verification**:
```bash
python -m ink
echo $?  # Should be 0

# Test error case
python -m ink --invalid-arg  # (future)
echo $?  # Should be non-zero
```

#### Risk 4: Logging Not Visible

**Impact**: Low (debugging harder)
**Probability**: Low
**Description**: Log messages don't appear in console

**Root Causes**:
- Logging not configured
- Wrong stream (stderr vs stdout)
- Logging after Qt redirects streams
- Terminal buffering

**Mitigation**:
- Configure logging early (before imports)
- Use stdout explicitly
- Flush after critical messages
- Test logging output

**Debug Script**:
```python
import sys
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.info("Test message")
sys.stdout.flush()
```

### 5.2 Platform Risks

#### Risk 5: Qt Platform Plugin Not Found

**Impact**: Critical (app won't start)
**Probability**: Low (Linux), Medium (other platforms)
**Description**: "Could not find the Qt platform plugin" error

**Root Causes**:
- PySide6 not properly installed
- Missing platform plugin libraries
- `QT_QPA_PLATFORM` env variable set incorrectly

**Mitigation**:
- Document installation requirements
- Provide installation troubleshooting guide
- Test on clean Linux installs
- Clear error message

**Error Message Improvement**:
```python
try:
    app = QApplication(sys.argv)
except Exception as e:
    if "platform plugin" in str(e).lower():
        logger.critical("Qt platform plugin error")
        logger.critical("Try: sudo apt install libxcb-xinerama0 libxcb-cursor0")
    logger.critical(f"Failed to create QApplication: {e}")
    return 1
```

#### Risk 6: Wayland vs X11 Issues

**Impact**: Medium (some features may not work)
**Probability**: Low
**Description**: Behavior differences between X11 and Wayland

**Root Causes**:
- Different window manager protocols
- Different decoration handling
- Clipboard behavior differences

**Mitigation**:
- Test on both X11 and Wayland
- Use Qt's abstraction (don't depend on X11-specific features)
- Document any known Wayland issues
- Accept minor cosmetic differences

**Platform Detection**:
```python
platform = app.platformName()
logger.info(f"Qt platform: {platform}")  # "xcb" (X11) or "wayland"
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Limited Scope**: Entry point is mostly integration, few pure units.

**Testable Units**:
- `setup_logging()`: Verify logger configuration
- `configure_high_dpi()`: Verify no exceptions

**Coverage Target**: 60% (main loop not unit-testable)

### 6.2 Integration Testing

**Test Cases**:
1. **Import Tests**
   - Main module can be imported
   - Main function exists and is callable
   - Package exports are correct

2. **Logging Tests**
   - Logging is configured
   - Log messages appear in stdout
   - Log format is correct

3. **Metadata Tests**
   - Application metadata is set correctly
   - Settings file location is correct

**Coverage Target**: 80%

### 6.3 Manual Testing

**Critical Test Cases**:

**TC-01: Module Execution**
- [ ] Run `python -m ink`
- [ ] Application launches
- [ ] Window appears
- [ ] Logs visible in console
- [ ] Can close window
- [ ] Exit code is 0

**TC-02: Direct Execution**
- [ ] Run `python src/ink/main.py`
- [ ] Application launches
- [ ] Works same as module execution

**TC-03: Error Handling**
- [ ] Break main_window.py (syntax error)
- [ ] Run `python -m ink`
- [ ] Critical error logged
- [ ] Exit code is 1
- [ ] Fix main_window.py

**TC-04: Logging Output**
- [ ] Run `python -m ink | tee log.txt`
- [ ] Verify log.txt contains:
  - "Starting Ink application"
  - "Ink version 0.1.0"
  - "Main window displayed"
  - "Starting Qt event loop"
  - "Application exiting with code 0"

**TC-05: Multiple Instances**
- [ ] Run `python -m ink` (instance 1)
- [ ] Run `python -m ink` (instance 2)
- [ ] Both windows appear
- [ ] Both function independently
- [ ] Close both, both exit cleanly

**TC-06: Process Cleanup**
- [ ] Run `python -m ink`
- [ ] Note PID: `ps aux | grep ink`
- [ ] Close window
- [ ] Verify process terminated: `ps aux | grep ink`
- [ ] No zombie processes

### 6.4 Performance Testing

**Startup Time Measurement**:
```bash
time python -m ink &
# Close window immediately
# Check real time < 2s
```

**Automated Timing**:
```python
import time
import subprocess

start = time.time()
proc = subprocess.Popen(
    ["python", "-m", "ink"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE
)
time.sleep(3)  # Let it start
proc.terminate()
proc.wait()
elapsed = time.time() - start

print(f"Startup time: ~{min(elapsed, 3):.1f}s")
```

---

## 7. Definition of Done

### 7.1 Code Complete

- [ ] `main.py` with `main()` function implemented
- [ ] `__main__.py` module entry point created
- [ ] `__init__.py` updated with exports
- [ ] Logging configuration implemented
- [ ] High-DPI configuration implemented
- [ ] Application metadata set
- [ ] Error handling for window creation
- [ ] Exit codes returned correctly
- [ ] All code follows PEP 8
- [ ] Type hints on public functions
- [ ] Comprehensive docstrings

### 7.2 Tests Complete

- [ ] Integration tests for entry point
- [ ] Tests for logging setup
- [ ] Tests for metadata
- [ ] All tests passing
- [ ] Coverage > 70%

### 7.3 Documentation Complete

- [ ] Docstrings on all functions
- [ ] Inline comments for non-obvious logic
- [ ] Logging messages clear and helpful
- [ ] Error messages user-friendly
- [ ] Architecture decisions in pre-docs

### 7.4 Manual Testing Complete

- [ ] All manual test cases passed
- [ ] Tested on Linux
- [ ] Tested on X11 and Wayland (if available)
- [ ] Startup time < 2 seconds
- [ ] Clean shutdown verified

### 7.5 Integration Ready

- [ ] T05 can test full integration
- [ ] E06-F02 can add menu system
- [ ] E01 can add file loading
- [ ] Future features can extend entry point

---

## 8. Integration Points

### 8.1 For Task T05 (Integration Testing)

**What T05 Needs**:
- Working application that launches
- All components assembled

**Integration**: T05 will test the complete stack created by T01-T04.

### 8.2 For Feature E06-F02 (Menu System)

**What E06-F02 Needs**:
- Running application to attach menus to

**No Changes**: Menu system extends `InkMainWindow`, not entry point.

### 8.3 For Epic E01 (Parsing)

**What E01 Will Need**:
- Command-line argument for file to open
- File loading logic in entry point

**Future Enhancement**:
```python
import argparse

def parse_args():
    parser = argparse.ArgumentParser(
        description="Ink - Incremental Schematic Viewer"
    )
    parser.add_argument(
        "file",
        nargs="?",
        help="CDL file to open"
    )
    return parser.parse_args()

def main():
    args = parse_args()
    # ... create window ...
    if args.file:
        window.load_file(args.file)
    # ...
```

### 8.4 For Future: Setuptools Entry Point

**Entry Point Configuration**:
```toml
[project.scripts]
ink = "ink.main:main"
```

**After Installation**:
```bash
pip install -e .
ink              # Runs ink.main:main()
ink file.ckt     # Opens file
```

---

## 9. Future Enhancements

### 9.1 Command-Line Arguments (P1)

```python
parser.add_argument("file", nargs="?", help="File to open")
parser.add_argument("--version", action="version")
parser.add_argument("--log-level", default="INFO")
parser.add_argument("--no-gui", action="store_true", help="CLI mode")
```

### 9.2 Splash Screen (P1)

```python
from PySide6.QtWidgets import QSplashScreen
from PySide6.QtGui import QPixmap

pixmap = QPixmap("splash.png")
splash = QSplashScreen(pixmap)
splash.show()
app.processEvents()

# ... create window ...

splash.finish(window)
```

### 9.3 Crash Handler (P1)

```python
def exception_handler(exc_type, exc_value, exc_traceback):
    """Handle uncaught exceptions."""
    logger.error(
        "Uncaught exception",
        exc_info=(exc_type, exc_value, exc_traceback)
    )
    # Show crash dialog
    # Save crash report

sys.excepthook = exception_handler
```

### 9.4 Single Instance Enforcement (P2)

```python
from PySide6.QtNetwork import QLocalServer, QLocalSocket

# Check if instance already running
socket = QLocalSocket()
socket.connectToServer("InkApp")
if socket.waitForConnected(500):
    # Already running, send file to open
    sys.exit(0)

# First instance, create server
server = QLocalServer()
server.listen("InkApp")
```

---

## 10. Appendix

### 10.1 File Structure

**New Files**:
```
src/ink/
├── main.py          (new - entry point logic)
└── __main__.py      (new - module execution)

tests/integration/
└── test_application_startup.py  (new)
```

**Modified Files**:
```
src/ink/__init__.py      (update - add version and main export)
pyproject.toml           (update - set version, add metadata)
```

### 10.2 Key Dependencies

- `PySide6.QtWidgets.QApplication`: Application instance
- `PySide6.QtCore.Qt`: Constants and enums
- `logging`: Python standard library logging
- `sys`: Exit codes and argv

### 10.3 Qt Documentation

- [QApplication](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QApplication.html)
- [High-DPI Scaling](https://doc.qt.io/qt-6/highdpi.html)
- [Application Metadata](https://doc.qt.io/qt-6/qcoreapplication.html#setApplicationName)

---

**Document Status**: Ready for Implementation
**Next Step**: Create `src/ink/main.py` and `src/ink/__main__.py`
