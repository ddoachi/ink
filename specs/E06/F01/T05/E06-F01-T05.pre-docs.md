# E06-F01-T05 - Integration Testing and Polish: Pre-Implementation Planning

**Task**: E06-F01-T05 - Integration Testing and Polish
**Date**: 2025-12-26
**Status**: Pre-Implementation
**Author**: Claude
**Estimated Hours**: 3

---

## 1. Overview

### 1.1 Purpose

This pre-implementation document provides comprehensive planning for creating integration tests that verify all components of the main window work together correctly, and for adding UI polish to ensure a professional appearance. This task validates that T01-T04 components integrate properly and provides the finishing touches for MVP quality.

### 1.2 Task Summary

Verify and polish the complete main window implementation:
- **Integration Testing**: Comprehensive test suite covering full window assembly
- **UI Polish**: Visual refinements for professional appearance
- **Performance Validation**: Ensure startup and runtime performance meet requirements
- **Manual Testing**: Systematic verification of all functionality
- **Documentation**: Complete testing guides and known issues

This is the final task that brings together all previous work and ensures production readiness.

### 1.3 Success Metrics

- Integration test coverage > 85%
- All integration tests passing
- Startup time < 2 seconds (verified)
- No Qt warnings during normal operation
- Professional visual appearance
- All acceptance criteria from parent spec met
- Manual testing checklist 100% complete

---

## 2. Architecture Decisions

### 2.1 Testing Strategy: Integration vs End-to-End

**Decision**: Focus on integration tests, with manual end-to-end validation

**Integration Tests**:
- Test complete main window creation
- Test all components working together
- Test dock operations programmatically
- Use pytest-qt for Qt testing

**Manual End-to-End Tests**:
- Visual appearance verification
- User interaction workflows
- Cross-platform compatibility
- Performance in real usage

**Rationale**:
- **Integration Tests**: Automated, fast, catch regressions
- **Manual Tests**: Visual issues, UX problems not caught by code
- **Balance**: Most coverage automated, critical UX manually verified

**NOT End-to-End Automation**:
- UI test frameworks (Squish, etc.) are heavy and fragile
- Manual testing sufficient for MVP
- Can add GUI automation in P1 if needed

### 2.2 UI Polish: Minimal vs Comprehensive

**Decision**: Minimal polish focused on professional appearance

**Scope**:
- Consistent spacing and margins
- Visible and styled splitter handles
- Clean placeholder text styling
- Smooth dock animations
- No visual glitches

**Out of Scope (for MVP)**:
- Custom theme system
- Elaborate visual effects
- Branded styling
- Custom window decorations

**Rationale**:
- **MVP Goal**: Functional and professional, not beautiful
- **Qt Defaults**: Already fairly polished
- **Time Constraint**: 3 hours for this task
- **Future**: Theme system is P1 enhancement

### 2.3 Performance Testing Approach

**Decision**: Profile-based validation with automated benchmarks

**Tools**:
- `cProfile`: Python profiling
- `pytest-benchmark`: Automated benchmarking
- `time` command: Startup timing
- `memory_profiler`: Memory usage (optional)

**Metrics**:
- Startup time: < 2 seconds (hard requirement)
- Window creation: < 500ms (target)
- Memory footprint: < 50MB at startup (target)
- No memory leaks in create/destroy cycles

**Rationale**:
- **Objective Metrics**: Numbers don't lie
- **Regression Detection**: Automated benchmarks catch slowdowns
- **Acceptable for MVP**: More detailed profiling in P1 if needed

### 2.4 Visual Polish Priorities

**Priority 1 (Must Have)**:
- Dock splitter handles visible
- Placeholder text readable
- No layout glitches
- Consistent panel padding

**Priority 2 (Should Have)**:
- Splitter handle hover effect
- Smooth dock animations
- Refined panel backgrounds
- Subtle panel borders

**Priority 3 (Nice to Have)**:
- Custom dock title styling
- Gradient backgrounds
- Icon in window title bar
- Platform-specific refinements

**Decision**: Implement P1, attempt P2 if time permits, defer P3 to theme system.

---

## 3. Implementation Strategy

### 3.1 Implementation Steps

#### Step 1: Create Comprehensive Integration Tests (60 minutes)

**File**: `tests/integration/presentation/test_main_window_integration.py`

```python
"""
Comprehensive integration tests for main window assembly.

Tests that all components (window, canvas, docks) work together correctly
and that the complete UI is properly assembled.
"""

import pytest
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt, QSize, QTimer
from ink.presentation.main_window import InkMainWindow


@pytest.fixture(scope="module")
def qapp():
    """Create QApplication for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app


@pytest.fixture
def main_window(qapp):
    """Create main window for tests."""
    window = InkMainWindow()
    yield window
    window.close()
    window.deleteLater()


class TestMainWindowAssembly:
    """Test complete main window is assembled correctly."""

    def test_window_created(self, main_window):
        """Test main window instance is created."""
        assert main_window is not None

    def test_window_title(self, main_window):
        """Test window has correct title."""
        assert main_window.windowTitle() == "Ink - Incremental Schematic Viewer"

    def test_window_size(self, main_window):
        """Test window has correct default size."""
        assert main_window.width() == 1600
        assert main_window.height() == 900

    def test_window_minimum_size(self, main_window):
        """Test window has correct minimum size."""
        min_size = main_window.minimumSize()
        assert min_size.width() == 1024
        assert min_size.height() == 768

    def test_window_minimum_enforced(self, main_window, qapp):
        """Test window minimum size is enforced when shown."""
        main_window.resize(800, 600)
        main_window.show()
        qapp.processEvents()

        # Should be clamped to minimum
        assert main_window.width() >= 1024
        assert main_window.height() >= 768

        main_window.close()


class TestCentralWidgetIntegration:
    """Test central widget (canvas) integration."""

    def test_central_widget_exists(self, main_window):
        """Test central widget is set."""
        assert main_window.centralWidget() is not None

    def test_central_widget_is_canvas(self, main_window):
        """Test central widget is schematic canvas."""
        assert main_window.centralWidget() == main_window.schematic_canvas

    def test_canvas_parent(self, main_window):
        """Test canvas parent is main window."""
        # Canvas is reparented to central widget container
        # but original parent was main window
        assert main_window.schematic_canvas is not None


class TestDockWidgetIntegration:
    """Test dock widgets integration."""

    def test_all_docks_exist(self, main_window):
        """Test all three docks are created."""
        assert hasattr(main_window, 'hierarchy_dock')
        assert hasattr(main_window, 'property_dock')
        assert hasattr(main_window, 'message_dock')

    def test_dock_positions(self, main_window):
        """Test docks are in correct default positions."""
        assert main_window.dockWidgetArea(main_window.hierarchy_dock) == \
               Qt.DockWidgetArea.LeftDockWidgetArea
        assert main_window.dockWidgetArea(main_window.property_dock) == \
               Qt.DockWidgetArea.RightDockWidgetArea
        assert main_window.dockWidgetArea(main_window.message_dock) == \
               Qt.DockWidgetArea.BottomDockWidgetArea

    def test_dock_titles(self, main_window):
        """Test docks have correct titles."""
        assert main_window.hierarchy_dock.windowTitle() == "Hierarchy"
        assert main_window.property_dock.windowTitle() == "Properties"
        assert main_window.message_dock.windowTitle() == "Messages"

    def test_docks_visible_by_default(self, main_window):
        """Test all docks are visible initially."""
        assert main_window.hierarchy_dock.isVisible()
        assert main_window.property_dock.isVisible()
        assert main_window.message_dock.isVisible()

    def test_dock_object_names(self, main_window):
        """Test docks have object names for state persistence."""
        assert main_window.hierarchy_dock.objectName() == "HierarchyDock"
        assert main_window.property_dock.objectName() == "PropertyDock"
        assert main_window.message_dock.objectName() == "MessageDock"


class TestDockWidgetOperations:
    """Test dock widget operations work correctly."""

    def test_dock_close_and_show(self, main_window, qapp):
        """Test dock can be closed and shown."""
        # Close hierarchy dock
        main_window.hierarchy_dock.close()
        qapp.processEvents()
        assert not main_window.hierarchy_dock.isVisible()

        # Show again
        main_window.hierarchy_dock.show()
        qapp.processEvents()
        assert main_window.hierarchy_dock.isVisible()

    def test_dock_float_and_dock(self, main_window, qapp):
        """Test dock can be floated and re-docked."""
        # Float hierarchy dock
        main_window.hierarchy_dock.setFloating(True)
        qapp.processEvents()
        assert main_window.hierarchy_dock.isFloating()

        # Re-dock
        main_window.hierarchy_dock.setFloating(False)
        qapp.processEvents()
        assert not main_window.hierarchy_dock.isFloating()

    def test_multiple_docks_closable(self, main_window, qapp):
        """Test multiple docks can be closed simultaneously."""
        main_window.hierarchy_dock.close()
        main_window.property_dock.close()
        qapp.processEvents()

        assert not main_window.hierarchy_dock.isVisible()
        assert not main_window.property_dock.isVisible()
        assert main_window.message_dock.isVisible()  # Still visible

        # Restore
        main_window.hierarchy_dock.show()
        main_window.property_dock.show()
        qapp.processEvents()


class TestWindowGeometry:
    """Test window geometry behavior."""

    def test_window_resizable(self, main_window):
        """Test window can be resized."""
        main_window.resize(1920, 1080)
        assert main_window.width() == 1920
        assert main_window.height() == 1080

    def test_window_respects_minimum(self, main_window, qapp):
        """Test window cannot be smaller than minimum."""
        main_window.resize(500, 400)
        main_window.show()
        qapp.processEvents()

        # Should be at least minimum size
        assert main_window.width() >= 1024
        assert main_window.height() >= 768

        main_window.close()


class TestWindowLifecycle:
    """Test window creation and destruction."""

    def test_window_can_be_shown_and_hidden(self, qapp):
        """Test window can be shown and hidden."""
        window = InkMainWindow()
        window.show()
        assert window.isVisible()

        window.hide()
        assert not window.isVisible()

        window.close()

    def test_window_cleanup(self, qapp):
        """Test window cleans up properly when deleted."""
        window = InkMainWindow()
        window.show()
        window.close()
        window.deleteLater()
        qapp.processEvents()
        # No assertion, just verify no crash

    def test_multiple_windows(self, qapp):
        """Test multiple windows can coexist."""
        window1 = InkMainWindow()
        window2 = InkMainWindow()

        window1.show()
        window2.show()

        assert window1.isVisible()
        assert window2.isVisible()

        window1.close()
        window2.close()


class TestDockNesting:
    """Test dock nesting is enabled."""

    def test_dock_nesting_enabled(self, main_window):
        """Test dock nesting is enabled for complex layouts."""
        # isDockNestingEnabled() is a QMainWindow method
        assert main_window.isDockNestingEnabled()
```

#### Step 2: Add Performance Tests (30 minutes)

**File**: `tests/performance/test_startup_performance.py`

```python
"""
Performance tests for application startup and window creation.

Ensures the application meets performance requirements:
- Startup time < 2 seconds
- Window creation < 500ms
- No memory leaks
"""

import time
import pytest
from PySide6.QtWidgets import QApplication
from ink.presentation.main_window import InkMainWindow


@pytest.fixture(scope="module")
def qapp():
    """Create QApplication for Qt widgets."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app


class TestWindowCreationPerformance:
    """Test window creation performance."""

    def test_window_creation_time(self, qapp, benchmark):
        """Benchmark window creation time."""
        def create_window():
            window = InkMainWindow()
            window.deleteLater()
            return window

        window = benchmark(create_window)
        assert window is not None

        # Benchmark should complete in < 500ms
        # pytest-benchmark provides stats automatically

    def test_window_creation_under_500ms(self, qapp):
        """Verify window creation is under 500ms."""
        start = time.perf_counter()
        window = InkMainWindow()
        elapsed = time.perf_counter() - start

        window.deleteLater()
        qapp.processEvents()

        assert elapsed < 0.5, f"Window creation took {elapsed:.3f}s, exceeds 500ms limit"

    def test_window_show_time(self, qapp):
        """Verify window show operation is fast."""
        window = InkMainWindow()

        start = time.perf_counter()
        window.show()
        qapp.processEvents()
        elapsed = time.perf_counter() - start

        window.close()
        window.deleteLater()

        # Show should be near-instantaneous
        assert elapsed < 0.1, f"Window show took {elapsed:.3f}s, too slow"


class TestMemoryUsage:
    """Test memory usage and leaks."""

    def test_no_memory_leak_in_create_destroy(self, qapp):
        """Test repeated window creation doesn't leak memory."""
        import gc

        # Create and destroy windows multiple times
        for _ in range(100):
            window = InkMainWindow()
            window.close()
            window.deleteLater()
            qapp.processEvents()

        # Force garbage collection
        gc.collect()

        # Create one final window to ensure everything still works
        window = InkMainWindow()
        window.show()
        assert window.isVisible()
        window.close()
        window.deleteLater()
        qapp.processEvents()

        # No assertion for memory, just verify no crash
        # Actual memory profiling would require external tools


class TestStartupTime:
    """Test complete application startup time."""

    def test_startup_under_2_seconds(self, qapp):
        """Verify complete startup meets 2-second requirement."""
        start = time.perf_counter()

        # Simulate full startup
        window = InkMainWindow()
        window.show()
        qapp.processEvents()

        elapsed = time.perf_counter() - start

        window.close()
        window.deleteLater()

        # Full startup should be under 2 seconds
        assert elapsed < 2.0, f"Startup took {elapsed:.2f}s, exceeds 2s limit"
        print(f"  ✓ Startup time: {elapsed:.3f}s")
```

**Create performance directory**:
```bash
mkdir -p tests/performance
touch tests/performance/__init__.py
```

#### Step 3: Add UI Polish (45 minutes)

**Modify**: `src/ink/presentation/main_window.py`

Add styling methods:

```python
def _setup_window(self):
    """Configure main window properties."""
    self.setWindowTitle("Ink - Incremental Schematic Viewer")
    self.resize(1600, 900)
    self.setMinimumSize(QSize(1024, 768))

    # Enable dock nesting for complex layouts
    self.setDockNestingEnabled(True)

    # Enable animated docks for smooth transitions
    self.setAnimated(True)

    # Apply visual polish
    self._apply_styling()

def _apply_styling(self):
    """
    Apply visual polish styling.

    Enhances splitter visibility, dock widget appearance,
    and overall visual consistency.
    """
    self.setStyleSheet("""
        /* Main Window */
        QMainWindow {
            background-color: #f5f5f5;
        }

        /* Dock Widget Styling */
        QDockWidget {
            titlebar-close-icon: url(close.png);
            titlebar-normal-icon: url(float.png);
        }

        QDockWidget::title {
            background-color: #e0e0e0;
            padding: 6px;
            border: 1px solid #c0c0c0;
        }

        /* Splitter Handles - Make them more visible */
        QSplitter::handle {
            background-color: #d0d0d0;
        }

        QSplitter::handle:hover {
            background-color: #b0b0b0;
        }

        QSplitter::handle:horizontal {
            width: 2px;
        }

        QSplitter::handle:vertical {
            height: 2px;
        }

        /* Dock Widget Content */
        QDockWidget QWidget {
            background-color: white;
        }
    """)
```

**Optional Enhancement** (if time permits):

Add subtle panel borders for better visual separation:

```python
# In panel placeholder setup
placeholder.setStyleSheet("""
    QLabel {
        color: #666;
        padding: 10px;
        background-color: #fafafa;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
    }
""")
```

#### Step 4: Create Manual Testing Guide (30 minutes)

**File**: `docs/testing/manual-testing-e06-f01.md`

```markdown
# Manual Testing Checklist: E06-F01 Main Window Shell

**Version**: 0.1.0
**Date**: 2025-12-26
**Tester**: _____________
**Platform**: Linux

---

## Test Environment

- **OS**: ____________________ (e.g., Ubuntu 22.04 LTS)
- **Desktop**: ____________________ (e.g., GNOME 44)
- **Display**: ____________________ (e.g., Wayland)
- **Screen**: ____________________ (e.g., 1920x1080 @ 100% scale)

---

## TC-01: Application Launch

**Objective**: Verify application launches correctly

### Steps:
1. Open terminal
2. Navigate to project root
3. Run: `python -m ink`

### Expected Results:
- [ ] Application launches without errors
- [ ] Window appears within 2 seconds
- [ ] Console shows startup log messages
- [ ] No error or warning messages in console

### Actual Results:
_________________________________________________________

---

## TC-02: Window Appearance

**Objective**: Verify window visual appearance

### Steps:
1. Launch application
2. Observe window

### Expected Results:
- [ ] Window title: "Ink - Incremental Schematic Viewer"
- [ ] Window size approximately 1600x900
- [ ] Window has title bar with standard buttons (min, max, close)
- [ ] Window decorations match system theme

### Actual Results:
_________________________________________________________

---

## TC-03: Layout Structure

**Objective**: Verify panel layout is correct

### Steps:
1. Launch application
2. Observe panel positions

### Expected Results:
- [ ] Central area shows "Schematic Canvas Area" placeholder
- [ ] Left panel shows "Hierarchy Panel" placeholder
- [ ] Right panel shows "Property Panel" placeholder
- [ ] Bottom panel shows "Message Panel" placeholder
- [ ] All panel titles visible in title bars
- [ ] Canvas occupies majority of window

### Actual Results:
_________________________________________________________

---

## TC-04: Dock Widget Closing

**Objective**: Verify docks can be closed

### Steps:
1. Launch application
2. Click close button (X) on hierarchy dock
3. Click close button on property dock
4. Click close button on message dock

### Expected Results:
- [ ] Each dock hides when close button clicked
- [ ] Canvas expands to fill space
- [ ] No errors in console
- [ ] Application remains responsive

### Actual Results:
_________________________________________________________

---

## TC-05: Dock Widget Floating

**Objective**: Verify docks can be floated and re-docked

### Steps:
1. Launch application
2. Drag hierarchy dock title bar away from window
3. Observe floating dock
4. Drag floating dock back to left area
5. Observe re-docking

### Expected Results:
- [ ] Dock undocks smoothly when dragged
- [ ] Floating dock becomes separate window
- [ ] Floating dock has own decorations
- [ ] Drop zone highlight appears when dragging near edge
- [ ] Dock re-docks when dropped in allowed area
- [ ] Dock returns to docked position

### Actual Results:
_________________________________________________________

---

## TC-06: Splitter Resizing

**Objective**: Verify panel splitters work

### Steps:
1. Launch application
2. Move mouse to boundary between hierarchy and canvas
3. Observe cursor changes to resize cursor
4. Drag splitter left/right
5. Repeat for property panel and message panel

### Expected Results:
- [ ] Splitter handle visible (subtle line)
- [ ] Cursor changes to resize cursor on hover
- [ ] Dragging splitter resizes panels smoothly
- [ ] No visual glitches during resize
- [ ] Minimum panel sizes respected

### Actual Results:
_________________________________________________________

---

## TC-07: Window Controls

**Objective**: Verify window controls work

### Steps:
1. Launch application
2. Click minimize button
3. Restore window from taskbar
4. Click maximize button
5. Click maximize again to restore
6. Drag title bar to move window
7. Click close button

### Expected Results:
- [ ] Minimize: Window hides to taskbar
- [ ] Restore: Window reappears
- [ ] Maximize: Window fills screen
- [ ] Restore: Window returns to previous size
- [ ] Move: Window moves when title dragged
- [ ] Close: Window closes, application exits

### Actual Results:
_________________________________________________________

---

## TC-08: Window Resizing

**Objective**: Verify window resize behavior

### Steps:
1. Launch application
2. Drag window bottom-right corner to resize larger (e.g., 1920x1080)
3. Drag to resize smaller (e.g., 1280x720)
4. Try to resize below minimum (800x600)

### Expected Results:
- [ ] Window resizes smoothly when dragged
- [ ] Panels scale proportionally
- [ ] Cannot resize below 1024x768
- [ ] All content remains visible during resize

### Actual Results:
_________________________________________________________

---

## TC-09: Tabbed Docks

**Objective**: Verify docks can be tabbed

### Steps:
1. Launch application
2. Drag property dock to left area (on top of hierarchy)
3. Observe tabbed interface
4. Click each tab to switch
5. Drag property tab back to right

### Expected Results:
- [ ] Property dock tabs with hierarchy when dropped on top
- [ ] Tabs visible at bottom of dock area
- [ ] Clicking tab switches active panel
- [ ] Panel content switches correctly
- [ ] Dragging tab out separates it

### Actual Results:
_________________________________________________________

---

## TC-10: Application Exit

**Objective**: Verify clean shutdown

### Steps:
1. Launch application
2. Close window via close button
3. Observe console output
4. Check for zombie processes: `ps aux | grep ink`

### Expected Results:
- [ ] Console shows: "Application exiting with code 0"
- [ ] Terminal prompt returns
- [ ] No zombie processes remain
- [ ] Exit code is 0 (check with `echo $?`)

### Actual Results:
_________________________________________________________

---

## TC-11: High-DPI Display (if available)

**Objective**: Verify high-DPI support

### Test Configurations:
- [ ] 1080p @ 100% scale
- [ ] 1080p @ 150% scale (if supported)
- [ ] 4K @ 200% scale (if available)

### Expected Results:
- [ ] Window scales appropriately for DPI
- [ ] Text is sharp and readable
- [ ] Panel sizes are reasonable
- [ ] No clipping or overlap
- [ ] Icons sharp (future - currently placeholders)

### Actual Results:
_________________________________________________________

---

## TC-12: Startup Performance

**Objective**: Verify startup time requirement

### Steps:
1. Close all Ink instances
2. Run in terminal: `time python -m ink`
3. Close window immediately
4. Note "real" time from output

### Expected Results:
- [ ] Startup time < 2 seconds
- [ ] Window appears quickly
- [ ] No perceived lag

### Actual Time: __________ seconds

---

## Summary

**Total Test Cases**: 12
**Passed**: _____
**Failed**: _____
**Blocked**: _____

**Overall Result**: PASS / FAIL

**Notes**:
_________________________________________________________
_________________________________________________________
_________________________________________________________

**Sign-off**: _______________ Date: _______________
```

#### Step 5: Validate Acceptance Criteria (15 minutes)

**File**: `tests/integration/test_acceptance_criteria.py`

```python
"""
Test parent spec (E06-F01) acceptance criteria.

Verifies all acceptance criteria from E06-F01.spec.md are met.
"""

import pytest
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt
from ink.presentation.main_window import InkMainWindow


@pytest.fixture(scope="module")
def qapp():
    app = QApplication.instance() or QApplication([])
    yield app


@pytest.fixture
def window(qapp):
    win = InkMainWindow()
    yield win
    win.close()


class TestE06F01AcceptanceCriteria:
    """Test acceptance criteria from parent spec."""

    def test_ac01_application_launches(self, window):
        """AC: Application launches with main window visible."""
        window.show()
        assert window.isVisible()
        window.close()

    def test_ac02_correct_title(self, window):
        """AC: Window has title 'Ink - Incremental Schematic Viewer'."""
        assert window.windowTitle() == "Ink - Incremental Schematic Viewer"

    def test_ac03_central_canvas(self, window):
        """AC: Central area contains schematic canvas widget."""
        assert window.centralWidget() is not None
        assert window.centralWidget() == window.schematic_canvas

    def test_ac04_three_docks(self, window):
        """AC: Three dock widgets present."""
        assert window.hierarchy_dock is not None
        assert window.property_dock is not None
        assert window.message_dock is not None

        assert window.hierarchy_dock.windowTitle() == "Hierarchy"
        assert window.property_dock.windowTitle() == "Properties"
        assert window.message_dock.windowTitle() == "Messages"

    def test_ac05_docks_closable(self, window, qapp):
        """AC: All dock widgets can be closed."""
        window.hierarchy_dock.close()
        qapp.processEvents()
        assert not window.hierarchy_dock.isVisible()

        window.property_dock.close()
        qapp.processEvents()
        assert not window.property_dock.isVisible()

        window.message_dock.close()
        qapp.processEvents()
        assert not window.message_dock.isVisible()

    def test_ac06_docks_floatable(self, window, qapp):
        """AC: All dock widgets can be floated."""
        window.hierarchy_dock.setFloating(True)
        qapp.processEvents()
        assert window.hierarchy_dock.isFloating()

        window.hierarchy_dock.setFloating(False)
        qapp.processEvents()

    def test_ac07_docks_redockable(self, window, qapp):
        """AC: All dock widgets can be re-docked."""
        # Float then re-dock
        window.hierarchy_dock.setFloating(True)
        qapp.processEvents()
        window.hierarchy_dock.setFloating(False)
        qapp.processEvents()

        # Should be docked again
        assert not window.hierarchy_dock.isFloating()

    def test_ac08_window_minimizable(self, window, qapp):
        """AC: Window can be minimized."""
        window.show()
        window.showMinimized()
        qapp.processEvents()
        # Note: isVisible() may still be True when minimized
        window.close()

    def test_ac09_window_maximizable(self, window, qapp):
        """AC: Window can be maximized."""
        window.show()
        window.showMaximized()
        qapp.processEvents()
        assert window.isMaximized()
        window.close()

    def test_ac10_window_closable(self, window):
        """AC: Window can be closed."""
        window.show()
        window.close()
        # Just verify no crash

    def test_ac11_respects_window_manager(self, window, qapp):
        """AC: Window respects system window manager decorations."""
        window.show()
        qapp.processEvents()
        # Cannot programmatically verify decorations
        # This is verified via manual testing
        window.close()
```

### 3.2 Estimated Effort

| Step | Duration | Notes |
|------|----------|-------|
| Integration tests | 60 min | Comprehensive test suite |
| Performance tests | 30 min | Benchmarks and timing |
| UI polish | 45 min | Styling and visual refinements |
| Manual testing guide | 30 min | Comprehensive checklist |
| Acceptance criteria validation | 15 min | Parent spec verification |
| **Total** | **180 min** | **3 hours (matches estimate)** |

### 3.3 Dependencies

**Upstream Dependencies**:
- All tasks T01-T04 must be complete
- All components functioning individually

**Downstream Dependencies**:
- Feature complete and ready for next epics (E06-F02, E02, etc.)

**No Blockers**: Can start immediately after T04.

---

## 4. Technical Deep Dive

### 4.1 pytest-qt Testing Framework

#### 4.1.1 QApplication Fixture

```python
@pytest.fixture(scope="module")
def qapp():
    """Create QApplication once per test module."""
    app = QApplication.instance()
    if app is None:
        app = QApplication([])
    yield app
```

**Why module scope?**
- QApplication can only be created once per process
- Module scope creates one app for all tests in file
- Faster test execution
- Prevents "QApplication already created" errors

#### 4.1.2 Widget Testing Patterns

**Pattern 1: Create and Destroy**
```python
def test_window_creation(qapp):
    window = InkMainWindow()
    assert window is not None
    window.deleteLater()
```

**Pattern 2: Fixture-Based**
```python
@pytest.fixture
def window(qapp):
    win = InkMainWindow()
    yield win
    win.close()
    win.deleteLater()

def test_window_title(window):
    assert window.windowTitle() == "Expected Title"
```

**Pattern 3: Process Events**
```python
def test_visibility(window, qapp):
    window.show()
    qapp.processEvents()  # Process show event
    assert window.isVisible()
    window.close()
```

**When to use `processEvents()`?**
- After `show()`, `hide()`, `close()`
- After dock operations
- When testing asynchronous behavior
- When geometry needs to be calculated

### 4.2 Performance Profiling

#### 4.2.1 Using cProfile

```bash
# Profile application startup
python -m cProfile -s cumtime -m ink > profile.txt

# Analyze top functions
head -50 profile.txt
```

**Key Metrics**:
- `cumtime`: Cumulative time (includes subcalls)
- `tottime`: Time in function only (excludes subcalls)
- `ncalls`: Number of calls

**Optimization Targets**:
- Functions with high cumtime in critical path
- Frequently called functions with high tottime
- Unexpected heavy imports

#### 4.2.2 Using pytest-benchmark

```python
def test_creation_benchmark(qapp, benchmark):
    def create():
        window = InkMainWindow()
        window.deleteLater()
        return window

    result = benchmark(create)
    assert result is not None
```

**Benchmark Output**:
```
Name                                     Min      Max     Mean  StdDev
test_creation_benchmark               50.23ms  75.45ms  60.12ms  5.23ms
```

**Install**:
```bash
pip install pytest-benchmark
```

### 4.3 Qt Style Sheets (QSS)

#### 4.3.1 Selector Syntax

```css
/* Widget type */
QDockWidget { }

/* Pseudo-state */
QSplitter::handle:hover { }

/* Child selector */
QDockWidget QWidget { }

/* Property */
QDockWidget::title { }
```

#### 4.3.2 Color Scheme

**Current Palette**:
- Background: `#f5f5f5` (very light gray)
- Dock title: `#e0e0e0` (light gray)
- Splitter: `#d0d0d0` (medium-light gray)
- Splitter hover: `#b0b0b0` (medium gray)
- Content: `white`
- Text: `#666` (dark gray)

**Rationale**:
- Neutral, professional
- High contrast for readability
- Subtle differentiation between areas
- Not distracting

#### 4.3.3 Dynamic Styling

**Current**: Static stylesheet in `_apply_styling()`

**Future** (P1 Theme System):
```python
class ThemeManager:
    def apply_theme(self, window, theme_name):
        if theme_name == "dark":
            qss = self._load_dark_theme()
        else:
            qss = self._load_light_theme()
        window.setStyleSheet(qss)
```

### 4.4 Known Qt Quirks

#### 4.4.1 Geometry Before Show

**Issue**: Widget geometry not calculated until shown

```python
window = InkMainWindow()
print(window.width())  # Returns initial value (1600)

window.show()
qapp.processEvents()
print(window.width())  # Returns actual value (may differ if constraints applied)
```

**Solution**: Always call `show()` and `processEvents()` before testing geometry.

#### 4.4.2 Dock State Restoration

**Issue**: Dock state only saved/restored with object names

```python
# WRONG - won't persist
dock = QDockWidget("Title")

# RIGHT - will persist
dock = QDockWidget("Title")
dock.setObjectName("UniqueName")
```

**Already Handled**: T03 sets object names.

#### 4.4.3 Minimum Size Enforcement

**Issue**: Minimum size only enforced when window shown

```python
window.resize(500, 300)
print(window.size())  # QSize(500, 300) - not enforced yet

window.show()
print(window.size())  # QSize(1024, 768) - clamped to minimum
```

**Test Pattern**: Always show window before testing size constraints.

---

## 5. Risk Analysis

### 5.1 Testing Risks

#### Risk 1: Flaky Tests Due to Timing

**Impact**: Medium (unreliable CI)
**Probability**: Medium
**Description**: Tests fail intermittently due to event timing

**Root Causes**:
- Missing `processEvents()` calls
- Race conditions in Qt event loop
- Platform differences in event processing speed

**Mitigation**:
- Use `qtbot.waitUntil()` for conditions
- Call `processEvents()` after async operations
- Add small delays if needed (`qtbot.wait(100)`)
- Test multiple times locally

**Example Fix**:
```python
# Flaky
window.show()
assert window.isVisible()

# Robust
window.show()
qtbot.waitUntil(lambda: window.isVisible(), timeout=1000)
```

#### Risk 2: Platform-Specific Test Failures

**Impact**: Medium (blocks CI on some platforms)
**Probability**: Low
**Description**: Tests pass on development machine but fail on CI

**Root Causes**:
- Display server differences (Wayland vs X11)
- Missing display (headless CI)
- Qt version differences
- Window manager differences

**Mitigation**:
- Use `pytest-xvfb` for headless testing
- Skip platform-specific tests with markers
- Test on multiple platforms locally
- Use CI matrix (X11, Wayland)

**CI Configuration**:
```yaml
- name: Setup Xvfb
  run: sudo apt-get install xvfb
- name: Run Tests
  run: xvfb-run pytest
```

#### Risk 3: Performance Test Failures on Slow Machines

**Impact**: Low (can adjust thresholds)
**Probability**: Medium
**Description**: Performance tests fail on CI or slow machines

**Root Causes**:
- Shared CI resources
- Different CPU speeds
- Cold start vs warm start
- Background processes

**Mitigation**:
- Set conservative thresholds (2s instead of 500ms)
- Run multiple times and take median
- Skip performance tests in CI (run manually)
- Mark as slow tests

**Threshold Strategy**:
```python
# Development: strict
assert time < 0.5

# CI: relaxed
import os
threshold = 2.0 if os.getenv("CI") else 0.5
assert time < threshold
```

### 5.2 UI Polish Risks

#### Risk 4: Stylesheet Not Applied

**Impact**: Low (cosmetic only)
**Probability**: Low
**Description**: Custom styling doesn't appear

**Root Causes**:
- QSS syntax errors
- Platform style override
- Qt theme system conflict
- Wrong selector specificity

**Mitigation**:
- Validate QSS syntax
- Test on multiple themes (light/dark)
- Use specific selectors
- Check Qt console for warnings

**Debug**:
```python
# Print effective stylesheet
print(window.styleSheet())

# Check for Qt warnings
# Run with: QT_LOGGING_RULES="*.debug=true" python -m ink
```

#### Risk 5: Visual Regressions Not Caught

**Impact**: Low (manual testing catches)
**Probability**: Medium
**Description**: UI changes break visual appearance

**Root Causes**:
- No visual regression testing
- Manual testing not repeated
- Platform differences not tested

**Mitigation**:
- Comprehensive manual testing checklist
- Screenshots in documentation
- Test on multiple platforms
- Future: Visual regression tests (P1)

**Contingency**:
- Accept that visual issues may slip through
- Rely on user feedback
- Fix in subsequent releases

---

## 6. Testing Strategy

### 6.1 Integration Testing

**Coverage Target**: 85%

**Test Pyramid**:
```
        Manual Tests (TC-01 to TC-12)
       /
      /  Integration Tests (85% coverage)
     /
    /    Unit Tests (T01-T04, 90% coverage)
   /
  /__________________________________________
```

### 6.2 Performance Testing

**Automated**: pytest-benchmark
**Manual**: `time` command, profiling

### 6.3 Manual Testing

**Required**: All 12 test cases in manual guide
**Platforms**: At least one Linux environment (X11 or Wayland)

### 6.4 Acceptance Testing

**Validation**: All parent spec acceptance criteria verified

---

## 7. Definition of Done

### 7.1 Testing Complete

- [ ] Integration test suite created and passing
- [ ] Performance tests created and passing
- [ ] Acceptance criteria tests created and passing
- [ ] All tests have > 85% coverage
- [ ] Manual testing guide created
- [ ] Manual testing checklist 100% complete

### 7.2 UI Polish Complete

- [ ] Styling applied to main window
- [ ] Splitter handles visible and styled
- [ ] Dock titles styled
- [ ] No visual glitches
- [ ] Professional appearance verified

### 7.3 Performance Validated

- [ ] Startup time < 2 seconds (verified)
- [ ] Window creation < 500ms (verified)
- [ ] No memory leaks (tested)
- [ ] Performance benchmarks passing

### 7.4 Documentation Complete

- [ ] Manual testing guide complete
- [ ] Test results documented
- [ ] Known issues documented
- [ ] Integration points documented

### 7.5 Parent Spec Validated

- [ ] All E06-F01 acceptance criteria met
- [ ] All user stories satisfied
- [ ] Technical requirements implemented
- [ ] Dependencies verified

---

## 8. Integration Points

### 8.1 Validation for E06-F02 (Menu System)

E06-F02 can proceed knowing:
- Main window structure complete
- Window ready for menu bar
- No known issues blocking menu integration

### 8.2 Validation for E02 (Rendering)

E02 can proceed knowing:
- Central widget area ready for canvas replacement
- No layout issues
- Performance acceptable

### 8.3 Validation for E04 (Panels)

E04 can proceed knowing:
- Dock widgets ready for content replacement
- Panel placeholders working correctly
- Docking operations reliable

---

## 9. Future Enhancements

### 9.1 Automated Visual Regression Testing (P1)

**Tool**: pytest-qt-screenshot or similar

```python
def test_window_appearance(window, qtbot):
    window.show()
    qtbot.waitExposed(window)

    # Capture screenshot
    screenshot = window.grab()

    # Compare with baseline
    assert compare_images(screenshot, "baseline.png")
```

### 9.2 Performance Monitoring Dashboard (P2)

- Track performance metrics over time
- Graph startup time trends
- Alert on regressions
- Integrate with CI

### 9.3 Comprehensive Theme Testing (P1)

- Test light and dark themes
- Test multiple Qt styles
- Test on different platforms
- Automated theme switching tests

---

## 10. Appendix

### 10.1 File Structure

**New Files**:
```
tests/integration/presentation/
├── test_main_window_integration.py  (new)
└── test_acceptance_criteria.py      (new)

tests/performance/
├── __init__.py                      (new)
└── test_startup_performance.py      (new)

docs/testing/
└── manual-testing-e06-f01.md        (new)
```

**Modified Files**:
```
src/ink/presentation/main_window.py  (add _apply_styling)
```

### 10.2 Testing Tools

- `pytest`: Test framework
- `pytest-qt`: Qt testing support
- `pytest-benchmark`: Performance benchmarking
- `pytest-cov`: Coverage reporting
- `cProfile`: Python profiling
- `time`: Shell timing command

### 10.3 Related Documentation

- [pytest-qt Documentation](https://pytest-qt.readthedocs.io/)
- [Qt Style Sheets](https://doc.qt.io/qt-6/stylesheet-reference.html)
- [Qt Testing](https://doc.qt.io/qt-6/qtest-overview.html)

---

**Document Status**: Ready for Implementation
**Next Step**: Create integration test suite and execute comprehensive testing
