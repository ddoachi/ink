# Pre-Implementation Documentation: E06-F02-T02 - File Menu Actions

## Overview

### Problem Context
Users need to load netlist files into Ink to begin schematic exploration. The File menu must provide standard file operations: opening files through a file dialog, accessing recently opened files for quick re-loading, and exiting the application. The recent files list must persist across sessions and handle edge cases like missing files gracefully.

### Scope
- Implement Open action with native file dialog (`Ctrl+O`)
- Create Recent Files submenu with last 10 opened files
- Implement Exit action (`Ctrl+Q`)
- Persist recent files list using QSettings
- Handle missing recent files with error dialogs
- Provide "Clear Recent Files" option

### Related Specifications
- **Parent Feature**: E06-F02 (Menu System)
- **Upstream Dependencies**:
  - E06-F02-T01 (Menu Bar Setup - requires `self.file_menu`)
  - E06-F06 (Settings Persistence - QSettings infrastructure)
- **Downstream Dependencies**:
  - E01-F01 (Netlist Parsing - will integrate with actual file loading)
  - E06-F05 (Status Bar - status messages on load)

---

## Implementation Approach

### Architecture Integration

**Layer**: Presentation Layer
**Component**: `InkMainWindow` class (`src/ink/presentation/main_window.py`)

The File menu actions are UI-driven operations that will eventually delegate to application layer services (FileService) for actual netlist loading. For MVP, we implement the UI flow and settings persistence, with placeholders for full integration.

### Key Components

```
InkMainWindow
├── _create_file_menu()           # Populate File menu (T01 stub)
├── _on_open_file()                # Handle Open dialog
├── _load_netlist(file_path)       # Load file and update recent list
├── _update_recent_files_menu()    # Rebuild recent files submenu
├── _open_recent_file(file_path)   # Open from recent list
├── _get_recent_files()            # Retrieve from QSettings
├── _add_recent_file(file_path)    # Add to recent list (dedupe + limit)
├── _remove_recent_file(file_path) # Remove from recent list
└── _clear_recent_files()          # Clear all recent files

Instance Variables:
├── self.recent_menu: QMenu        # Recent Files submenu
└── MAX_RECENT_FILES: int = 10     # Class constant

QSettings:
└── "recent_files": list[str]      # Stored file paths
```

### Implementation Steps

1. **Implement `_create_file_menu()`**
   - Create Open action with Ctrl+O shortcut
   - Create Recent Files submenu
   - Create Exit action with Ctrl+Q shortcut
   - Connect actions to handler methods

2. **Implement file opening flow**
   - `_on_open_file()` - Show QFileDialog with `.ckt` and `.cdl` filters
   - `_load_netlist()` - Placeholder integration, update recent files
   - Error handling with QMessageBox

3. **Implement recent files management**
   - `_get_recent_files()` - Load from QSettings, handle type safety
   - `_add_recent_file()` - Deduplicate, add to front, limit to 10
   - `_remove_recent_file()` - Remove deleted files
   - `_clear_recent_files()` - Clear entire list
   - `_update_recent_files_menu()` - Rebuild submenu with current list

4. **Implement recent file opening**
   - `_open_recent_file()` - Check existence, show error if missing
   - Remove missing files from list automatically

5. **Add QSettings integration**
   - Use organization: "Ink", application: "InkSchematicViewer"
   - Store/retrieve "recent_files" key

---

## Key Design Decisions

### Decision 1: Recent Files Storage Format

**Options Considered**:
1. **QSettings with list of strings** - Simple, Qt-native
2. **JSON file** - More flexible, manual management
3. **SQLite database** - Overkill for simple list

**Chosen**: QSettings with list of strings

**Rationale**:
- Qt-native solution, automatically handles platform differences
- Simple to implement and maintain
- Automatic persistence across sessions
- Platform-specific storage locations (no path hardcoding)
- Built-in type safety and serialization

**Trade-offs**:
- Less control over storage location
- Requires type checking (QSettings can return various types)

### Decision 2: Recent Files List Management

**Options Considered**:
1. **Most recent at end** - Append new files
2. **Most recent at front** - Prepend new files
3. **Timestamp-based sorting** - Store with timestamps

**Chosen**: Most recent at front

**Rationale**:
- Intuitive for users (most recent appears first in menu)
- Simple implementation (insert at index 0)
- No need for timestamp management
- Standard pattern in desktop applications

**Implementation**:
- Remove file if already in list
- Insert at front (index 0)
- Limit to MAX_RECENT_FILES

### Decision 3: Missing File Handling

**Options Considered**:
1. **Silent removal** - Remove without telling user
2. **Warning dialog + removal** - Inform user, then remove
3. **Keep in list with disabled action** - Show but disable

**Chosen**: Warning dialog + removal

**Rationale**:
- Users should know why a file didn't open
- Automatic cleanup prevents stale entries
- Clear communication builds trust
- Standard behavior in most applications

**Dialog Content**:
- Explain file no longer exists
- Show file path for user reference
- Indicate it will be removed from list

### Decision 4: File Loading Integration Point

**Options Considered**:
1. **Implement full loading now** - Complete integration with FileService
2. **Placeholder with TODO** - Update recent files, defer actual loading
3. **Skip file loading entirely** - Just manage recent files

**Chosen**: Placeholder with TODO

**Rationale**:
- E01-F01 (Netlist Parsing) may not be complete
- Allows menu to be functional for UI testing
- Clear integration point documented
- Recent files functionality can be tested independently

**Placeholder Behavior**:
- Update recent files list
- Show status message "Loaded: {file}"
- Catch and display errors

### Decision 5: Recent Files Menu Structure

**Chosen Structure**:
```
Open Recent
  ├── /path/to/file1.ckt
  ├── /path/to/file2.ckt
  ├── ...
  ├── [separator]
  └── Clear Recent Files
```

**Rationale**:
- File paths as action text (simple, clear)
- Tooltips show full path (for long paths)
- Clear action separated at bottom
- "No recent files" placeholder when empty

---

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F02-T01 (Menu Bar Setup)**
- **Required**: `self.file_menu` instance variable
- **Required**: `_create_file_menu()` stub method
- **Integration**: Replace stub with full implementation

**E06-F06 (Settings Persistence)**
- **Required**: QSettings infrastructure (Qt built-in, no custom code needed)
- **Integration**: Use QSettings("Ink", "InkSchematicViewer")

### Downstream Dependencies

**E01-F01 (Netlist Parsing)**
- **Future Integration**: Replace placeholder in `_load_netlist()`
- **Interface**: Call `FileService.load_netlist(file_path)` or similar
- **Error Handling**: Catch parsing exceptions and show user-friendly errors

**E06-F05 (Status Bar)**
- **Current**: Use `self.statusBar().showMessage()` (QMainWindow built-in)
- **Future**: May enhance with progress indicators
- **Integration**: Status messages on successful load

### External Dependencies

**PySide6 Modules**:
- `QFileDialog` - Native file open dialog
- `QMessageBox` - Error/warning dialogs
- `QAction` - Menu action items
- `QKeySequence` - Standard keyboard shortcuts
- `QSettings` - Persistent storage

**Python Standard Library**:
- `pathlib.Path` - File existence checking

### Integration Points

1. **File Loading Pipeline**
   ```
   User clicks "Open"
     → _on_open_file() shows dialog
     → User selects file
     → _load_netlist(file_path)
     → [TODO: FileService integration]
     → _add_recent_file(file_path)
     → _update_recent_files_menu()
   ```

2. **Recent File Selection**
   ```
   User clicks recent file
     → _open_recent_file(file_path)
     → Check Path(file_path).exists()
     → If missing: show warning, _remove_recent_file()
     → If exists: _load_netlist(file_path)
   ```

3. **Settings Persistence**
   ```
   QSettings("Ink", "InkSchematicViewer")
     → Linux: ~/.config/Ink/InkSchematicViewer.conf
     → Windows: Registry
     → macOS: ~/Library/Preferences/com.Ink.InkSchematicViewer.plist
   ```

---

## Testing Strategy

### Unit Tests

**Location**: `tests/ui/test_file_menu.py`

**Test Cases**:
1. **Menu Structure**
   - `test_open_action_exists` - Verify Open action with Ctrl+O
   - `test_recent_files_submenu_exists` - Verify Recent Files submenu
   - `test_exit_action_exists` - Verify Exit action with Ctrl+Q

2. **Recent Files Management**
   - `test_add_recent_file` - Add file, verify at top
   - `test_recent_files_max_limit` - Add 15 files, verify only 10 kept
   - `test_recent_files_deduplication` - Add same file twice, verify single entry
   - `test_remove_recent_file` - Remove file, verify gone from list
   - `test_clear_recent_files` - Clear all, verify empty list

3. **QSettings Integration**
   - `test_recent_files_persistence` - Add file, restart fixture, verify persists
   - `test_settings_type_safety` - Verify list handling when QSettings returns non-list

4. **Menu Updates**
   - `test_update_recent_files_menu_empty` - Verify "No recent files" when empty
   - `test_update_recent_files_menu_populated` - Verify file actions created
   - `test_clear_action_in_menu` - Verify "Clear Recent Files" appears

**Test Fixtures**:
```python
@pytest.fixture
def main_window(qtbot, tmp_path):
    """Create InkMainWindow with temporary settings."""
    # Use tmp_path for QSettings to avoid polluting user settings
    settings = QSettings(str(tmp_path / "test.ini"), QSettings.Format.IniFormat)
    window = InkMainWindow()
    window._settings = settings  # Override settings for testing
    qtbot.addWidget(window)
    return window
```

### Integration Tests

**Scenario 1: Full Open Flow**
```python
def test_open_file_flow(main_window, qtbot, tmp_path):
    """Test complete file opening flow."""
    # Create test file
    test_file = tmp_path / "test.ckt"
    test_file.write_text("* Test netlist")

    # Mock QFileDialog to return test file
    with patch.object(QFileDialog, 'getOpenFileName', return_value=(str(test_file), '')):
        main_window._on_open_file()

    # Verify file added to recent list
    recent = main_window._get_recent_files()
    assert str(test_file) in recent
```

**Scenario 2: Missing File Handling**
```python
def test_open_missing_recent_file(main_window, qtbot):
    """Test opening a recent file that no longer exists."""
    # Add file to recent list
    missing_file = "/nonexistent/file.ckt"
    main_window._add_recent_file(missing_file)

    # Mock QMessageBox to avoid blocking
    with patch.object(QMessageBox, 'warning'):
        main_window._open_recent_file(missing_file)

    # Verify file removed from list
    recent = main_window._get_recent_files()
    assert missing_file not in recent
```

### Manual Testing Checklist

1. **Open File Dialog**
   - [ ] Press `Ctrl+O` - dialog appears
   - [ ] Click File > Open - dialog appears
   - [ ] Verify filter shows "Netlist Files (*.ckt *.cdl)"
   - [ ] Verify "All Files (*)" filter available
   - [ ] Select `.ckt` file - file opens, appears in recent list
   - [ ] Select `.cdl` file - file opens, appears in recent list
   - [ ] Cancel dialog - no action taken

2. **Recent Files Menu**
   - [ ] Open 3 files - verify all appear in Recent Files
   - [ ] Verify most recent appears at top
   - [ ] Click recent file - file opens
   - [ ] Open same file again - verify still only one entry (at top)
   - [ ] Open 12 files - verify only 10 shown
   - [ ] Restart application - verify recent files persist

3. **Missing File Handling**
   - [ ] Open file, add to recent list
   - [ ] Delete file from disk
   - [ ] Click file in Recent Files menu
   - [ ] Verify warning dialog appears
   - [ ] Verify dialog explains file is missing
   - [ ] Click OK - verify file removed from recent list

4. **Clear Recent Files**
   - [ ] Open several files
   - [ ] File > Open Recent > Clear Recent Files
   - [ ] Verify list is cleared
   - [ ] Verify "No recent files" message appears

5. **Exit Action**
   - [ ] Press `Ctrl+Q` - application exits
   - [ ] Click File > Exit - application exits

---

## Risks and Considerations

### Risk 1: QSettings Type Variability

**Description**: `QSettings.value()` can return various types (list, string, None) depending on storage state

**Likelihood**: High

**Impact**: Medium (crashes if not handled)

**Mitigation**:
```python
recent = settings.value("recent_files", [])
if not isinstance(recent, list):
    recent = [] if recent is None else [recent]
```
- Defensive type checking
- Convert single values to list
- Default to empty list if None

### Risk 2: File Path Portability

**Description**: Absolute paths in recent files may not work if files move or across systems

**Likelihood**: Medium

**Impact**: Low (user can re-open file)

**Mitigation**:
- Store absolute paths (standard approach)
- Missing file handling removes invalid entries
- Future enhancement: store relative to project root
- Document limitation in user docs

### Risk 3: Recent Files Menu Performance

**Description**: Rebuilding menu on every file open may be slow with many files

**Likelihood**: Low (max 10 files)

**Impact**: Very Low (negligible performance)

**Mitigation**:
- Limited to 10 files
- Menu rebuild is fast operation
- If needed in future: only update specific actions vs full rebuild

### Risk 4: File Loading Integration Timing

**Description**: E01-F01 may not be ready when this task completes

**Likelihood**: Medium

**Impact**: Low (placeholder works for testing)

**Mitigation**:
- Use placeholder with clear TODO comments
- File menu UI can be fully tested
- Recent files functionality works independently
- Integration point clearly documented

### Risk 5: Lambda Capture Bug

**Description**: Lambda in loop may capture wrong variable (common Python pitfall)

**Likelihood**: High (if not careful)

**Impact**: High (all recent files open the same file)

**Mitigation**:
```python
# WRONG:
for file_path in recent_files:
    action.triggered.connect(lambda: self._open_recent_file(file_path))  # Bug!

# CORRECT:
for file_path in recent_files:
    action.triggered.connect(
        lambda checked, path=file_path: self._open_recent_file(path)
    )
```
- Use default argument to capture value
- Test thoroughly with multiple recent files

### Consideration 1: File Dialog Starting Directory

The file dialog should remember the last used directory for better UX:
```python
# Future enhancement:
last_dir = settings.value("last_file_directory", "")
file_path, _ = QFileDialog.getOpenFileName(self, "Open Netlist File", last_dir, ...)
if file_path:
    settings.setValue("last_file_directory", os.path.dirname(file_path))
```

Not required for MVP but easy to add later.

### Consideration 2: Recent Files Display Format

For long file paths, consider showing just filename in action text:
```python
filename = Path(file_path).name
action = QAction(filename, self)
action.setToolTip(file_path)  # Full path on hover
```

Current spec shows full path. Consider UX testing for final decision.

### Consideration 3: File Type Validation

The file dialog filters by extension, but `_load_netlist()` should validate file content. This will be handled in E01-F01 integration.

---

## Implementation Checklist

### Pre-Implementation
- [ ] Verify E06-F02-T01 (Menu Bar Setup) is complete
- [ ] Verify `self.file_menu` exists and `_create_file_menu()` is stubbed
- [ ] Review PySide6 QFileDialog, QSettings documentation
- [ ] Set up test fixtures with temporary QSettings

### Implementation
- [ ] Implement `_create_file_menu()` with Open, Recent Files, Exit actions
- [ ] Add `MAX_RECENT_FILES = 10` class constant
- [ ] Implement `_on_open_file()` with QFileDialog
- [ ] Implement `_load_netlist()` with placeholder and error handling
- [ ] Implement `_get_recent_files()` with type safety
- [ ] Implement `_add_recent_file()` with deduplication and limiting
- [ ] Implement `_remove_recent_file()`
- [ ] Implement `_clear_recent_files()`
- [ ] Implement `_update_recent_files_menu()` with dynamic action creation
- [ ] Implement `_open_recent_file()` with existence checking
- [ ] Add keyboard shortcuts: `Ctrl+O`, `Ctrl+Q`
- [ ] Add status tips to all actions
- [ ] Add proper lambda capture for recent file actions
- [ ] Add type hints to all methods
- [ ] Add comprehensive docstrings

### Testing
- [ ] Write unit tests for menu structure
- [ ] Write unit tests for recent files management
- [ ] Write unit tests for QSettings integration
- [ ] Write integration test for full open flow
- [ ] Write integration test for missing file handling
- [ ] Test lambda capture with multiple recent files
- [ ] Test QSettings type safety edge cases
- [ ] Run all tests and verify they pass
- [ ] Perform complete manual testing checklist
- [ ] Test keyboard shortcuts

### Documentation
- [ ] Add TODO comments for E01-F01 integration
- [ ] Document QSettings keys and formats
- [ ] Add inline comments for non-obvious code
- [ ] Update method docstrings with integration points

---

## Success Criteria

**Definition of Done**:
1. File > Open shows file dialog with correct filters
2. Selected files added to recent list (max 10)
3. Recent Files submenu populated dynamically
4. Most recent file appears at top
5. Missing files handled with warning dialog
6. Clear Recent Files works correctly
7. Exit action closes application
8. Keyboard shortcuts work: `Ctrl+O`, `Ctrl+Q`
9. Recent files persist across application restarts
10. All unit and integration tests pass
11. Manual testing checklist complete
12. Code follows project style guidelines

**Acceptance Validation**:
- All acceptance criteria from spec are met
- No crashes or errors during file operations
- QSettings storage working correctly
- Ready for E01-F01 integration
- Clear documentation of integration points
