# Pre-Implementation Documentation: E06-F02-T03 - Edit Menu Actions

## Overview

### Problem Context
Schematic exploration involves expanding and collapsing cells, and users need the ability to undo/redo these operations. The Edit menu must provide standard undo/redo actions with context-sensitive enabling (disabled when no history), plus a Find action to activate the search panel. These are fundamental user expectations for any interactive application.

### Scope
- Implement Undo action with dynamic state management (`Ctrl+Z`)
- Implement Redo action with dynamic state management (`Ctrl+Shift+Z`)
- Implement Find action to show and focus search panel (`Ctrl+F`)
- Enable/disable Undo/Redo based on expansion history availability
- Update action text to show what will be undone/redone ("Undo Expand", etc.)
- Integrate with search panel focus mechanism

### Related Specifications
- **Parent Feature**: E06-F02 (Menu System)
- **Upstream Dependencies**:
  - E06-F02-T01 (Menu Bar Setup - requires `self.edit_menu`)
  - E06-F03 (Search Panel - requires search dock and panel)
- **Downstream Dependencies**:
  - E04-F03 (Undo/Redo - ExpansionService with undo/redo methods)
  - E05-F01 (Search - search panel focus method)

---

## Implementation Approach

### Architecture Integration

**Layer**: Presentation Layer
**Component**: `InkMainWindow` class (`src/ink/presentation/main_window.py`)

The Edit menu actions are UI-driven operations that delegate to application layer services. Undo/Redo will eventually call ExpansionService methods, while Find controls search panel visibility and focus.

### Key Components

```
InkMainWindow
├── _create_edit_menu()           # Populate Edit menu (T01 stub)
├── _on_undo()                    # Handle Undo action
├── _on_redo()                    # Handle Redo action
├── _on_find()                    # Handle Find action
└── _update_undo_redo_state()     # Update action enabled state and text

Instance Variables:
├── self.undo_action: QAction     # Undo action (stored for state updates)
└── self.redo_action: QAction     # Redo action (stored for state updates)

Integration Points:
├── ExpansionService              # TODO: can_undo(), can_redo(), undo(), redo()
└── SearchPanel                   # focus_search_input()
```

### Implementation Steps

1. **Implement `_create_edit_menu()`**
   - Create Undo action with Ctrl+Z shortcut, initially disabled
   - Create Redo action with Ctrl+Shift+Z shortcut, initially disabled
   - Create Find action with Ctrl+F shortcut
   - Store undo/redo actions as instance variables for state updates
   - Connect actions to handler methods

2. **Implement undo/redo handlers**
   - `_on_undo()` - Placeholder for ExpansionService integration
   - `_on_redo()` - Placeholder for ExpansionService integration
   - Both call `_update_undo_redo_state()` after operation

3. **Implement state management**
   - `_update_undo_redo_state()` - Query history availability (placeholder)
   - Enable/disable actions based on history state
   - Update action text dynamically ("Undo", "Undo Expand", etc.)

4. **Implement Find handler**
   - `_on_find()` - Show search dock if hidden
   - Focus search input field via search panel method

5. **Add state update hooks**
   - Call `_update_undo_redo_state()` after expansion operations
   - Call `_update_undo_redo_state()` after collapse operations
   - Call `_update_undo_redo_state()` after loading netlist (reset)

---

## Key Design Decisions

### Decision 1: Action State Storage

**Options Considered**:
1. **Store actions as instance variables** (`self.undo_action`)
2. **Find actions via `findChild()` when needed**
3. **Use action groups with centralized state**

**Chosen**: Store actions as instance variables

**Rationale**:
- Frequent state updates require direct access
- Simpler and more performant than searching
- Clear ownership and lifecycle
- Allows state updates from anywhere in main window

**Note**: File menu actions don't need storage because they're always enabled.

### Decision 2: Undo/Redo State Update Timing

**Options Considered**:
1. **Manual calls** after each expansion/collapse
2. **Signal-based** - Expansion service emits signal
3. **Polling** - Check state periodically

**Chosen**: Manual calls after operations

**Rationale**:
- Simple and explicit
- No signal overhead
- State changes are infrequent
- Easy to understand control flow

**Implementation**:
```python
def _on_expand_cell(self, cell_id):
    # ... expansion logic ...
    self._update_undo_redo_state()

def _on_collapse_cell(self, cell_id):
    # ... collapse logic ...
    self._update_undo_redo_state()
```

### Decision 3: Action Text Updates

**Options Considered**:
1. **Static text** - Always "Undo" and "Redo"
2. **Dynamic text** - "Undo Expand", "Redo Collapse", etc.
3. **Detailed text** - "Undo Expand: CELL_NAME"

**Chosen**: Dynamic text with action type

**Rationale**:
- Provides useful context to users
- Not overly verbose
- Standard pattern in desktop applications
- Easy to implement with action type from service

**Examples**:
- "Undo Expand" when last action was expansion
- "Undo Collapse" when last action was collapse
- "Undo" when no history (grayed out anyway)

### Decision 4: Placeholder vs Full Integration

**Options Considered**:
1. **Full integration now** - Implement complete undo/redo
2. **Placeholder with TODO** - UI ready, defer undo/redo logic
3. **Disable actions** - Leave grayed out until E04-F03

**Chosen**: Placeholder with TODO

**Rationale**:
- E04-F03 (Undo/Redo) is a separate task
- Allows menu to be visually complete
- State management logic can be tested with mocks
- Clear integration points documented

**Placeholder Behavior**:
- Show status message when triggered
- Call `_update_undo_redo_state()` (will use real service later)
- Actions remain disabled until service integration

### Decision 5: Find Action Behavior

**Options Considered**:
1. **Toggle visibility** - Show if hidden, hide if visible
2. **Always show + focus** - Show and focus, even if already visible
3. **Show only** - Make visible without focus

**Chosen**: Always show + focus

**Rationale**:
- User intent is to search - focus makes this immediate
- Toggle is confusing (Ctrl+F might hide the panel)
- If already visible, re-focusing is harmless and ensures user can type
- Standard behavior in code editors and browsers

**Implementation**:
```python
def _on_find(self):
    if not self.search_dock.isVisible():
        self.search_dock.setVisible(True)
    self.search_panel.focus_search_input()  # Always focus
```

---

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F02-T01 (Menu Bar Setup)**
- **Required**: `self.edit_menu` instance variable
- **Required**: `_create_edit_menu()` stub method
- **Integration**: Replace stub with full implementation

**E06-F03 (Search Panel)**
- **Required**: `self.search_dock` (QDockWidget containing search panel)
- **Required**: `self.search_panel` (SearchPanel widget)
- **Integration**: Call `setVisible(True)` and `focus_search_input()`

### Downstream Dependencies

**E04-F03 (Undo/Redo)**
- **Future Integration**: Replace placeholder in `_on_undo()` and `_on_redo()`
- **Interface**: ExpansionService methods:
  - `can_undo() -> bool`
  - `can_redo() -> bool`
  - `undo() -> None`
  - `redo() -> None`
  - `get_undo_description() -> str` (e.g., "Expand", "Collapse")
  - `get_redo_description() -> str`
- **Integration Point**: `_update_undo_redo_state()`

**E05-F01 (Search)**
- **Future Integration**: SearchPanel must provide `focus_search_input()` method
- **Interface**:
  ```python
  class SearchPanel(QWidget):
      def focus_search_input(self):
          self.search_input.setFocus()
          self.search_input.selectAll()
  ```

### External Dependencies

**PySide6 Modules**:
- `QAction` - Menu action items
- `QKeySequence` - Standard keyboard shortcuts
- `QKeySequence.StandardKey` - Platform-specific shortcuts

### Integration Points

1. **Undo/Redo Flow (Future)**
   ```
   User presses Ctrl+Z
     → _on_undo()
     → expansion_service.undo()
     → _update_undo_redo_state()
     → Query: can_undo(), can_redo()
     → Update: setEnabled(), setText()
   ```

2. **Find Flow**
   ```
   User presses Ctrl+F
     → _on_find()
     → search_dock.setVisible(True)
     → search_panel.focus_search_input()
     → User can immediately type search query
   ```

3. **State Update Hooks**
   ```
   After expansion/collapse/load:
     → _update_undo_redo_state()
     → Query ExpansionService (or placeholder)
     → Enable/disable actions
     → Update action text
   ```

---

## Testing Strategy

### Unit Tests

**Location**: `tests/ui/test_edit_menu.py`

**Test Cases**:
1. **Menu Structure**
   - `test_undo_action_exists` - Verify Undo action with Ctrl+Z
   - `test_redo_action_exists` - Verify Redo action with Ctrl+Shift+Z
   - `test_find_action_exists` - Verify Find action with Ctrl+F
   - `test_menu_order` - Verify Undo, Redo, separator, Find

2. **Initial State**
   - `test_undo_redo_initially_disabled` - Verify actions start disabled
   - `test_undo_redo_text_initial` - Verify default text ("Undo", "Redo")

3. **State Management**
   - `test_update_undo_redo_state` - Verify state update method exists
   - `test_undo_action_stored` - Verify `self.undo_action` accessible
   - `test_redo_action_stored` - Verify `self.redo_action` accessible

4. **Find Action**
   - `test_find_shows_search_panel` - Verify search dock becomes visible
   - `test_find_focuses_search_input` - Verify focus set (requires mock)

**Test Fixtures**:
```python
@pytest.fixture
def main_window_with_search(qtbot):
    """Create InkMainWindow with search panel."""
    window = InkMainWindow()
    # Ensure search panel is initialized
    qtbot.addWidget(window)
    return window
```

### Integration Tests

**Scenario 1: Find Action Integration**
```python
def test_find_action_integration(main_window, qtbot):
    """Test Find action shows and focuses search panel."""
    # Hide search panel
    main_window.search_dock.setVisible(False)

    # Create mock for focus method
    focus_called = False
    original_focus = main_window.search_panel.focus_search_input

    def mock_focus():
        nonlocal focus_called
        focus_called = True
        original_focus()

    main_window.search_panel.focus_search_input = mock_focus

    # Trigger find action
    main_window._on_find()

    # Verify panel visible and focus called
    assert main_window.search_dock.isVisible()
    assert focus_called
```

**Scenario 2: State Update After Operations** (will fully test in E04-F03)
```python
def test_undo_redo_state_after_expansion(main_window, qtbot):
    """Test undo/redo state updates after expansion."""
    # Initially disabled
    assert not main_window.undo_action.isEnabled()

    # Mock expansion service to simulate undo availability
    # (This will be real integration in E04-F03)
    # For now, just test that update method can be called
    main_window._update_undo_redo_state()

    # With placeholder, should remain disabled
    assert not main_window.undo_action.isEnabled()
```

### Manual Testing Checklist

1. **Undo/Redo Initial State**
   - [ ] Launch application
   - [ ] Verify Undo grayed out (disabled)
   - [ ] Verify Redo grayed out (disabled)
   - [ ] Verify text is "Undo" and "Redo"

2. **Find Action**
   - [ ] Ensure search panel is hidden
   - [ ] Press `Ctrl+F`
   - [ ] Verify search panel becomes visible
   - [ ] Verify cursor in search input field
   - [ ] Type immediately - verify typing works
   - [ ] Press `Ctrl+F` again with panel visible
   - [ ] Verify search input re-focuses (existing text selected)

3. **Menu Navigation**
   - [ ] Click Edit menu
   - [ ] Verify Undo, Redo, separator, Find items
   - [ ] Hover over items - verify status tips appear in status bar

4. **Keyboard Shortcuts**
   - [ ] Press `Ctrl+Z` - verify undo handler called (status message)
   - [ ] Press `Ctrl+Shift+Z` - verify redo handler called (status message)
   - [ ] Press `Ctrl+F` - verify find action triggered

5. **Platform-Specific Shortcuts** (if testing on macOS)
   - [ ] Verify `Cmd+Z` works (Qt handles automatically)
   - [ ] Verify `Cmd+Shift+Z` works

---

## Risks and Considerations

### Risk 1: Search Panel Not Ready

**Description**: E06-F03 (Search Panel) may not be complete when this task starts

**Likelihood**: Medium

**Impact**: Medium (blocks Find action)

**Mitigation**:
- Coordinate task scheduling with E06-F03
- If blocked, implement Find action with try/except:
  ```python
  def _on_find(self):
      try:
          if not self.search_dock.isVisible():
              self.search_dock.setVisible(True)
          self.search_panel.focus_search_input()
      except AttributeError:
          self.statusBar().showMessage("Search panel not yet implemented", 2000)
  ```
- Document dependency clearly

### Risk 2: Undo/Redo Integration Complexity

**Description**: ExpansionService interface may differ from expected

**Likelihood**: Medium

**Impact**: Low (isolated to placeholder replacement)

**Mitigation**:
- Define expected interface clearly in this doc
- Communicate with E04-F03 implementer
- Placeholder makes actual integration straightforward
- Integration point is single method: `_update_undo_redo_state()`

### Risk 3: State Update Performance

**Description**: Calling `_update_undo_redo_state()` frequently may be slow

**Likelihood**: Very Low

**Impact**: Very Low (only called after user actions)

**Mitigation**:
- Undo/redo state changes are infrequent (user-triggered)
- Querying history availability should be O(1)
- If needed, cache state and invalidate on changes

### Risk 4: Keyboard Shortcut Conflicts

**Description**: Ctrl+Z, Ctrl+Shift+Z, Ctrl+F may conflict with other widgets

**Likelihood**: Low (standard shortcuts)

**Impact**: Low (Qt handles focus correctly)

**Mitigation**:
- Qt's action system handles focus context automatically
- Shortcuts only trigger when main window or child widgets have focus
- Test with various panels focused

### Risk 5: Focus Management for Find

**Description**: Search input focus may not work if search panel not properly initialized

**Likelihood**: Low

**Impact**: Low (Find shows panel but doesn't focus)

**Mitigation**:
- Ensure search panel fully initialized before calling focus method
- Add defensive check:
  ```python
  if hasattr(self.search_panel, 'focus_search_input'):
      self.search_panel.focus_search_input()
  ```
- Test Find action thoroughly

### Consideration 1: Dynamic Action Text Detail Level

The spec suggests "Undo Expand" vs "Undo Expand: CELL_NAME". Current choice is action type only. Consider user feedback:
- More detail helps but may be verbose
- Cell names can be long
- Menu width may be limited

Decision: Start with action type, gather user feedback, enhance if needed.

### Consideration 2: Multiple Undo Levels in Menu

Some applications show multiple undo levels in a submenu. Not in MVP scope, but consider for future:
```
Undo
  ├── Expand CELL_A
  ├── Collapse CELL_B
  └── Expand CELL_C
```

Requires undo stack exposure from ExpansionService.

### Consideration 3: Status Bar Messages

Placeholder handlers show status messages. Consider whether to keep these in final implementation:
- Helpful for debugging
- May be redundant with actual undo/redo operations
- Decision: Remove status messages in E04-F03 integration

---

## Implementation Checklist

### Pre-Implementation
- [ ] Verify E06-F02-T01 (Menu Bar Setup) is complete
- [ ] Verify `self.edit_menu` exists and `_create_edit_menu()` is stubbed
- [ ] Check status of E06-F03 (Search Panel) - coordinate if needed
- [ ] Review PySide6 QAction and QKeySequence documentation
- [ ] Define expected ExpansionService interface for E04-F03

### Implementation
- [ ] Implement `_create_edit_menu()` with Undo, Redo, Find actions
- [ ] Add keyboard shortcuts: `Ctrl+Z`, `Ctrl+Shift+Z`, `Ctrl+F`
- [ ] Store `self.undo_action` and `self.redo_action` instance variables
- [ ] Set Undo/Redo initially disabled
- [ ] Add status tips to all actions
- [ ] Implement `_on_undo()` with placeholder and state update call
- [ ] Implement `_on_redo()` with placeholder and state update call
- [ ] Implement `_on_find()` with search panel show and focus
- [ ] Implement `_update_undo_redo_state()` with placeholder logic
- [ ] Add dynamic text updates to actions
- [ ] Add comprehensive docstrings with integration notes
- [ ] Add TODO comments for E04-F03 integration points

### Testing
- [ ] Write unit tests for menu structure
- [ ] Write unit tests for initial state
- [ ] Write unit tests for state management
- [ ] Write integration test for Find action
- [ ] Write placeholder tests for undo/redo (will enhance in E04-F03)
- [ ] Test keyboard shortcuts (Ctrl+Z, Ctrl+Shift+Z, Ctrl+F)
- [ ] Test Find action with search panel hidden/visible
- [ ] Run all tests and verify they pass
- [ ] Perform complete manual testing checklist

### Documentation
- [ ] Document ExpansionService interface expectations
- [ ] Document SearchPanel interface expectations
- [ ] Add TODO comments for E04-F03 and E05-F01 integration
- [ ] Update method docstrings with integration points
- [ ] Add inline comments for state management logic

---

## Success Criteria

**Definition of Done**:
1. Edit menu contains Undo, Redo, and Find actions
2. Keyboard shortcuts work: `Ctrl+Z`, `Ctrl+Shift+Z`, `Ctrl+F`
3. Undo/Redo actions initially disabled
4. Undo/Redo actions stored as instance variables
5. `_update_undo_redo_state()` method implemented
6. Find action shows search panel if hidden
7. Find action focuses search input field
8. Status tips appear in status bar on hover
9. All unit and integration tests pass
10. Manual testing checklist complete
11. Code follows project style guidelines
12. Integration points clearly documented

**Acceptance Validation**:
- All acceptance criteria from spec are met
- Actions enable/disable correctly (with placeholder logic)
- Find action integrates with search panel
- Ready for E04-F03 integration (undo/redo)
- Ready for E05-F01 integration (search focus)
- Clear documentation of expected interfaces
