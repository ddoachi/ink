# Pre-Implementation Documentation: E06-F02-T01 - Menu Bar Setup

## Overview

### Problem Context
The Ink application currently lacks a menu bar interface, which is a standard component of desktop applications. Users expect to access core functionality through File, Edit, View, and Help menus. This task establishes the foundational menu bar structure that will be populated with actions in subsequent tasks.

### Scope
- Create and attach QMenuBar to InkMainWindow
- Add four top-level menu containers: File, Edit, View, Help
- Implement helper methods for menu population (stubbed initially)
- Ensure proper mnemonic keyboard access (Alt+F, Alt+E, Alt+V, Alt+H)

### Related Specifications
- **Parent Feature**: E06-F02 (Menu System)
- **Upstream Dependency**: E06-F01 (Main Window Shell - requires InkMainWindow class)
- **Downstream Consumers**:
  - E06-F02-T02 (File Menu Actions)
  - E06-F02-T03 (Edit Menu Actions)
  - E06-F02-T04 (View and Help Menus)

---

## Implementation Approach

### Architecture Integration

**Layer**: Presentation Layer
**Component**: `InkMainWindow` class (`src/ink/presentation/main_window.py`)

The menu bar is a pure UI concern and belongs in the presentation layer. It will:
1. Use Qt's built-in QMenuBar automatically created by QMainWindow
2. Store menu references as instance variables for later population
3. Delegate to helper methods for organization and maintainability

### Key Components

```
InkMainWindow
├── _setup_menus()           # Main menu initialization method
├── _create_file_menu()      # Stub for T02
├── _create_edit_menu()      # Stub for T03
├── _create_view_menu()      # Stub for T04
└── _create_help_menu()      # Stub for T04

Instance Variables:
├── self.file_menu: QMenu
├── self.edit_menu: QMenu
├── self.view_menu: QMenu
└── self.help_menu: QMenu
```

### Implementation Steps

1. **Add menu setup to `__init__`**
   - Call `_setup_menus()` after `_setup_ui()`
   - Ensure proper initialization order

2. **Implement `_setup_menus()`**
   - Get menuBar() from QMainWindow (auto-created)
   - Add four top-level menus with mnemonics
   - Store menu references as instance variables
   - Call helper methods for each menu

3. **Create stub helper methods**
   - `_create_file_menu()` with `pass`
   - `_create_edit_menu()` with `pass`
   - `_create_view_menu()` with `pass`
   - `_create_help_menu()` with `pass`

4. **Add docstrings**
   - Document purpose of each method
   - Note which task will populate each menu

---

## Key Design Decisions

### Decision 1: Menu Organization Pattern

**Options Considered**:
1. **Single monolithic method** - All menus created in one method
2. **Separate helper methods** - Each menu gets its own creation method
3. **Separate menu classes** - Each menu is a separate class

**Chosen**: Separate helper methods

**Rationale**:
- Keeps code organized and readable
- Allows each task to focus on a specific helper method
- Balances simplicity with maintainability
- Avoids over-engineering for MVP scope

**Trade-offs**:
- Helper methods are stubs initially (acceptable for phased implementation)
- Slight increase in line count vs monolithic approach

### Decision 2: Menu Reference Storage

**Options Considered**:
1. **Store as instance variables** (`self.file_menu`)
2. **Use `findChild()` to retrieve menus when needed**
3. **Create a menu registry dictionary**

**Chosen**: Store as instance variables

**Rationale**:
- Direct access is simpler and faster
- Clear ownership and lifecycle
- Type hints work well with instance variables
- Standard Qt pattern for widget references

### Decision 3: Mnemonic Placement

**Chosen**: First letter of menu name (`&File`, `&Edit`, `&View`, `&Help`)

**Rationale**:
- Standard convention across desktop applications
- No conflicts between these four menu names
- Intuitive for users (Alt+F for File, etc.)

---

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F01 (Main Window Shell)**
- **Required**: `InkMainWindow` class must exist
- **Required**: `_setup_ui()` method must be implemented
- **Integration**: Call `_setup_menus()` after `_setup_ui()` in `__init__`

### Downstream Dependencies

**E06-F02-T02 (File Menu Actions)**
- Will populate `_create_file_menu()` method
- Needs `self.file_menu` reference

**E06-F02-T03 (Edit Menu Actions)**
- Will populate `_create_edit_menu()` method
- Needs `self.edit_menu` reference

**E06-F02-T04 (View and Help Menus)**
- Will populate `_create_view_menu()` and `_create_help_menu()` methods
- Needs `self.view_menu` and `self.help_menu` references

### External Dependencies

**PySide6**
- `QMenuBar` - Auto-created by QMainWindow
- `QMenu` - Menu containers
- `QMainWindow.menuBar()` - Accessor method

### Integration Points

1. **Main Window Initialization**
   ```python
   def __init__(self):
       super().__init__()
       self._setup_ui()      # Existing
       self._setup_menus()   # NEW - add after UI setup
   ```

2. **Menu Reference Access**
   - Other components can access menus via instance variables
   - Actions can be added/modified by other initialization methods

---

## Testing Strategy

### Unit Tests

**Location**: `tests/ui/test_main_window.py`

**Test Cases**:
1. `test_menu_bar_exists` - Verify menuBar() is created
2. `test_top_level_menus_exist` - Verify all four menu references exist
3. `test_menu_titles` - Verify correct titles with mnemonics
4. `test_helper_methods_exist` - Verify helper methods are defined
5. `test_menu_order` - Verify menus appear in correct order (File, Edit, View, Help)

**Fixtures Needed**:
```python
@pytest.fixture
def main_window(qtbot):
    """Create InkMainWindow instance for testing."""
    window = InkMainWindow()
    qtbot.addWidget(window)
    return window
```

### Integration Tests

Not required for this task - purely structural setup.

### Manual Testing Checklist

1. **Visual Verification**
   - [ ] Launch application
   - [ ] Menu bar appears at top of window
   - [ ] Four menus visible: File, Edit, View, Help

2. **Menu Interaction**
   - [ ] Click each menu - should open (empty is OK)
   - [ ] Menus display correct titles
   - [ ] Clicking outside closes menu

3. **Keyboard Access**
   - [ ] Press Alt+F - File menu opens
   - [ ] Press Alt+E - Edit menu opens
   - [ ] Press Alt+V - View menu opens
   - [ ] Press Alt+H - Help menu opens

4. **Platform Compatibility**
   - [ ] Test on Linux (primary platform)
   - [ ] Verify menu bar positioning (Qt handles platform differences)

---

## Risks and Considerations

### Risk 1: Platform Menu Bar Differences

**Description**: macOS uses application-level menu bars, not window-level

**Likelihood**: Medium (affects cross-platform)

**Impact**: Low (Qt handles this automatically)

**Mitigation**:
- Qt's QMenuBar handles platform differences
- On macOS, menu appears in system menu bar
- On Linux/Windows, menu appears in window
- No code changes needed for MVP (Linux-only)
- Document for future cross-platform work

### Risk 2: Menu Bar Z-Order Issues

**Description**: Menu bar might not position correctly with central widget

**Likelihood**: Very Low

**Impact**: Low (visual glitch)

**Mitigation**:
- QMainWindow automatically handles menu bar layout
- Call `_setup_menus()` after `_setup_ui()` to ensure proper initialization order
- Test visually during manual testing

### Risk 3: Incomplete Main Window Shell

**Description**: E06-F01 might not be complete when this task starts

**Likelihood**: Low

**Impact**: High (blocks implementation)

**Mitigation**:
- Verify E06-F01 completion before starting
- Check that `InkMainWindow` class exists and `_setup_ui()` is implemented
- Coordinate with parallel development efforts

### Consideration 1: Future Menu Customization

The stub helper methods provide flexibility for:
- Adding submenus in future tasks
- Dynamic menu item enabling/disabling
- Menu reorganization based on user feedback

### Consideration 2: Accessibility

Mnemonics provide keyboard access for users who:
- Prefer keyboard navigation
- Have mobility limitations
- Use screen readers

This is good practice and should be maintained in future menu additions.

### Consideration 3: Styling and Theming

Menu bar will use Qt's default styling for MVP. Future P1 theming feature (if implemented) will be able to style menus through Qt style sheets without code changes.

---

## Implementation Checklist

### Pre-Implementation
- [ ] Verify E06-F01 (Main Window Shell) is complete
- [ ] Read `InkMainWindow` class to understand current structure
- [ ] Review PySide6 QMenuBar documentation
- [ ] Set up test fixtures for `InkMainWindow`

### Implementation
- [ ] Add `_setup_menus()` call to `__init__`
- [ ] Implement `_setup_menus()` method
- [ ] Create `self.file_menu` with mnemonic
- [ ] Create `self.edit_menu` with mnemonic
- [ ] Create `self.view_menu` with mnemonic
- [ ] Create `self.help_menu` with mnemonic
- [ ] Add stub `_create_file_menu()` with docstring
- [ ] Add stub `_create_edit_menu()` with docstring
- [ ] Add stub `_create_view_menu()` with docstring
- [ ] Add stub `_create_help_menu()` with docstring
- [ ] Add type hints to all methods
- [ ] Add docstrings to all methods

### Testing
- [ ] Write unit tests for menu existence
- [ ] Write unit tests for menu titles
- [ ] Run all tests and verify they pass
- [ ] Perform manual visual verification
- [ ] Test keyboard mnemonics (Alt+F, Alt+E, Alt+V, Alt+H)
- [ ] Verify code follows PEP 8 style guidelines

### Documentation
- [ ] Update method docstrings with task references
- [ ] Add inline comments for non-obvious code
- [ ] Verify pre-docs match implementation

---

## Success Criteria

**Definition of Done**:
1. Menu bar visible in main window
2. Four top-level menus created with correct titles
3. Mnemonics work for keyboard access
4. Helper methods exist and are callable
5. Unit tests pass
6. Manual testing checklist complete
7. Code follows project style guidelines
8. No errors or warnings in implementation

**Acceptance Validation**:
- All acceptance criteria from spec are met
- Code review passes (if applicable)
- No regression in existing functionality
- Ready for T02, T03, T04 to populate menus
