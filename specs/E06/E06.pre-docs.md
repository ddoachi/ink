# E06 - User Interface Shell: Pre-Implementation Planning

**Epic**: E06 - User Interface Shell
**Date**: 2025-12-26
**Status**: Pre-Implementation
**Author**: Claude

---

## 1. Overview

### 1.1 Purpose

This pre-implementation document provides comprehensive planning for building the User Interface Shell (E06), which serves as the foundational framework for the Ink schematic viewer application. This epic creates the main window structure, menu system, toolbar, panels, and settings persistence that all other UI components will integrate into.

### 1.2 Epic Summary

The UI Shell establishes the core application window using PySide6 (Qt6), implementing a standard EDA tool layout with:
- Central schematic canvas workspace
- Dockable panels (hierarchy, properties, messages)
- Menu bar with File, Edit, View, Help menus
- Toolbar with quick-access actions
- Status bar for contextual information
- Settings persistence for layout and recent files

### 1.3 Success Metrics

- Application startup time < 2 seconds
- Zero crashes during panel docking/undocking
- 100% settings persistence across sessions
- Keyboard shortcuts response time < 50ms
- Memory footprint < 50MB at startup (empty canvas)

---

## 2. Architecture Decisions

### 2.1 UI Framework Choice: PySide6

**Decision**: Use PySide6 (Qt6) as the UI framework

**Rationale**:
- **Industry Standard**: Qt is the de facto standard for EDA tools (Cadence, Synopsys, Mentor)
- **Feature Completeness**: Built-in support for dock widgets, MDI, custom painting, keyboard shortcuts
- **Performance**: Native C++ rendering with Python bindings provides good performance
- **Cross-Platform**: Although targeting Linux, Qt provides cross-platform capability for future expansion
- **Licensing**: LGPL-licensed PySide6 suitable for open-source project

**Alternatives Considered**:
- **PyQt6**: Similar to PySide6 but GPL-licensed, less permissive
- **GTK4 (PyGObject)**: Linux-native but less common in EDA domain, fewer custom drawing primitives
- **wxPython**: Less powerful dock widget system, smaller EDA adoption
- **Dear ImGui**: Excellent for custom rendering but lacks standard desktop widgets (menus, dock panels)

**Trade-offs**:
- Qt has steep learning curve but provides comprehensive documentation
- Larger dependency footprint (~100MB) but acceptable for desktop application
- Python bindings add overhead but provide excellent developer productivity

### 2.2 Application Architecture Pattern: MVC with Qt's Signal/Slot

**Decision**: Use Model-View-Controller pattern with Qt's signal/slot mechanism for event handling

**Architecture**:
```
┌─────────────────────────────────────────┐
│         InkMainWindow (Controller)       │
│  - Coordinates views and models          │
│  - Handles menu/toolbar actions          │
│  - Manages application state             │
└─────────────────────────────────────────┘
         │                │              │
         ▼                ▼              ▼
┌─────────────┐  ┌──────────────┐  ┌──────────────┐
│  Canvas     │  │  Panels      │  │  Settings    │
│  (View)     │  │  (Views)     │  │  (Model)     │
└─────────────┘  └──────────────┘  └──────────────┘
         │                │              │
         └────────────────┴──────────────┘
                       │
                       ▼
              ┌─────────────────┐
              │  Graph Model    │
              │  (Core Data)    │
              └─────────────────┘
```

**Rationale**:
- Decouples UI from business logic
- Qt's signal/slot provides loose coupling between components
- Testable: Can test controller logic independently of UI
- Extensible: Easy to add new panels/views

### 2.3 Settings Persistence: QSettings with INI Format

**Decision**: Use Qt's `QSettings` class with INI file format

**Storage Location**: `~/.config/InkProject/Ink.conf` (Linux XDG standard)

**Rationale**:
- **Native Integration**: QSettings seamlessly stores Qt types (QByteArray, QSize, etc.)
- **Cross-Platform**: Handles platform-specific storage locations automatically
- **Type-Safe**: Stores Python primitives and Qt objects with proper serialization
- **Human-Readable**: INI format allows manual editing if needed

**Alternatives Considered**:
- **JSON file**: More verbose, requires manual Qt type serialization
- **YAML file**: External dependency, overkill for simple settings
- **SQLite database**: Unnecessary complexity for flat key-value settings

### 2.4 Panel Management: QDockWidget System

**Decision**: Use Qt's `QDockWidget` for all side/bottom panels

**Features Enabled**:
- Drag-and-drop docking to window edges
- Floating as independent windows
- Tabbed grouping (multiple panels in same area)
- Resize handles
- Close/show toggle

**Rationale**:
- Industry standard in EDA tools (users expect this behavior)
- Zero custom implementation needed
- Automatic layout serialization via `QMainWindow.saveState()`
- Native look and feel

### 2.5 Menu System Organization

**Decision**: Organize menus by workflow rather than component

**Structure**:
- **File**: Document lifecycle (open, recent, exit)
- **Edit**: Modification actions (undo, redo, find)
- **View**: Visualization controls (zoom, panels)
- **Help**: Documentation and about

**Rationale**:
- Follows standard desktop application conventions
- Intuitive for users familiar with any desktop application
- Scalable for future feature additions (Tools menu, Window menu)

---

## 3. Implementation Strategy

### 3.1 Phased Development Approach

#### Phase 1: Foundation (Priority 1)
**Goal**: Create minimal launchable application

**Tasks**:
1. Create `InkMainWindow` class inheriting from `QMainWindow`
2. Set up application entry point in `main.py`
3. Configure Qt application metadata (name, organization)
4. Implement basic window with placeholder central widget
5. Add basic File → Exit menu
6. Verify application launches and closes cleanly

**Deliverable**: Application window that launches and displays empty window

**Estimated Effort**: 2-4 hours

#### Phase 2: Panel Structure (Priority 1)
**Goal**: Establish dockable panel framework

**Tasks**:
1. Create three `QDockWidget` instances (hierarchy, property, message)
2. Add placeholder content to each dock (simple `QLabel`)
3. Set initial dock positions (left, right, bottom)
4. Configure dock features (closable, movable, floatable)
5. Test docking, undocking, tabbing behavior

**Deliverable**: Application with three functional dockable panels

**Estimated Effort**: 3-5 hours

#### Phase 3: Menu & Toolbar (Priority 2)
**Goal**: Implement complete menu system and toolbar

**Tasks**:
1. Create menu bar with File, Edit, View, Help menus
2. Add all menu actions with keyboard shortcuts
3. Create toolbar with icon buttons (use placeholder icons initially)
4. Connect menu/toolbar actions to placeholder slots
5. Implement View menu checkboxes for panel visibility
6. Test all keyboard shortcuts

**Deliverable**: Full menu system and toolbar with placeholder actions

**Estimated Effort**: 4-6 hours

#### Phase 4: Status Bar (Priority 2)
**Goal**: Add contextual information display

**Tasks**:
1. Create status bar with four sections (file, zoom, selection, counts)
2. Implement status update methods (set_file, set_zoom, etc.)
3. Add permanent widgets for each status section
4. Test status updates with mock data

**Deliverable**: Functional status bar displaying contextual info

**Estimated Effort**: 2-3 hours

#### Phase 5: Settings Persistence (Priority 2)
**Goal**: Save and restore window layout and preferences

**Tasks**:
1. Create `AppSettings` service class wrapping `QSettings`
2. Implement save/restore for window geometry and state
3. Implement save/restore for panel visibility
4. Implement recent files list management
5. Hook save to `closeEvent`, restore to `__init__`
6. Test settings persist across application restarts

**Deliverable**: Complete settings persistence system

**Estimated Effort**: 4-6 hours

#### Phase 6: Recent Files (Priority 3)
**Goal**: Implement recent files functionality

**Tasks**:
1. Add recent files submenu to File menu
2. Implement logic to add file to recent list (max 10)
3. Update menu dynamically when recent files change
4. Handle missing/moved files gracefully
5. Add "Clear Recent" action
6. Test recent files across sessions

**Deliverable**: Working recent files feature

**Estimated Effort**: 3-4 hours

#### Phase 7: Polish & Integration (Priority 3)
**Goal**: Refine UI and prepare for component integration

**Tasks**:
1. Replace placeholder icons with proper SVG icons
2. Add tooltips to all toolbar buttons
3. Implement About dialog with version info
4. Add keyboard shortcuts help dialog
5. Test high-DPI display scaling
6. Performance profiling and optimization
7. Create integration points for canvas and panel components

**Deliverable**: Production-ready UI shell

**Estimated Effort**: 4-6 hours

### 3.2 Total Estimated Effort

**Total**: 22-34 hours (3-4 working days)

### 3.3 Critical Path

```
Phase 1 (Foundation) → Phase 2 (Panels) → Phase 5 (Settings) → Phase 7 (Integration)
                                ↓
                       Phase 3 (Menus) → Phase 4 (Status) → Phase 6 (Recent Files)
```

**Critical Path**: Phase 1 → 2 → 7 (foundation for other epics to integrate)

**Parallel Work**: Phase 3, 4, 6 can be developed in parallel with other epics once Phase 2 is complete

---

## 4. Technical Deep Dive

### 4.1 Main Window Structure

#### 4.1.1 Class Hierarchy

```python
QMainWindow (Qt)
    └── InkMainWindow (ink.ui.main_window)
            ├── _setup_ui()
            ├── _create_menus()
            ├── _create_toolbar()
            ├── _create_status_bar()
            ├── _create_dock_panels()
            ├── _connect_signals()
            ├── _restore_settings()
            └── closeEvent()
```

#### 4.1.2 Initialization Sequence

```python
def __init__(self):
    super().__init__()

    # 1. Basic window setup
    self.setWindowTitle("Ink - Incremental Schematic Viewer")
    self.resize(1400, 900)  # Default size

    # 2. Create services
    self.settings = AppSettings()

    # 3. Create central widget (canvas placeholder)
    self.central_widget = QWidget()
    self.setCentralWidget(self.central_widget)

    # 4. Create UI components
    self._create_dock_panels()
    self._create_menus()
    self._create_toolbar()
    self._create_status_bar()

    # 5. Connect signals
    self._connect_signals()

    # 6. Restore saved state
    self._restore_settings()
```

#### 4.1.3 Memory Management

**Ownership Model**:
- `QMainWindow` owns all child widgets (Qt parent-child hierarchy)
- Automatic cleanup when window is destroyed
- No manual `deleteLater()` calls needed for standard widgets

**Resource Considerations**:
- Status bar widgets: Keep references to avoid recreation on updates
- Menu actions: Store in class attributes for signal connection
- Icons: Load once, reuse via `QIcon.fromTheme()` or resource file

### 4.2 Dock Panel System

#### 4.2.1 Dock Widget Configuration

```python
def _create_dock_panels(self):
    # Hierarchy Panel (Left)
    self.hierarchy_dock = QDockWidget("Hierarchy", self)
    self.hierarchy_dock.setObjectName("HierarchyDock")  # For state persistence
    self.hierarchy_dock.setAllowedAreas(
        Qt.DockWidgetArea.LeftDockWidgetArea |
        Qt.DockWidgetArea.RightDockWidgetArea
    )

    # Placeholder content
    hierarchy_content = QLabel("Hierarchy Panel")
    self.hierarchy_dock.setWidget(hierarchy_content)

    self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.hierarchy_dock)

    # Property Panel (Right)
    self.property_dock = QDockWidget("Properties", self)
    self.property_dock.setObjectName("PropertyDock")
    # ... similar setup

    # Message Panel (Bottom)
    self.message_dock = QDockWidget("Messages", self)
    self.message_dock.setObjectName("MessageDock")
    # ... similar setup
```

**Key Design Decisions**:
- `setObjectName()`: Required for `saveState()/restoreState()` to work
- `setAllowedAreas()`: Restrict docking to logical positions
- Initial widget: Simple placeholder until real panel components ready

#### 4.2.2 Panel Visibility Management

```python
def _sync_panel_visibility_menu(self):
    """Sync View menu checkboxes with actual panel visibility"""
    self.action_hierarchy_panel.setChecked(self.hierarchy_dock.isVisible())
    self.action_property_panel.setChecked(self.property_dock.isVisible())
    self.action_message_panel.setChecked(self.message_dock.isVisible())

def _connect_signals(self):
    # Two-way binding: menu ↔ panel visibility
    self.action_hierarchy_panel.triggered.connect(
        lambda checked: self.hierarchy_dock.setVisible(checked)
    )
    self.hierarchy_dock.visibilityChanged.connect(
        self._sync_panel_visibility_menu
    )
    # ... repeat for other panels
```

### 4.3 Menu System Implementation

#### 4.3.1 Menu Action Management

```python
def _create_menus(self):
    menubar = self.menuBar()

    # File Menu
    file_menu = menubar.addMenu("&File")

    self.action_open = QAction("&Open...", self)
    self.action_open.setShortcut(QKeySequence.StandardKey.Open)  # Ctrl+O
    self.action_open.setStatusTip("Open a netlist file")
    file_menu.addAction(self.action_open)

    # Recent Files submenu (dynamic)
    self.recent_files_menu = file_menu.addMenu("Open &Recent")
    self._update_recent_files_menu()

    file_menu.addSeparator()

    self.action_exit = QAction("E&xit", self)
    self.action_exit.setShortcut(QKeySequence.StandardKey.Quit)  # Ctrl+Q
    file_menu.addAction(self.action_exit)
```

**Best Practices**:
- Use `QKeySequence.StandardKey` for platform-consistent shortcuts
- Set status tips for all actions (displayed in status bar on hover)
- Use ampersand (`&`) for mnemonic shortcuts (Alt+F → File)
- Store actions as instance attributes for signal connection

#### 4.3.2 Dynamic Menu Updates

```python
def _update_recent_files_menu(self):
    """Rebuild recent files menu from settings"""
    self.recent_files_menu.clear()

    recent_files = self.settings.get_recent_files()

    if not recent_files:
        action = self.recent_files_menu.addAction("No recent files")
        action.setEnabled(False)
        return

    for file_path in recent_files:
        action = self.recent_files_menu.addAction(file_path)
        action.triggered.connect(
            lambda checked, path=file_path: self._open_recent_file(path)
        )

    self.recent_files_menu.addSeparator()
    clear_action = self.recent_files_menu.addAction("Clear Recent")
    clear_action.triggered.connect(self._clear_recent_files)
```

**Critical Detail**: Lambda captures `path=file_path` to avoid closure bug (all lambdas would reference same variable)

### 4.4 Settings Persistence

#### 4.4.1 AppSettings Service

```python
from PySide6.QtCore import QSettings

class AppSettings:
    """Manages application settings persistence"""

    def __init__(self):
        self.settings = QSettings(
            "InkProject",  # Organization
            "Ink"          # Application
        )

    def save_window_state(self, window: QMainWindow):
        """Save window geometry and dock layout"""
        self.settings.setValue("window/geometry", window.saveGeometry())
        self.settings.setValue("window/state", window.saveState())

    def restore_window_state(self, window: QMainWindow):
        """Restore window geometry and dock layout"""
        geometry = self.settings.value("window/geometry")
        if geometry:
            window.restoreGeometry(geometry)

        state = self.settings.value("window/state")
        if state:
            window.restoreState(state)

    def add_recent_file(self, file_path: str):
        """Add file to recent files list (max 10)"""
        recent = self.get_recent_files()

        # Remove if already exists (will re-add at front)
        if file_path in recent:
            recent.remove(file_path)

        # Add to front
        recent.insert(0, file_path)

        # Limit to 10
        recent = recent[:10]

        self.settings.setValue("recent_files", recent)

    def get_recent_files(self) -> list[str]:
        """Get recent files list"""
        return self.settings.value("recent_files", [])

    def clear_recent_files(self):
        """Clear recent files list"""
        self.settings.setValue("recent_files", [])
```

#### 4.4.2 Save/Restore Integration

```python
class InkMainWindow(QMainWindow):

    def _restore_settings(self):
        """Called at end of __init__"""
        self.settings.restore_window_state(self)

    def closeEvent(self, event):
        """Called when window is closing"""
        self.settings.save_window_state(self)
        event.accept()
```

**Settings File Location**: `~/.config/InkProject/Ink.conf` (on Linux)

**Format** (INI):
```ini
[window]
geometry=@ByteArray(...)
state=@ByteArray(...)

[recent_files]
1\path=/home/user/design1.ckt
2\path=/home/user/design2.ckt
size=2
```

### 4.5 Toolbar Implementation

#### 4.5.1 Toolbar Creation

```python
def _create_toolbar(self):
    toolbar = self.addToolBar("Main Toolbar")
    toolbar.setObjectName("MainToolbar")
    toolbar.setMovable(False)  # Fixed position

    # Open
    toolbar.addAction(self.action_open)

    toolbar.addSeparator()

    # Zoom controls (will be implemented in E02)
    self.action_zoom_in = QAction("Zoom In", self)
    self.action_zoom_in.setShortcut(QKeySequence.StandardKey.ZoomIn)
    toolbar.addAction(self.action_zoom_in)

    self.action_zoom_out = QAction("Zoom Out", self)
    self.action_zoom_out.setShortcut(QKeySequence.StandardKey.ZoomOut)
    toolbar.addAction(self.action_zoom_out)

    self.action_fit_view = QAction("Fit View", self)
    self.action_fit_view.setShortcut(QKeySequence("Ctrl+0"))
    toolbar.addAction(self.action_fit_view)

    toolbar.addSeparator()

    # Undo/Redo
    self.action_undo = QAction("Undo", self)
    self.action_undo.setShortcut(QKeySequence.StandardKey.Undo)
    toolbar.addAction(self.action_undo)

    self.action_redo = QAction("Redo", self)
    self.action_redo.setShortcut(QKeySequence.StandardKey.Redo)
    toolbar.addAction(self.action_redo)
```

**Icon Strategy** (Phase 7):
```python
# Option 1: Use system theme icons (Linux standard)
self.action_open.setIcon(QIcon.fromTheme("document-open"))

# Option 2: Bundle custom SVG icons
icon_path = Path(__file__).parent / "resources" / "icons" / "open.svg"
self.action_open.setIcon(QIcon(str(icon_path)))

# Option 3: Use Qt resource system (compile .qrc file)
self.action_open.setIcon(QIcon(":/icons/open.svg"))
```

**Recommendation**: Use Option 1 (system theme) for Phase 6, move to Option 3 for production (ensures consistency)

### 4.6 Status Bar Implementation

#### 4.6.1 Status Bar Structure

```python
def _create_status_bar(self):
    status = self.statusBar()

    # Left: Temporary messages (shown via showMessage())
    # No widget needed, uses default behavior

    # Right: Permanent widgets
    self.status_file = QLabel("No file loaded")
    self.status_file.setMinimumWidth(200)
    status.addPermanentWidget(self.status_file)

    status.addPermanentWidget(QLabel(" | "))  # Separator

    self.status_zoom = QLabel("Zoom: 100%")
    status.addPermanentWidget(self.status_zoom)

    status.addPermanentWidget(QLabel(" | "))

    self.status_selection = QLabel("Selected: 0")
    status.addPermanentWidget(self.status_selection)

    status.addPermanentWidget(QLabel(" | "))

    self.status_counts = QLabel("Cells: 0  Nets: 0")
    status.addPermanentWidget(self.status_counts)

def update_status_file(self, file_path: str):
    """Update loaded file in status bar"""
    file_name = Path(file_path).name
    self.status_file.setText(file_name)

def update_status_zoom(self, zoom_percent: float):
    """Update zoom level in status bar"""
    self.status_zoom.setText(f"Zoom: {zoom_percent:.0f}%")

# Similar for other status fields...
```

### 4.7 High-DPI Display Support

```python
def main():
    # Enable high-DPI scaling BEFORE creating QApplication
    QApplication.setHighDpiScaleFactorRoundingPolicy(
        Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )

    app = QApplication(sys.argv)

    # Enable high-DPI pixmaps
    app.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)

    # ... rest of application setup
```

**Testing Strategy**:
- Test on 1x display (1920x1080)
- Test on 2x display (4K/5K)
- Test fractional scaling (1.5x, 1.25x)
- Verify icons scale properly
- Verify font rendering

---

## 5. Risk Analysis

### 5.1 Technical Risks

#### Risk 1: Qt Version Compatibility Issues
**Impact**: High
**Probability**: Low
**Description**: PySide6 API changes between minor versions could break functionality

**Mitigation**:
- Pin exact PySide6 version in `pyproject.toml` (e.g., `PySide6==6.6.1`)
- Document Qt version in README
- Test on minimum supported Qt version (6.5+)
- Use only stable Qt APIs (avoid deprecated features)
- Subscribe to Qt changelog for breaking changes

**Contingency**:
- If breaking change occurs, evaluate upgrade vs. version pin
- Maintain compatibility layer for common API changes

#### Risk 2: High-DPI Display Rendering Issues
**Impact**: Medium
**Probability**: Medium
**Description**: Custom painting or image assets may not scale correctly on high-DPI displays

**Mitigation**:
- Use vector graphics (SVG) for all icons
- Enable Qt high-DPI scaling from startup
- Use device-independent pixels in all measurements
- Test on multiple DPI settings (100%, 150%, 200%)
- Use Qt's built-in scaling APIs rather than manual calculations

**Contingency**:
- If scaling issues occur, provide manual DPI override setting
- Document known issues and workarounds

#### Risk 3: Settings File Corruption
**Impact**: Low
**Probability**: Low
**Description**: QSettings file could become corrupted, preventing application launch

**Mitigation**:
- Wrap `restoreState()` in try-except block
- Fall back to default layout if restore fails
- Log restoration failures for debugging
- Provide "Reset Layout" action to delete settings

**Contingency**:
```python
def _restore_settings(self):
    try:
        self.settings.restore_window_state(self)
    except Exception as e:
        logging.warning(f"Failed to restore settings: {e}")
        # Continue with default layout
```

#### Risk 4: Panel Docking State Inconsistencies
**Impact**: Low
**Probability**: Medium
**Description**: Dock widget state may not restore correctly across Qt versions or screen configurations

**Mitigation**:
- Use `setObjectName()` on all dock widgets (required for state persistence)
- Test state restoration after screen resolution changes
- Provide "Reset Layout" menu action
- Document expected behavior

**Contingency**:
- If restoration fails, fall back to default layout silently
- Log warning for debugging

### 5.2 Usability Risks

#### Risk 5: Non-Standard Keyboard Shortcuts
**Impact**: Low
**Probability**: Low
**Description**: Users expect standard shortcuts; custom shortcuts may frustrate users

**Mitigation**:
- Use `QKeySequence.StandardKey` enum for all standard operations
- Document all keyboard shortcuts in Help menu
- Follow platform conventions (Ctrl on Linux/Windows, Cmd on macOS)
- Test shortcuts don't conflict with system shortcuts

**Contingency**:
- Provide customizable keyboard shortcuts in Phase 2 (post-MVP)

#### Risk 6: Poor Initial Layout on Unusual Screen Sizes
**Impact**: Low
**Probability**: Medium
**Description**: Default window size/layout may not work well on very small or very large screens

**Mitigation**:
- Use percentage-based sizing where possible
- Set reasonable minimum window size (800x600)
- Set maximum initial size (90% of screen)
- Test on common screen sizes (1920x1080, 1366x768, 2560x1440, 3840x2160)

**Contingency**:
```python
def __init__(self):
    # ... setup code

    # Size to 80% of screen, but don't exceed 1600x1000
    screen = QApplication.primaryScreen().geometry()
    width = min(int(screen.width() * 0.8), 1600)
    height = min(int(screen.height() * 0.8), 1000)
    self.resize(width, height)

    # Center window
    self.move(
        (screen.width() - width) // 2,
        (screen.height() - height) // 2
    )
```

### 5.3 Performance Risks

#### Risk 7: Slow Application Startup
**Impact**: Medium
**Probability**: Low
**Description**: Qt application initialization could be slow, exceeding 2-second target

**Mitigation**:
- Defer loading of non-essential components
- Use lazy initialization for panels (load content only when visible)
- Profile startup time with `cProfile`
- Measure cold start vs. warm start (cached Python modules)

**Performance Budget**:
- Qt initialization: < 500ms
- UI creation: < 300ms
- Settings restoration: < 100ms
- Total: < 1000ms (with buffer to 2s)

**Contingency**:
- Show splash screen if startup exceeds 1 second
- Load panels asynchronously after window shown

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Test Framework**: `pytest` with `pytest-qt` plugin

**Coverage Target**: 80% for UI logic (excluding trivial getters/setters)

#### 6.1.1 Main Window Tests

```python
# tests/ui/test_main_window.py

import pytest
from PySide6.QtWidgets import QApplication
from ink.ui.main_window import InkMainWindow

@pytest.fixture
def app(qtbot):
    """Create QApplication instance"""
    return QApplication.instance() or QApplication([])

@pytest.fixture
def main_window(qtbot, app):
    """Create main window instance"""
    window = InkMainWindow()
    qtbot.addWidget(window)
    return window

def test_main_window_creation(main_window):
    """Test window is created with correct title"""
    assert main_window.windowTitle() == "Ink - Incremental Schematic Viewer"

def test_dock_widgets_created(main_window):
    """Test all dock widgets are created"""
    assert main_window.hierarchy_dock is not None
    assert main_window.property_dock is not None
    assert main_window.message_dock is not None

def test_initial_dock_positions(main_window):
    """Test docks are in correct initial positions"""
    assert main_window.dockWidgetArea(main_window.hierarchy_dock) == Qt.DockWidgetArea.LeftDockWidgetArea
    assert main_window.dockWidgetArea(main_window.property_dock) == Qt.DockWidgetArea.RightDockWidgetArea
    assert main_window.dockWidgetArea(main_window.message_dock) == Qt.DockWidgetArea.BottomDockWidgetArea

def test_menu_actions_exist(main_window):
    """Test all required menu actions exist"""
    assert main_window.action_open is not None
    assert main_window.action_exit is not None
    assert main_window.action_undo is not None
    assert main_window.action_redo is not None

def test_keyboard_shortcuts(main_window):
    """Test keyboard shortcuts are configured"""
    assert main_window.action_open.shortcut() == QKeySequence.StandardKey.Open
    assert main_window.action_exit.shortcut() == QKeySequence.StandardKey.Quit
```

#### 6.1.2 Settings Persistence Tests

```python
# tests/services/test_app_settings.py

import pytest
from PySide6.QtCore import QSettings
from ink.services.app_settings import AppSettings

@pytest.fixture
def settings(tmp_path):
    """Create settings with temporary storage"""
    QSettings.setPath(
        QSettings.Format.IniFormat,
        QSettings.Scope.UserScope,
        str(tmp_path)
    )
    return AppSettings()

def test_recent_files_add(settings):
    """Test adding files to recent list"""
    settings.add_recent_file("/path/to/file1.ckt")
    settings.add_recent_file("/path/to/file2.ckt")

    recent = settings.get_recent_files()
    assert len(recent) == 2
    assert recent[0] == "/path/to/file2.ckt"  # Most recent first
    assert recent[1] == "/path/to/file1.ckt"

def test_recent_files_deduplicate(settings):
    """Test duplicate files move to front"""
    settings.add_recent_file("/path/to/file1.ckt")
    settings.add_recent_file("/path/to/file2.ckt")
    settings.add_recent_file("/path/to/file1.ckt")  # Re-add first file

    recent = settings.get_recent_files()
    assert len(recent) == 2
    assert recent[0] == "/path/to/file1.ckt"  # Moved to front

def test_recent_files_max_limit(settings):
    """Test recent files limited to 10"""
    for i in range(15):
        settings.add_recent_file(f"/path/to/file{i}.ckt")

    recent = settings.get_recent_files()
    assert len(recent) == 10
    assert recent[0] == "/path/to/file14.ckt"  # Most recent
    assert recent[9] == "/path/to/file5.ckt"   # Oldest in list

def test_clear_recent_files(settings):
    """Test clearing recent files"""
    settings.add_recent_file("/path/to/file1.ckt")
    settings.clear_recent_files()

    recent = settings.get_recent_files()
    assert len(recent) == 0
```

### 6.2 Integration Testing

#### 6.2.1 Panel Visibility Integration

```python
def test_panel_visibility_sync(main_window, qtbot):
    """Test panel visibility syncs with View menu"""
    # Hide hierarchy panel via dock close
    main_window.hierarchy_dock.close()
    qtbot.wait(10)  # Wait for signal propagation

    # Check menu is unchecked
    assert not main_window.action_hierarchy_panel.isChecked()

    # Show via menu
    main_window.action_hierarchy_panel.trigger()
    qtbot.wait(10)

    # Check panel is visible
    assert main_window.hierarchy_dock.isVisible()
```

#### 6.2.2 Settings Persistence Integration

```python
def test_window_state_persistence(qtbot, tmp_path):
    """Test window state persists across instances"""
    # Configure settings location
    QSettings.setPath(
        QSettings.Format.IniFormat,
        QSettings.Scope.UserScope,
        str(tmp_path)
    )

    # Create first window, modify layout
    window1 = InkMainWindow()
    qtbot.addWidget(window1)
    window1.resize(800, 600)
    window1.hierarchy_dock.close()

    # Save and close
    window1.close()

    # Create second window
    window2 = InkMainWindow()
    qtbot.addWidget(window2)

    # Verify state restored
    assert window2.size() == QSize(800, 600)
    assert not window2.hierarchy_dock.isVisible()
```

### 6.3 Manual Testing Checklist

#### 6.3.1 Functional Testing

- [ ] Application launches without errors
- [ ] Window appears on screen at reasonable size
- [ ] All three dock panels are visible
- [ ] Menu bar contains File, Edit, View, Help menus
- [ ] Toolbar contains all expected buttons
- [ ] Status bar displays default text

**Panel Docking**:
- [ ] Hierarchy panel can be dragged to right side
- [ ] Property panel can be dragged to left side
- [ ] Message panel can be dragged to left/right side
- [ ] Panels can be floated (detached from window)
- [ ] Floating panels can be re-docked
- [ ] Two panels can be tabbed together
- [ ] Panel resize handles work correctly

**Menu Actions**:
- [ ] File → Open shows file dialog
- [ ] File → Exit closes application
- [ ] Edit → Undo is initially disabled (no actions)
- [ ] Edit → Find is present (may be disabled)
- [ ] View → Zoom In/Out/Fit are present
- [ ] View → Panel checkboxes toggle panel visibility
- [ ] Help → About shows about dialog
- [ ] Help → Keyboard Shortcuts shows shortcuts

**Keyboard Shortcuts**:
- [ ] Ctrl+O opens file dialog
- [ ] Ctrl+Q exits application
- [ ] Ctrl+Z attempts undo (disabled in shell only)
- [ ] Ctrl+F focuses find (if implemented)
- [ ] Ctrl++ / Ctrl+- / Ctrl+0 for zoom (may be no-op in shell)

**Recent Files**:
- [ ] Recent files menu shows "No recent files" initially
- [ ] After opening file, it appears in recent list
- [ ] Opening same file moves it to top
- [ ] Recent list limited to 10 files
- [ ] Clear Recent removes all files
- [ ] Missing files handled gracefully (grayed out or error message)

**Settings Persistence**:
- [ ] Resize window, close, reopen → size persists
- [ ] Move window, close, reopen → position persists
- [ ] Rearrange docks, close, reopen → layout persists
- [ ] Hide panel, close, reopen → panel stays hidden

#### 6.3.2 Visual Testing

**High-DPI Testing**:
- [ ] Test on 100% scaling (1920x1080)
- [ ] Test on 150% scaling
- [ ] Test on 200% scaling (4K)
- [ ] Icons are sharp at all DPI levels
- [ ] Text is readable at all DPI levels
- [ ] No clipping or overlap at any scale

**Theme Testing** (if system theme support added):
- [ ] Light theme displays correctly
- [ ] Dark theme displays correctly
- [ ] Icons visible in both themes

#### 6.3.3 Performance Testing

**Startup Time**:
- [ ] Cold start (Python not cached): < 2 seconds
- [ ] Warm start (Python cached): < 1 second
- [ ] Measure with: `time python -m ink` (exit immediately)

**Memory Usage**:
- [ ] Startup memory: < 50MB (check with `ps` or `htop`)
- [ ] No memory leaks when opening/closing panels
- [ ] No memory leaks when toggling visibility

**Responsiveness**:
- [ ] Menu opens instantly (< 50ms perceived)
- [ ] Keyboard shortcuts respond immediately
- [ ] Panel dragging is smooth (60fps)
- [ ] Window resize is smooth

---

## 7. Definition of Done

### 7.1 Functional Completeness

- [ ] All user stories (US-E06-01 to US-E06-06) acceptance criteria met
- [ ] All menu actions present (may be disabled/placeholders)
- [ ] All toolbar buttons present (may be disabled/placeholders)
- [ ] Status bar displays all four sections
- [ ] Recent files functionality works end-to-end
- [ ] Settings persistence works across application restarts

### 7.2 Code Quality

- [ ] All code follows PEP 8 style (verified with `ruff`)
- [ ] Type hints on all public methods
- [ ] Docstrings on all classes and public methods
- [ ] No `# type: ignore` comments without justification
- [ ] No pylint/mypy errors
- [ ] Code review completed

### 7.3 Testing

- [ ] Unit tests written for all testable components
- [ ] Integration tests for panel visibility and settings
- [ ] Test coverage ≥ 80% for non-trivial code
- [ ] All tests passing in CI
- [ ] Manual testing checklist completed

### 7.4 Documentation

- [ ] Inline comments explain non-obvious logic
- [ ] Docstrings include usage examples
- [ ] Architecture decisions documented
- [ ] Known limitations documented
- [ ] Integration points documented for other epics

### 7.5 Integration Readiness

- [ ] Clear API for canvas integration (central widget replacement)
- [ ] Clear API for panel content integration
- [ ] Signals/slots documented for other components to connect
- [ ] Settings service supports extension for other components
- [ ] No hardcoded dependencies on unimplemented features

### 7.6 Performance

- [ ] Application startup < 2 seconds
- [ ] Memory usage < 50MB at startup
- [ ] No perceived lag in UI interactions
- [ ] Profiling completed, no obvious bottlenecks

### 7.7 User Experience

- [ ] Application looks professional (no ugly placeholder UI)
- [ ] All panels have descriptive titles
- [ ] Tooltips on all toolbar buttons
- [ ] Status bar provides useful information
- [ ] High-DPI displays work correctly
- [ ] Keyboard shortcuts work as expected

### 7.8 Deployment

- [ ] Dependencies documented in `pyproject.toml`
- [ ] Application can be installed via `uv sync`
- [ ] Application can be launched via `uv run python -m ink`
- [ ] Works on clean Linux installation
- [ ] No external dependencies beyond PySide6

---

## 8. Integration Points for Downstream Epics

### 8.1 E02 - Rendering Engine Integration

**What E02 Needs from E06**:
- Access to central widget area for canvas placement
- Zoom action signals to connect zoom logic
- Status bar update methods for zoom level display

**Integration Method**:
```python
# In InkMainWindow.__init__ (after E02 is implemented)
from ink.ui.canvas.schematic_canvas import SchematicCanvas

self.canvas = SchematicCanvas()
self.setCentralWidget(self.canvas)

# Connect zoom actions
self.action_zoom_in.triggered.connect(self.canvas.zoom_in)
self.action_zoom_out.triggered.connect(self.canvas.zoom_out)
self.action_fit_view.triggered.connect(self.canvas.fit_view)

# Connect canvas signals to status bar
self.canvas.zoom_changed.connect(self.update_status_zoom)
self.canvas.selection_changed.connect(self.update_status_selection)
```

### 8.2 E04 - Interaction System Integration

**What E04 Needs from E06**:
- Property dock widget reference for panel population
- Menu actions for undo/redo to enable/disable
- Selection status updates

**Integration Method**:
```python
# In InkMainWindow (after E04 is implemented)
from ink.ui.panels.property_panel import PropertyPanel

self.property_panel = PropertyPanel()
self.property_dock.setWidget(self.property_panel)

# Connect canvas selection to property panel
self.canvas.selection_changed.connect(self.property_panel.display_selection)

# Connect undo/redo system
from ink.services.undo_stack import UndoStack
self.undo_stack = UndoStack()
self.action_undo.triggered.connect(self.undo_stack.undo)
self.action_redo.triggered.connect(self.undo_stack.redo)
self.undo_stack.can_undo_changed.connect(self.action_undo.setEnabled)
self.undo_stack.can_redo_changed.connect(self.action_redo.setEnabled)
```

### 8.3 E05 - Search Integration

**What E05 Needs from E06**:
- Message dock widget for search results display
- Find action to trigger search dialog
- Status bar for search feedback

**Integration Method**:
```python
# In InkMainWindow (after E05 is implemented)
from ink.ui.panels.search_panel import SearchPanel
from ink.ui.dialogs.search_dialog import SearchDialog

self.search_panel = SearchPanel()
self.message_dock.setWidget(self.search_panel)

# Connect find action
self.action_find.triggered.connect(self._show_search_dialog)

def _show_search_dialog(self):
    dialog = SearchDialog(self)
    if dialog.exec():
        query = dialog.get_query()
        self.search_panel.perform_search(query)
```

---

## 9. Post-Implementation Tasks

### 9.1 Immediate Next Steps (After E06 Complete)

1. **Create skeleton panel classes** for other epics to integrate:
   - `ink/ui/panels/hierarchy_panel.py`
   - `ink/ui/panels/property_panel.py`
   - `ink/ui/panels/message_panel.py`

2. **Document integration APIs** in `docs/integration.md`

3. **Create example integration** showing how to add content to panels

### 9.2 Future Enhancements (Post-MVP)

**P1 Enhancements**:
- [ ] Customizable keyboard shortcuts
- [ ] Theme support (light/dark)
- [ ] Workspace presets (save/load panel arrangements)
- [ ] Toolbar customization

**P2 Enhancements**:
- [ ] Multi-document interface (MDI) for multiple designs
- [ ] Detachable toolbar
- [ ] Status bar progress indicators
- [ ] Welcome screen on startup

---

## 10. Appendix

### 10.1 File Structure (Post-Implementation)

```
src/ink/
├── main.py                     # Application entry point
├── ui/
│   ├── __init__.py
│   ├── main_window.py          # InkMainWindow class
│   ├── panels/
│   │   ├── __init__.py
│   │   ├── hierarchy_panel.py  # Skeleton (E06), populated by E03
│   │   ├── property_panel.py   # Skeleton (E06), populated by E04
│   │   └── message_panel.py    # Skeleton (E06), populated by E05
│   ├── dialogs/
│   │   ├── __init__.py
│   │   ├── about_dialog.py
│   │   └── shortcuts_dialog.py
│   └── resources/
│       └── icons/              # SVG icons (Phase 7)
└── services/
    ├── __init__.py
    └── app_settings.py         # Settings persistence service

tests/
├── ui/
│   ├── test_main_window.py
│   └── panels/
│       └── test_panel_skeleton.py
└── services/
    └── test_app_settings.py
```

### 10.2 Key Dependencies

```toml
# pyproject.toml
[project]
dependencies = [
    "PySide6>=6.6.0,<6.7.0",  # Pin to 6.6.x for stability
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4.0",
    "pytest-qt>=4.2.0",       # Qt testing support
    "pytest-cov>=4.1.0",
    "ruff>=0.1.0",
    "mypy>=1.7.0",
]
```

### 10.3 Related Documents

- **PRD**: `/home/joohan/dev/project-ink/ink/docs/prd.md` (§13.1 Main Window Layout)
- **Epic Spec**: `/home/joohan/dev/project-ink/ink/specs/E06/E06.spec.md`
- **CLAUDE.md**: `/home/joohan/dev/project-ink/ink/CLAUDE.md` (Project structure and guidelines)

---

**Document Status**: Ready for Implementation
**Next Step**: Begin Phase 1 implementation (Foundation)
