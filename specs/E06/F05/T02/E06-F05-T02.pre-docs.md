# Pre-Implementation Documentation: E06-F05-T02 - Panel Layout Persistence

## Overview

### Problem Context
Panel state management (T01) provides runtime tracking of panel configurations, but this state is lost when the application closes. Users expect their carefully customized workspace layouts to persist across sessions. Qt provides `QSettings` as a platform-appropriate persistence mechanism (registry on Windows, config files on Linux/macOS), and `QMainWindow` provides `saveState()`/`saveGeometry()` methods that create binary blobs preserving complex dock widget arrangements.

This task bridges runtime state management with persistent storage, ensuring user workspace preferences survive application restarts.

### Goal Summary
Implement persistent storage layer that:
1. Serializes `PanelState` to `QSettings` on application close
2. Deserializes `QSettings` to `PanelState` on application startup
3. Handles missing/corrupted settings gracefully with defaults
4. Stores both Qt native state blobs and custom panel metadata
5. Provides manual save/load API for user-triggered operations
6. Integrates with main window lifecycle (closeEvent, startup)

## Implementation Approach

### High-Level Strategy

**Hybrid Persistence Model**:
1. **Qt Native State**: Store `QMainWindow.saveState()` and `saveGeometry()` as `QByteArray` blobs for accurate complex layout restoration
2. **Custom Metadata**: Store individual `PanelInfo` fields as structured settings for queryability and migration support
3. **Validation on Load**: Verify loaded settings are valid, fallback to defaults on corruption

**QSettings Organization**:
```
ink/
├── geometry/
│   ├── window          # QByteArray from saveGeometry()
│   └── state           # QByteArray from saveState()
└── panels/
    ├── Hierarchy/      # Per-panel group
    │   ├── visible     # bool
    │   ├── area        # string enum ("LEFT", "RIGHT", etc.)
    │   ├── is_floating # bool
    │   ├── geometry    # dict {width, height, x, y}
    │   └── tab_group   # optional string
    └── ... (Properties, Messages)
```

**Lifecycle Integration**:
- **Startup**: Load settings → restore to state manager → apply to UI
- **Shutdown**: Capture state from manager → save to settings
- **Manual Reset**: Clear settings → apply defaults → save new defaults

### Component Breakdown

#### 1. Settings Store (`panel_settings_store.py`)

**Class Design**:
```python
class PanelSettingsStore:
    SETTINGS_GROUP = "panels"
    GEOMETRY_GROUP = "geometry"

    def __init__(self):
        self.settings = QSettings()  # Uses app org/name for location
```

**Key Methods**:

*Save Operation*:
```python
def save_panel_state(state: PanelState):
    # 1. Save Qt blobs to geometry group
    settings.beginGroup(GEOMETRY_GROUP)
    settings.setValue("window", state.qt_geometry)  # QByteArray
    settings.setValue("state", state.qt_state)      # QByteArray
    settings.endGroup()

    # 2. Save structured panel metadata
    settings.beginGroup(SETTINGS_GROUP)
    for panel_name, panel_info in state.panels.items():
        _save_panel_info(panel_name, panel_info)
    settings.endGroup()

    # 3. Force sync to disk
    settings.sync()
```

*Load Operation*:
```python
def load_panel_state() -> Optional[PanelState]:
    # 1. Check if settings exist
    if not _has_saved_state():
        return None  # Triggers default layout

    # 2. Load Qt blobs
    settings.beginGroup(GEOMETRY_GROUP)
    qt_geometry = settings.value("window")
    qt_state = settings.value("state")
    settings.endGroup()

    # 3. Load structured metadata
    state = PanelState(qt_geometry=qt_geometry, qt_state=qt_state)
    settings.beginGroup(SETTINGS_GROUP)
    for panel_name in settings.childGroups():
        panel_info = _load_panel_info(panel_name)
        if panel_info:
            state.panels[panel_name] = panel_info
    settings.endGroup()

    return state
```

*Panel Info Serialization*:
```python
def _save_panel_info(panel_name: str, panel_info: PanelInfo):
    settings.beginGroup(panel_name)

    # Save primitive fields
    settings.setValue("visible", panel_info.visible)
    settings.setValue("area", panel_info.area.name)  # Enum to string
    settings.setValue("is_floating", panel_info.is_floating)

    # Save geometry as dict (QSettings supports dict serialization)
    geometry_dict = {
        "width": panel_info.geometry.width,
        "height": panel_info.geometry.height,
        "x": panel_info.geometry.x,
        "y": panel_info.geometry.y,
    }
    settings.setValue("geometry", geometry_dict)

    if panel_info.tab_group:
        settings.setValue("tab_group", panel_info.tab_group)

    settings.endGroup()
```

*Panel Info Deserialization*:
```python
def _load_panel_info(panel_name: str) -> Optional[PanelInfo]:
    settings.beginGroup(panel_name)

    # Validate key exists
    if not settings.contains("visible"):
        settings.endGroup()
        return None

    # Load with type hints and defaults
    visible = settings.value("visible", True, type=bool)
    area_name = settings.value("area", "LEFT", type=str)
    is_floating = settings.value("is_floating", False, type=bool)

    # Parse enum with fallback
    try:
        area = DockArea[area_name]
    except KeyError:
        area = DockArea.LEFT  # Default on invalid

    # Load geometry dict
    geometry_dict = settings.value("geometry", {}, type=dict)
    geometry = PanelGeometry(
        width=geometry_dict.get("width", 0),
        height=geometry_dict.get("height", 0),
        x=geometry_dict.get("x", 0),
        y=geometry_dict.get("y", 0),
    )

    tab_group = settings.value("tab_group", None, type=str)

    settings.endGroup()

    return PanelInfo(
        name=panel_name,
        visible=visible,
        area=area,
        is_floating=is_floating,
        geometry=geometry,
        tab_group=tab_group
    )
```

**Helper Methods**:
- `_has_saved_state()`: Check if any settings exist (geometry or panels)
- `clear_panel_state()`: Remove all panel settings (for reset)
- `has_saved_settings()`: Public check for settings existence

#### 2. Main Window Lifecycle Integration

**Startup Restoration**:
```python
class InkMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Initialize managers
        self.panel_state_manager = PanelStateManager(self)
        self.panel_settings_store = PanelSettingsStore()

        # Create UI
        self._setup_dock_widgets()  # Creates panels, registers with manager

        # Restore saved layout
        self._restore_panel_layout()

    def _restore_panel_layout(self):
        """Load and apply saved panel state"""
        saved_state = self.panel_settings_store.load_panel_state()

        if saved_state:
            # Apply saved state
            self.panel_state_manager.restore_state(saved_state)
        else:
            # No saved state, use defaults
            self._set_initial_dock_sizes()
```

**Shutdown Persistence**:
```python
def closeEvent(self, event):
    """Handle application close - save panel state"""
    # Capture current state
    current_state = self.panel_state_manager.capture_state()

    # Save to settings
    self.panel_settings_store.save_panel_state(current_state)

    # Continue with normal close
    super().closeEvent(event)
```

**Default Layout Setup**:
```python
def _set_initial_dock_sizes(self):
    """Set default panel sizes (when no saved state exists)"""
    width = self.width()
    height = self.height()

    # Hierarchy: 15% of width
    self.resizeDocks(
        [self.hierarchy_dock],
        [int(width * 0.15)],
        Qt.Orientation.Horizontal
    )

    # Properties: 25% of width
    self.resizeDocks(
        [self.property_dock],
        [int(width * 0.25)],
        Qt.Orientation.Horizontal
    )

    # Messages: 20% of height
    self.resizeDocks(
        [self.message_dock],
        [int(height * 0.20)],
        Qt.Orientation.Vertical
    )
```

**Manual Reset**:
```python
def reset_panel_layout(self):
    """Reset panel layout to default (user action)"""
    # Clear saved settings
    self.panel_settings_store.clear_panel_state()

    # Reset to default sizes
    self._set_initial_dock_sizes()

    # Show all panels
    self.panel_state_manager.show_panel("Hierarchy")
    self.panel_state_manager.show_panel("Properties")
    self.panel_state_manager.show_panel("Messages")
```

### Key Design Decisions

#### Decision 1: Why Store Both Qt State and Custom Metadata?

**Rationale**:
- **Qt `saveState()` Blob**:
  - Pros: Perfectly preserves complex layouts (tabs, splitters, nested docks), tested by Qt, version-aware
  - Cons: Opaque binary format, can't query, can't migrate, Qt version dependent

- **Custom Metadata**:
  - Pros: Queryable structure, can inspect in debugger, enables migrations, human-readable in settings file
  - Cons: May not capture all Qt nuances (tabs, splitter positions)

- **Both Together**:
  - Qt state ensures accurate restoration
  - Custom metadata provides fallback and enables programmatic inspection
  - Redundancy protects against Qt version changes

**Trade-off**: Storage overhead (~1KB per session) vs. robustness and flexibility

#### Decision 2: QSettings vs. JSON File

**Chosen**: QSettings

**Rationale**:
- **Platform Appropriate**: Automatic platform-specific storage (Windows registry, Linux `~/.config`, macOS plist)
- **Qt Native**: Deep integration with Qt types (`QByteArray`, type coercion)
- **Type Safe**: Value storage with type hints (`settings.value("visible", type=bool)`)
- **Atomic Writes**: `sync()` ensures atomic disk writes, prevents corruption
- **No Boilerplate**: No manual file I/O, JSON parsing, error handling

**Trade-off**: Less portable than JSON (can't easily edit settings file) vs. integration and safety

**Rejected Alternatives**:
- JSON file: More manual, less type-safe, requires custom serialization for `QByteArray`
- SQLite: Overkill for simple key-value storage
- Pickle: Security risk, version fragility

#### Decision 3: Validation on Load

**Approach**: Validate and fallback, never crash

**Validation Points**:
1. Settings existence check (`_has_saved_state()`)
2. Per-panel existence check (`settings.contains("visible")`)
3. Enum parsing with try/except (`DockArea[area_name]` with fallback)
4. Dict get with defaults (`geometry_dict.get("width", 0)`)
5. Type coercion in `settings.value()` with defaults

**Rationale**:
- Users may manually edit settings files
- Qt version upgrades may change state format
- Disk corruption possible
- Graceful degradation better than crash
- Default layout is always safe fallback

#### Decision 4: Sync Timing

**Approach**: Explicit `settings.sync()` after save

**Rationale**:
- QSettings buffers writes for performance
- Application crash before sync = lost settings
- Explicit sync on `save_panel_state()` ensures disk write
- Small performance cost (milliseconds) acceptable on app close

**Alternative Considered**: Rely on QSettings destructor (risky if crash occurs)

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F05-T01 (Panel State Management)**:
- Provides `PanelState`, `PanelInfo`, `DockArea`, `PanelGeometry` data structures
- Provides `PanelStateManager.capture_state()` for state extraction
- Provides `PanelStateManager.restore_state()` for state application
- Must be fully implemented and tested before T02

**E06-F06 (Settings Persistence - Application Configuration)**:
- Assumes `QCoreApplication.setOrganizationName("Ink")` and `setApplicationName("Ink")` configured in `main.py`
- QSettings uses these for platform-appropriate storage location

**Qt Framework**:
- `QSettings` for persistent storage
- `QByteArray` for Qt state blob storage
- `QMainWindow.saveState()`/`restoreState()` for native Qt persistence

### Downstream Dependencies

**E06-F05-T04 (Default Layout Reset)**:
- Calls `clear_panel_state()` to remove saved settings
- Triggers `_set_initial_dock_sizes()` to apply defaults

**Future Session Management (P1)**:
- Could extend to multiple named layouts (workspace profiles)
- Settings schema allows `layout/{name}/panels/...` for multiple profiles

### Integration Sequence

**Application Startup**:
1. Main window `__init__` creates `PanelStateManager` and `PanelSettingsStore`
2. `_setup_dock_widgets()` creates panels and registers with manager
3. `_restore_panel_layout()` calls `load_panel_state()`
4. If state exists, call `restore_state()` on manager
5. If no state, call `_set_initial_dock_sizes()`

**Application Shutdown**:
1. User closes window or quits application
2. `closeEvent()` triggered
3. Call `panel_state_manager.capture_state()`
4. Call `panel_settings_store.save_panel_state(state)`
5. QSettings syncs to disk
6. Normal close event propagation continues

**Manual Reset**:
1. User triggers "Reset Panel Layout" action (T04)
2. Call `panel_settings_store.clear_panel_state()`
3. Call `_set_initial_dock_sizes()`
4. Optionally save new default state

## Testing Strategy

### Unit Tests

**Location**: `tests/unit/infrastructure/persistence/test_panel_settings_store.py`

**Mocked QSettings Tests**:
```python
@pytest.fixture
def mock_settings(monkeypatch):
    """Mock QSettings to avoid touching real settings"""
    settings_data = {}

    class MockSettings:
        def __init__(self):
            self._group_stack = []
            self._data = settings_data

        def beginGroup(self, name):
            self._group_stack.append(name)

        def endGroup(self):
            self._group_stack.pop()

        def _current_path(self, key):
            path = "/".join(self._group_stack + [key])
            return path

        def setValue(self, key, value):
            self._data[self._current_path(key)] = value

        def value(self, key, default=None, type=None):
            val = self._data.get(self._current_path(key), default)
            if type and val is not None:
                return type(val)
            return val

        def contains(self, key):
            return self._current_path(key) in self._data

        def childGroups(self):
            # Simplified implementation
            ...

        def sync(self):
            pass

    monkeypatch.setattr("PySide6.QtCore.QSettings", MockSettings)
    return settings_data
```

**Test Cases**:
- `test_save_panel_state_creates_settings()`: Verify all keys created
- `test_load_panel_state_returns_none_when_empty()`: No settings = None
- `test_save_load_roundtrip()`: Save → load → verify equality
- `test_load_with_missing_fields_uses_defaults()`: Missing keys use fallback values
- `test_load_with_invalid_area_uses_default()`: Invalid enum string defaults to LEFT
- `test_geometry_serialization()`: Dict round-trip preserves all fields
- `test_qt_blobs_stored_correctly()`: QByteArray saved and loaded
- `test_clear_panel_state_removes_all()`: Clear removes all settings
- `test_has_saved_settings()`: Correctly detects presence/absence

**Coverage Target**: 90%+ (comprehensive data handling coverage)

### Integration Tests

**Location**: `tests/integration/infrastructure/test_panel_persistence.py`

**Real QSettings Tests**:
```python
@pytest.fixture
def temp_settings(tmp_path):
    """Use temporary QSettings location"""
    QSettings.setPath(
        QSettings.Format.IniFormat,
        QSettings.Scope.UserScope,
        str(tmp_path)
    )
    QCoreApplication.setOrganizationName("InkTest")
    QCoreApplication.setApplicationName("InkTest")
    yield
    # Cleanup happens automatically with tmp_path
```

**Test Cases**:
- `test_real_qsettings_save_and_load()`: Use real QSettings, verify file created
- `test_platform_appropriate_location()`: Check settings file in expected location
- `test_save_creates_file_on_disk()`: Verify actual file I/O
- `test_load_after_app_restart_simulation()`: Create settings, delete object, reload
- `test_corrupted_settings_file()`: Manually corrupt file, verify graceful fallback
- `test_concurrent_save_operations()`: Verify sync prevents race conditions

**Coverage Target**: 85%+ (real I/O, platform integration)

### Manual Testing Checklist

**Basic Persistence**:
- [ ] Customize panel layout (move, resize, hide panels)
- [ ] Close application
- [ ] Reopen application
- [ ] Verify layout exactly matches pre-close state

**Edge Cases**:
- [ ] Delete settings file (Linux: `~/.config/Ink/Ink.conf`)
- [ ] Launch app, verify default layout applied
- [ ] Manually edit settings file with invalid values
- [ ] Launch app, verify graceful fallback to defaults
- [ ] Float panel to secondary monitor, unplug monitor, restart app
- [ ] Verify panel restored to primary monitor (Qt validation)

**Reset Functionality**:
- [ ] Customize layout heavily
- [ ] Call `reset_panel_layout()`
- [ ] Verify layout returns to defaults
- [ ] Close and reopen app
- [ ] Verify defaults persist (not custom layout)

**Cross-Platform** (if applicable):
- [ ] Test on Linux: verify `~/.config/Ink/Ink.conf` created
- [ ] Test on Windows: verify registry entries under `HKCU\Software\Ink\Ink`
- [ ] Test on macOS: verify `~/Library/Preferences/com.Ink.Ink.plist` created

## Risks and Considerations

### Risk 1: QSettings Format Changes

**Issue**: Qt version upgrades may change `QByteArray` blob format or QSettings behavior

**Mitigation**:
- Store Qt version string in settings (future enhancement)
- Custom metadata provides fallback restoration path
- Integration tests catch format changes during Qt upgrades
- Document tested Qt version range in requirements

**Likelihood**: Low (Qt maintains backward compatibility)
**Impact**: Medium (degraded UX, fallback to defaults)

### Risk 2: Disk Write Failure

**Issue**: Disk full, permissions issue, or I/O error during `sync()`

**Current Approach**: No error handling in spec

**Recommendation**:
```python
def save_panel_state(state: PanelState):
    try:
        # ... save operations ...
        self.settings.sync()
    except Exception as e:
        logging.error(f"Failed to save panel state: {e}")
        # State lost, but app doesn't crash
```

**Likelihood**: Very Low (rare in modern systems)
**Impact**: Low (state not saved, user must reconfigure)

### Risk 3: Settings File Corruption

**Issue**: Power loss during write, disk corruption, or manual editing damage settings file

**Mitigation**:
- QSettings provides atomic writes via sync
- Validation on load with fallback to defaults
- Never crash on corrupted settings
- User can manually delete settings file to recover

**Likelihood**: Very Low (QSettings atomic writes)
**Impact**: Low (fallback to defaults, no data loss)

### Risk 4: Platform-Specific Path Issues

**Issue**: Settings file location varies by platform, may not exist or be accessible

**Mitigation**:
- QSettings handles platform differences automatically
- Qt creates directories as needed
- Integration tests verify file creation on each platform

**Likelihood**: Very Low (Qt handles this)
**Impact**: Very Low (Qt API is robust)

### Risk 5: QByteArray Serialization Edge Cases

**Issue**: `QByteArray` from `saveState()` may not serialize correctly to QSettings on all platforms

**Mitigation**:
- QSettings natively supports `QByteArray` storage
- Integration tests with real Qt objects verify serialization
- Fallback to custom metadata if blobs fail to restore

**Likelihood**: Very Low (common Qt pattern)
**Impact**: Low (custom metadata provides fallback)

## Open Questions

### Question 1: Should We Version Settings?

**Question**: Should we store a version number to handle future schema migrations?

**Current Approach**: No versioning in spec

**Consideration**:
```python
SETTINGS_VERSION = 1

def save_panel_state(state: PanelState):
    settings.setValue("version", SETTINGS_VERSION)
    # ... rest of save ...

def load_panel_state():
    version = settings.value("version", 0, type=int)
    if version != SETTINGS_VERSION:
        return None  # Trigger migration or defaults
    # ... rest of load ...
```

**Recommendation**: Add version field (low cost, high future value for migrations)

### Question 2: How to Handle Qt Version Changes?

**Question**: If Qt 6.x → Qt 7.x changes `saveState()` format, how do we migrate?

**Options**:
1. Store Qt version string, reject incompatible blobs
2. Try to restore, catch exception, fallback to defaults
3. Rely on custom metadata only, ignore Qt blobs on version mismatch

**Current Approach**: Option 2 (implicit in `restore_state()`)

**Recommendation**: Document supported Qt version range, rely on Qt's internal versioning

### Question 3: Should Clear Also Clear Window Geometry?

**Question**: Should `clear_panel_state()` also clear window size/position?

**Current Spec**: Yes (clears entire geometry group)

**Consideration**: User may want to keep window size but reset panels

**Recommendation**: Keep current spec (full reset), add `clear_panels_only()` method if needed later

### Question 4: Should We Compress Qt Blobs?

**Question**: `QByteArray` blobs can be large (several KB). Should we compress before storing?

**Current Approach**: No compression

**Analysis**:
- QSettings may compress automatically (platform-dependent)
- Panel state is small (<10KB even with many panels)
- Compression adds complexity and CPU overhead
- Disk space not a concern for settings

**Recommendation**: No compression for MVP, revisit if settings file grows large

## Implementation Checklist

### Phase 1: Settings Store Core
- [ ] Create `src/ink/infrastructure/persistence/` directory
- [ ] Implement `PanelSettingsStore` class with QSettings initialization
- [ ] Define `SETTINGS_GROUP` and `GEOMETRY_GROUP` constants
- [ ] Implement `_has_saved_state()` helper method
- [ ] Implement `has_saved_settings()` public method
- [ ] Write unit tests for initialization and helper methods

### Phase 2: Save Operations
- [ ] Implement `save_panel_state(state)` main method
- [ ] Implement Qt blob saving (geometry, state)
- [ ] Implement `_save_panel_info(name, info)` helper
- [ ] Handle enum to string conversion (DockArea)
- [ ] Handle geometry dict serialization
- [ ] Call `settings.sync()` to force disk write
- [ ] Write unit tests for save operations (mocked QSettings)

### Phase 3: Load Operations
- [ ] Implement `load_panel_state()` main method
- [ ] Implement Qt blob loading with None check
- [ ] Implement `_load_panel_info(name)` helper
- [ ] Handle string to enum conversion with validation
- [ ] Handle geometry dict deserialization with defaults
- [ ] Return None if no settings exist
- [ ] Write unit tests for load operations (mocked QSettings)

### Phase 4: Validation and Error Handling
- [ ] Add validation for missing settings keys
- [ ] Add try/except for enum parsing
- [ ] Add default values for all `settings.value()` calls
- [ ] Add type hints to `settings.value()` for type safety
- [ ] Test with corrupted settings data (unit tests)
- [ ] Test with missing fields (unit tests)

### Phase 5: Clear and Reset
- [ ] Implement `clear_panel_state()` method
- [ ] Remove geometry group settings
- [ ] Remove panels group settings
- [ ] Call `settings.sync()` after clear
- [ ] Write unit tests for clear operation

### Phase 6: Main Window Integration
- [ ] Add `PanelSettingsStore` instantiation to main window
- [ ] Implement `_restore_panel_layout()` method
- [ ] Call restore in `__init__` after dock widget setup
- [ ] Implement `closeEvent()` override
- [ ] Call `capture_state()` and `save_panel_state()` in closeEvent
- [ ] Update `reset_panel_layout()` to call `clear_panel_state()`
- [ ] Test integration with real main window

### Phase 7: Testing and Validation
- [ ] Achieve 90%+ unit test coverage (mocked QSettings)
- [ ] Achieve 85%+ integration test coverage (real QSettings)
- [ ] Complete manual testing checklist
- [ ] Test on Linux (primary platform)
- [ ] Verify settings file location and format
- [ ] Test round-trip persistence (close/open/verify)
- [ ] Verify all acceptance criteria met

## Success Metrics

**Functional Completeness**:
- Panel layout persists across application restarts
- Missing settings file handled gracefully (defaults applied)
- Corrupted settings handled gracefully (fallback to defaults)
- Reset functionality clears saved state correctly
- Qt blobs and custom metadata both saved and loaded

**Code Quality**:
- 90%+ unit test coverage on `PanelSettingsStore`
- 85%+ integration test coverage on persistence layer
- All type hints present and passing mypy
- Zero ruff linting errors
- All public methods have docstrings

**User Experience**:
- State restoration completes in <100ms on startup (imperceptible)
- State save completes in <50ms on shutdown (imperceptible)
- First-time users get sensible default layout
- Returning users get exact previous layout
- Settings file stored in platform-appropriate location

**Reliability**:
- No crashes on missing settings
- No crashes on corrupted settings
- No data loss on disk write failure (graceful degradation)
- Atomic writes prevent partial state corruption
