---
id: E06-F05-T02
title: Panel Layout Persistence
type: Task
priority: P0 (MVP)
status: Draft
parent: E06-F05
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Medium
tags:
  - persistence
  - qsettings
  - panels
---

# Spec: E06-F05-T02 - Panel Layout Persistence

## 1. Overview

### 1.1 Problem Statement
Implement persistent storage for panel layout state using Qt's QSettings mechanism. Panel configurations (visibility, size, position, docking arrangement) must be saved on application exit and restored on startup to maintain user workspace preferences across sessions.

### 1.2 Goals
- Save panel state to QSettings on application close
- Restore panel state on application startup
- Handle missing or corrupted settings gracefully with defaults
- Store both Qt's native state and custom panel metadata
- Support multiple configuration profiles (future extensibility)
- Provide manual save/load methods for user-triggered actions

---

## 2. Technical Requirements

### 2.1 Settings Schema

**QSettings Organization**:
```
ink/
├── geometry/
│   ├── window          # QMainWindow.saveGeometry() blob
│   └── state           # QMainWindow.saveState() blob
└── panels/
    ├── Hierarchy/
    │   ├── visible     # bool
    │   ├── area        # string: "left", "right", "bottom", "floating"
    │   └── geometry    # dict: {width, height, x, y}
    ├── Properties/
    │   ├── visible
    │   ├── area
    │   └── geometry
    └── Messages/
        ├── visible
        ├── area
        └── geometry
```

### 2.2 Settings Persistence Service

**Location**: `src/ink/infrastructure/persistence/panel_settings_store.py`

```python
from typing import Optional, Dict, Any
from PySide6.QtCore import QSettings, QByteArray

from ink.presentation.state.panel_state import PanelState, PanelInfo, DockArea, PanelGeometry


class PanelSettingsStore:
    """Handles persistence of panel state to QSettings"""

    SETTINGS_GROUP = "panels"
    GEOMETRY_GROUP = "geometry"

    def __init__(self):
        self.settings = QSettings()

    def save_panel_state(self, state: PanelState):
        """
        Save panel state to QSettings.

        Args:
            state: Current PanelState to persist
        """
        # Save Qt's native state blobs
        self.settings.beginGroup(self.GEOMETRY_GROUP)
        if state.qt_geometry:
            self.settings.setValue("window", state.qt_geometry)
        if state.qt_state:
            self.settings.setValue("state", state.qt_state)
        self.settings.endGroup()

        # Save individual panel metadata
        self.settings.beginGroup(self.SETTINGS_GROUP)
        for panel_name, panel_info in state.panels.items():
            self._save_panel_info(panel_name, panel_info)
        self.settings.endGroup()

        self.settings.sync()  # Force write to disk

    def _save_panel_info(self, panel_name: str, panel_info: PanelInfo):
        """Save individual panel information"""
        self.settings.beginGroup(panel_name)

        self.settings.setValue("visible", panel_info.visible)
        self.settings.setValue("area", panel_info.area.name)
        self.settings.setValue("is_floating", panel_info.is_floating)

        # Save geometry as dict
        geometry_dict = {
            "width": panel_info.geometry.width,
            "height": panel_info.geometry.height,
            "x": panel_info.geometry.x,
            "y": panel_info.geometry.y,
        }
        self.settings.setValue("geometry", geometry_dict)

        if panel_info.tab_group:
            self.settings.setValue("tab_group", panel_info.tab_group)

        self.settings.endGroup()

    def load_panel_state(self) -> Optional[PanelState]:
        """
        Load panel state from QSettings.

        Returns:
            PanelState if saved state exists, None otherwise
        """
        # Check if any settings exist
        if not self._has_saved_state():
            return None

        state = PanelState()

        # Load Qt's native state blobs
        self.settings.beginGroup(self.GEOMETRY_GROUP)
        state.qt_geometry = self.settings.value("window")
        state.qt_state = self.settings.value("state")
        self.settings.endGroup()

        # Load individual panel metadata
        self.settings.beginGroup(self.SETTINGS_GROUP)
        panel_groups = self.settings.childGroups()

        for panel_name in panel_groups:
            panel_info = self._load_panel_info(panel_name)
            if panel_info:
                state.panels[panel_name] = panel_info

        self.settings.endGroup()

        return state

    def _load_panel_info(self, panel_name: str) -> Optional[PanelInfo]:
        """Load individual panel information"""
        self.settings.beginGroup(panel_name)

        # Check if panel settings exist
        if not self.settings.contains("visible"):
            self.settings.endGroup()
            return None

        # Load basic properties
        visible = self.settings.value("visible", True, type=bool)
        area_name = self.settings.value("area", "LEFT", type=str)
        is_floating = self.settings.value("is_floating", False, type=bool)

        # Parse area enum
        try:
            area = DockArea[area_name]
        except KeyError:
            area = DockArea.LEFT  # Default fallback

        # Load geometry
        geometry_dict = self.settings.value("geometry", {}, type=dict)
        geometry = PanelGeometry(
            width=geometry_dict.get("width", 0),
            height=geometry_dict.get("height", 0),
            x=geometry_dict.get("x", 0),
            y=geometry_dict.get("y", 0),
        )

        tab_group = self.settings.value("tab_group", None, type=str)

        self.settings.endGroup()

        return PanelInfo(
            name=panel_name,
            visible=visible,
            area=area,
            is_floating=is_floating,
            geometry=geometry,
            tab_group=tab_group
        )

    def _has_saved_state(self) -> bool:
        """Check if any saved panel state exists"""
        self.settings.beginGroup(self.GEOMETRY_GROUP)
        has_geometry = self.settings.contains("window")
        self.settings.endGroup()

        self.settings.beginGroup(self.SETTINGS_GROUP)
        has_panels = len(self.settings.childGroups()) > 0
        self.settings.endGroup()

        return has_geometry or has_panels

    def clear_panel_state(self):
        """Clear all saved panel state (reset to defaults)"""
        self.settings.beginGroup(self.GEOMETRY_GROUP)
        self.settings.remove("")  # Remove all keys in group
        self.settings.endGroup()

        self.settings.beginGroup(self.SETTINGS_GROUP)
        self.settings.remove("")
        self.settings.endGroup()

        self.settings.sync()

    def has_saved_settings(self) -> bool:
        """Check if saved settings exist"""
        return self._has_saved_state()
```

### 2.3 Integration with Main Window Lifecycle

**Location**: `src/ink/presentation/main_window.py` (additions)

```python
from ink.infrastructure.persistence.panel_settings_store import PanelSettingsStore

class InkMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # ... existing initialization ...

        self.panel_state_manager = PanelStateManager(self)
        self.panel_settings_store = PanelSettingsStore()

        # Setup UI
        self._setup_dock_widgets()

        # Restore saved panel layout
        self._restore_panel_layout()

    def _restore_panel_layout(self):
        """Restore panel layout from saved settings"""
        saved_state = self.panel_settings_store.load_panel_state()

        if saved_state:
            self.panel_state_manager.restore_state(saved_state)
        else:
            # No saved state, use default layout
            self._set_initial_dock_sizes()

    def _set_initial_dock_sizes(self):
        """Set default panel sizes (when no saved state exists)"""
        width = self.width()
        height = self.height()

        self.resizeDocks(
            [self.hierarchy_dock],
            [int(width * 0.15)],
            Qt.Orientation.Horizontal
        )
        self.resizeDocks(
            [self.property_dock],
            [int(width * 0.25)],
            Qt.Orientation.Horizontal
        )
        self.resizeDocks(
            [self.message_dock],
            [int(height * 0.20)],
            Qt.Orientation.Vertical
        )

    def closeEvent(self, event):
        """Handle application close - save panel state"""
        # Capture current state
        current_state = self.panel_state_manager.capture_state()

        # Save to settings
        self.panel_settings_store.save_panel_state(current_state)

        # Continue with normal close
        super().closeEvent(event)

    def reset_panel_layout(self):
        """Reset panel layout to default (user action)"""
        # Clear saved settings
        self.panel_settings_store.clear_panel_state()

        # Reset to default sizes
        self._set_initial_dock_sizes()

        # Show all panels
        self.panel_state_manager.show_panel("Hierarchy")
        self.panel_state_manager.show_panel("Properties")
        self.panel_state_manager.show_panel("Messages")
```

---

## 3. Dependencies

### 3.1 Upstream
- E06-F05-T01 (Panel State Management) - Uses PanelState data structure
- E06-F06 (Settings Persistence) - QSettings configuration

### 3.2 Downstream
- E06-F05-T04 (Default Layout Reset) - Uses `clear_panel_state()` method

### 3.3 External Dependencies
- PySide6 QSettings for persistent storage
- Qt platform integration for settings location (registry/config files)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] Panel state saved to QSettings on application close
- [ ] Panel state restored on application startup
- [ ] Qt's native state (saveState/saveGeometry) persisted
- [ ] Individual panel metadata (visibility, area, geometry) persisted
- [ ] Missing settings file handled gracefully (use defaults)
- [ ] Corrupted settings handled gracefully (fallback to defaults)
- [ ] Settings written to platform-appropriate location (Linux: ~/.config)

### 4.2 Data Integrity
- [ ] Settings are validated on load (e.g., valid DockArea values)
- [ ] Invalid area names default to DockArea.LEFT
- [ ] Missing geometry values default to zeros
- [ ] QByteArray blobs handled correctly (not corrupted)
- [ ] Settings sync forced after save to ensure disk write

### 4.3 User Experience
- [ ] Panel layout preserved exactly across application restart
- [ ] Floating panel positions restored correctly
- [ ] Tabbed panel arrangements preserved
- [ ] Panel visibility states remembered
- [ ] First-time users get sensible default layout

### 4.4 Testing
- [ ] Unit tests for PanelSettingsStore save/load operations
- [ ] Test round-trip: save -> load -> verify equality
- [ ] Test missing settings file (fresh install scenario)
- [ ] Test corrupted settings (invalid JSON, missing keys)
- [ ] Integration test: close app, reopen, verify layout restored
- [ ] 90%+ code coverage on persistence module

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why store both Qt state and custom metadata?**
- Qt's `saveState()` accurately preserves complex layouts (tabs, splitters)
- Custom metadata enables programmatic queries and migrations
- Redundancy provides fallback if Qt state format changes

**Why use QSettings instead of JSON file?**
- QSettings is Qt-native, platform-appropriate storage
- Automatic handling of platform differences (registry on Windows, config files on Linux)
- Type-safe value storage with type hints
- Built-in synchronization and atomic writes

**Why validate on load?**
- Protects against manual settings file edits
- Handles Qt version changes that might alter state format
- Enables graceful degradation instead of crashes

### 5.2 QSettings Location

**Linux**: `~/.config/Ink/Ink.conf` (INI format)
**Windows**: Registry `HKEY_CURRENT_USER\Software\Ink\Ink`
**macOS**: `~/Library/Preferences/com.Ink.Ink.plist`

Configured via `QCoreApplication.setOrganizationName("Ink")` and `setApplicationName("Ink")` in main.

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/persistence/test_panel_settings_store.py`):
- Mock QSettings to test save/load logic
- Verify data serialization correctness
- Test error handling paths

**Integration Tests** (`tests/integration/infrastructure/test_panel_persistence.py`):
- Use real QSettings with temporary test location
- Test full save/restore workflow
- Verify platform-appropriate file creation

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E06-F05 split |
