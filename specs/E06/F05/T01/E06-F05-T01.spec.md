---
id: E06-F05-T01
title: Panel State Management
type: Task
priority: P0 (MVP)
status: Draft
parent: E06-F05
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - ui
  - panels
  - state-management
---

# Spec: E06-F05-T01 - Panel State Management

## 1. Overview

### 1.1 Problem Statement
Implement panel state management to track dock widget visibility, position, size, and floating state. The state management must integrate with the main window's lifecycle to save and restore panel layouts across sessions.

### 1.2 Goals
- Track visibility state for all dock widgets (hierarchy, property, message panels)
- Monitor dock area assignments (left, right, bottom, floating)
- Record panel sizes and floating window geometry
- Track tab group configurations when panels are tabbed together
- Provide programmatic API to query and modify panel state
- Emit state change events for synchronization with settings persistence

---

## 2. Technical Requirements

### 2.1 Panel State Data Structure

**Location**: `src/ink/presentation/state/panel_state.py`

```python
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, Optional, Tuple
from PySide6.QtCore import Qt, QByteArray


class DockArea(Enum):
    """Dock widget area enumeration"""
    LEFT = Qt.DockWidgetArea.LeftDockWidgetArea
    RIGHT = Qt.DockWidgetArea.RightDockWidgetArea
    BOTTOM = Qt.DockWidgetArea.BottomDockWidgetArea
    FLOATING = -1  # Custom value for floating state


@dataclass
class PanelGeometry:
    """Panel size and position information"""
    width: int = 0
    height: int = 0
    x: int = 0  # For floating panels
    y: int = 0  # For floating panels


@dataclass
class PanelInfo:
    """Information about a single panel's state"""
    name: str
    visible: bool = True
    area: DockArea = DockArea.LEFT
    is_floating: bool = False
    geometry: PanelGeometry = field(default_factory=PanelGeometry)
    tab_group: Optional[str] = None  # Identifier for tabbed group


@dataclass
class PanelState:
    """Complete state of all panels"""
    panels: Dict[str, PanelInfo] = field(default_factory=dict)
    qt_state: Optional[QByteArray] = None  # QMainWindow.saveState() blob
    qt_geometry: Optional[QByteArray] = None  # QMainWindow.saveGeometry() blob

    def get_panel(self, name: str) -> Optional[PanelInfo]:
        """Get panel info by name"""
        return self.panels.get(name)

    def set_panel_visible(self, name: str, visible: bool):
        """Update panel visibility"""
        if name in self.panels:
            self.panels[name].visible = visible

    def is_panel_visible(self, name: str) -> bool:
        """Check if panel is visible"""
        panel = self.get_panel(name)
        return panel.visible if panel else False
```

### 2.2 Panel State Manager

**Location**: `src/ink/presentation/state/panel_state_manager.py`

```python
from typing import Dict, Optional
from PySide6.QtWidgets import QDockWidget, QMainWindow
from PySide6.QtCore import Qt, QObject, Signal

from .panel_state import PanelState, PanelInfo, DockArea, PanelGeometry


class PanelStateManager(QObject):
    """Manages panel state tracking and updates"""

    # Signals
    state_changed = Signal()  # Emitted when panel state changes
    panel_visibility_changed = Signal(str, bool)  # (panel_name, visible)
    panel_area_changed = Signal(str, DockArea)  # (panel_name, area)

    def __init__(self, main_window: QMainWindow):
        super().__init__()
        self.main_window = main_window
        self.state = PanelState()
        self._dock_widgets: Dict[str, QDockWidget] = {}

    def register_panel(self, name: str, dock_widget: QDockWidget):
        """
        Register a dock widget for state tracking.

        Args:
            name: Panel identifier (e.g., "Hierarchy", "Properties")
            dock_widget: QDockWidget instance to track
        """
        self._dock_widgets[name] = dock_widget

        # Create initial panel info
        panel_info = PanelInfo(
            name=name,
            visible=dock_widget.isVisible(),
            area=self._get_dock_area(dock_widget),
            is_floating=dock_widget.isFloating(),
            geometry=self._get_panel_geometry(dock_widget)
        )
        self.state.panels[name] = panel_info

        # Connect signals to track changes
        self._connect_panel_signals(name, dock_widget)

    def _connect_panel_signals(self, name: str, dock_widget: QDockWidget):
        """Connect dock widget signals to track state changes"""
        dock_widget.visibilityChanged.connect(
            lambda visible: self._on_visibility_changed(name, visible)
        )
        dock_widget.topLevelChanged.connect(
            lambda floating: self._on_floating_changed(name, floating)
        )
        dock_widget.dockLocationChanged.connect(
            lambda area: self._on_location_changed(name, area)
        )

    def _on_visibility_changed(self, name: str, visible: bool):
        """Handle panel visibility change"""
        if name in self.state.panels:
            self.state.panels[name].visible = visible
            self.panel_visibility_changed.emit(name, visible)
            self.state_changed.emit()

    def _on_floating_changed(self, name: str, floating: bool):
        """Handle panel floating state change"""
        if name in self.state.panels:
            panel = self.state.panels[name]
            panel.is_floating = floating
            if floating:
                panel.area = DockArea.FLOATING
                # Update geometry when floating
                if name in self._dock_widgets:
                    panel.geometry = self._get_panel_geometry(self._dock_widgets[name])
            self.state_changed.emit()

    def _on_location_changed(self, name: str, area: Qt.DockWidgetArea):
        """Handle panel dock area change"""
        if name in self.state.panels:
            dock_area = self._qt_area_to_dock_area(area)
            self.state.panels[name].area = dock_area
            self.panel_area_changed.emit(name, dock_area)
            self.state_changed.emit()

    def _get_dock_area(self, dock_widget: QDockWidget) -> DockArea:
        """Get current dock area of widget"""
        if dock_widget.isFloating():
            return DockArea.FLOATING

        area = self.main_window.dockWidgetArea(dock_widget)
        return self._qt_area_to_dock_area(area)

    def _qt_area_to_dock_area(self, qt_area: Qt.DockWidgetArea) -> DockArea:
        """Convert Qt dock area to DockArea enum"""
        area_map = {
            Qt.DockWidgetArea.LeftDockWidgetArea: DockArea.LEFT,
            Qt.DockWidgetArea.RightDockWidgetArea: DockArea.RIGHT,
            Qt.DockWidgetArea.BottomDockWidgetArea: DockArea.BOTTOM,
        }
        return area_map.get(qt_area, DockArea.LEFT)

    def _get_panel_geometry(self, dock_widget: QDockWidget) -> PanelGeometry:
        """Extract geometry information from dock widget"""
        geometry = dock_widget.geometry()
        return PanelGeometry(
            width=geometry.width(),
            height=geometry.height(),
            x=geometry.x(),
            y=geometry.y()
        )

    def capture_state(self) -> PanelState:
        """
        Capture current state of all panels.

        Returns:
            Complete PanelState snapshot
        """
        # Update geometries before capturing
        for name, dock_widget in self._dock_widgets.items():
            if name in self.state.panels:
                self.state.panels[name].geometry = self._get_panel_geometry(dock_widget)

        # Capture Qt's internal state
        self.state.qt_state = self.main_window.saveState()
        self.state.qt_geometry = self.main_window.saveGeometry()

        return self.state

    def restore_state(self, state: PanelState):
        """
        Restore panel state.

        Args:
            state: PanelState to restore
        """
        # Restore Qt's internal state first (handles docking arrangement)
        if state.qt_geometry:
            self.main_window.restoreGeometry(state.qt_geometry)
        if state.qt_state:
            self.main_window.restoreState(state.qt_state)

        # Apply individual panel states
        for name, panel_info in state.panels.items():
            if name in self._dock_widgets:
                dock_widget = self._dock_widgets[name]
                dock_widget.setVisible(panel_info.visible)

        # Update our tracking state
        self.state = state

    def show_panel(self, name: str):
        """Show a panel by name"""
        if name in self._dock_widgets:
            self._dock_widgets[name].show()
            self._dock_widgets[name].raise_()

    def hide_panel(self, name: str):
        """Hide a panel by name"""
        if name in self._dock_widgets:
            self._dock_widgets[name].hide()

    def toggle_panel(self, name: str):
        """Toggle panel visibility"""
        if name in self._dock_widgets:
            dock_widget = self._dock_widgets[name]
            if dock_widget.isVisible():
                dock_widget.hide()
            else:
                dock_widget.show()
                dock_widget.raise_()

    def get_state(self) -> PanelState:
        """Get current panel state (snapshot)"""
        return self.capture_state()
```

### 2.3 Integration with Main Window

**Location**: `src/ink/presentation/main_window.py` (additions)

```python
from .state.panel_state_manager import PanelStateManager

class InkMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # ... existing initialization ...

        # Initialize panel state manager
        self.panel_state_manager = PanelStateManager(self)

        # Setup UI
        self._setup_dock_widgets()

    def _setup_dock_widgets(self):
        """Create and configure all dockable panels."""
        # Create hierarchy panel
        self.hierarchy_dock = self._create_dock_widget(
            "Hierarchy",
            Qt.DockWidgetArea.LeftDockWidgetArea,
            allowed_areas=(
                Qt.DockWidgetArea.LeftDockWidgetArea |
                Qt.DockWidgetArea.RightDockWidgetArea
            )
        )
        self.hierarchy_panel = HierarchyPanel(self)
        self.hierarchy_dock.setWidget(self.hierarchy_panel)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.hierarchy_dock)
        self.panel_state_manager.register_panel("Hierarchy", self.hierarchy_dock)

        # Create property panel
        self.property_dock = self._create_dock_widget(
            "Properties",
            Qt.DockWidgetArea.RightDockWidgetArea,
            allowed_areas=(
                Qt.DockWidgetArea.LeftDockWidgetArea |
                Qt.DockWidgetArea.RightDockWidgetArea
            )
        )
        self.property_panel = PropertyPanel(self)
        self.property_dock.setWidget(self.property_panel)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.property_dock)
        self.panel_state_manager.register_panel("Properties", self.property_dock)

        # Create message panel
        self.message_dock = self._create_dock_widget(
            "Messages",
            Qt.DockWidgetArea.BottomDockWidgetArea,
            allowed_areas=Qt.DockWidgetArea.BottomDockWidgetArea
        )
        self.message_panel = MessagePanel(self)
        self.message_dock.setWidget(self.message_panel)
        self.addDockWidget(Qt.DockWidgetArea.BottomDockWidgetArea, self.message_dock)
        self.panel_state_manager.register_panel("Messages", self.message_dock)

        # Set initial sizes
        self._set_initial_dock_sizes()

    def _create_dock_widget(
        self,
        title: str,
        default_area: Qt.DockWidgetArea,
        allowed_areas: Qt.DockWidgetArea
    ) -> QDockWidget:
        """Create a configured dock widget."""
        dock = QDockWidget(title, self)
        dock.setObjectName(f"{title.replace(' ', '')}Dock")
        dock.setAllowedAreas(allowed_areas)
        dock.setFeatures(
            QDockWidget.DockWidgetFeature.DockWidgetClosable |
            QDockWidget.DockWidgetFeature.DockWidgetMovable |
            QDockWidget.DockWidgetFeature.DockWidgetFloatable
        )
        return dock
```

---

## 3. Dependencies

### 3.1 Upstream
- E06-F01 (Main Window Shell) - QMainWindow instance
- PySide6 QDockWidget API for state tracking

### 3.2 Downstream
- E06-F05-T02 (Panel Layout Persistence) - Uses PanelState for serialization
- E06-F05-T03 (Panel Toggle Actions) - Uses show/hide/toggle methods

### 3.3 External Dependencies
- PySide6 (`QDockWidget`, `QMainWindow`, signals/slots)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] PanelStateManager tracks all three panels (hierarchy, properties, messages)
- [ ] Visibility changes are detected and state updated
- [ ] Dock area changes are detected when panels are dragged
- [ ] Floating state changes are detected when panels are undocked
- [ ] Panel geometries (width, height, position) are tracked
- [ ] Qt's native state (saveState/saveGeometry) is captured
- [ ] State can be captured as snapshot via `capture_state()`
- [ ] State can be restored via `restore_state()`

### 4.2 Event Handling
- [ ] `state_changed` signal emitted when any panel state changes
- [ ] `panel_visibility_changed` signal emitted with panel name and visibility
- [ ] `panel_area_changed` signal emitted with panel name and dock area
- [ ] Signals connect to Qt dock widget native signals

### 4.3 API Functionality
- [ ] `show_panel(name)` makes panel visible and raises it
- [ ] `hide_panel(name)` hides panel without destroying it
- [ ] `toggle_panel(name)` switches visibility state
- [ ] `get_state()` returns current PanelState snapshot
- [ ] `register_panel()` adds new panel to tracking

### 4.4 Testing
- [ ] Unit tests for PanelState data structure
- [ ] Unit tests for DockArea enum conversions
- [ ] Mock-based tests for PanelStateManager signal handling
- [ ] Integration tests with real QDockWidget instances
- [ ] Test state capture and restore round-trip
- [ ] 85%+ code coverage on state management modules

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate PanelState and Qt's saveState()?**
- Qt's `saveState()` is opaque binary blob - can't inspect or query
- PanelState provides queryable, serializable structure
- Both are needed: PanelState for logic, Qt state for accurate restore

**Why signal-based state tracking?**
- Qt dock widgets emit signals on all state changes
- Reactive pattern ensures state stays synchronized
- Avoids polling or manual state updates

**Why PanelStateManager as QObject?**
- Enables Qt signal/slot mechanism
- Integrates cleanly with Qt event loop
- Can emit custom signals for application layer

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/presentation/state/test_panel_state_manager.py`):
- Test state data structures in isolation
- Mock QDockWidget and signals
- Verify signal emission on state changes

**Integration Tests** (`tests/integration/presentation/test_panel_state_integration.py`):
- Create real QMainWindow with dock widgets
- Test drag-and-drop state changes (if possible)
- Test state persistence across window close/reopen

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E06-F05 split |
