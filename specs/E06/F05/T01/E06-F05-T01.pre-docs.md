# Pre-Implementation Documentation: E06-F05-T01 - Panel State Management

## Overview

### Problem Context
The Ink application requires robust state management for its dock-based panel system (Hierarchy, Properties, Messages). Users expect panels to maintain their configuration (visibility, position, size, docking arrangement) across UI interactions and application sessions. This task establishes the foundation for panel state tracking by implementing a reactive state management system that monitors Qt dock widget changes in real-time.

### Goal Summary
Build a state management layer that:
1. Tracks panel visibility, dock area, floating state, and geometry
2. Provides reactive updates via Qt signals when state changes
3. Captures complete state snapshots for persistence
4. Restores saved state to recreate user workspace
5. Offers programmatic API for panel control (show/hide/toggle)

## Implementation Approach

### High-Level Strategy

**Two-Tier State Architecture**:
1. **Structured State** (`PanelState`, `PanelInfo`): Queryable, serializable Python dataclasses tracking individual panel metadata
2. **Qt Native State**: Opaque `QByteArray` blobs from `QMainWindow.saveState()` for accurate complex layout restoration

**Reactive Pattern**:
- Connect to Qt dock widget signals (`visibilityChanged`, `topLevelChanged`, `dockLocationChanged`)
- Update internal state on signal emission
- Emit custom signals for application layer integration
- No polling or manual state updates needed

**Registration-Based Tracking**:
- Panels register with `PanelStateManager` on creation
- Manager maintains bidirectional mapping: `name → QDockWidget` and `name → PanelInfo`
- Signals connected during registration for automatic tracking

### Component Breakdown

#### 1. Data Structures (`panel_state.py`)

**`DockArea` Enum**:
- Maps Qt's `DockWidgetArea` to simplified enum
- Includes custom `FLOATING` value for undocked panels
- Enables type-safe area comparisons

**`PanelGeometry` Dataclass**:
- Immutable snapshot of size/position (width, height, x, y)
- Extracted from `QDockWidget.geometry()`
- Used for both docked (size) and floating (size + position) panels

**`PanelInfo` Dataclass**:
- Complete metadata for single panel
- Fields: name, visible, area, is_floating, geometry, tab_group
- `tab_group` reserved for future tabbed panel support

**`PanelState` Dataclass**:
- Aggregates all panel info in dictionary (`name → PanelInfo`)
- Stores Qt native state blobs for restoration
- Provides convenience methods (`get_panel`, `set_panel_visible`, `is_panel_visible`)

#### 2. State Manager (`panel_state_manager.py`)

**Core Responsibilities**:
- Registration: `register_panel(name, dock_widget)` adds panel to tracking
- Signal Connection: Automatically wires Qt signals during registration
- State Updates: Handlers for visibility, floating, location changes
- Snapshot Capture: `capture_state()` creates complete state snapshot
- State Restoration: `restore_state(state)` applies saved configuration
- Panel Control: `show_panel`, `hide_panel`, `toggle_panel` methods

**Signal Flow**:
```
QDockWidget signal → Manager handler → Update PanelState → Emit custom signal
```

**Key Algorithms**:

*Dock Area Detection*:
```python
def _get_dock_area(dock_widget):
    if dock_widget.isFloating():
        return DockArea.FLOATING
    qt_area = main_window.dockWidgetArea(dock_widget)
    return _qt_area_to_dock_area(qt_area)
```

*State Capture*:
```python
def capture_state():
    # Update all geometries
    for name, dock_widget in _dock_widgets.items():
        panels[name].geometry = _get_panel_geometry(dock_widget)

    # Capture Qt blobs
    state.qt_state = main_window.saveState()
    state.qt_geometry = main_window.saveGeometry()

    return state
```

*State Restoration*:
```python
def restore_state(state):
    # Qt state first (handles complex docking)
    if state.qt_geometry:
        main_window.restoreGeometry(state.qt_geometry)
    if state.qt_state:
        main_window.restoreState(state.qt_state)

    # Apply individual visibility
    for name, panel_info in state.panels.items():
        if name in _dock_widgets:
            _dock_widgets[name].setVisible(panel_info.visible)
```

#### 3. Main Window Integration

**Setup Sequence**:
1. Create `PanelStateManager` with `QMainWindow` reference
2. Create dock widgets via `_create_dock_widget` helper
3. Set dock widget content (panel classes)
4. Add to main window via `addDockWidget`
5. Register with state manager via `register_panel`
6. Repeat for all panels (Hierarchy, Properties, Messages)

**Dock Widget Configuration**:
- Object name for Qt state persistence (e.g., "HierarchyDock")
- Allowed areas for drag constraints
- Features: Closable, Movable, Floatable
- Initial dock area assignment

### Key Design Decisions

#### Decision 1: Why Both Custom State and Qt State?

**Rationale**:
- **Qt's `saveState()`**: Binary blob that perfectly preserves complex layouts (splitters, tabs, nested docks) but is opaque and unqueryable
- **Custom `PanelState`**: Queryable structure enabling programmatic logic, serialization inspection, and cross-version migration
- **Both Together**: Qt state ensures accurate restoration; custom state enables runtime queries and application logic

**Trade-off**: Storage redundancy vs. flexibility and reliability

#### Decision 2: Signal-Based vs. Polling State Updates

**Chosen**: Signal-based reactive updates

**Rationale**:
- Qt dock widgets natively emit signals on all state changes
- Reactive pattern guarantees synchronization without manual intervention
- No performance overhead from polling
- Integrates naturally with Qt's event loop
- Enables downstream components to react to state changes

**Rejected**: Polling approach (CPU overhead, potential lag, complexity)

#### Decision 3: PanelStateManager as QObject

**Rationale**:
- Enables Qt signal/slot mechanism for custom events
- Integrates with Qt meta-object system
- Allows signal emission (`state_changed`, `panel_visibility_changed`, etc.)
- Fits naturally into Qt application architecture

**Alternative Considered**: Plain Python class with callback pattern (less idiomatic in Qt)

#### Decision 4: Geometry Tracking for All Panels

**Rationale**:
- Floating panels need position (x, y) for screen placement
- Docked panels need size (width, height) for proportional restoration
- Uniform tracking simplifies state structure
- Minimal overhead (4 integers per panel)

**Implementation Note**: Only x/y meaningful for floating; width/height meaningful for docked

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F01 (Main Window Shell)**:
- Provides `QMainWindow` instance as state manager constructor parameter
- Must exist before state manager instantiation
- Provides `addDockWidget` and `saveState`/`restoreState` methods

**Qt Framework**:
- `QDockWidget`: Source of state change signals
- `QMainWindow`: Dock widget container and state persistence
- `Qt.DockWidgetArea`: Area enumeration for positioning
- Signal/slot mechanism for event handling

### Downstream Dependencies

**E06-F05-T02 (Panel Layout Persistence)**:
- Consumes `PanelState` structure for QSettings serialization
- Calls `capture_state()` on app close
- Calls `restore_state()` on app startup

**E06-F05-T03 (Panel Toggle Actions)**:
- Uses `show_panel`, `hide_panel`, `toggle_panel` methods
- Connects to `panel_visibility_changed` signal for UI updates

**E06-F05-T04 (Default Layout Reset)**:
- Uses `capture_state()` after applying defaults
- May use `restore_state()` for preset layouts

### Integration Sequence

1. Main window creates dock widgets and state manager
2. Each dock widget registered via `register_panel()`
3. State manager connects to dock widget signals
4. Application uses state manager API for panel control
5. State manager emits signals consumed by persistence layer
6. On app close, persistence layer calls `capture_state()`
7. On app start, persistence layer calls `restore_state()`

## Testing Strategy

### Unit Tests

**Location**: `tests/unit/presentation/state/test_panel_state.py`

**Data Structure Tests**:
- `PanelGeometry` initialization and field access
- `PanelInfo` default values and construction
- `PanelState.get_panel()` returns correct panel info
- `PanelState.set_panel_visible()` updates visibility
- `PanelState.is_panel_visible()` returns correct state
- `DockArea` enum values match Qt constants

**Coverage Target**: 100% for data structures (pure logic, no external deps)

---

**Location**: `tests/unit/presentation/state/test_panel_state_manager.py`

**Manager Tests (Mocked)**:
- Mock `QDockWidget` with simulated signals
- Mock `QMainWindow` with mocked `dockWidgetArea()`, `saveState()`, `saveGeometry()`
- Test `register_panel()` creates `PanelInfo` and connects signals
- Test visibility change handler updates state and emits signal
- Test floating change handler updates area to FLOATING
- Test location change handler updates area and emits signal
- Test `_qt_area_to_dock_area()` conversion logic
- Test `capture_state()` updates geometries and captures Qt blobs
- Test `restore_state()` calls Qt restore methods and sets visibility

**Mocking Strategy**:
```python
@pytest.fixture
def mock_dock_widget():
    dock = MagicMock(spec=QDockWidget)
    dock.isVisible.return_value = True
    dock.isFloating.return_value = False
    dock.geometry.return_value = MagicMock(width=200, height=300, x=10, y=20)
    return dock

@pytest.fixture
def mock_main_window():
    window = MagicMock(spec=QMainWindow)
    window.dockWidgetArea.return_value = Qt.DockWidgetArea.LeftDockWidgetArea
    window.saveState.return_value = QByteArray(b"state_blob")
    window.saveGeometry.return_value = QByteArray(b"geometry_blob")
    return window
```

**Coverage Target**: 85%+ (signals/slots hard to test in isolation)

### Integration Tests

**Location**: `tests/integration/presentation/test_panel_state_integration.py`

**Real Qt Tests**:
- Create real `QMainWindow` with `QApplication` context
- Create real `QDockWidget` instances
- Test state capture with real widgets
- Test state restoration round-trip (capture → restore → verify)
- Test signal emission with real Qt signals
- Test programmatic panel control (show/hide/toggle)
- Test geometry extraction from real widgets

**Setup Pattern**:
```python
@pytest.fixture
def qt_main_window(qtbot):
    window = QMainWindow()
    qtbot.addWidget(window)
    window.show()
    qtbot.waitExposed(window)
    return window

def test_capture_restore_roundtrip(qt_main_window, qtbot):
    # Setup panels
    manager = PanelStateManager(qt_main_window)
    dock = QDockWidget("Test", qt_main_window)
    qt_main_window.addDockWidget(Qt.LeftDockWidgetArea, dock)
    manager.register_panel("Test", dock)

    # Modify state
    dock.hide()

    # Capture
    state = manager.capture_state()

    # Restore
    manager.restore_state(state)

    # Verify
    assert not dock.isVisible()
```

**Coverage Target**: 90%+ (full integration of real components)

### Manual Testing Checklist

**State Tracking**:
- [ ] Create panel, verify initial state captured correctly
- [ ] Hide panel via close button, verify visibility state updated
- [ ] Drag panel to different area, verify area state updated
- [ ] Float panel by dragging out, verify floating state and area=FLOATING
- [ ] Dock floating panel, verify floating=False and correct area
- [ ] Resize docked panel, verify geometry updated on capture

**Signal Emission**:
- [ ] Connect to `state_changed` signal, verify emitted on any change
- [ ] Connect to `panel_visibility_changed`, verify emits with correct name/visible
- [ ] Connect to `panel_area_changed`, verify emits with correct name/area

**Panel Control API**:
- [ ] Call `show_panel()` on hidden panel, verify visible and raised
- [ ] Call `hide_panel()` on visible panel, verify hidden
- [ ] Call `toggle_panel()` on visible panel, verify hidden
- [ ] Call `toggle_panel()` on hidden panel, verify visible and raised

**State Capture/Restore**:
- [ ] Arrange custom layout (move, resize, hide panels)
- [ ] Call `capture_state()`, verify all state recorded
- [ ] Modify layout
- [ ] Call `restore_state()` with captured state
- [ ] Verify layout exactly matches pre-modification state

## Risks and Considerations

### Risk 1: Qt State Blob Versioning

**Issue**: Qt's `saveState()` format may change between Qt versions, breaking saved state compatibility

**Mitigation**:
- Store Qt version in persistence layer (handled in T02)
- Custom `PanelState` provides fallback restoration path
- Document tested Qt version ranges
- Validate state on load, fallback to defaults on failure

**Likelihood**: Low (Qt maintains backward compatibility)
**Impact**: Medium (degraded UX, not data loss)

### Risk 2: Signal Connection Timing

**Issue**: Signals connected before initial state captured could miss events or create race conditions

**Mitigation**:
- Register panels after full initialization
- Capture initial state immediately after registration
- Signal handlers are idempotent (safe to call multiple times)

**Likelihood**: Low (controlled initialization sequence)
**Impact**: Low (state converges quickly)

### Risk 3: Tab Group Tracking Complexity

**Issue**: Qt's dock widget tabbing is complex; tab_group field may be insufficient for all tab scenarios

**Current Approach**: `tab_group` field reserved but not implemented in MVP
**Mitigation**:
- Qt's `saveState()` handles tabs correctly
- Custom tracking deferred to P1
- Field present in data structure for future use

**Likelihood**: N/A (deferred feature)
**Impact**: None for MVP

### Risk 4: Floating Panel Multi-Monitor Issues

**Issue**: Saved floating panel positions may be invalid if monitor configuration changes (unplugged external monitor)

**Mitigation**:
- Qt's `restoreGeometry()` has built-in validation
- Panels outside screen bounds automatically repositioned by Qt
- Document behavior in user guide

**Likelihood**: Medium (common laptop use case)
**Impact**: Low (Qt handles gracefully)

### Risk 5: Geometry Capture Timing

**Issue**: Qt layouts are asynchronous; capturing geometry immediately after changes may get stale values

**Mitigation**:
- `capture_state()` always called explicitly (on app close, manual save)
- These operations occur after event loop processes layout
- Integration tests verify geometry accuracy

**Likelihood**: Low (controlled capture points)
**Impact**: Low (would show previous geometry, not crash)

## Open Questions

### Question 1: Tab Group Identifier Format
**Question**: What should `tab_group` string format be when tabs are tracked?
**Options**:
- Comma-separated panel names: "Hierarchy,Properties"
- UUID assigned to tab group
- Index-based: "tab_0", "tab_1"

**Decision Needed By**: P1 implementation (tab tracking feature)
**Recommendation**: Comma-separated panel names (human-readable, deterministic)

### Question 2: Should State Manager Handle Undo/Redo?
**Question**: Should state manager maintain history stack for undo/redo of layout changes?
**Current Scope**: Not in MVP (T01)

**Consideration**:
- Would require state snapshot on every change
- Memory overhead for history stack
- Complexity of identifying "undoable" changes vs. transient drags

**Recommendation**: Defer to P1, implement as separate UndoManager class consuming state_changed signals

### Question 3: How to Handle Panel Deletion?
**Question**: What happens if a panel is removed from application (future extensibility)?

**Current Approach**: No unregister method
**Options**:
1. Add `unregister_panel(name)` method
2. Automatically detect widget destruction via Qt destroyed signal
3. Leave stale entries in state (harmless if widget doesn't exist)

**Recommendation**: Add `unregister_panel()` method for clean API, but defer to when dynamic panels are implemented

## Implementation Checklist

### Phase 1: Data Structures
- [ ] Create `src/ink/presentation/state/` directory
- [ ] Implement `DockArea` enum with Qt area mappings
- [ ] Implement `PanelGeometry` dataclass with fields
- [ ] Implement `PanelInfo` dataclass with all metadata fields
- [ ] Implement `PanelState` dataclass with panel dictionary
- [ ] Add convenience methods to `PanelState`
- [ ] Write unit tests for all data structures

### Phase 2: State Manager Core
- [ ] Create `PanelStateManager` as `QObject` subclass
- [ ] Define custom signals (state_changed, panel_visibility_changed, panel_area_changed)
- [ ] Implement `__init__` with main_window parameter
- [ ] Implement `register_panel` method
- [ ] Implement `_connect_panel_signals` helper
- [ ] Implement signal handlers (_on_visibility_changed, _on_floating_changed, _on_location_changed)
- [ ] Implement `_get_dock_area` helper
- [ ] Implement `_qt_area_to_dock_area` conversion
- [ ] Implement `_get_panel_geometry` helper
- [ ] Write unit tests for signal handling (mocked)

### Phase 3: State Capture/Restore
- [ ] Implement `capture_state` method
- [ ] Implement `restore_state` method
- [ ] Handle Qt geometry/state blobs correctly
- [ ] Write unit tests for capture/restore (mocked)
- [ ] Write integration tests for capture/restore (real Qt)

### Phase 4: Panel Control API
- [ ] Implement `show_panel` method
- [ ] Implement `hide_panel` method
- [ ] Implement `toggle_panel` method
- [ ] Implement `get_state` convenience method
- [ ] Write unit tests for panel control methods

### Phase 5: Main Window Integration
- [ ] Add panel state manager instantiation to main window
- [ ] Create `_create_dock_widget` helper method
- [ ] Implement `_setup_dock_widgets` method
- [ ] Register all three panels (Hierarchy, Properties, Messages)
- [ ] Implement `_set_initial_dock_sizes` helper
- [ ] Test integration with real application

### Phase 6: Testing and Validation
- [ ] Achieve 85%+ unit test coverage
- [ ] Achieve 90%+ integration test coverage
- [ ] Complete manual testing checklist
- [ ] Verify all acceptance criteria met
- [ ] Test edge cases (rapid state changes, missing widgets)

## Success Metrics

**Functional Completeness**:
- All three panels (Hierarchy, Properties, Messages) tracked correctly
- All state changes detected and updated
- State capture/restore works for all panel configurations
- Panel control API functions as specified

**Code Quality**:
- 85%+ unit test coverage on state management modules
- 90%+ integration test coverage on state integration
- All type hints present and passing mypy
- Zero ruff linting errors

**Performance**:
- State capture completes in <50ms (no noticeable lag on app close)
- State restore completes in <100ms (no noticeable delay on app start)
- Signal handling has negligible overhead (no UI lag on panel drag)

**Documentation**:
- All public methods have docstrings with Args/Returns
- Complex logic has inline comments
- Design decisions documented in code or architecture docs
