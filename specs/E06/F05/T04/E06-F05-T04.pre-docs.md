# Pre-Implementation Documentation: E06-F05-T04 - Default Layout Reset

## Overview

### Problem Context
Users frequently customize panel layouts through experimentation or specific workflows, which can lead to suboptimal configurations. Common issues include:
- Accidentally hiding all panels (no visible workspace)
- Creating complex tab arrangements that obscure important panels
- Dragging panels to unintended locations
- Floating panels off-screen or on disconnected monitors
- Losing track of which panels are where

Professional applications provide a "Reset Layout" feature to return to a known-good default state. This acts as both a recovery mechanism and a learning tool, allowing users to experiment freely knowing they can always reset.

### Goal Summary
Implement default layout reset functionality that:
1. Provides user-triggered action to restore default panel arrangement
2. Clears all saved panel state from persistent storage
3. Resets panels to initial positions (Hierarchy left, Properties right, Messages bottom)
4. Ensures all panels are visible and docked (not floating)
5. Applies default panel sizes (15%, 25%, 20% respectively)
6. Requires user confirmation before destructive operation
7. Integrates with View menu and keyboard shortcut (Ctrl+Shift+R)

## Implementation Approach

### High-Level Strategy

**Reset Operation Sequence**:
1. User triggers "Reset Panel Layout" action (menu or shortcut)
2. Show confirmation dialog (destructive operation warning)
3. If confirmed:
   - Clear saved panel state from QSettings
   - Remove all dock widgets from main window
   - Re-add dock widgets in default positions
   - Set all panels visible and docked (not floating)
   - Apply default sizes via `resizeDocks()`
   - Update panel state manager with new state
4. Show success feedback in status bar

**Default Layout Specification**:
```
┌─────────────────────────────────────────────────────────┐
│                     Main Window                         │
├──────────┬──────────────────────────────┬───────────────┤
│ Hierarch │                              │   Properties  │
│   15%    │       Canvas (Central)       │      25%      │
│          │                              │               │
├──────────┴──────────────────────────────┴───────────────┤
│                   Messages (20%)                        │
└─────────────────────────────────────────────────────────┘
```

**Confirmation Dialog Design**:
- Modal dialog requiring explicit user consent
- Default button is "No" (safe default)
- Clear explanation of consequences
- Prevents accidental resets from misclicks

### Component Breakdown

#### 1. Confirmation Dialog

**Dialog Specification**:
```python
def reset_panel_layout(self):
    """Reset panel layout to default configuration"""

    # Show confirmation dialog
    result = QMessageBox.question(
        self,                                           # Parent
        "Reset Panel Layout",                           # Title
        "This will reset all panels to their default positions and sizes.\n"
        "Any custom layout will be lost.\n\n"
        "Continue?",                                    # Message
        QMessageBox.StandardButton.Yes |
        QMessageBox.StandardButton.No,                  # Buttons
        QMessageBox.StandardButton.No                   # Default button
    )

    if result != QMessageBox.StandardButton.Yes:
        return  # User cancelled

    # Perform reset (see next section)
    ...
```

**Dialog Properties**:
- **Icon**: Question mark (informational destructive action)
- **Modality**: Window modal (blocks main window interaction)
- **Default**: "No" button (requires conscious "Yes" click)
- **Escape**: Closes dialog without resetting
- **Enter**: Activates default button (No), safe behavior

**Message Content**:
- Line 1: Clear statement of action
- Line 2: Explicit warning of data loss
- Line 3: Empty (spacing)
- Line 4: Simple yes/no question

#### 2. Reset Implementation

**Core Reset Logic**:
```python
def _apply_default_panel_layout(self):
    """Apply the default panel layout configuration"""

    # Step 1: Remove all dock widgets to clear state
    self.removeDockWidget(self.hierarchy_dock)
    self.removeDockWidget(self.property_dock)
    self.removeDockWidget(self.message_dock)

    # Step 2: Re-add in default positions
    self.addDockWidget(
        Qt.DockWidgetArea.LeftDockWidgetArea,
        self.hierarchy_dock
    )
    self.addDockWidget(
        Qt.DockWidgetArea.RightDockWidgetArea,
        self.property_dock
    )
    self.addDockWidget(
        Qt.DockWidgetArea.BottomDockWidgetArea,
        self.message_dock
    )

    # Step 3: Ensure all panels visible and docked
    for dock in [self.hierarchy_dock, self.property_dock, self.message_dock]:
        dock.setFloating(False)  # Dock if floating
        dock.show()              # Make visible

    # Step 4: Apply default sizes
    self._set_initial_dock_sizes()

    # Step 5: Update state manager (capture new state)
    self.panel_state_manager.capture_state()
```

**Why Remove and Re-add Dock Widgets?**:
- **Clears Internal State**: Qt maintains complex internal state (splitters, tabs, nesting)
- **Guaranteed Reset**: Programmatically moving panels may leave residual state
- **Simplicity**: One pattern works for all scenarios
- **Qt Recommended**: Matches Qt documentation approach for full layout reset

**Alternative Considered**: Programmatic movement via `splitDockWidget()`, `tabifyDockWidget()`, etc.
- More complex
- Requires tracking current state to undo
- May not clear all internal Qt state
- Remove/re-add is cleaner

#### 3. Default Size Application

**Size Specification**:
```python
def _set_initial_dock_sizes(self):
    """Set default panel sizes"""

    # Wait for layout to settle (Qt layout is asynchronous)
    QApplication.processEvents()

    width = self.width()
    height = self.height()

    # Hierarchy panel: 15% of window width
    self.resizeDocks(
        [self.hierarchy_dock],
        [int(width * 0.15)],
        Qt.Orientation.Horizontal
    )

    # Property panel: 25% of window width
    self.resizeDocks(
        [self.property_dock],
        [int(width * 0.25)],
        Qt.Orientation.Horizontal
    )

    # Message panel: 20% of window height
    self.resizeDocks(
        [self.message_dock],
        [int(height * 0.20)],
        Qt.Orientation.Vertical
    )
```

**Why `processEvents()` Before Resize?**:
- Qt's layout system processes geometry asynchronously
- Calling `resizeDocks()` immediately after `addDockWidget()` may use stale geometry
- `processEvents()` forces event loop to process pending layout calculations
- Ensures `width()` and `height()` are accurate
- Common Qt pattern for layout-dependent operations

**Proportional vs. Absolute Sizing**:
- **Chosen**: Proportional (percentage of window size)
- **Rationale**: Adapts to different window sizes, resolutions, and DPI settings
- **Trade-off**: Recalculates on every reset vs. consistent absolute sizes

#### 4. Error Handling

**Robust Reset with Error Handling**:
```python
def reset_panel_layout(self):
    """Reset panel layout with error handling"""

    # Confirmation dialog
    result = QMessageBox.question(...)
    if result != QMessageBox.StandardButton.Yes:
        return

    try:
        # Clear settings
        self.panel_settings_store.clear_panel_state()

        # Apply default layout
        self._apply_default_panel_layout()

        # Show success feedback
        self.statusBar().showMessage(
            "Panel layout reset to default",
            3000  # 3 second timeout
        )

    except Exception as e:
        # Handle errors gracefully
        QMessageBox.warning(
            self,
            "Reset Failed",
            f"Failed to reset panel layout: {str(e)}\n\n"
            "Please restart the application.",
            QMessageBox.StandardButton.Ok
        )
        logging.exception("Failed to reset panel layout")
        # Don't re-raise, allow app to continue
```

**Error Scenarios**:
1. **Settings Clear Failure**: Disk I/O error, permissions issue
2. **Dock Widget Removal Failure**: Widget destroyed, invalid state
3. **Size Application Failure**: Invalid geometry, layout constraints

**Recovery Strategy**:
- Log error for debugging
- Show user-friendly error message
- Suggest restart as recovery (settings cleared, layout may be partially reset)
- Don't crash application (allow user to manually fix)

#### 5. Integration with Settings Persistence

**Settings Store Integration**:
```python
# In panel_settings_store.py
def clear_panel_state(self):
    """Clear all saved panel state (reset to defaults)"""

    # Remove geometry group (window size/position, Qt state blobs)
    self.settings.beginGroup(self.GEOMETRY_GROUP)
    self.settings.remove("")  # Remove all keys in group
    self.settings.endGroup()

    # Remove panels group (custom panel metadata)
    self.settings.beginGroup(self.SETTINGS_GROUP)
    self.settings.remove("")  # Remove all keys in group
    self.settings.endGroup()

    # Force sync to disk
    self.settings.sync()
```

**What Gets Cleared**:
- Qt state blobs (`QMainWindow.saveState()`, `saveGeometry()`)
- Individual panel metadata (visibility, area, geometry)
- All custom settings related to panels

**What Remains**:
- Other application settings (not in panels/geometry groups)
- User preferences unrelated to panel layout

#### 6. Status Bar Feedback

**Success Feedback**:
```python
self.statusBar().showMessage(
    "Panel layout reset to default",
    3000  # Display for 3 seconds
)
```

**Why Status Bar Message?**:
- **Confirmation**: User knows action succeeded
- **Non-intrusive**: Doesn't require dismissal (auto-timeout)
- **Standard Pattern**: Common in Qt applications for non-critical feedback
- **No Modal Blocking**: User can immediately continue working

**Alternative Considered**: Success dialog
- Too intrusive for successful operation
- Requires user to dismiss
- Status bar message is sufficient

### Key Design Decisions

#### Decision 1: Confirmation Dialog Requirement

**Chosen**: Require confirmation before reset

**Rationale**:
- **Destructive Action**: User loses custom layout (no undo in MVP)
- **Prevents Accidents**: Keyboard shortcut or menu misclick protection
- **Standard Pattern**: File > Revert, Edit > Clear All, etc. all confirm
- **Low Cost**: One extra click is acceptable for destructive operation

**When Not to Require Confirmation**:
- If undo/redo implemented (can undo reset)
- If auto-save snapshots exist (can recover previous layout)
- If reset is non-destructive (saved as separate "default" profile)

**MVP Status**: No undo, no snapshots, confirmation required

#### Decision 2: Default Button is "No"

**Chosen**: Default button is "No" (safe option)

**Rationale**:
- **Safety First**: Pressing Enter doesn't trigger destructive action
- **Conscious Choice**: User must click "Yes" or press Y key
- **Standard UX**: Destructive actions default to cancel (Windows, macOS, Linux)
- **Prevents Automation**: Can't accidentally script reset with Enter key

**Implementation**: `QMessageBox.StandardButton.No` as default button parameter

#### Decision 3: Remove/Re-add vs. Programmatic Movement

**Chosen**: Remove all dock widgets, re-add in default positions

**Rationale**:
- **Complete Reset**: Clears all Qt internal state (splitters, tabs, z-order)
- **Simplicity**: Single pattern for all reset scenarios
- **Reliability**: Doesn't depend on current state (works if layout is "broken")
- **Qt Recommended**: Documentation suggests this for full layout resets

**Trade-off**: Brief flicker during remove/re-add vs. guaranteed clean slate

**Alternative**: Use `splitDockWidget()`, `tabifyDockWidget()` to rearrange
- Would need to track current state to undo
- Doesn't clear all internal state (tabs may remain)
- More complex logic
- Not worth the complexity

#### Decision 4: processEvents() Timing

**Chosen**: Call `QApplication.processEvents()` before `resizeDocks()`

**Rationale**:
- **Async Layout**: Qt layout system is event-driven, not immediate
- **Accurate Geometry**: Ensures `width()`/`height()` reflect actual window size
- **Prevents Races**: Avoids race conditions between add and resize
- **Common Pattern**: Standard Qt approach for layout-dependent operations

**Risks**: `processEvents()` can trigger other events (keyboard, mouse)
- Unlikely during reset (modal dialog just closed)
- Reset completes quickly (no long processing)
- Acceptable risk for correct geometry

**Alternative**: `QTimer.singleShot(0, self._set_initial_dock_sizes)`
- More correct (defers to next event loop iteration)
- More complex (callback-based)
- Overkill for simple geometry calculation

#### Decision 5: Proportional vs. Absolute Sizes

**Chosen**: Proportional sizing (percentage of window dimensions)

**Rationale**:
- **Resolution Independence**: Works on 1080p, 1440p, 4K, etc.
- **DPI Scaling**: Adapts to high-DPI displays
- **Window Resize**: Sizes make sense regardless of initial window size
- **User Customization**: User may have different window size preferences

**Default Percentages**:
- Hierarchy: 15% (narrow tree, quick navigation)
- Properties: 25% (wider for property details)
- Messages: 20% (bottom panel, logs/errors)
- Canvas: Remainder (~40% width, ~80% height)

**Tuning Considerations**:
- Hierarchy could be 20% if tree is deeply nested
- Properties could be 30% for verbose details
- Messages could be 15% to maximize canvas

**Decision**: Start with 15/25/20, adjust based on user testing

## Dependencies and Integration Points

### Upstream Dependencies

**E06-F05-T01 (Panel State Management)**:
- Uses `PanelStateManager.capture_state()` to record new default state
- May use show/hide methods (though direct dock widget calls also work)

**E06-F05-T02 (Panel Layout Persistence)**:
- Uses `PanelSettingsStore.clear_panel_state()` to remove saved settings
- Ensures reset is persistent (doesn't just apply temporarily)

**E06-F05-T03 (Panel Toggle Actions)**:
- Reset action created in T03 menu structure
- This task implements the `reset_panel_layout()` method connected to action

**E06-F01 (Main Window Shell)**:
- Uses dock widget references (`self.hierarchy_dock`, etc.)
- Uses `addDockWidget()`, `removeDockWidget()` methods
- Uses `resizeDocks()` for size application

**Qt Framework**:
- `QMessageBox` for confirmation dialog
- `QApplication.processEvents()` for layout settling
- `QMainWindow` dock widget management methods

### Downstream Dependencies

**None**: This is a leaf task (no other features depend on reset)

### Integration Sequence

1. User triggers "Reset Panel Layout" action (T03)
2. `reset_panel_layout()` method called
3. Confirmation dialog shown
4. If confirmed:
   - Call `panel_settings_store.clear_panel_state()` (T02)
   - Call `_apply_default_panel_layout()` (this task)
   - Clear settings removes saved state
   - Remove/re-add clears UI state
   - `_set_initial_dock_sizes()` sets defaults
   - `panel_state_manager.capture_state()` records new state (T01)
5. Status bar shows success message
6. User sees default layout

## Testing Strategy

### Unit Tests

**Location**: `tests/unit/presentation/test_panel_reset.py`

**Mock-Based Tests**:
```python
@pytest.fixture
def mock_main_window():
    """Mock main window with panel components"""
    window = MagicMock(spec=InkMainWindow)

    # Mock dock widgets
    window.hierarchy_dock = MagicMock(spec=QDockWidget)
    window.property_dock = MagicMock(spec=QDockWidget)
    window.message_dock = MagicMock(spec=QDockWidget)

    # Mock managers
    window.panel_state_manager = MagicMock()
    window.panel_settings_store = MagicMock()

    # Mock Qt methods
    window.width.return_value = 1000
    window.height.return_value = 800
    window.statusBar.return_value = MagicMock()

    return window

def test_reset_confirmation_dialog_shown():
    """Test that confirmation dialog is shown"""
    window = mock_main_window()

    # Mock dialog to return No
    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.No):
        window.reset_panel_layout()

    # Verify settings not cleared (user cancelled)
    window.panel_settings_store.clear_panel_state.assert_not_called()

def test_reset_cancelled_does_nothing():
    """Test that clicking No prevents reset"""
    window = mock_main_window()

    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.No):
        window.reset_panel_layout()

    # Verify no dock widget operations
    window.removeDockWidget.assert_not_called()

def test_reset_confirmed_clears_settings():
    """Test that clicking Yes clears settings"""
    window = mock_main_window()

    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.Yes):
        window.reset_panel_layout()

    # Verify settings cleared
    window.panel_settings_store.clear_panel_state.assert_called_once()

def test_apply_default_layout_removes_and_readds():
    """Test that panels are removed and re-added"""
    window = mock_main_window()

    window._apply_default_panel_layout()

    # Verify all panels removed
    assert window.removeDockWidget.call_count == 3

    # Verify all panels re-added
    assert window.addDockWidget.call_count == 3

def test_apply_default_layout_shows_all_panels():
    """Test that all panels are made visible"""
    window = mock_main_window()

    window._apply_default_panel_layout()

    # Verify all panels shown
    window.hierarchy_dock.show.assert_called_once()
    window.property_dock.show.assert_called_once()
    window.message_dock.show.assert_called_once()

def test_apply_default_layout_docks_floating_panels():
    """Test that floating panels are docked"""
    window = mock_main_window()

    window._apply_default_panel_layout()

    # Verify setFloating(False) called
    window.hierarchy_dock.setFloating.assert_called_with(False)
    window.property_dock.setFloating.assert_called_with(False)
    window.message_dock.setFloating.assert_called_with(False)

def test_set_initial_sizes_uses_proportions():
    """Test that sizes are proportional to window dimensions"""
    window = mock_main_window()
    window.width.return_value = 1000
    window.height.return_value = 800

    window._set_initial_dock_sizes()

    # Verify resizeDocks called with percentages
    calls = window.resizeDocks.call_args_list
    # Hierarchy: 15% of 1000 = 150
    # Properties: 25% of 1000 = 250
    # Messages: 20% of 800 = 160
    # (Exact assertions depend on call signature)

def test_reset_error_shows_warning():
    """Test that errors during reset show warning dialog"""
    window = mock_main_window()

    # Mock settings clear to raise exception
    window.panel_settings_store.clear_panel_state.side_effect = \
        Exception("Disk error")

    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.Yes):
        with patch('PySide6.QtWidgets.QMessageBox.warning') as mock_warning:
            window.reset_panel_layout()

    # Verify warning shown
    mock_warning.assert_called_once()
    args = mock_warning.call_args[0]
    assert "Failed to reset" in args[2]
```

**Coverage Target**: 85%+ (logic and error handling paths)

### Integration Tests

**Location**: `tests/integration/presentation/test_panel_reset_integration.py`

**Real Qt Tests**:
```python
@pytest.fixture
def main_window(qtbot):
    """Create real main window for integration testing"""
    app = QApplication.instance() or QApplication([])
    window = InkMainWindow()
    qtbot.addWidget(window)
    window.show()
    qtbot.waitExposed(window)
    return window

def test_reset_restores_default_layout(main_window, qtbot):
    """Test full reset workflow with real widgets"""

    # Step 1: Customize layout
    main_window.hierarchy_dock.hide()
    main_window.property_dock.setFloating(True)
    qtbot.wait(100)

    # Step 2: Mock confirmation dialog (return Yes)
    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.Yes):
        main_window.reset_panel_layout()

    qtbot.wait(100)

    # Step 3: Verify default layout
    assert main_window.hierarchy_dock.isVisible()
    assert not main_window.hierarchy_dock.isFloating()
    assert main_window.property_dock.isVisible()
    assert not main_window.property_dock.isFloating()
    assert main_window.message_dock.isVisible()
    assert not main_window.message_dock.isFloating()

    # Verify dock areas
    assert main_window.dockWidgetArea(main_window.hierarchy_dock) == \
        Qt.DockWidgetArea.LeftDockWidgetArea
    assert main_window.dockWidgetArea(main_window.property_dock) == \
        Qt.DockWidgetArea.RightDockWidgetArea
    assert main_window.dockWidgetArea(main_window.message_dock) == \
        Qt.DockWidgetArea.BottomDockWidgetArea

def test_reset_clears_saved_settings(main_window, qtbot, tmp_path):
    """Test that reset clears QSettings"""

    # Setup temporary settings location
    QSettings.setPath(QSettings.Format.IniFormat,
                      QSettings.Scope.UserScope, str(tmp_path))

    # Save current state
    state = main_window.panel_state_manager.capture_state()
    main_window.panel_settings_store.save_panel_state(state)

    # Verify settings exist
    assert main_window.panel_settings_store.has_saved_settings()

    # Reset
    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.Yes):
        main_window.reset_panel_layout()

    # Verify settings cleared
    assert not main_window.panel_settings_store.has_saved_settings()

def test_reset_persists_across_restart(main_window, qtbot, tmp_path):
    """Test that reset state persists after app close/open"""

    # Setup temporary settings
    QSettings.setPath(QSettings.Format.IniFormat,
                      QSettings.Scope.UserScope, str(tmp_path))

    # Customize, save, reset
    main_window.hierarchy_dock.hide()
    state = main_window.panel_state_manager.capture_state()
    main_window.panel_settings_store.save_panel_state(state)

    with patch('PySide6.QtWidgets.QMessageBox.question',
               return_value=QMessageBox.StandardButton.Yes):
        main_window.reset_panel_layout()

    # Simulate app close
    close_state = main_window.panel_state_manager.capture_state()
    main_window.panel_settings_store.save_panel_state(close_state)

    # Simulate app restart (load settings)
    loaded_state = main_window.panel_settings_store.load_panel_state()

    # Verify default layout loaded (not customized)
    assert loaded_state.panels["Hierarchy"].visible
```

**Coverage Target**: 90%+ (full workflow with real components)

### Manual Testing Checklist

**Basic Reset**:
- [ ] Open application with default layout
- [ ] Trigger "Reset Panel Layout" (menu or Ctrl+Shift+R)
- [ ] Verify confirmation dialog appears
- [ ] Click "No", verify no changes occur
- [ ] Trigger reset again, click "Yes"
- [ ] Verify all panels visible and docked
- [ ] Verify panels in correct areas (Hierarchy left, Properties right, Messages bottom)
- [ ] Verify approximate sizes (Hierarchy narrow, Properties wider, Messages bottom strip)

**Complex Customization Reset**:
- [ ] Hide Hierarchy panel
- [ ] Float Properties panel and move to corner
- [ ] Resize Messages panel to very small
- [ ] Trigger reset, confirm
- [ ] Verify all panels restored to defaults
- [ ] Close and reopen application
- [ ] Verify default layout persists (not custom)

**Edge Cases**:
- [ ] Tab Hierarchy and Properties together
- [ ] Trigger reset, confirm
- [ ] Verify panels no longer tabbed (separate areas)
- [ ] Float all panels off-screen (simulated)
- [ ] Trigger reset, confirm
- [ ] Verify panels on-screen in default positions
- [ ] Resize window to very small
- [ ] Trigger reset, confirm
- [ ] Verify panels scale proportionally

**Error Handling**:
- [ ] Simulate disk full (if possible)
- [ ] Trigger reset, confirm
- [ ] Verify error dialog appears
- [ ] Verify application doesn't crash
- [ ] Manually delete settings file mid-reset (unlikely, but defensive)
- [ ] Verify graceful handling

**User Experience**:
- [ ] Verify confirmation dialog message is clear
- [ ] Verify default button is "No" (pressing Enter doesn't reset)
- [ ] Verify status bar shows success message after reset
- [ ] Verify reset completes quickly (<500ms)
- [ ] Verify no visual glitches during reset

## Risks and Considerations

### Risk 1: processEvents() Side Effects

**Issue**: Calling `QApplication.processEvents()` can trigger other events (keyboard, mouse, timers)

**Scenario**: User presses keys during reset, events processed unexpectedly

**Mitigation**:
- Reset operation is fast (<100ms typically)
- Modal dialog just closed (user unlikely to be interacting)
- Event processing is necessary for correct layout
- Alternative (QTimer callback) is more complex

**Likelihood**: Very Low (brief window, user not interacting)
**Impact**: Very Low (would just be extra key event during reset)

**Recommendation**: Acceptable risk, document in code comments

### Risk 2: Partial Reset on Error

**Issue**: If error occurs mid-reset (e.g., after remove, before re-add), layout may be broken

**Mitigation**:
```python
try:
    clear_settings()
    apply_default_layout()  # Atomic from user perspective
except Exception:
    # Layout may be partial, but app doesn't crash
    # User can restart app to fully recover
    show_error_dialog()
```

**Likelihood**: Very Low (operations are simple, unlikely to fail)
**Impact**: Medium (broken layout, but restart fixes)

**Recommendation**: Error handling shows restart suggestion

### Risk 3: Window Geometry Changes During Reset

**Issue**: If user resizes window during `processEvents()`, size calculations may be wrong

**Mitigation**:
- User unlikely to resize during reset (fast operation)
- `resizeDocks()` uses percentages, adapts to resize
- Even if wrong, user can manually adjust

**Likelihood**: Very Low (very brief window, user not resizing during reset)
**Impact**: Low (sizes slightly off, but functional)

**Recommendation**: Accept risk, no mitigation needed

### Risk 4: Dock Widget Destruction

**Issue**: If dock widgets are somehow destroyed (unlikely), reset will crash

**Mitigation**:
```python
def _apply_default_panel_layout(self):
    # Defensive check
    if not all([self.hierarchy_dock, self.property_dock, self.message_dock]):
        raise RuntimeError("Dock widgets not initialized")

    # Rest of reset logic
    ...
```

**Likelihood**: Very Low (widgets created in `__init__`, not destroyed until app close)
**Impact**: High (crash if not checked)

**Recommendation**: Add defensive check

### Risk 5: Settings Clear Failure

**Issue**: Disk full, permissions issue, or I/O error prevents `clear_panel_state()` from completing

**Current Approach**: Exception caught, warning shown, app continues

**Consequence**: Settings not cleared, but layout reset in UI
- User sees default layout
- Close and reopen app
- Saved custom layout restored (confusing)

**Mitigation**: Improved error message
```python
except Exception as e:
    QMessageBox.warning(
        self,
        "Reset Failed",
        f"Failed to clear saved settings: {str(e)}\n\n"
        "Layout has been reset in the current session, but may "
        "revert on restart. Please check disk space and permissions.",
        QMessageBox.StandardButton.Ok
    )
```

**Likelihood**: Very Low (rare on modern systems)
**Impact**: Medium (confusing UX, but not data loss)

## Open Questions

### Question 1: Should Reset Also Reset Window Size/Position?

**Question**: Should `clear_panel_state()` also clear window geometry (size, position)?

**Current Spec**: Yes (clears entire geometry group, including window geometry)

**Consideration**:
- User may want default panel layout but keep custom window size
- Separate "Reset Panels" vs. "Reset All Window Settings"?

**Recommendation**: Keep current spec (full reset), add separate action if users request it

### Question 2: Should Reset Be Undoable?

**Question**: Should we save pre-reset state for undo?

**Current Scope**: No undo in MVP

**Implementation Approach** (if added):
```python
def reset_panel_layout(self):
    # Capture current state before reset
    self._pre_reset_state = self.panel_state_manager.capture_state()

    # Perform reset
    ...

def undo_reset_panel_layout(self):
    if self._pre_reset_state:
        self.panel_state_manager.restore_state(self._pre_reset_state)
```

**Recommendation**: Defer to P1 (post-MVP enhancement)

### Question 3: Should We Provide Multiple Default Layouts?

**Question**: Should users be able to save/load custom "preset" layouts?

**Examples**:
- "Coding Layout": Hierarchy and properties hidden, maximized canvas
- "Debugging Layout": Messages maximized, properties visible
- "Default Layout": Balanced view

**Current Scope**: Single default layout only

**Recommendation**: Defer to P1 (workspace profiles feature)

### Question 4: Keyboard Shortcut for Reset?

**Question**: Is Ctrl+Shift+R appropriate, or should we use something else?

**Current Spec**: Ctrl+Shift+R

**Conflicts**:
- Some apps use Ctrl+Shift+R for "Reload" (browser behavior)
- Not a standard cross-application shortcut

**Alternatives**:
- Ctrl+Shift+D (D for default)
- Ctrl+Alt+R (less common modifier)
- No shortcut (menu only)

**Recommendation**: Keep Ctrl+Shift+R (distinct from browser Reload, intuitive mnemonic)

## Implementation Checklist

### Phase 1: Confirmation Dialog
- [ ] Implement `reset_panel_layout()` method skeleton
- [ ] Add confirmation dialog using `QMessageBox.question()`
- [ ] Set dialog title, message, buttons, and default button
- [ ] Handle "No" response (return early, no changes)
- [ ] Handle "Yes" response (proceed with reset)
- [ ] Test dialog appearance and button behavior

### Phase 2: Default Layout Application
- [ ] Implement `_apply_default_panel_layout()` method
- [ ] Add defensive check for dock widget existence
- [ ] Remove all dock widgets via `removeDockWidget()`
- [ ] Re-add dock widgets to default areas via `addDockWidget()`
- [ ] Set all dock widgets to non-floating via `setFloating(False)`
- [ ] Show all dock widgets via `show()`
- [ ] Call `_set_initial_dock_sizes()` to apply default sizes
- [ ] Call `panel_state_manager.capture_state()` to record new state
- [ ] Test with real dock widgets

### Phase 3: Default Size Application
- [ ] Verify `_set_initial_dock_sizes()` method exists (should be from T02)
- [ ] Add `QApplication.processEvents()` call before size calculations
- [ ] Calculate Hierarchy size (15% of window width)
- [ ] Calculate Properties size (25% of window width)
- [ ] Calculate Messages size (20% of window height)
- [ ] Call `resizeDocks()` for each panel
- [ ] Test proportional sizing with different window sizes

### Phase 4: Settings Persistence Integration
- [ ] Call `panel_settings_store.clear_panel_state()` before layout reset
- [ ] Verify settings cleared (test with `has_saved_settings()`)
- [ ] Test that cleared settings don't restore on app restart
- [ ] Verify new default state is saved on app close (normal persistence flow)

### Phase 5: Error Handling
- [ ] Wrap reset logic in try/except block
- [ ] Catch `Exception` (broad, for robustness)
- [ ] Show `QMessageBox.warning()` on error
- [ ] Include error message and restart suggestion
- [ ] Log exception via `logging.exception()`
- [ ] Test error handling with mocked exception
- [ ] Verify app doesn't crash on error

### Phase 6: User Feedback
- [ ] Add status bar success message after reset
- [ ] Set message text: "Panel layout reset to default"
- [ ] Set timeout: 3000ms (3 seconds)
- [ ] Test message appears and disappears correctly
- [ ] Verify message doesn't block user interaction

### Phase 7: Action Integration
- [ ] Verify "Reset Panel Layout" action created in T03
- [ ] Verify action connected to `reset_panel_layout()` method
- [ ] Test menu action triggers reset
- [ ] Test keyboard shortcut (Ctrl+Shift+R) triggers reset
- [ ] Test action enabled/disabled state (should always be enabled)

### Phase 8: Testing and Validation
- [ ] Write unit tests for confirmation dialog logic (mocked)
- [ ] Write unit tests for layout application (mocked widgets)
- [ ] Write unit tests for error handling
- [ ] Write integration tests with real dock widgets
- [ ] Write integration tests for settings persistence
- [ ] Complete manual testing checklist
- [ ] Achieve 85%+ unit test coverage
- [ ] Achieve 90%+ integration test coverage
- [ ] Verify all acceptance criteria met

## Success Metrics

**Functional Completeness**:
- "Reset Panel Layout" action in View > Panels menu
- Keyboard shortcut (Ctrl+Shift+R) triggers reset
- Confirmation dialog appears before reset
- All panels reset to default positions, sizes, and visibility
- Saved settings cleared (reset persists across restarts)
- Error handling prevents crashes

**Code Quality**:
- 85%+ unit test coverage on reset logic
- 90%+ integration test coverage on full workflow
- All type hints present and passing mypy
- Zero ruff linting errors
- Defensive programming (null checks, error handling)

**User Experience**:
- Reset completes in <500ms (imperceptible delay)
- Confirmation dialog is clear and safe (default No)
- Status bar provides success feedback
- Error messages are helpful (suggest restart)
- Layout is visually clean after reset (no glitches)

**Reliability**:
- No crashes on reset (even with errors)
- Settings always cleared or error reported
- Layout always in functional state (even if partial reset)
- Graceful degradation on all error paths
