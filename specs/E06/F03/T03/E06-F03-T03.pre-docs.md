# E06-F03-T03: File, Edit and Search Tools - Pre-Implementation Documentation

## Document Metadata
- **Task**: E06-F03-T03 - File, Edit and Search Tools
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

E06-F03-T03 implements the majority of toolbar actions for file operations, edit operations, and search functionality. This task adds four critical toolbar buttons: Open (file loading), Undo/Redo (action history), and Search (cell/net/pin lookup). Unlike view controls which are always enabled, these actions require integration with application services and dynamic state management.

### 1.2 Core Objectives

1. **Open File Button**: `Ctrl+O` shortcut, displays file dialog for netlist loading
2. **Undo Button**: `Ctrl+Z` shortcut, reverts last expansion/collapse with state management
3. **Redo Button**: `Ctrl+Shift+Z` shortcut, re-applies undone action with state management
4. **Search Button**: `Ctrl+F` shortcut, shows/focuses search panel
5. **Service Integration**: Connect actions to file service, expansion service, search panel
6. **State Management**: Dynamic enable/disable for undo/redo based on history
7. **Visual Grouping**: Organize actions into File, Edit, and Search groups with separators

### 1.3 Success Criteria

- Four toolbar buttons with appropriate icons
- Buttons arranged in logical groups (File | Edit | Search)
- Keyboard shortcuts work globally
- Open button shows file dialog with correct filters
- Undo/Redo initially disabled, enable when history available
- Undo/Redo state updates after expansion/collapse operations
- Search button shows/focuses search panel
- Graceful handling of missing services (no crashes)

---

## 2. Problem Context

### 2.1 User Need

**Critical workflow operations require quick access**:

- **File Loading**: Starting point for all schematic exploration sessions
- **Undo/Redo**: Safety net for exploration, enables experimentation
- **Search**: Navigation to specific cells/nets without manual traversal

**Pain points without toolbar buttons**:
- Menu navigation interrupts flow state
- Keyboard shortcuts not discoverable
- No visual cue for undo/redo availability
- Search buried in menu hierarchy

**Solution benefits**:
- One-click file loading at session start
- Visible undo/redo availability status
- Instant search access during exploration
- Standard CAD tool conventions

### 2.2 Technical Challenge

**Complexity Factors**:

1. **State-Dependent Actions**: Undo/Redo require dynamic enable/disable
   - Monitor expansion service history state
   - Update UI state after each operation
   - Connect to service signals/events

2. **Service Integration**: Multiple service dependencies
   - File service for design loading (E01)
   - Expansion service for undo/redo (E04)
   - Search panel for search (E05)
   - Services may not exist yet (defensive programming)

3. **File Dialog Configuration**: Platform-specific file selection
   - Correct file filters (`.ckt`, `.cdl`)
   - Remember last directory (QSettings)
   - Validate file before loading

4. **Search Panel Interaction**: Toggle vs focus behavior
   - Show panel if hidden
   - Focus input if already visible
   - Handle panel lifecycle

### 2.3 Integration Context

**Depends On**:
- **E06-F03-T01**: Toolbar infrastructure (`self._toolbar`)
- **E01**: File loading service
- **E04**: Expansion service with undo/redo support
- **E05**: Search panel widget
- **E06-F01**: Main window structure

**Used By**:
- **E06-F03-T04**: Icon resources (provides fallback icons)

**Integrates With**:
- **E02**: Canvas rendering (undo/redo affects visible cells)
- **E03**: Expansion logic (undo/redo reverses expansion operations)

---

## 3. Implementation Approach

### 3.1 Architecture Design

**Component Structure**:
```
InkMainWindow
├── _setup_toolbar()
│   ├── _add_file_actions()      # NEW: Open button
│   ├── _add_edit_actions()      # NEW: Undo/Redo buttons
│   └── _add_search_actions()    # NEW: Search button
├── _on_open_file()              # NEW: File dialog handler
├── _on_undo()                   # NEW: Undo handler
├── _on_redo()                   # NEW: Redo handler
├── _on_find()                   # NEW: Search handler
├── _update_undo_redo_state()    # NEW: State management
├── _undo_action                 # Store for state updates
├── _redo_action                 # Store for state updates
├── _file_service                # From E01 integration
├── _expansion_service           # From E04 integration
└── _search_panel                # From E05 integration
```

**State Management Flow**:
```
User performs expansion
  → ExpansionService.expand()
  → History updated
  → Signal/event emitted
  → _update_undo_redo_state()
  → _undo_action.setEnabled(True)
  → _redo_action.setEnabled(False)
```

### 3.2 Key Components

#### Component 1: File Actions Group

```python
def _add_file_actions(self, toolbar: QToolBar):
    """Add file-related toolbar actions."""
    # Open file button
    open_action = QAction(
        QIcon.fromTheme("document-open"),
        "Open",
        self
    )
    open_action.setToolTip("Open netlist file (Ctrl+O)")
    open_action.setShortcut(QKeySequence.StandardKey.Open)
    open_action.triggered.connect(self._on_open_file)
    toolbar.addAction(open_action)

    # Store reference for potential state management
    self._open_action = open_action
```

**Design Choices**:
- Always enabled (users can always open new files)
- Standard Qt Open shortcut (`Ctrl+O`)
- Icon from system theme (`document-open`)
- Stored reference for future enhancements (disable while loading)

#### Component 2: Edit Actions Group

```python
def _add_edit_actions(self, toolbar: QToolBar):
    """Add edit-related toolbar actions."""
    # Undo button
    self._undo_action = QAction(
        QIcon.fromTheme("edit-undo"),
        "Undo",
        self
    )
    self._undo_action.setToolTip("Undo expansion/collapse (Ctrl+Z)")
    self._undo_action.setShortcut(QKeySequence.StandardKey.Undo)
    self._undo_action.setEnabled(False)  # Initially disabled
    self._undo_action.triggered.connect(self._on_undo)
    toolbar.addAction(self._undo_action)

    # Redo button
    self._redo_action = QAction(
        QIcon.fromTheme("edit-redo"),
        "Redo",
        self
    )
    self._redo_action.setToolTip("Redo expansion/collapse (Ctrl+Shift+Z)")
    self._redo_action.setShortcut(QKeySequence.StandardKey.Redo)
    self._redo_action.setEnabled(False)  # Initially disabled
    self._redo_action.triggered.connect(self._on_redo)
    toolbar.addAction(self._redo_action)
```

**Design Choices**:
- Initially disabled (no history at startup)
- Must store references (`self._undo_action`, `self._redo_action`) for state updates
- Standard Qt shortcuts
- Tooltips clarify these are for expansion/collapse (not text editing)

#### Component 3: Search Actions Group

```python
def _add_search_actions(self, toolbar: QToolBar):
    """Add search-related toolbar actions."""
    # Search button
    search_action = QAction(
        QIcon.fromTheme("edit-find"),
        "Search",
        self
    )
    search_action.setToolTip("Search cells/nets/pins (Ctrl+F)")
    search_action.setShortcut(QKeySequence.StandardKey.Find)
    search_action.triggered.connect(self._on_find)
    toolbar.addAction(search_action)

    # Store reference for potential state management
    self._search_action = search_action
```

**Design Choices**:
- Always enabled
- Standard Qt Find shortcut (`Ctrl+F`)
- Tooltip clarifies what can be searched (cells/nets/pins)

#### Component 4: Action Handlers

```python
def _on_open_file(self):
    """Handle open file action."""
    file_path, _ = QFileDialog.getOpenFileName(
        self,
        "Open Netlist File",
        "",  # TODO: Remember last directory from QSettings
        "CDL Files (*.ckt *.cdl);;All Files (*)"
    )
    if file_path:
        # Integrate with file service (from E01)
        if hasattr(self, '_file_service') and self._file_service:
            self._file_service.load_design(file_path)
        else:
            logger.warning("File service not available")

def _on_undo(self):
    """Handle undo action."""
    if hasattr(self, '_expansion_service') and self._expansion_service:
        self._expansion_service.undo()
        self._update_undo_redo_state()

def _on_redo(self):
    """Handle redo action."""
    if hasattr(self, '_expansion_service') and self._expansion_service:
        self._expansion_service.redo()
        self._update_undo_redo_state()

def _on_find(self):
    """Handle search action."""
    # Toggle search panel visibility or focus search input
    if hasattr(self, '_search_panel') and self._search_panel:
        if self._search_panel.isVisible():
            self._search_panel.focus_search_input()
        else:
            self._search_panel.show()
            self._search_panel.focus_search_input()
```

**Defensive Programming**:
- All handlers check for service existence
- Graceful degradation if services not initialized
- Logging for debugging (optional, for development)

#### Component 5: State Management

```python
def _update_undo_redo_state(self):
    """Update undo/redo button enabled state based on history."""
    if hasattr(self, '_expansion_service') and self._expansion_service:
        can_undo = self._expansion_service.can_undo()
        can_redo = self._expansion_service.can_redo()

        self._undo_action.setEnabled(can_undo)
        self._redo_action.setEnabled(can_redo)

def _connect_expansion_signals(self):
    """
    Connect to expansion service signals for state updates.

    Call this during initialization after expansion service created.
    """
    if hasattr(self, '_expansion_service') and self._expansion_service:
        # Assuming expansion service emits Qt signal on history change
        if hasattr(self._expansion_service, 'history_changed'):
            self._expansion_service.history_changed.connect(
                self._update_undo_redo_state
            )
```

**State Update Triggers**:
1. After undo operation
2. After redo operation
3. After expansion operation (via signal)
4. After collapse operation (via signal)
5. After design load (reset to disabled)

### 3.3 Implementation Strategy

#### Phase 1: Core Action Implementation

**Steps**:
1. Implement `_add_file_actions()`, `_add_edit_actions()`, `_add_search_actions()`
2. Implement action handlers with defensive null checks
3. Add actions to toolbar in `_setup_toolbar()`
4. Test with mock services

**Deliverables**:
- Four toolbar buttons with icons
- Action handlers connected
- Visual separators between groups

#### Phase 2: Service Integration

**Steps**:
1. Integrate with file service (E01)
2. Integrate with expansion service (E04)
3. Integrate with search panel (E05)
4. Implement state management for undo/redo
5. Connect to service signals/events

**Deliverables**:
- Working file open dialog
- Functional undo/redo with state updates
- Search panel toggle/focus behavior

#### Phase 3: State Management

**Steps**:
1. Implement `_update_undo_redo_state()`
2. Connect to expansion service signals
3. Test state transitions (disabled → enabled → disabled)
4. Verify state persistence across operations

**Deliverables**:
- Undo/Redo buttons correctly enabled/disabled
- State updates after each operation
- No race conditions or stale state

### 3.4 File Modifications

**Primary File**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/main_window.py`

**Changes**:
```python
# Add imports
from PySide6.QtGui import QAction, QIcon, QKeySequence
from PySide6.QtWidgets import QFileDialog
import logging

logger = logging.getLogger(__name__)

class InkMainWindow(QMainWindow):
    # Instance variables for state management
    _undo_action: QAction
    _redo_action: QAction
    _open_action: QAction
    _search_action: QAction

    def _setup_toolbar(self):
        """Create main toolbar with action buttons."""
        # ... existing setup from T01

        # File Group
        self._add_file_actions(self._toolbar)
        self._toolbar.addSeparator()

        # Edit Group
        self._add_edit_actions(self._toolbar)
        self._toolbar.addSeparator()

        # View Group (from T02)
        # self._add_view_actions(self._toolbar)
        # self._toolbar.addSeparator()

        # Search Group
        self._add_search_actions(self._toolbar)

    # NEW METHODS (detailed in Component sections above)
    def _add_file_actions(self, toolbar): ...
    def _add_edit_actions(self, toolbar): ...
    def _add_search_actions(self, toolbar): ...
    def _on_open_file(self): ...
    def _on_undo(self): ...
    def _on_redo(self): ...
    def _on_find(self): ...
    def _update_undo_redo_state(self): ...
    def _connect_expansion_signals(self): ...  # Optional, signal-based
```

---

## 4. Design Decisions

### 4.1 Decision: Undo/Redo Scope

**Question**: What operations should undo/redo affect?

**Options**:

1. **Expansion/Collapse Only** (CHOSEN)
   - Pros: Clear scope, matches PRD requirements
   - Cons: Doesn't cover other operations (e.g., selection)

2. **All User Actions**
   - Pros: Comprehensive undo system
   - Cons: Complex implementation, out of MVP scope

**Decision**: Undo/Redo only for expansion and collapse operations

**Rationale**:
- PRD specifies undo/redo for exploration
- Expansion/collapse are the most consequential actions
- Selection, pan, zoom are easily reversible manually
- Can extend to other operations in P1

### 4.2 Decision: File Dialog Starting Directory

**Options**:

1. **Current Working Directory**
   - Pros: Simple, no persistence needed
   - Cons: Not user-friendly, CWD may be unexpected

2. **Home Directory**
   - Pros: Predictable location
   - Cons: May not be where files are stored

3. **Remember Last Directory** (CHOSEN)
   - Pros: Best UX, users open related files
   - Cons: Requires QSettings persistence

**Decision**: Remember last opened directory, fallback to home

**Implementation**:
```python
settings = QSettings("Ink", "InkSchematicViewer")
last_dir = settings.value("last_open_directory", str(Path.home()))

file_path, _ = QFileDialog.getOpenFileName(
    self,
    "Open Netlist File",
    last_dir,
    "CDL Files (*.ckt *.cdl);;All Files (*)"
)

if file_path:
    settings.setValue("last_open_directory", str(Path(file_path).parent))
```

### 4.3 Decision: Search Button Behavior

**Options**:

1. **Toggle Panel** (CHOSEN)
   - If hidden: Show panel and focus input
   - If visible: Focus input (keep panel visible)
   - Pros: Predictable, always brings focus to search
   - Cons: Can't hide panel via button

2. **Toggle Panel (Show/Hide)**
   - Pros: Single button controls visibility
   - Cons: Confusing when panel already visible

3. **Show Dialog**
   - Pros: Modal, focused interaction
   - Cons: Blocks other operations, less flexible

**Decision**: Toggle to show, focus if already visible

**Rationale**:
- Users want to search repeatedly without hiding/showing
- Focus behavior supports keyboard-driven workflow
- Panel has close button for hiding

### 4.4 Decision: Undo/Redo State Update Strategy

**Options**:

1. **Signal-Based** (PREFERRED)
   - Expansion service emits `history_changed` signal
   - Main window connects to signal, updates state
   - Pros: Decoupled, automatic updates
   - Cons: Requires signal infrastructure in service

2. **Manual Call After Operations**
   - Main window calls `_update_undo_redo_state()` after each operation
   - Pros: Simple, no signal dependency
   - Cons: Easy to forget, tightly coupled

3. **Polling**
   - Timer periodically checks history state
   - Pros: No coupling to service
   - Cons: Inefficient, delayed updates

**Decision**: Signal-based if available, manual call as fallback

**Implementation**:
```python
# Preferred: Signal-based
self._expansion_service.history_changed.connect(self._update_undo_redo_state)

# Fallback: Manual call
def _on_undo(self):
    self._expansion_service.undo()
    self._update_undo_redo_state()  # Explicit call
```

---

## 5. Dependencies and Integration

### 5.1 Upstream Dependencies

**E06-F03-T01: Toolbar Setup** (REQUIRED)
- Provides `self._toolbar` reference
- Toolbar must exist before adding actions

**E01: File Loading** (REQUIRED for functionality)
- Provides file service with `load_design(path)` method
- Main window must have `_file_service` reference
- File service should emit signals on load complete/error

**E04: Interaction (Undo/Redo)** (REQUIRED for functionality)
- Provides expansion service with:
  - `undo()` method
  - `redo()` method
  - `can_undo()` method
  - `can_redo()` method
  - `history_changed` signal (optional but preferred)
- Main window must have `_expansion_service` reference

**E05: Search** (REQUIRED for functionality)
- Provides search panel widget
- Panel must have `focus_search_input()` method
- Panel must be QDockWidget or similar with show/hide
- Main window must have `_search_panel` reference

**E06-F01: Main Window Shell** (REQUIRED)
- Provides `InkMainWindow` class structure
- May provide service initialization and references

### 5.2 Downstream Dependencies

**E06-F03-T04: Icon Resources** (NICE-TO-HAVE)
- Provides fallback icons when system theme missing
- Actions will refactor to use `IconProvider.get_icon()`
- Not blocking (system themes sufficient for development)

### 5.3 External Dependencies

**PySide6 Components**:
- `QAction`: Toolbar action objects
- `QIcon`: Icon loading from theme
- `QKeySequence`: Keyboard shortcut definitions
- `QFileDialog`: File selection dialog
- `QSettings`: Last directory persistence

**Python Standard Library**:
- `pathlib.Path`: File path manipulation
- `logging`: Debug logging for service checks

### 5.4 Service Interface Contracts

**File Service Interface**:
```python
class FileService:
    """File loading service (from E01)."""

    def load_design(self, file_path: str) -> None:
        """Load design from CDL file."""
        # Implementation in E01

    # Optional signals
    design_loaded = Signal()  # Emitted on successful load
    load_failed = Signal(str)  # Emitted on error with message
```

**Expansion Service Interface**:
```python
class ExpansionService:
    """Expansion service with undo/redo (from E04)."""

    def undo(self) -> None:
        """Undo last expansion/collapse."""

    def redo(self) -> None:
        """Redo last undone expansion/collapse."""

    def can_undo(self) -> bool:
        """Check if undo is available."""

    def can_redo(self) -> bool:
        """Check if redo is available."""

    # Optional signal
    history_changed = Signal()  # Emitted when history state changes
```

**Search Panel Interface**:
```python
class SearchPanel(QDockWidget):
    """Search panel widget (from E05)."""

    def focus_search_input(self) -> None:
        """Focus the search input field."""

    # Standard QDockWidget methods: show(), hide(), isVisible()
```

### 5.5 Integration Sequence

```
1. E06-F01 creates main window
2. E01 provides file service → _file_service reference
3. E04 provides expansion service → _expansion_service reference
4. E05 provides search panel → _search_panel reference
5. E06-F03-T01 creates toolbar → _toolbar reference
6. E06-F03-T03 (this task) adds actions → toolbar buttons functional
7. E06-F03-T04 provides icon fallbacks → icons always available
```

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/unit/presentation/test_main_window.py`

**Test Cases**:

```python
import pytest
from unittest.mock import Mock, MagicMock, patch
from PySide6.QtWidgets import QFileDialog
from ink.presentation.main_window import InkMainWindow

class TestFileEditSearchActions:
    """Test file, edit, and search toolbar actions."""

    @pytest.fixture
    def main_window_with_services(self, qtbot):
        """Create main window with mock services."""
        window = InkMainWindow()
        qtbot.addWidget(window)

        # Mock services
        window._file_service = Mock()
        window._expansion_service = Mock()
        window._search_panel = Mock()

        return window

    def test_actions_created(self, main_window_with_services):
        """Test all actions are added to toolbar."""
        toolbar = main_window_with_services._toolbar
        action_names = [a.text() for a in toolbar.actions() if not a.isSeparator()]

        assert "Open" in action_names
        assert "Undo" in action_names
        assert "Redo" in action_names
        assert "Search" in action_names

    def test_undo_redo_initial_state(self, main_window_with_services):
        """Test undo/redo buttons are initially disabled."""
        window = main_window_with_services
        assert not window._undo_action.isEnabled()
        assert not window._redo_action.isEnabled()

    def test_open_action_always_enabled(self, main_window_with_services):
        """Test open button is always enabled."""
        window = main_window_with_services
        assert window._open_action.isEnabled()

    def test_search_action_always_enabled(self, main_window_with_services):
        """Test search button is always enabled."""
        window = main_window_with_services
        assert window._search_action.isEnabled()

    def test_action_shortcuts(self, main_window_with_services):
        """Test keyboard shortcuts are correctly assigned."""
        from PySide6.QtGui import QKeySequence

        window = main_window_with_services
        assert window._open_action.shortcut() == QKeySequence.StandardKey.Open
        assert window._undo_action.shortcut() == QKeySequence.StandardKey.Undo
        assert window._redo_action.shortcut() == QKeySequence.StandardKey.Redo
        assert window._search_action.shortcut() == QKeySequence.StandardKey.Find

    def test_open_file_shows_dialog(self, main_window_with_services, monkeypatch):
        """Test open button shows file dialog."""
        window = main_window_with_services
        dialog_shown = False

        def mock_get_open_filename(*args, **kwargs):
            nonlocal dialog_shown
            dialog_shown = True
            return ("", "")  # User cancelled

        monkeypatch.setattr(QFileDialog, "getOpenFileName", mock_get_open_filename)

        window._on_open_file()
        assert dialog_shown

    def test_open_file_loads_design(self, main_window_with_services, monkeypatch):
        """Test selecting file calls file service."""
        window = main_window_with_services

        def mock_get_open_filename(*args, **kwargs):
            return ("/path/to/design.ckt", "CDL Files (*.ckt *.cdl)")

        monkeypatch.setattr(QFileDialog, "getOpenFileName", mock_get_open_filename)

        window._on_open_file()
        window._file_service.load_design.assert_called_once_with("/path/to/design.ckt")

    def test_undo_action_calls_service(self, main_window_with_services):
        """Test undo button calls expansion service."""
        window = main_window_with_services
        window._expansion_service.can_undo.return_value = True
        window._expansion_service.can_redo.return_value = False
        window._undo_action.setEnabled(True)

        window._on_undo()
        window._expansion_service.undo.assert_called_once()

    def test_redo_action_calls_service(self, main_window_with_services):
        """Test redo button calls expansion service."""
        window = main_window_with_services
        window._expansion_service.can_undo.return_value = False
        window._expansion_service.can_redo.return_value = True
        window._redo_action.setEnabled(True)

        window._on_redo()
        window._expansion_service.redo.assert_called_once()

    def test_update_undo_redo_state(self, main_window_with_services):
        """Test undo/redo state updates based on service."""
        window = main_window_with_services

        # Undo available, redo not
        window._expansion_service.can_undo.return_value = True
        window._expansion_service.can_redo.return_value = False
        window._update_undo_redo_state()

        assert window._undo_action.isEnabled()
        assert not window._redo_action.isEnabled()

        # Redo available, undo not
        window._expansion_service.can_undo.return_value = False
        window._expansion_service.can_redo.return_value = True
        window._update_undo_redo_state()

        assert not window._undo_action.isEnabled()
        assert window._redo_action.isEnabled()

    def test_search_button_shows_panel(self, main_window_with_services):
        """Test search button shows search panel if hidden."""
        window = main_window_with_services
        window._search_panel.isVisible.return_value = False

        window._on_find()

        window._search_panel.show.assert_called_once()
        window._search_panel.focus_search_input.assert_called_once()

    def test_search_button_focuses_visible_panel(self, main_window_with_services):
        """Test search button focuses input if panel already visible."""
        window = main_window_with_services
        window._search_panel.isVisible.return_value = True

        window._on_find()

        window._search_panel.show.assert_not_called()
        window._search_panel.focus_search_input.assert_called_once()

    def test_graceful_handling_missing_services(self, qtbot):
        """Test actions don't crash when services missing."""
        window = InkMainWindow()
        qtbot.addWidget(window)
        # No services attached

        # Should not raise exceptions
        window._on_open_file()  # Will show dialog, user cancels
        window._on_undo()       # No-op
        window._on_redo()       # No-op
        window._on_find()       # No-op
```

### 6.2 Integration Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/integration/ui/test_toolbar_file_edit_search.py`

```python
import pytest
from PySide6.QtTest import QTest
from PySide6.QtCore import Qt
from ink.presentation.main_window import InkMainWindow
from ink.application.services.file_service import FileService
from ink.application.services.expansion_service import ExpansionService
from ink.presentation.panels.search_panel import SearchPanel

class TestFileEditSearchIntegration:
    """Integration tests with real services."""

    @pytest.fixture
    def integrated_window(self, qtbot, tmp_path):
        """Create main window with real services."""
        window = InkMainWindow()
        qtbot.addWidget(window)

        # Real services (stubbed or minimal implementations)
        window._file_service = FileService()
        window._expansion_service = ExpansionService()
        window._search_panel = SearchPanel()

        window.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, window._search_panel)

        return window

    def test_undo_redo_workflow(self, integrated_window, qtbot):
        """Test full undo/redo workflow."""
        window = integrated_window

        # Initially no history
        assert not window._undo_action.isEnabled()
        assert not window._redo_action.isEnabled()

        # Perform expansion
        window._expansion_service.expand_cell("test_cell")
        window._update_undo_redo_state()

        # Undo should be enabled
        assert window._undo_action.isEnabled()
        assert not window._redo_action.isEnabled()

        # Perform undo
        window._on_undo()

        # Redo should be enabled
        assert not window._undo_action.isEnabled()
        assert window._redo_action.isEnabled()

        # Perform redo
        window._on_redo()

        # Back to undo enabled
        assert window._undo_action.isEnabled()
        assert not window._redo_action.isEnabled()

    def test_search_panel_toggle(self, integrated_window, qtbot):
        """Test search panel show/focus behavior."""
        window = integrated_window
        panel = window._search_panel

        # Hide panel initially
        panel.hide()
        qtbot.wait(100)
        assert not panel.isVisible()

        # First click shows panel
        window._on_find()
        qtbot.wait(100)
        assert panel.isVisible()

        # Second click focuses input (panel remains visible)
        window._on_find()
        qtbot.wait(100)
        assert panel.isVisible()
        # Verify focus (implementation-specific)
```

### 6.3 Manual Testing

**Test Scenarios**:

1. **File Operations**:
   - Click Open button → file dialog appears
   - Select `.ckt` file → design loads
   - Cancel dialog → no action taken
   - Verify file filter shows only `.ckt` and `.cdl` files

2. **Undo/Redo Workflow**:
   - Launch app → undo/redo disabled (grayed out)
   - Perform expansion → undo enabled, redo disabled
   - Click Undo → action reversed, redo enabled, undo disabled
   - Click Redo → action restored, undo enabled, redo disabled
   - Perform new expansion → redo history cleared, redo disabled

3. **Search Functionality**:
   - Click Search → panel appears (if hidden)
   - Click Search again → input field focused
   - Close panel, click Search → panel reappears

4. **Keyboard Shortcuts**:
   - `Ctrl+O` → file dialog
   - `Ctrl+Z` → undo (if available)
   - `Ctrl+Shift+Z` → redo (if available)
   - `Ctrl+F` → show/focus search

**Expected Results**:
- All buttons have recognizable icons
- Tooltips show within 1 second
- Keyboard shortcuts work globally
- State management feels responsive
- No visual glitches or lag

---

## 7. Risks and Mitigation

### 7.1 Technical Risks

#### Risk 1: Service Dependencies Not Available

**Risk**: File service, expansion service, or search panel not implemented when this task completes

**Impact**: High (toolbar buttons non-functional)

**Probability**: Medium (parallel development, timing issues)

**Mitigation**:
- Implement defensive programming with null checks
- Create stub/mock services for testing
- Document service interface contracts
- Graceful degradation (no crashes, just no-ops)

**Stub Services**:
```python
class StubFileService:
    def load_design(self, path: str):
        logger.info(f"Stub: Would load {path}")

class StubExpansionService:
    def __init__(self):
        self._can_undo = False
        self._can_redo = False

    def undo(self): self._can_undo = False; self._can_redo = True
    def redo(self): self._can_redo = False; self._can_undo = True
    def can_undo(self): return self._can_undo
    def can_redo(self): return self._can_redo
```

#### Risk 2: Undo/Redo State Synchronization

**Risk**: State gets out of sync (button enabled but no history, or vice versa)

**Impact**: Medium (confusing UX, potential crashes)

**Probability**: Medium (complex state management)

**Mitigation**:
- Use signals for automatic state updates
- Fallback to manual calls after operations
- Add assertions in debug mode
- Comprehensive state transition tests

```python
def _on_undo(self):
    # Defensive check before calling
    if self._expansion_service.can_undo():
        self._expansion_service.undo()
        self._update_undo_redo_state()
    else:
        logger.warning("Undo called but no history available")
```

#### Risk 3: File Dialog Platform Differences

**Risk**: File dialog behavior differs across platforms (Linux/Windows/Mac)

**Impact**: Low (cosmetic, doesn't affect functionality)

**Probability**: Low (Qt abstracts platform differences)

**Mitigation**:
- Use Qt standard dialogs (platform-native)
- Test on target platform (Linux)
- Avoid platform-specific hacks
- Document any platform-specific issues

### 7.2 Integration Risks

#### Risk 4: Service API Changes

**Risk**: E01/E04/E05 implement different APIs than assumed

**Impact**: High (requires refactoring)

**Probability**: Low (coordination via specs)

**Mitigation**:
- Document assumed interfaces in this pre-doc
- Coordinate with E01/E04/E05 implementers
- Use Protocol types for interface definitions
- Create integration tests early

#### Risk 5: Signal Connection Timing

**Risk**: Signals connected before service emits, or after events already occurred

**Impact**: Medium (state updates missed)

**Probability**: Low (controlled initialization)

**Mitigation**:
- Connect signals during/after service initialization
- Call `_update_undo_redo_state()` after connection
- Document connection timing requirements
- Add logging to verify signal connections

```python
def _connect_expansion_signals(self):
    """Connect signals (call after service created)."""
    if self._expansion_service:
        self._expansion_service.history_changed.connect(
            self._update_undo_redo_state
        )
        # Initial state update
        self._update_undo_redo_state()
```

---

## 8. Implementation Notes

### 8.1 Code Organization

**Method Grouping in Main Window**:
```python
class InkMainWindow(QMainWindow):
    # === Initialization ===
    def __init__(self): ...
    def _setup_ui(self): ...
    def _setup_toolbar(self): ...
    def _connect_expansion_signals(self): ...

    # === Toolbar Action Groups ===
    def _add_file_actions(self, toolbar): ...
    def _add_edit_actions(self, toolbar): ...
    def _add_view_actions(self, toolbar): ...  # From T02
    def _add_search_actions(self, toolbar): ...

    # === File Action Handlers ===
    def _on_open_file(self): ...

    # === Edit Action Handlers ===
    def _on_undo(self): ...
    def _on_redo(self): ...
    def _update_undo_redo_state(self): ...

    # === Search Action Handlers ===
    def _on_find(self): ...

    # === View Action Handlers (from T02) ===
    def _on_zoom_in(self): ...
    def _on_zoom_out(self): ...
    def _on_fit_view(self): ...
```

### 8.2 Settings Persistence

**QSettings Structure**:
```python
# Organization: "Ink"
# Application: "InkSchematicViewer"

settings = QSettings("Ink", "InkSchematicViewer")

# Keys:
# - "last_open_directory": Last directory for file dialog
# - "MainToolBar/geometry": Toolbar position (future)
# - "search_panel/visible": Search panel visibility (future)
```

### 8.3 Logging Strategy

**Log Levels**:
- `DEBUG`: Service checks, state updates
- `INFO`: User actions (file opened, undo/redo)
- `WARNING`: Missing services, unexpected states
- `ERROR`: Service call failures

**Example**:
```python
logger.debug(f"Updating undo/redo state: undo={can_undo}, redo={can_redo}")
logger.info(f"Loading design from {file_path}")
logger.warning("Expansion service not available for undo")
```

### 8.4 Future Enhancements

**P1 Features**:
1. **Recent Files Menu**: Dropdown from Open button
2. **Undo/Redo History List**: Dropdown showing operation stack
3. **Search History**: Recent searches in dropdown
4. **Save/Save As**: Additional file operations
5. **Export**: Export schematic to image/PDF

**Implementation Hooks**:
```python
# Future: Recent files
class RecentFilesManager:
    def add_recent_file(self, path: str): ...
    def get_recent_files(self) -> List[str]: ...

# Future: Undo history dropdown
def _show_undo_history_menu(self):
    """Show dropdown menu with undo stack."""
    menu = QMenu(self)
    for operation in self._expansion_service.get_undo_stack():
        menu.addAction(operation.description)
    # Show menu below undo button...
```

---

## 9. Acceptance Checklist

### 9.1 Implementation Complete

- [ ] `_add_file_actions()` method implemented
- [ ] `_add_edit_actions()` method implemented
- [ ] `_add_search_actions()` method implemented
- [ ] `_on_open_file()` handler implemented with file dialog
- [ ] `_on_undo()` handler implemented
- [ ] `_on_redo()` handler implemented
- [ ] `_on_find()` handler implemented
- [ ] `_update_undo_redo_state()` method implemented
- [ ] Actions added to toolbar in correct order
- [ ] Visual separators between groups
- [ ] Action references stored for state management

### 9.2 Testing Complete

- [ ] Unit tests for all action groups pass
- [ ] Unit tests for state management pass
- [ ] Integration tests with services pass
- [ ] Manual testing confirms all workflows
- [ ] Keyboard shortcuts work correctly
- [ ] No crashes with missing services
- [ ] State transitions verified

### 9.3 Service Integration

- [ ] File service integration working
- [ ] Expansion service integration working
- [ ] Search panel integration working
- [ ] Signal connections established (if applicable)
- [ ] State updates after operations
- [ ] Graceful degradation without services

### 9.4 Code Quality

- [ ] Type hints for all methods
- [ ] Docstrings for all action handlers
- [ ] Defensive null checks for services
- [ ] Logging for debugging
- [ ] Comments explain state management
- [ ] PEP 8 compliance

### 9.5 User Experience

- [ ] All buttons have appropriate icons
- [ ] Tooltips display action + shortcut
- [ ] Undo/Redo initially disabled
- [ ] Undo/Redo enable when appropriate
- [ ] File dialog remembers last directory
- [ ] Search panel shows/focuses correctly
- [ ] Keyboard shortcuts feel responsive

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Implement action group methods**:
   - `_add_file_actions()`
   - `_add_edit_actions()`
   - `_add_search_actions()`

2. **Implement action handlers**:
   - `_on_open_file()` with file dialog
   - `_on_undo()` and `_on_redo()` with state updates
   - `_on_find()` with panel toggle

3. **Implement state management**:
   - `_update_undo_redo_state()`
   - Signal connection (if available)

4. **Write tests**:
   - Unit tests with mock services
   - Integration tests with real/stub services
   - Manual test checklist

### 10.2 Coordination Points

**Before Starting**:
- [ ] Confirm T01 (toolbar infrastructure) complete
- [ ] Check E01/E04/E05 service interface specs
- [ ] Verify service availability timeline

**During Development**:
- [ ] Coordinate with E01 on file service API
- [ ] Coordinate with E04 on expansion service API
- [ ] Coordinate with E05 on search panel API
- [ ] Test with stub services if real services delayed

**After Completion**:
- [ ] Notify T04 of icon names used
- [ ] Integration test with real services when available
- [ ] Document any API assumptions/changes

### 10.3 Follow-Up Items

**Post-MVP Enhancements**:
1. Recent files menu
2. Undo/redo history dropdown
3. Save/Save As functionality
4. Export to image/PDF

**Documentation Updates**:
1. User guide: File operations section
2. User guide: Undo/redo usage
3. Developer guide: Service integration patterns
4. Keyboard shortcuts reference

---

## Appendix A: Service Interface Specifications

### A.1 File Service Interface (E01)

```python
# Expected interface from E01
from pathlib import Path
from PySide6.QtCore import QObject, Signal

class FileService(QObject):
    """
    File loading service.

    Handles CDL netlist parsing and design construction.
    """

    # Signals
    design_loaded = Signal()  # Emitted on successful load
    load_failed = Signal(str)  # Emitted on error (error message)

    def load_design(self, file_path: str) -> None:
        """
        Load design from CDL file.

        Args:
            file_path: Path to .ckt or .cdl file

        Raises:
            FileNotFoundError: If file doesn't exist
            ParseError: If file has syntax errors
        """
        pass  # Implementation in E01
```

### A.2 Expansion Service Interface (E04)

```python
# Expected interface from E04
from PySide6.QtCore import QObject, Signal

class ExpansionService(QObject):
    """
    Expansion service with undo/redo support.

    Manages schematic expansion/collapse operations and maintains
    operation history for undo/redo.
    """

    # Signals
    history_changed = Signal()  # Emitted when undo/redo state changes

    def undo(self) -> None:
        """
        Undo last expansion/collapse operation.

        Reverts the most recent operation and updates canvas.
        Does nothing if no operations to undo.
        """
        pass

    def redo(self) -> None:
        """
        Redo last undone operation.

        Re-applies the most recently undone operation.
        Does nothing if no operations to redo.
        """
        pass

    def can_undo(self) -> bool:
        """
        Check if undo is available.

        Returns:
            True if at least one operation in undo stack
        """
        pass

    def can_redo(self) -> bool:
        """
        Check if redo is available.

        Returns:
            True if at least one operation in redo stack
        """
        pass

    def expand_cell(self, cell_id: str) -> None:
        """
        Expand cell (for testing state management).

        Args:
            cell_id: Cell identifier to expand
        """
        pass
```

### A.3 Search Panel Interface (E05)

```python
# Expected interface from E05
from PySide6.QtWidgets import QDockWidget

class SearchPanel(QDockWidget):
    """
    Search panel for finding cells, nets, and pins.

    Dockable panel providing search functionality with text input
    and results list.
    """

    def focus_search_input(self) -> None:
        """
        Focus the search input field.

        Sets keyboard focus to search text input, ready for typing.
        If panel is hidden, shows it first.
        """
        pass  # Implementation in E05
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
