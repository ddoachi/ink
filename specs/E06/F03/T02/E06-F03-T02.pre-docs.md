# E06-F03-T02: View Control Tools - Pre-Implementation Documentation

## Document Metadata
- **Task**: E06-F03-T02 - View Control Tools
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

E06-F03-T02 implements view manipulation toolbar buttons that enable users to quickly control schematic canvas zoom and view fitting. These controls are fundamental to navigating large schematics during exploration sessions, providing one-click access to zoom in, zoom out, and fit-to-view operations with corresponding keyboard shortcuts.

### 1.2 Core Objectives

1. **Zoom In Button**: `Ctrl+=` shortcut, scales canvas view in
2. **Zoom Out Button**: `Ctrl+-` shortcut, scales canvas view out
3. **Fit View Button**: `Ctrl+0` shortcut, fits all content in viewport
4. **Canvas Integration**: Connect toolbar actions to schematic canvas methods
5. **User Feedback**: Provide tooltips showing action names and shortcuts
6. **Visual Grouping**: Add visual separator around view control group

### 1.3 Success Criteria

- Three view control buttons appear in toolbar
- Buttons have appropriate icons (zoom-in, zoom-out, zoom-fit-best)
- Keyboard shortcuts work globally when main window has focus
- Clicking buttons triggers correct canvas operations
- Actions work when canvas loaded
- Actions gracefully handle missing canvas (no crash)
- Tooltips display action name and keyboard shortcut

---

## 2. Problem Context

### 2.1 User Need

**Schematic exploration requires frequent view adjustments**:

- **Zoom In**: Examine detailed connections at gate level
- **Zoom Out**: See broader circuit context
- **Fit View**: Return to overview after zooming

**Pain points without toolbar buttons**:
- Menu navigation interrupts workflow
- Keyboard shortcuts not discoverable
- Mouse wheel zoom has no "fit view" equivalent
- No visual cue for available view operations

**Solution benefits**:
- One-click access reduces cognitive load
- Icons provide visual affordance
- Tooltips show keyboard shortcuts for learning
- Standard zoom controls match user expectations from CAD tools

### 2.2 Technical Challenge

**Integration Challenges**:

1. **Canvas Availability**: Canvas may not exist when main window initializes
   - Need defensive programming with null checks
   - Graceful degradation when canvas missing

2. **Action State Management**: View actions always enabled
   - Unlike undo/redo, no state-dependent enable/disable
   - Simpler implementation but still need error handling

3. **Icon Loading**: System theme icons may not be available
   - Primary: `QIcon.fromTheme()` for system icons
   - Fallback: Bundled SVG icons (from T04)
   - Need robust icon loading strategy

4. **Coordinate with Canvas API**: Assume canvas provides zoom methods
   - `zoom_in()`, `zoom_out()`, `fit_view()`
   - If canvas API different, need adapter layer

### 2.3 Integration Context

**Depends On**:
- **E06-F03-T01**: Toolbar infrastructure (`self._toolbar` reference)
- **E02**: Schematic canvas with zoom/fit methods
- **E06-F01**: Main window with canvas reference

**Used By**:
- **E06-F03-T04**: Icon resources (provides fallback icons)

**Integrates With**:
- **E04**: Canvas interactions (zoom affects expansion rendering)
- **E05**: Search results (fit view useful after navigation)

---

## 3. Implementation Approach

### 3.1 Architecture Design

**Component Structure**:
```
InkMainWindow
├── _setup_toolbar()
│   └── _add_view_actions()      # NEW: Add view control actions
├── _on_zoom_in()                # NEW: Zoom in handler
├── _on_zoom_out()               # NEW: Zoom out handler
├── _on_fit_view()               # NEW: Fit view handler
├── _toolbar                     # From T01
└── _canvas                      # From E02/E06-F01
```

**Call Sequence**:
```
User clicks Zoom In button
  → QAction.triggered signal
  → _on_zoom_in() slot
  → self._canvas.zoom_in()
  → Canvas view scales up
```

### 3.2 Key Components

#### Component 1: View Actions Group

```python
def _add_view_actions(self, toolbar: QToolBar):
    """Add view-related toolbar actions."""
    # Order: Zoom Out, Zoom In, Fit View (conventional order)

    # Zoom Out (decrease first)
    zoom_out_action = QAction(
        QIcon.fromTheme("zoom-out"),
        "Zoom Out",
        self
    )
    zoom_out_action.setToolTip("Zoom out (Ctrl+-)")
    zoom_out_action.setShortcut(QKeySequence.StandardKey.ZoomOut)
    zoom_out_action.triggered.connect(self._on_zoom_out)
    toolbar.addAction(zoom_out_action)

    # Zoom In (increase second)
    zoom_in_action = QAction(
        QIcon.fromTheme("zoom-in"),
        "Zoom In",
        self
    )
    zoom_in_action.setToolTip("Zoom in (Ctrl+=)")
    zoom_in_action.setShortcut(QKeySequence.StandardKey.ZoomIn)
    zoom_in_action.triggered.connect(self._on_zoom_in)
    toolbar.addAction(zoom_in_action)

    # Fit View (special operation last)
    fit_view_action = QAction(
        QIcon.fromTheme("zoom-fit-best"),
        "Fit View",
        self
    )
    fit_view_action.setToolTip("Fit view to content (Ctrl+0)")
    fit_view_action.setShortcut(QKeySequence("Ctrl+0"))
    fit_view_action.triggered.connect(self._on_fit_view)
    toolbar.addAction(fit_view_action)
```

**Design Choices**:
- **Button Order**: Zoom Out → Zoom In → Fit View (industry convention)
- **Tooltips**: Include action name + keyboard shortcut in parentheses
- **Shortcuts**: Qt standard keys for zoom, custom for fit view
- **No State Management**: Actions always enabled (unlike undo/redo)

#### Component 2: Action Handlers

```python
def _on_zoom_in(self):
    """Handle zoom in action."""
    if hasattr(self, '_canvas') and self._canvas:
        self._canvas.zoom_in()

def _on_zoom_out(self):
    """Handle zoom out action."""
    if hasattr(self, '_canvas') and self._canvas:
        self._canvas.zoom_out()

def _on_fit_view(self):
    """Handle fit view action."""
    if hasattr(self, '_canvas') and self._canvas:
        self._canvas.fit_view()
```

**Defensive Programming**:
- Check `hasattr()` in case `_canvas` not initialized
- Check truthiness in case `_canvas` is `None`
- Silent failure if canvas missing (could add logging)

#### Component 3: Canvas API Integration

**Assumed Canvas Interface** (from E02):
```python
# src/ink/presentation/canvas/schematic_canvas.py
class SchematicCanvas(QGraphicsView):
    def zoom_in(self, factor: float = 1.2):
        """Zoom in by scaling factor (default 20% increase)."""
        self.scale(factor, factor)

    def zoom_out(self, factor: float = 1.2):
        """Zoom out by inverse scaling factor."""
        self.scale(1.0 / factor, 1.0 / factor)

    def fit_view(self):
        """Fit all visible items in view with aspect ratio preserved."""
        self.fitInView(
            self.scene().itemsBoundingRect(),
            Qt.AspectRatioMode.KeepAspectRatio
        )
```

**If Canvas API Different**:
- Create adapter method in main window
- Map toolbar action to actual canvas methods
- Document API assumptions in code comments

### 3.3 Implementation Strategy

#### Phase 1: Add View Actions (Core Implementation)

**Steps**:
1. Add `_add_view_actions()` method to main window
2. Call from `_setup_toolbar()` with separator
3. Implement action handlers (`_on_zoom_in`, etc.)
4. Test with mock canvas

**Deliverables**:
- Three toolbar buttons with icons
- Action handlers connected to canvas methods
- Visual separator before/after view group

#### Phase 2: Canvas Integration Testing

**Steps**:
1. Test with actual schematic canvas (E02)
2. Verify zoom factor feels natural
3. Confirm fit view shows all content
4. Test edge cases (empty canvas, single item, etc.)

**Deliverables**:
- Integration tests with real canvas
- Manual testing confirms smooth zoom behavior
- Edge cases handled gracefully

### 3.4 File Modifications

**Primary File**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/main_window.py`

**Changes**:
```python
# Add imports
from PySide6.QtGui import QAction, QIcon, QKeySequence

class InkMainWindow(QMainWindow):
    def _setup_toolbar(self):
        """Create main toolbar with action buttons."""
        # ... existing setup from T01

        # View Group (added by this task)
        self._add_view_actions(self._toolbar)
        self._toolbar.addSeparator()

        # Other groups added by T03...

    def _add_view_actions(self, toolbar: QToolBar):  # NEW METHOD
        """Add view-related toolbar actions."""
        # Implementation shown above

    # NEW: Action handlers
    def _on_zoom_in(self):
        """Handle zoom in action."""
        # Implementation shown above

    def _on_zoom_out(self):
        """Handle zoom out action."""
        # Implementation shown above

    def _on_fit_view(self):
        """Handle fit view action."""
        # Implementation shown above
```

---

## 4. Design Decisions

### 4.1 Decision: Zoom Factor

**Options Considered**:

1. **1.2x (20% change)** (CHOSEN)
   - Pros: Smooth progression, feels responsive
   - Cons: Takes more clicks for large zoom changes

2. **1.5x (50% change)**
   - Pros: Faster zooming
   - Cons: Too abrupt, jarring transitions

3. **2.0x (100% change)**
   - Pros: Very fast
   - Cons: Hard to control, skips useful zoom levels

**Decision**: 1.2x factor for both zoom in and zoom out

**Rationale**:
- Standard Qt/CAD convention
- Balances speed and control
- Matches mouse wheel zoom expectations
- Can be adjusted based on user feedback

### 4.2 Decision: Keyboard Shortcuts

**Choices**:

1. **Zoom In**: `Ctrl+=` (Qt standard)
   - Also accepts `Ctrl++` automatically
   - Standard across applications

2. **Zoom Out**: `Ctrl+-` (Qt standard)
   - Universal convention

3. **Fit View**: `Ctrl+0` (custom)
   - Industry convention (Figma, CAD tools)
   - Zero = "reset to overview"
   - Not a Qt standard, need custom binding

**Alternative Considered**: `Ctrl+Shift+F` for fit view
- Pros: Mnemonic (F for Fit)
- Cons: Less discoverable, requires two modifier keys
- Decision: Stick with `Ctrl+0` for consistency with industry

### 4.3 Decision: Always-Enabled Actions

**Question**: Should view actions be disabled when no design loaded?

**Options**:

1. **Always Enabled** (CHOSEN)
   - Pros: Simpler implementation, consistent behavior
   - Cons: Clicking when no design does nothing

2. **State-Dependent**
   - Pros: Clear visual feedback about availability
   - Cons: More complexity, state management overhead

**Decision**: Always enabled, graceful no-op if canvas missing

**Rationale**:
- View controls are expected to always be available
- Error handling is simple (null check)
- Users will have design loaded in normal usage
- Reduces UI state complexity

### 4.4 Decision: Icon Loading Strategy

**Strategy**: Theme-first with fallback

**Implementation**:
```python
# For now (T02): Use QIcon.fromTheme()
icon = QIcon.fromTheme("zoom-in")

# Future (T04): IconProvider with fallback
from ink.presentation.utils.icon_provider import IconProvider
icon = IconProvider.get_icon("zoom-in")
```

**Timeline**:
- T02: Use direct theme loading (works on systems with themes)
- T04: Refactor to use `IconProvider` with fallback

**Migration Path**:
- Simple find-replace when T04 complete
- No API changes, just icon source

---

## 5. Dependencies and Integration

### 5.1 Upstream Dependencies

**E06-F03-T01: Toolbar Setup** (REQUIRED)
- Provides `self._toolbar` reference
- Toolbar instance must exist before adding actions
- Must call `_add_view_actions()` in `_setup_toolbar()`

**E02: Schematic Rendering** (OPTIONAL for UI, REQUIRED for functionality)
- Provides `SchematicCanvas` class with zoom methods
- Canvas attached as central widget or child
- Main window has `self._canvas` reference

**E06-F01: Main Window Shell** (REQUIRED)
- Provides `InkMainWindow` class structure
- May provide canvas reference mechanism

### 5.2 Downstream Dependencies

**E06-F03-T04: Icon Resources** (NICE-TO-HAVE)
- Provides fallback icons when system theme missing
- View actions will refactor to use `IconProvider.get_icon()`
- Not blocking (system themes work on most Linux setups)

### 5.3 External Dependencies

**PySide6 Components**:
- `QAction`: Toolbar action objects
- `QIcon`: Icon loading from theme
- `QKeySequence`: Keyboard shortcut definitions
- `QToolBar`: Toolbar widget (from T01)

**Icon Theme Requirements**:
- System must provide icon theme with:
  - `zoom-in` icon
  - `zoom-out` icon
  - `zoom-fit-best` icon
- Common on Linux with GNOME/KDE/XFCE
- May be missing on minimal systems → T04 provides fallback

### 5.4 Integration Points

**With Canvas**:
```python
# Main window needs canvas reference
class InkMainWindow(QMainWindow):
    _canvas: Optional[SchematicCanvas] = None

    def set_canvas(self, canvas: SchematicCanvas):
        """Set schematic canvas (called during initialization)."""
        self._canvas = canvas
```

**With Expansion System** (E03/E04):
- Zoom doesn't directly trigger expansion
- But zoom level affects visual detail rendering
- Future: Level-of-detail based on zoom (P1 feature)

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/unit/presentation/test_main_window.py`

**Test Cases**:

```python
import pytest
from unittest.mock import Mock, MagicMock
from PySide6.QtGui import QKeySequence
from PySide6.QtWidgets import QToolBar
from ink.presentation.main_window import InkMainWindow

class TestViewControlActions:
    """Test view control toolbar actions."""

    @pytest.fixture
    def main_window(self, qtbot):
        """Create main window with mock canvas."""
        window = InkMainWindow()
        qtbot.addWidget(window)
        window._canvas = Mock()  # Mock canvas
        return window

    def test_view_actions_created(self, main_window):
        """Test view control actions are added to toolbar."""
        toolbar = main_window.findChild(QToolBar, "MainToolBar")
        actions = toolbar.actions()

        # Find view actions (filter out separators)
        action_names = [a.text() for a in actions if not a.isSeparator()]

        assert "Zoom In" in action_names
        assert "Zoom Out" in action_names
        assert "Fit View" in action_names

    def test_view_actions_order(self, main_window):
        """Test view actions appear in correct order."""
        toolbar = main_window._toolbar
        action_texts = [a.text() for a in toolbar.actions() if not a.isSeparator()]

        # Should be: Zoom Out, Zoom In, Fit View
        zoom_out_idx = action_texts.index("Zoom Out")
        zoom_in_idx = action_texts.index("Zoom In")
        fit_view_idx = action_texts.index("Fit View")

        assert zoom_out_idx < zoom_in_idx < fit_view_idx

    def test_view_action_shortcuts(self, main_window):
        """Test view actions have correct keyboard shortcuts."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        zoom_in = actions["Zoom In"]
        zoom_out = actions["Zoom Out"]
        fit_view = actions["Fit View"]

        assert zoom_in.shortcut() == QKeySequence.StandardKey.ZoomIn
        assert zoom_out.shortcut() == QKeySequence.StandardKey.ZoomOut
        assert fit_view.shortcut() == QKeySequence("Ctrl+0")

    def test_view_action_tooltips(self, main_window):
        """Test tooltips include action name and shortcut."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        assert "Ctrl" in actions["Zoom In"].toolTip()
        assert "Ctrl" in actions["Zoom Out"].toolTip()
        assert "Ctrl+0" in actions["Fit View"].toolTip()

    def test_zoom_in_triggered(self, main_window):
        """Test zoom in action calls canvas.zoom_in()."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        actions["Zoom In"].trigger()
        main_window._canvas.zoom_in.assert_called_once()

    def test_zoom_out_triggered(self, main_window):
        """Test zoom out action calls canvas.zoom_out()."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        actions["Zoom Out"].trigger()
        main_window._canvas.zoom_out.assert_called_once()

    def test_fit_view_triggered(self, main_window):
        """Test fit view action calls canvas.fit_view()."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        actions["Fit View"].trigger()
        main_window._canvas.fit_view.assert_called_once()

    def test_view_actions_without_canvas(self, main_window):
        """Test view actions don't crash when canvas is missing."""
        main_window._canvas = None
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        # Should not raise exception
        actions["Zoom In"].trigger()
        actions["Zoom Out"].trigger()
        actions["Fit View"].trigger()

    def test_view_actions_always_enabled(self, main_window):
        """Test view actions are always enabled."""
        toolbar = main_window._toolbar
        actions = {a.text(): a for a in toolbar.actions() if not a.isSeparator()}

        assert actions["Zoom In"].isEnabled()
        assert actions["Zoom Out"].isEnabled()
        assert actions["Fit View"].isEnabled()
```

### 6.2 Integration Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/integration/ui/test_toolbar_view_controls.py`

```python
import pytest
from PySide6.QtCore import Qt
from PySide6.QtTest import QTest
from ink.presentation.main_window import InkMainWindow
from ink.presentation.canvas.schematic_canvas import SchematicCanvas

class TestViewControlsIntegration:
    """Integration tests with real canvas."""

    @pytest.fixture
    def main_window_with_canvas(self, qtbot):
        """Create main window with real canvas."""
        window = InkMainWindow()
        qtbot.addWidget(window)

        canvas = SchematicCanvas()
        window._canvas = canvas

        return window, canvas

    def test_zoom_in_integration(self, main_window_with_canvas, qtbot):
        """Test zoom in actually scales the canvas."""
        window, canvas = main_window_with_canvas
        initial_scale = canvas.transform().m11()

        # Trigger zoom in via keyboard shortcut
        QTest.keyClick(window, Qt.Key.Key_Plus, Qt.KeyboardModifier.ControlModifier)
        qtbot.wait(100)

        assert canvas.transform().m11() > initial_scale

    def test_zoom_out_integration(self, main_window_with_canvas, qtbot):
        """Test zoom out actually scales the canvas."""
        window, canvas = main_window_with_canvas
        initial_scale = canvas.transform().m11()

        # Trigger zoom out
        QTest.keyClick(window, Qt.Key.Key_Minus, Qt.KeyboardModifier.ControlModifier)
        qtbot.wait(100)

        assert canvas.transform().m11() < initial_scale

    def test_fit_view_integration(self, main_window_with_canvas, qtbot):
        """Test fit view adjusts canvas to show all content."""
        window, canvas = main_window_with_canvas

        # Add some content to canvas
        from PySide6.QtWidgets import QGraphicsRectItem
        rect = QGraphicsRectItem(0, 0, 100, 100)
        canvas.scene().addItem(rect)

        # Zoom in first
        canvas.zoom_in()
        canvas.zoom_in()

        # Trigger fit view
        QTest.keyClick(window, Qt.Key.Key_0, Qt.KeyboardModifier.ControlModifier)
        qtbot.wait(100)

        # Verify content is visible
        visible_rect = canvas.mapToScene(canvas.viewport().rect()).boundingRect()
        items_rect = canvas.scene().itemsBoundingRect()
        assert visible_rect.contains(items_rect)

    def test_zoom_sequence(self, main_window_with_canvas, qtbot):
        """Test zoom in/out sequence maintains consistency."""
        window, canvas = main_window_with_canvas
        initial_scale = canvas.transform().m11()

        # Zoom in 3 times
        for _ in range(3):
            canvas.zoom_in()

        # Zoom out 3 times
        for _ in range(3):
            canvas.zoom_out()

        # Should be approximately back to initial scale
        final_scale = canvas.transform().m11()
        assert abs(final_scale - initial_scale) < 0.01
```

### 6.3 Manual Testing

**Test Scenarios**:

1. **Basic Zoom Controls**:
   - Load design with schematic content
   - Click Zoom In button → verify canvas zooms in smoothly
   - Click Zoom Out button → verify canvas zooms out smoothly
   - Click Fit View button → verify all content visible

2. **Keyboard Shortcuts**:
   - Press `Ctrl+=` → zoom in
   - Press `Ctrl+-` → zoom out
   - Press `Ctrl+0` → fit view
   - Verify shortcuts work when focus on canvas, toolbar, or main window

3. **Visual Feedback**:
   - Hover over buttons → verify tooltips appear
   - Check tooltip text includes action name and shortcut
   - Verify button icons are clear and recognizable

4. **Edge Cases**:
   - Empty canvas → zoom/fit should not crash
   - Very zoomed in → zoom out should work
   - Very zoomed out → zoom in should work
   - Single cell → fit view should center it

**Expected Results**:
- Smooth zoom transitions
- Fit view always shows all content
- No visual glitches or performance issues
- Tooltips appear within 1 second

---

## 7. Risks and Mitigation

### 7.1 Technical Risks

#### Risk 1: Canvas API Mismatch

**Risk**: Assumed canvas methods don't match actual implementation

**Impact**: High (toolbar buttons don't work)

**Probability**: Low (E02 spec should define API)

**Mitigation**:
- Review E02 schematic canvas spec for API
- Coordinate with E02 implementer
- Document assumed interface in code comments
- Create adapter layer if needed

```python
# Adapter pattern if API different
def _on_zoom_in(self):
    if hasattr(self._canvas, 'zoom_in'):
        self._canvas.zoom_in()
    elif hasattr(self._canvas, 'scale_view'):
        self._canvas.scale_view(1.2)  # Adapter
    else:
        logger.warning("Canvas does not support zoom in")
```

#### Risk 2: Icon Theme Missing

**Risk**: System lacks icon theme, toolbar shows placeholder icons

**Impact**: Medium (visual quality, no functional impact)

**Probability**: Medium (minimal Linux systems, CI environments)

**Mitigation**:
- T04 will provide bundled fallback icons
- For now, check if icons loaded:

```python
icon = QIcon.fromTheme("zoom-in")
if icon.isNull():
    logger.warning("Icon theme missing, using text fallback")
    # Could use Unicode symbols as temporary fallback
```

**Contingency**:
- Use text-based actions temporarily
- Fast-track T04 if issue widespread

#### Risk 3: Zoom Factor Not Optimal

**Risk**: 1.2x zoom factor feels too slow/fast

**Impact**: Low (usability, but adjustable)

**Probability**: Medium (subjective preference)

**Mitigation**:
- Make zoom factor configurable constant
- Easy to adjust based on user feedback
- Consider adding preferences dialog (P1)

```python
# Make factor configurable
ZOOM_FACTOR = 1.2  # Adjust based on testing

def zoom_in(self, factor: float = ZOOM_FACTOR):
    self.scale(factor, factor)
```

### 7.2 Integration Risks

#### Risk 4: Toolbar Setup Order

**Risk**: `_add_view_actions()` called before toolbar created

**Impact**: High (runtime error)

**Probability**: Very Low (clear initialization sequence)

**Mitigation**:
- T01 establishes `self._toolbar` first
- Documentation clarifies call order
- Unit tests verify toolbar exists before action addition

#### Risk 5: Canvas Not Yet Implemented

**Risk**: E02 (canvas) delayed, blocking testing

**Impact**: Medium (can't test integration)

**Probability**: Low (E02 is P0, parallel development)

**Mitigation**:
- Mock canvas in unit tests (already planned)
- Use minimal `QGraphicsView` stub for integration tests
- Implement defensive null checks (already planned)

**Stub Canvas**:
```python
# For early testing if E02 delayed
class StubCanvas(QGraphicsView):
    def zoom_in(self):
        self.scale(1.2, 1.2)
    def zoom_out(self):
        self.scale(1/1.2, 1/1.2)
    def fit_view(self):
        pass  # No-op for stub
```

---

## 8. Implementation Notes

### 8.1 Code Organization

**Method Grouping**:
```python
class InkMainWindow(QMainWindow):
    # Initialization
    def __init__(self): ...
    def _setup_ui(self): ...
    def _setup_toolbar(self): ...

    # Toolbar action groups
    def _add_view_actions(self, toolbar): ...  # This task
    # def _add_file_actions(self, toolbar): ...  # T03
    # def _add_edit_actions(self, toolbar): ...  # T03

    # Action handlers
    def _on_zoom_in(self): ...
    def _on_zoom_out(self): ...
    def _on_fit_view(self): ...
```

### 8.2 Tooltip Conventions

**Format**: `"{Action Name} ({Shortcut})"`

**Examples**:
- "Zoom in (Ctrl+=)"
- "Zoom out (Ctrl+-)"
- "Fit view to content (Ctrl+0)"

**Rationale**:
- Descriptive action name (lowercase for verb phrases)
- Keyboard shortcut in parentheses
- Consistent with Qt/KDE conventions

### 8.3 Icon Naming Conventions

**Icon Theme Names** (Freedesktop standard):
- `zoom-in`: Plus icon or magnifying glass with "+"
- `zoom-out`: Minus icon or magnifying glass with "-"
- `zoom-fit-best`: Arrows pointing outward (maximize)

**Fallback Plan** (if theme missing):
- Unicode symbols: "+" (U+002B), "−" (U+2212), "⊡" (U+229F)
- Custom SVG icons from T04

### 8.4 Future Enhancements

**P1 Features**:
1. **Zoom Percentage Display**: Show "125%" in status bar
2. **Zoom Presets**: Dropdown menu for 25%, 50%, 100%, 200%
3. **Zoom to Selection**: Fit view to selected cells
4. **Pan Mode Toggle**: Hand tool for dragging canvas
5. **Reset View**: Restore initial zoom and position

**Implementation Hooks**:
```python
# Future: Zoom percentage tracking
def _on_zoom_in(self):
    if self._canvas:
        self._canvas.zoom_in()
        self._update_zoom_percentage()  # P1 feature

def _update_zoom_percentage(self):
    """Update status bar with current zoom level."""
    scale = self._canvas.transform().m11()
    percentage = int(scale * 100)
    self.statusBar().showMessage(f"Zoom: {percentage}%")
```

---

## 9. Acceptance Checklist

### 9.1 Implementation Complete

- [ ] `_add_view_actions()` method added to main window
- [ ] Three view action objects created (Zoom In, Zoom Out, Fit View)
- [ ] Actions configured with icons, tooltips, shortcuts
- [ ] Actions connected to handler methods
- [ ] Actions added to toolbar in correct order
- [ ] Visual separator added after view group
- [ ] Action handlers implemented with null checks
- [ ] Canvas methods called correctly

### 9.2 Testing Complete

- [ ] Unit tests pass for action creation
- [ ] Unit tests verify correct shortcuts
- [ ] Unit tests check tooltip content
- [ ] Unit tests validate action triggering
- [ ] Unit tests confirm null-safety
- [ ] Integration tests with real canvas pass
- [ ] Manual testing confirms smooth zoom behavior
- [ ] No console errors or warnings

### 9.3 Code Quality

- [ ] Type hints added for all methods
- [ ] Docstrings explain each action handler
- [ ] Code follows PEP 8 style
- [ ] No magic numbers (zoom factor as constant)
- [ ] Defensive programming with null checks
- [ ] Comments explain icon loading strategy

### 9.4 User Experience

- [ ] Buttons appear in toolbar with recognizable icons
- [ ] Tooltips display on hover (<1 second)
- [ ] Keyboard shortcuts work globally
- [ ] Zoom feels smooth and responsive
- [ ] Fit view shows all content properly
- [ ] No visual glitches during zoom

### 9.5 Integration Ready

- [ ] Works with E06-F03-T01 toolbar infrastructure
- [ ] Compatible with E02 canvas API
- [ ] Ready for T04 icon provider refactoring
- [ ] No blocking issues for parallel development

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Implement `_add_view_actions()` method**:
   - Create three QAction objects
   - Configure icons, tooltips, shortcuts
   - Add to toolbar with separator

2. **Implement action handlers**:
   - `_on_zoom_in()`
   - `_on_zoom_out()`
   - `_on_fit_view()`
   - Add defensive null checks

3. **Write unit tests**:
   - Test action creation
   - Test shortcuts and tooltips
   - Test handler triggering with mock canvas
   - Test null-safety

4. **Manual verification**:
   - Run application with stub/real canvas
   - Test all three buttons
   - Verify keyboard shortcuts
   - Check tooltip appearance

### 10.2 Coordination Points

**Before Starting**:
- [ ] Confirm T01 toolbar infrastructure complete
- [ ] Check if E02 canvas API documented
- [ ] Verify icon theme available on development system

**During Development**:
- [ ] Coordinate with E02 on canvas method signatures
- [ ] Test with both stub and real canvas
- [ ] Document any API assumptions

**After Completion**:
- [ ] Notify T04 implementer of icon names used
- [ ] Provide feedback on zoom factor to UX/PM
- [ ] Update integration tests when E02 complete

### 10.3 Follow-Up Items

**Post-MVP Enhancements**:
1. Zoom percentage display in status bar
2. Zoom preset dropdown menu
3. Configurable zoom factor in preferences
4. Zoom to selection feature

**Documentation Updates**:
1. Add view controls to user manual
2. Document keyboard shortcuts in help dialog
3. Create animated GIF demo for docs

---

## Appendix A: Code Reference

### A.1 Complete Implementation

```python
# src/ink/presentation/main_window.py

from PySide6.QtCore import Qt
from PySide6.QtGui import QAction, QIcon, QKeySequence
from PySide6.QtWidgets import QMainWindow, QToolBar

class InkMainWindow(QMainWindow):
    """Main application window for Ink schematic viewer."""

    def _setup_toolbar(self):
        """
        Create main toolbar with action buttons.

        Calls action group methods in order:
        1. File actions (T03)
        2. Edit actions (T03)
        3. View actions (T02 - this task)
        4. Search actions (T03)
        """
        # Existing setup from T01...

        # View Group (this task)
        self._add_view_actions(self._toolbar)
        self._toolbar.addSeparator()

    def _add_view_actions(self, toolbar: QToolBar):
        """
        Add view-related toolbar actions.

        Creates three buttons:
        - Zoom Out: Decrease view scale (Ctrl+-)
        - Zoom In: Increase view scale (Ctrl+=)
        - Fit View: Fit all content in viewport (Ctrl+0)

        All actions are always enabled. Handlers gracefully handle
        missing canvas by checking for None before calling methods.

        Args:
            toolbar: QToolBar instance to add actions to
        """
        # Zoom Out (conventional order: decrease first)
        zoom_out_action = QAction(
            QIcon.fromTheme("zoom-out"),
            "Zoom Out",
            self
        )
        zoom_out_action.setToolTip("Zoom out (Ctrl+-)")
        zoom_out_action.setShortcut(QKeySequence.StandardKey.ZoomOut)
        zoom_out_action.triggered.connect(self._on_zoom_out)
        toolbar.addAction(zoom_out_action)

        # Zoom In
        zoom_in_action = QAction(
            QIcon.fromTheme("zoom-in"),
            "Zoom In",
            self
        )
        zoom_in_action.setToolTip("Zoom in (Ctrl+=)")
        zoom_in_action.setShortcut(QKeySequence.StandardKey.ZoomIn)
        zoom_in_action.triggered.connect(self._on_zoom_in)
        toolbar.addAction(zoom_in_action)

        # Fit View
        fit_view_action = QAction(
            QIcon.fromTheme("zoom-fit-best"),
            "Fit View",
            self
        )
        fit_view_action.setToolTip("Fit view to content (Ctrl+0)")
        fit_view_action.setShortcut(QKeySequence("Ctrl+0"))
        fit_view_action.triggered.connect(self._on_fit_view)
        toolbar.addAction(fit_view_action)

    # Action Handlers

    def _on_zoom_in(self):
        """
        Handle zoom in action.

        Calls canvas.zoom_in() if canvas exists. Gracefully handles
        missing canvas (no-op with no error).
        """
        if hasattr(self, '_canvas') and self._canvas:
            self._canvas.zoom_in()

    def _on_zoom_out(self):
        """
        Handle zoom out action.

        Calls canvas.zoom_out() if canvas exists. Gracefully handles
        missing canvas (no-op with no error).
        """
        if hasattr(self, '_canvas') and self._canvas:
            self._canvas.zoom_out()

    def _on_fit_view(self):
        """
        Handle fit view action.

        Calls canvas.fit_view() if canvas exists. Gracefully handles
        missing canvas (no-op with no error).
        """
        if hasattr(self, '_canvas') and self._canvas:
            self._canvas.fit_view()
```

### A.2 Canvas API Contract

```python
# Expected interface from E02
# src/ink/presentation/canvas/schematic_canvas.py

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QGraphicsView

class SchematicCanvas(QGraphicsView):
    """
    Schematic canvas for rendering gate-level netlist.

    Provides view manipulation methods for zoom and fit operations.
    """

    def zoom_in(self, factor: float = 1.2):
        """
        Zoom in by scaling factor.

        Args:
            factor: Scale multiplier (default 1.2 = 20% increase)
        """
        self.scale(factor, factor)

    def zoom_out(self, factor: float = 1.2):
        """
        Zoom out by inverse scaling factor.

        Args:
            factor: Scale divisor (default 1.2 = 20% decrease)
        """
        self.scale(1.0 / factor, 1.0 / factor)

    def fit_view(self):
        """
        Fit all visible items in view.

        Centers scene bounding rect in viewport while preserving
        aspect ratio.
        """
        self.fitInView(
            self.scene().itemsBoundingRect(),
            Qt.AspectRatioMode.KeepAspectRatio
        )
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
