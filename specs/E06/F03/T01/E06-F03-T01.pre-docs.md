# E06-F03-T01: Toolbar Setup and Infrastructure - Pre-Implementation Documentation

## Document Metadata
- **Task**: E06-F03-T01 - Toolbar Setup and Infrastructure
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

E06-F03-T01 establishes the foundational infrastructure for the application toolbar. This task creates the `QToolBar` widget framework that will host action buttons for common operations (file, edit, view, search). The toolbar provides quick one-click access to frequently-used commands, significantly improving workflow efficiency during schematic exploration.

### 1.2 Core Objectives

1. **Toolbar Creation**: Initialize `QToolBar` instance and attach to main window
2. **Layout Structure**: Establish logical groupings (File, Edit, View, Search) with visual separators
3. **Configuration**: Set toolbar properties (fixed position, icon size, button style)
4. **Integration**: Provide foundation for action button additions in subsequent tasks (T02-T04)
5. **Persistence**: Enable toolbar state persistence via `QSettings` for future enhancements

### 1.3 Success Criteria

- Toolbar appears below menu bar in main window
- Toolbar is non-movable and properly configured
- Toolbar reference accessible for action additions
- No runtime errors on application launch
- Ready for integration with T02-T04 action implementations

---

## 2. Problem Context

### 2.1 User Need

Power users require rapid access to common schematic exploration operations without navigating through menu hierarchies. A toolbar provides:

- **One-click access**: Reduce mouse travel and click count
- **Visual discoverability**: Icons make features more discoverable than text menus
- **Muscle memory**: Fixed toolbar positions enable faster workflows
- **Consistency**: Standard toolbar pattern familiar across applications

### 2.2 Technical Challenge

The challenge is establishing a clean architectural foundation that:

1. **Supports incremental development**: Tasks T02-T04 will add actions independently
2. **Maintains logical grouping**: Visual separators organize related actions
3. **Enables future customization**: Object naming and structure support persistence
4. **Follows Qt best practices**: Proper toolbar lifecycle and integration patterns

### 2.3 Integration Context

This task provides the infrastructure used by:

- **T02 (View Controls)**: Adds zoom in/out/fit buttons
- **T03 (File/Edit/Search)**: Adds open, undo/redo, and search buttons
- **T04 (Icon Resources)**: Provides icons for all toolbar actions

The main window must be properly initialized before toolbar setup, requiring coordination with E06-F01 (Main Window Shell).

---

## 3. Implementation Approach

### 3.1 Architecture Design

**Component Structure**:
```
InkMainWindow
├── _setup_ui()              # Main window layout (from E06-F01)
├── _setup_toolbar()         # NEW: Toolbar initialization
│   ├── Create QToolBar
│   ├── Configure properties
│   ├── Add to window
│   └── Setup group structure
└── _toolbar                 # Instance variable for action additions
```

**Initialization Sequence**:
```python
class InkMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._setup_ui()       # 1. Window layout first
        self._setup_toolbar()  # 2. Toolbar after layout
        # Other initialization...
```

### 3.2 Key Components

#### Component 1: Toolbar Creation

```python
def _setup_toolbar(self):
    """Create main toolbar with logical groupings."""
    toolbar = QToolBar("Main Toolbar", self)
    toolbar.setObjectName("MainToolBar")
    # Configuration...
    self.addToolBar(toolbar)
    self._toolbar = toolbar
```

**Responsibilities**:
- Instantiate `QToolBar` with descriptive title
- Set object name for QSettings persistence
- Store reference for action additions

#### Component 2: Configuration

```python
# Properties to set
toolbar.setMovable(False)                          # Fixed position for MVP
toolbar.setIconSize(QSize(24, 24))                 # Standard icon size
toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)  # Icon-only buttons
```

**Rationale**:
- **Non-movable**: Simplifies MVP, reduces UI complexity
- **24x24 icons**: Industry standard, works across DPI settings
- **Icon-only**: Maximizes toolbar space, tooltips provide text

#### Component 3: Group Structure

The toolbar will have 4 logical groups separated by visual dividers:

```
┌─────────────────────────────────────────────────────────────┐
│ [Open] │ [Undo] [Redo] │ [Zoom-] [Zoom+] [Fit] │ [Search] │
└─────────────────────────────────────────────────────────────┘
  File       Edit             View                  Search
  (T03)      (T03)            (T02)                 (T03)
```

Separators added programmatically when actions are added:
```python
# In T02/T03 implementations
self._toolbar.addAction(file_action)
self._toolbar.addSeparator()  # After each group
```

### 3.3 Implementation Strategy

#### Phase 1: Core Infrastructure (This Task)

**Deliverables**:
1. `_setup_toolbar()` method in `InkMainWindow`
2. Toolbar instance created and configured
3. Toolbar attached to main window
4. Reference stored in `self._toolbar`

**Testing**:
- Unit tests verify toolbar exists and has correct properties
- Manual test confirms toolbar appears below menu bar
- No actions yet, just empty toolbar infrastructure

#### Phase 2: Action Integration (T02-T04)

Future tasks will add actions via:
```python
# Example from T02 (View Controls)
def _add_view_actions(self, toolbar: QToolBar):
    """Add view-related toolbar actions."""
    zoom_in = QAction(IconProvider.get_icon("zoom-in"), "Zoom In", self)
    # Configure action...
    toolbar.addAction(zoom_in)
```

### 3.4 File Modifications

**Primary File**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/main_window.py`

**Changes**:
```python
# Add imports
from PySide6.QtCore import QSize, Qt
from PySide6.QtWidgets import QToolBar

class InkMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._setup_ui()
        self._setup_toolbar()  # ADD THIS LINE
        # ... rest of initialization

    def _setup_toolbar(self):  # ADD THIS METHOD
        """Create main toolbar with logical groupings."""
        toolbar = QToolBar("Main Toolbar", self)
        toolbar.setObjectName("MainToolBar")
        toolbar.setMovable(False)
        toolbar.setIconSize(QSize(24, 24))
        toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)

        self.addToolBar(toolbar)
        self._toolbar = toolbar
```

---

## 4. Design Decisions

### 4.1 Decision: Fixed vs Movable Toolbar

**Options Considered**:

1. **Fixed Toolbar** (CHOSEN)
   - Pros: Simpler MVP, consistent UI, no state persistence needed
   - Cons: Less flexible for power users

2. **Movable Toolbar**
   - Pros: User customization, standard Qt feature
   - Cons: Requires state persistence, docking behavior complexity

**Decision**: Fixed toolbar for MVP, make movable in P1 enhancement

**Rationale**: MVP focuses on core functionality. Toolbar positioning customization is valuable but not essential for initial release. Can be added later without breaking changes.

### 4.2 Decision: Icon-Only vs Icon+Text

**Options Considered**:

1. **Icon-Only** (CHOSEN)
   - Pros: Compact, standard toolbar pattern, clean appearance
   - Cons: Requires good icons, relies on tooltips

2. **Icon + Text**
   - Pros: More discoverable, accessible
   - Cons: Takes more space, looks cluttered

3. **User Preference**
   - Pros: Best of both worlds
   - Cons: Complexity, state management

**Decision**: Icon-only with comprehensive tooltips

**Rationale**:
- Tooltips show action name + keyboard shortcut
- Icons are recognizable (standard theme icons)
- Maximizes viewport space for schematic canvas
- Follows industry convention (Qt Creator, VS Code, etc.)

### 4.3 Decision: Toolbar Placement

**Options Considered**:

1. **Top Toolbar Area** (CHOSEN)
   - Pros: Standard placement, below menu bar, immediately visible
   - Cons: None significant

2. **Side Toolbar**
   - Pros: More vertical space for canvas
   - Cons: Unconventional for these actions

**Decision**: Top toolbar area (Qt default)

**Rationale**: Users expect toolbars above the canvas. Side toolbars better suited for tool palettes (future feature).

### 4.4 Decision: Object Naming Convention

**Decision**: Use `"MainToolBar"` as object name

**Rationale**:
- PascalCase matches Qt naming conventions
- "Main" distinguishes from potential future toolbars
- Used by `QSettings` for state persistence
- Enables `findChild(QToolBar, "MainToolBar")` in tests

---

## 5. Dependencies and Integration

### 5.1 Upstream Dependencies

**E06-F01: Main Window Shell** (REQUIRED)

- Provides `InkMainWindow` class
- Establishes window layout and central widget
- Must be called before toolbar setup

**Integration Point**:
```python
# E06-F01 provides:
class InkMainWindow(QMainWindow):
    def _setup_ui(self):
        # Window layout, central widget, etc.
        pass

# E06-F03-T01 extends:
    def _setup_toolbar(self):
        # Toolbar setup
        pass
```

### 5.2 Downstream Dependencies

**E06-F03-T02: View Control Tools**

- Adds zoom in/out/fit actions to toolbar
- Requires `self._toolbar` reference
- Adds separator after view group

**E06-F03-T03: File, Edit and Search Tools**

- Adds open, undo/redo, search actions
- Requires `self._toolbar` reference
- Adds separators after file/edit/search groups

**E06-F03-T04: Icon Resources**

- Provides fallback icons for toolbar buttons
- Independent of toolbar infrastructure
- Icons loaded when actions created (T02-T03)

### 5.3 External Dependencies

**PySide6 Components**:
- `QToolBar`: Main toolbar widget
- `QSize`: For icon size specification
- `Qt.ToolButtonStyle`: Button display mode enum
- `QMainWindow.addToolBar()`: Toolbar attachment

**Version**: PySide6 6.5+ (Qt 6.5+)

### 5.4 Integration Sequence

```
1. E06-F01 creates main window → InkMainWindow class exists
2. E06-F03-T01 adds toolbar infrastructure → self._toolbar available
3. E06-F03-T02 adds view actions → toolbar has zoom buttons
4. E06-F03-T03 adds file/edit/search actions → toolbar complete
5. E06-F03-T04 provides icon fallbacks → icons always load
```

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/unit/presentation/test_main_window.py`

**Test Cases**:

```python
import pytest
from PySide6.QtCore import QSize, Qt
from PySide6.QtWidgets import QToolBar
from ink.presentation.main_window import InkMainWindow

class TestToolbarInfrastructure:
    """Test toolbar setup and configuration."""

    @pytest.fixture
    def main_window(self, qtbot):
        """Create main window instance."""
        window = InkMainWindow()
        qtbot.addWidget(window)
        return window

    def test_toolbar_created(self, main_window):
        """Test toolbar is created and attached to main window."""
        toolbar = main_window.findChild(QToolBar, "MainToolBar")
        assert toolbar is not None
        assert toolbar.windowTitle() == "Main Toolbar"

    def test_toolbar_configuration(self, main_window):
        """Test toolbar has correct configuration properties."""
        toolbar = main_window.findChild(QToolBar, "MainToolBar")
        assert not toolbar.isMovable()
        assert toolbar.iconSize() == QSize(24, 24)
        assert toolbar.toolButtonStyle() == Qt.ToolButtonStyle.ToolButtonIconOnly

    def test_toolbar_position(self, main_window):
        """Test toolbar is in top toolbar area."""
        toolbar = main_window.findChild(QToolBar, "MainToolBar")
        area = main_window.toolBarArea(toolbar)
        assert area == Qt.ToolBarArea.TopToolBarArea

    def test_toolbar_reference_stored(self, main_window):
        """Test toolbar reference accessible via instance variable."""
        assert hasattr(main_window, '_toolbar')
        assert isinstance(main_window._toolbar, QToolBar)
        assert main_window._toolbar.objectName() == "MainToolBar"

    def test_toolbar_initially_empty(self, main_window):
        """Test toolbar has no actions initially (infrastructure only)."""
        toolbar = main_window._toolbar
        # No actions yet, just infrastructure
        actions = [a for a in toolbar.actions() if not a.isSeparator()]
        assert len(actions) == 0
```

**Coverage Target**: 100% of `_setup_toolbar()` method

### 6.2 Integration Tests

**Test File**: `/home/joohan/dev/project-ink/ink/tests/integration/ui/test_main_window_toolbar.py`

```python
def test_toolbar_visible_on_launch(qtbot):
    """Test toolbar appears when main window displayed."""
    window = InkMainWindow()
    qtbot.addWidget(window)
    window.show()

    toolbar = window.findChild(QToolBar, "MainToolBar")
    assert toolbar.isVisible()

def test_toolbar_persists_across_resize(qtbot):
    """Test toolbar remains stable during window resize."""
    window = InkMainWindow()
    qtbot.addWidget(window)
    window.show()

    toolbar = window.findChild(QToolBar, "MainToolBar")
    initial_height = toolbar.height()

    window.resize(1200, 800)
    qtbot.wait(100)

    assert toolbar.height() == initial_height
    assert toolbar.isVisible()
```

### 6.3 Manual Testing

**Test Plan**:

1. **Visual Inspection**:
   - Launch application
   - Verify toolbar appears below menu bar
   - Confirm toolbar spans full window width
   - Check toolbar is empty (no buttons yet)

2. **Configuration Validation**:
   - Attempt to drag toolbar → should not move
   - Verify toolbar has consistent height
   - Check alignment with window edges

3. **Stability Testing**:
   - Resize window → toolbar should remain visible
   - Minimize/maximize window → no errors
   - Multiple windows → each has own toolbar

**Expected Results**:
- Toolbar visible and non-movable
- No visual glitches or alignment issues
- No console errors or warnings

---

## 7. Risks and Mitigation

### 7.1 Technical Risks

#### Risk 1: Toolbar Lifecycle Management

**Risk**: Toolbar not properly cleaned up on window close

**Impact**: Low (memory leak in long-running sessions)

**Probability**: Low (Qt handles child widget cleanup)

**Mitigation**:
- Qt automatically deletes child widgets when parent destroyed
- Verify with memory profiling in integration tests
- If needed, explicit cleanup in `closeEvent()`

#### Risk 2: Coordinate with Main Window Initialization

**Risk**: Toolbar setup called before main window layout ready

**Impact**: Medium (toolbar attached to wrong area or missing)

**Probability**: Low (clear init sequence)

**Mitigation**:
- Call `_setup_toolbar()` after `_setup_ui()`
- Add assertion check in toolbar setup
- Document initialization order in code comments

```python
def _setup_toolbar(self):
    """Create main toolbar (call after _setup_ui)."""
    assert hasattr(self, 'centralWidget'), "Call _setup_ui() first"
    # ... setup code
```

#### Risk 3: Qt Theme Compatibility

**Risk**: Toolbar appearance differs across platforms/themes

**Impact**: Low (cosmetic, doesn't affect functionality)

**Probability**: Medium (Qt themes vary)

**Mitigation**:
- Use Qt standard properties (avoid custom styling for MVP)
- Test on multiple platforms (Linux with different themes)
- Document known theme issues if discovered
- Future: custom stylesheet for consistent appearance

### 7.2 Integration Risks

#### Risk 4: Action Addition Pattern Not Clear

**Risk**: T02-T04 implementers unsure how to add actions

**Impact**: Medium (delays downstream tasks)

**Probability**: Low (clear code structure)

**Mitigation**:
- Document action addition pattern in code comments
- Provide example stub method
- Reference this pre-docs in T02-T04 specs

```python
def _setup_toolbar(self):
    """
    Create main toolbar with logical groupings.

    Future tasks add actions via methods like:
        self._add_file_actions(self._toolbar)
        self._toolbar.addSeparator()
        self._add_view_actions(self._toolbar)
    """
    # ... setup code
```

#### Risk 5: Toolbar Reference Name Collision

**Risk**: `self._toolbar` conflicts with existing attribute

**Impact**: High (runtime errors)

**Probability**: Very Low (controlled codebase)

**Mitigation**:
- Check main window class for existing `_toolbar` attribute
- Use more specific name if needed (`_main_toolbar`)
- Add type hint for clarity

```python
class InkMainWindow(QMainWindow):
    _toolbar: QToolBar  # Type hint documents attribute
```

---

## 8. Implementation Notes

### 8.1 Code Structure

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/presentation/main_window.py`

**Method Placement**:
```python
class InkMainWindow(QMainWindow):
    def __init__(self):
        # Initialization

    def _setup_ui(self):
        # Window layout (from E06-F01)

    def _setup_toolbar(self):  # ADD HERE
        # Toolbar setup

    # Other methods...
```

### 8.2 Configuration Best Practices

**Icon Size Selection**:
- 16x16: Too small, hard to see
- 24x24: Standard, good visibility (CHOSEN)
- 32x32: Too large, wastes space

**Toolbar Style Options**:
- `ToolButtonIconOnly`: Clean, compact (CHOSEN)
- `ToolButtonTextOnly`: No icons, text-heavy
- `ToolButtonTextBesideIcon`: Wide, not recommended
- `ToolButtonTextUnderIcon`: Vertical space issue

### 8.3 Future Enhancements

**P1 Features** (not in MVP):
1. **Movable Toolbar**: `setMovable(True)` + state persistence
2. **Multiple Toolbars**: Separate view/edit toolbars
3. **Toolbar Customization**: User-configurable button layout
4. **Toolbar Context Menu**: Right-click to hide/show
5. **Icon Size Options**: User preference for 16/24/32px

**Implementation Path**:
```python
# Future: Load toolbar state from QSettings
def _setup_toolbar(self):
    toolbar = QToolBar("Main Toolbar", self)
    # ... configuration

    # P1: Restore saved state
    if settings.contains("MainToolBar/geometry"):
        toolbar.restoreGeometry(settings.value("MainToolBar/geometry"))
```

### 8.4 Naming Conventions

**Follow Project Standards**:
- Private methods: `_setup_toolbar()` (underscore prefix)
- Instance variables: `self._toolbar` (underscore prefix)
- Object names: `"MainToolBar"` (PascalCase for Qt)
- Window title: `"Main Toolbar"` (Human-readable)

---

## 9. Acceptance Checklist

### 9.1 Implementation Complete

- [ ] `_setup_toolbar()` method added to `InkMainWindow`
- [ ] `QToolBar` instance created with name "Main Toolbar"
- [ ] Object name set to "MainToolBar"
- [ ] Toolbar configured as non-movable
- [ ] Icon size set to 24x24 pixels
- [ ] Button style set to icon-only
- [ ] Toolbar attached to top toolbar area
- [ ] Toolbar reference stored in `self._toolbar`

### 9.2 Testing Complete

- [ ] Unit tests pass with 100% method coverage
- [ ] Integration tests verify toolbar visibility
- [ ] Manual testing confirms visual appearance
- [ ] No console warnings or errors
- [ ] Memory profiling shows no leaks

### 9.3 Code Quality

- [ ] Type hints added for toolbar reference
- [ ] Docstring explains initialization order
- [ ] Code follows PEP 8 style guidelines
- [ ] Comments document future action addition pattern
- [ ] No hardcoded magic numbers (use constants)

### 9.4 Documentation

- [ ] Inline comments explain configuration choices
- [ ] Docstring references T02-T04 for action additions
- [ ] Integration points documented
- [ ] Future enhancements noted in comments

### 9.5 Ready for Integration

- [ ] T02 can add view actions via `self._toolbar`
- [ ] T03 can add file/edit/search actions
- [ ] T04 icons will work when actions added
- [ ] No breaking changes to main window API

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Implement `_setup_toolbar()` method**:
   - Add to main window initialization
   - Configure toolbar properties
   - Store toolbar reference

2. **Write unit tests**:
   - Create test fixture for main window
   - Test toolbar creation and configuration
   - Verify toolbar placement

3. **Manual verification**:
   - Run application
   - Confirm toolbar appears correctly
   - Check for runtime errors

### 10.2 Coordination with Other Tasks

**Before Starting**:
- [ ] Confirm E06-F01 (Main Window Shell) is complete
- [ ] Verify `InkMainWindow` class exists and is functional
- [ ] Check `_setup_ui()` method is implemented

**After Completion**:
- [ ] Notify T02 implementer that toolbar ready for view actions
- [ ] Notify T03 implementer that toolbar ready for file/edit/search actions
- [ ] Provide code example of how to add actions

### 10.3 Follow-Up Items

**Post-MVP Enhancements**:
1. Toolbar customization dialog
2. State persistence via QSettings
3. Multiple toolbar support
4. Theme-aware styling

**Documentation**:
1. Update architecture docs with toolbar structure
2. Add toolbar usage examples to developer guide
3. Document keyboard shortcut conventions

---

## Appendix A: Code Reference

### A.1 Complete Implementation

```python
# src/ink/presentation/main_window.py

from PySide6.QtCore import QSize, Qt
from PySide6.QtWidgets import QMainWindow, QToolBar

class InkMainWindow(QMainWindow):
    """Main application window for Ink schematic viewer."""

    _toolbar: QToolBar  # Main toolbar instance

    def __init__(self):
        """Initialize main window with UI components."""
        super().__init__()
        self._setup_ui()        # Window layout first
        self._setup_toolbar()   # Toolbar after layout
        # Other initialization...

    def _setup_ui(self):
        """Set up main window layout (from E06-F01)."""
        # Central widget, menu bar, etc.
        pass

    def _setup_toolbar(self):
        """
        Create main toolbar with logical groupings.

        The toolbar provides quick access to common actions:
        - File group: Open (added in T03)
        - Edit group: Undo, Redo (added in T03)
        - View group: Zoom in/out, Fit view (added in T02)
        - Search group: Search (added in T03)

        Future tasks add actions via methods like:
            self._add_file_actions(self._toolbar)
            self._toolbar.addSeparator()
            self._add_view_actions(self._toolbar)

        Note: Call after _setup_ui() to ensure window layout ready.
        """
        # Create toolbar
        toolbar = QToolBar("Main Toolbar", self)
        toolbar.setObjectName("MainToolBar")  # For QSettings persistence

        # Configure properties
        toolbar.setMovable(False)  # Fixed position for MVP
        toolbar.setIconSize(QSize(24, 24))  # Standard 24x24px icons
        toolbar.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)

        # Add to main window (top toolbar area)
        self.addToolBar(toolbar)

        # Store reference for action additions in T02-T04
        self._toolbar = toolbar
```

### A.2 Test Reference

```python
# tests/unit/presentation/test_main_window.py

import pytest
from PySide6.QtCore import QSize, Qt
from PySide6.QtWidgets import QToolBar
from ink.presentation.main_window import InkMainWindow

@pytest.fixture
def main_window(qtbot):
    """Create main window instance for testing."""
    window = InkMainWindow()
    qtbot.addWidget(window)
    return window

class TestToolbarSetup:
    """Test toolbar infrastructure setup."""

    def test_toolbar_exists(self, main_window):
        """Toolbar is created and attached to window."""
        toolbar = main_window.findChild(QToolBar, "MainToolBar")
        assert toolbar is not None

    def test_toolbar_properties(self, main_window):
        """Toolbar has correct configuration."""
        toolbar = main_window._toolbar
        assert toolbar.windowTitle() == "Main Toolbar"
        assert toolbar.objectName() == "MainToolBar"
        assert not toolbar.isMovable()
        assert toolbar.iconSize() == QSize(24, 24)
        assert toolbar.toolButtonStyle() == Qt.ToolButtonStyle.ToolButtonIconOnly

    def test_toolbar_placement(self, main_window):
        """Toolbar is in top toolbar area."""
        toolbar = main_window._toolbar
        area = main_window.toolBarArea(toolbar)
        assert area == Qt.ToolBarArea.TopToolBarArea
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
