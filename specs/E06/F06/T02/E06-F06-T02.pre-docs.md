# Pre-Implementation Documentation: E06-F06-T02 - Window Geometry Persistence

**Task ID**: E06-F06-T02
**Generated**: 2025-12-26
**Status**: Pre-Implementation

---

## 1. Overview and Problem Context

### 1.1 Problem Statement

Users invest time positioning and sizing their workspace (main window, dock panels) to suit their workflow. Without geometry persistence, this configuration is lost on every application restart, forcing users to manually recreate their preferred layout each session. This creates friction and reduces productivity.

### 1.2 Current State

- AppSettings infrastructure exists (from T01)
- Main window has no geometry persistence
- Dock widgets (hierarchy panel, property panel, search panel) are created but not saved
- Users must resize and reposition every session

### 1.3 Desired State

- Window size and position automatically saved on close
- Window maximized/minimized state preserved
- Dock widget layout (positions, sizes, floating state, visibility) saved
- All geometry restored on startup
- First run uses sensible defaults (1280x800, centered)
- Invalid/corrupt geometry data handled gracefully

---

## 2. Implementation Approach

### 2.1 High-Level Strategy

1. **Extend AppSettings** with window-specific methods (`save_window_geometry`, `load_window_geometry`, etc.)
2. **Modify InkMainWindow.__init__()** to restore geometry after UI setup
3. **Override closeEvent()** to save geometry before shutdown
4. **Handle first run** with default size and centering logic
5. **Test restoration** across multiple scenarios

### 2.2 Architecture Decisions

**Location**:
- AppSettings extensions: `src/ink/infrastructure/persistence/app_settings.py`
- Window integration: `src/ink/presentation/main_window.py`

**Rationale**:
- AppSettings in infrastructure layer (Qt adapter)
- Main window in presentation layer (uses infrastructure services)
- Dependency flows inward: Presentation → Infrastructure

**Design Pattern**: Template Method
- Base behavior in `closeEvent()`
- Save logic factored into `_save_geometry()`
- Restore logic in `_restore_geometry()`

### 2.3 Key Components

```
Window Geometry Persistence
├── AppSettings Extensions
│   ├── save_window_geometry(QByteArray)
│   ├── load_window_geometry() -> QByteArray | None
│   ├── save_window_state(QByteArray)
│   ├── load_window_state() -> QByteArray | None
│   ├── has_window_geometry() -> bool
│   └── has_window_state() -> bool
├── InkMainWindow Integration
│   ├── _restore_geometry()
│   │   ├── Load and apply geometry
│   │   ├── Load and apply state
│   │   └── Fallback to defaults
│   ├── _save_geometry()
│   │   ├── Save current geometry
│   │   ├── Save current state
│   │   └── Force sync to disk
│   ├── _center_on_screen()
│   └── closeEvent() override
└── Default Handling
    ├── Default size (1280x800)
    └── Center on primary screen
```

---

## 3. Key Design Decisions

### 3.1 Decision: When to restore geometry

**Options**:
- A) In `__init__()` before creating widgets
- B) In `__init__()` after creating all widgets
- C) In `showEvent()` on first show
- D) Separate `restore()` method called by main application

**Chosen**: B (In `__init__()` after widget creation)

**Rationale**:
- Qt requires all dock widgets to exist before `restoreState()` can position them
- Early restoration in `__init__()` ensures window appears in correct position from first frame
- No flicker or repositioning visible to user
- Simple, self-contained initialization

**Trade-offs**:
- Must ensure all widgets created first (strict ordering requirement)
- Cannot restore state if widget creation fails

### 3.2 Decision: When to save geometry

**Options**:
- A) On `closeEvent()` only
- B) Periodically (timer-based)
- C) On every resize/move event
- D) On both `closeEvent()` and application `aboutToQuit()` signal

**Chosen**: A (closeEvent() only)

**Rationale**:
- Simplest implementation
- Guaranteed to be called on normal close
- Avoids performance overhead of frequent saves
- Qt handles crash scenarios with QSettings atomic writes

**Trade-offs**:
- If application crashes, last session's geometry may be lost
- Acceptable for MVP (crashes should be rare)

### 3.3 Decision: How to handle first run

**Options**:
- A) Use Qt defaults (may be very small)
- B) Maximize window
- C) Fixed size, centered on screen
- D) Size based on screen resolution (e.g., 80% of screen)

**Chosen**: C (1280x800, centered)

**Rationale**:
- Predictable, professional appearance
- Works well on common screen sizes (1080p, 1440p, 4K)
- Not overwhelming on smaller screens
- Matches industry standards for desktop applications

**Trade-offs**:
- May not be optimal for very large or very small screens
- Future enhancement: remember last size per user

### 3.4 Decision: Geometry data format

**Options**:
- A) Qt's `saveGeometry()` / `saveState()` (QByteArray)
- B) Custom JSON with explicit fields
- C) Separate keys for each geometry property

**Chosen**: A (Qt's binary format)

**Rationale**:
- Native Qt format handles all edge cases (multi-monitor, screen resolution changes, etc.)
- Single method call (simple API)
- Forward/backward compatibility built-in
- Handles complex state (dock widget positions, toolbar locations)

**Trade-offs**:
- Not human-readable
- Opaque binary format
- Acceptable: users don't need to edit geometry manually

### 3.5 Decision: Invalid geometry handling

**Options**:
- A) Show error dialog and exit
- B) Attempt to restore, fall back to defaults on failure
- C) Always ignore saved geometry if any part is invalid
- D) Validate geometry before applying

**Chosen**: B (Attempt restore, silent fallback)

**Rationale**:
- `restoreGeometry()` returns bool indicating success
- Qt handles invalid data gracefully (returns false)
- Silent fallback provides best user experience
- No data corruption risk

---

## 4. Dependencies and Integration Points

### 4.1 External Dependencies

- **PySide6.QtWidgets.QMainWindow**: `saveGeometry()`, `restoreGeometry()`, `saveState()`, `restoreState()`
- **PySide6.QtGui.QGuiApplication**: `primaryScreen()` for centering logic
- **PySide6.QtCore.QByteArray**: Geometry/state data container
- **PySide6.QtCore.QCloseEvent**: Window close event handling

### 4.2 Internal Dependencies

**Upstream**:
- E06-F06-T01 (QSettings Infrastructure) - REQUIRED
  - Must be implemented first
  - Provides `AppSettings` class to extend

**Downstream**: None (self-contained feature)

**Parallel**:
- E06-F06-T03 (Recent Files) - Independent, can be implemented in parallel

### 4.3 Integration Points

**AppSettings Extension**:
```python
class AppSettings:
    # New methods for T02
    def save_window_geometry(self, geometry: QByteArray): ...
    def load_window_geometry(self) -> QByteArray | None: ...
    def save_window_state(self, state: QByteArray): ...
    def load_window_state(self) -> QByteArray | None: ...
```

**Main Window Integration**:
```python
class InkMainWindow(QMainWindow):
    def __init__(self, app_settings: AppSettings):
        super().__init__()
        self.app_settings = app_settings

        # Create all UI components FIRST
        self._setup_window()
        self._setup_central_widget()
        self._setup_dock_widgets()  # MUST exist before restoreState()
        self._setup_menus()

        # THEN restore geometry
        self._restore_geometry()
```

**Dependency Injection**:
- AppSettings instance passed to InkMainWindow constructor
- No global state or singletons

---

## 5. Testing Strategy

### 5.1 Automated Testing

**Unit Tests** (AppSettings methods):
```python
def test_save_load_window_geometry():
    """Test QByteArray geometry save/load."""

def test_save_load_window_state():
    """Test QByteArray state save/load."""

def test_has_window_geometry():
    """Test existence checks."""

def test_geometry_returns_none_when_missing():
    """Test default behavior."""
```

**Integration Tests** (Main window):
```python
def test_window_geometry_restored(qtbot):
    """Test window size/position restored."""

def test_dock_state_restored(qtbot):
    """Test dock widget layout restored."""

def test_first_run_defaults(qtbot):
    """Test default size when no saved geometry."""

def test_invalid_geometry_ignored(qtbot):
    """Test fallback to defaults on invalid data."""

def test_geometry_saved_on_close(qtbot):
    """Test closeEvent() saves geometry."""
```

### 5.2 Manual Testing Scenarios

**Basic Persistence**:
1. Resize window → Close → Reopen → Verify size matches
2. Move window → Close → Reopen → Verify position matches
3. Maximize window → Close → Reopen → Verify maximized state

**Dock Widget State**:
1. Resize hierarchy panel → Close → Reopen → Verify panel width
2. Float property panel → Close → Reopen → Verify floating state
3. Hide search panel → Close → Reopen → Verify hidden state
4. Rearrange panels (move to different edges) → Close → Reopen → Verify arrangement

**Edge Cases**:
1. First run → Verify 1280x800 and centered
2. Delete settings file → Reopen → Verify defaults
3. Change screen resolution → Reopen → Verify window fits on screen
4. Move to secondary monitor → Close → Reopen → Verify position restored

**Multi-Monitor** (if available):
1. Move to secondary screen → Close → Reopen → Verify on same screen
2. Disconnect secondary monitor → Reopen → Verify window on primary screen

### 5.3 Test Data

**Valid Geometry**:
```python
# Create window, set known geometry
window.resize(800, 600)
window.move(100, 100)
expected_geometry = window.saveGeometry()
```

**Invalid Data**:
```python
# Test with corrupted data
settings.set_value(KEY_WINDOW_GEOMETRY, "not a QByteArray")
settings.set_value(KEY_WINDOW_GEOMETRY, b"corrupted binary")
settings.set_value(KEY_WINDOW_GEOMETRY, QByteArray())  # Empty
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| **Geometry restored before widgets created** | High | Strict ordering in `__init__()` + code comments |
| **Window off-screen after monitor config change** | Medium | Qt handles automatically (moves to visible area) |
| **Corrupt geometry data** | Low | `restoreGeometry()` returns false on failure; fallback to defaults |
| **Dock widgets not restoring** | Medium | Ensure all dock widgets have `objectName()` set |
| **First run on small screen** | Low | 1280x800 fits on 1366x768 (common laptop size) |

### 6.2 Implementation Challenges

**Challenge**: Ensuring correct restoration order
- **Solution**: Document order in code comments; add assertion to verify all docks exist

**Challenge**: Testing window geometry programmatically
- **Solution**: Use `qtbot` fixture; some tests may need to be manual (window manager dependent)

**Challenge**: Multi-monitor testing
- **Solution**: Manual testing on multi-monitor setups; Qt handles edge cases

**Challenge**: Dock widget naming
- **Solution**: Ensure all dock widgets have unique `objectName()` set:
  ```python
  self.hierarchy_panel.setObjectName("HierarchyPanel")
  self.property_panel.setObjectName("PropertyPanel")
  ```

### 6.3 Performance Considerations

- **Startup Time**: Geometry restoration is fast (<1ms)
- **Shutdown Time**: Saving geometry is negligible (<1ms)
- **Memory**: QByteArray typically <1KB per window
- **Disk Space**: Settings file typically <10KB total

### 6.4 Platform Considerations

**Linux**:
- X11 vs Wayland: Qt handles differences
- Window managers may override position (tiling WMs)
- Test on common DEs (GNOME, KDE, XFCE)

**Windows**:
- Registry storage (automatic)
- DPI scaling handled by Qt

**macOS**:
- plist storage (automatic)
- Retina displays handled by Qt

---

## 7. Pre-Implementation Checklist

- [ ] Verify T01 (QSettings Infrastructure) is complete
- [ ] Review Qt documentation for `saveGeometry()` / `restoreGeometry()`
- [ ] Review Qt documentation for `saveState()` / `restoreState()`
- [ ] Identify all dock widgets that need state persistence
- [ ] Plan test scenarios for manual testing
- [ ] Set up qtbot fixtures for automated UI tests
- [ ] Document restoration order in code comments
- [ ] Prepare default geometry constants

---

## 8. Open Questions

1. **Should we validate geometry data before restoring?**
   - Decision: No, let Qt handle validation (returns bool on failure)

2. **Should we persist full-screen state separately?**
   - Decision: No, `saveGeometry()` handles this automatically

3. **Should we have separate defaults for different screen sizes?**
   - Decision: No for MVP; use fixed 1280x800 for simplicity

4. **Should we save on application aboutToQuit signal as well?**
   - Decision: No, `closeEvent()` sufficient for MVP

5. **Should we version the geometry data format?**
   - Decision: Qt handles versioning internally; not needed for MVP

6. **What if dock widget set changes in future version?**
   - Decision: Qt ignores unknown widgets in saved state; handles gracefully

---

## 9. Success Criteria

### 9.1 Functional Success

- [ ] Window size persists across restarts
- [ ] Window position persists across restarts
- [ ] Window maximized state persists across restarts
- [ ] All dock widget positions persist across restarts
- [ ] All dock widget sizes persist across restarts
- [ ] All dock widget floating states persist across restarts
- [ ] All dock widget visibility states persist across restarts
- [ ] First run shows 1280x800 window, centered on screen
- [ ] Invalid geometry data falls back to defaults silently

### 9.2 Quality Success

- [ ] All unit tests pass (AppSettings methods)
- [ ] All integration tests pass (main window)
- [ ] Manual testing scenarios completed
- [ ] No console warnings or errors during save/restore
- [ ] Code documented with clear comments on ordering
- [ ] Type hints for all new methods

### 9.3 User Experience Success

- [ ] Window appears in correct position on first frame (no flicker)
- [ ] No visible delay during startup
- [ ] Geometry saves silently on close (no dialogs)
- [ ] First run experience is professional (centered, good size)

---

## 10. Post-Implementation Notes

_This section will be filled after implementation with lessons learned, actual challenges encountered, and deviations from this plan._

---

## Appendix A: Code Skeleton

```python
# src/ink/infrastructure/persistence/app_settings.py

class AppSettings:
    # ... existing code from T01 ...

    def save_window_geometry(self, geometry: QByteArray):
        """Save window geometry."""
        self.set_value(self.KEY_WINDOW_GEOMETRY, geometry)

    def load_window_geometry(self) -> QByteArray | None:
        """Load window geometry."""
        # TODO: Implement with type checking
        pass

    def save_window_state(self, state: QByteArray):
        """Save window state (dock widget layout)."""
        # TODO: Implement
        pass

    def load_window_state(self) -> QByteArray | None:
        """Load window state (dock widget layout)."""
        # TODO: Implement with type checking
        pass
```

```python
# src/ink/presentation/main_window.py

class InkMainWindow(QMainWindow):
    DEFAULT_WIDTH = 1280
    DEFAULT_HEIGHT = 800

    def __init__(self, app_settings: AppSettings):
        super().__init__()
        self.app_settings = app_settings

        # CRITICAL: Create all widgets BEFORE restoring geometry
        self._setup_window()
        self._setup_central_widget()
        self._setup_dock_widgets()  # Must exist for restoreState()
        self._setup_menus()
        self._setup_toolbar()

        # THEN restore geometry
        self._restore_geometry()

    def _restore_geometry(self):
        """Restore window geometry and state from settings."""
        # TODO: Implement restoration with fallback
        pass

    def _center_on_screen(self):
        """Center window on primary screen."""
        # TODO: Implement centering logic
        pass

    def closeEvent(self, event):
        """Handle application close - save geometry."""
        self._save_geometry()
        event.accept()

    def _save_geometry(self):
        """Save window geometry and state to settings."""
        # TODO: Implement save + sync
        pass
```

---

## Appendix B: Dock Widget Setup

```python
def _setup_dock_widgets(self):
    """Create and configure dock widgets.

    IMPORTANT: All dock widgets must have unique objectName()
    set for saveState()/restoreState() to work correctly.
    """
    # Hierarchy panel (left)
    self.hierarchy_panel = HierarchyPanel()
    self.hierarchy_panel.setObjectName("HierarchyPanel")  # Required!
    hierarchy_dock = QDockWidget("Hierarchy", self)
    hierarchy_dock.setObjectName("HierarchyDock")
    hierarchy_dock.setWidget(self.hierarchy_panel)
    self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, hierarchy_dock)

    # Property panel (right)
    self.property_panel = PropertyPanel()
    self.property_panel.setObjectName("PropertyPanel")  # Required!
    property_dock = QDockWidget("Properties", self)
    property_dock.setObjectName("PropertyDock")
    property_dock.setWidget(self.property_panel)
    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, property_dock)

    # Search panel (bottom)
    self.search_panel = SearchPanel()
    self.search_panel.setObjectName("SearchPanel")  # Required!
    search_dock = QDockWidget("Search", self)
    search_dock.setObjectName("SearchDock")
    search_dock.setWidget(self.search_panel)
    self.addDockWidget(Qt.DockWidgetArea.BottomDockWidgetArea, search_dock)
```

---

## Appendix C: Test Outline

```python
# tests/integration/persistence/test_window_geometry.py

class TestWindowGeometry:
    def test_geometry_saved_and_restored(self, qtbot, app_settings):
        """Test complete save/restore cycle."""

    def test_dock_state_saved_and_restored(self, qtbot, app_settings):
        """Test dock widget layout persistence."""

    def test_first_run_uses_defaults(self, qtbot, app_settings):
        """Test first run shows centered 1280x800 window."""

    def test_maximized_state_persists(self, qtbot, app_settings):
        """Test maximized window state."""

    def test_invalid_geometry_falls_back(self, qtbot, app_settings):
        """Test graceful handling of corrupt data."""

    def test_missing_geometry_uses_defaults(self, qtbot, app_settings):
        """Test behavior when no saved geometry exists."""
```
