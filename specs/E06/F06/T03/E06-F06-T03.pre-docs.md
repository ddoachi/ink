# Pre-Implementation Documentation: E06-F06-T03 - Recent Files Management

**Task ID**: E06-F06-T03
**Generated**: 2025-12-26
**Status**: Pre-Implementation

---

## 1. Overview and Problem Context

### 1.1 Problem Statement

Users frequently work with the same netlist files during development, testing, and debugging. Without a recent files list, users must navigate through potentially deep directory structures repeatedly to open the same files. This workflow friction wastes time and breaks concentration.

### 1.2 Current State

- AppSettings infrastructure exists (from T01)
- File menu exists with "Open" dialog
- No history of recently opened files
- Users must use file browser for every file open operation
- No quick access to previously viewed netlists

### 1.3 Desired State

- Maintain list of up to 10 most recently opened files
- Display recent files in File > Open Recent submenu
- Numbered menu items (1-9) with keyboard shortcuts
- Clicking recent file opens it immediately
- Auto-remove files that no longer exist
- "Clear Recent Files" functionality
- Recent files list persists across application sessions
- Most recently opened file always at top of list

---

## 2. Implementation Approach

### 2.1 High-Level Strategy

1. **Extend AppSettings** with recent files management methods
2. **Create dynamic submenu** in File menu for recent files
3. **Update list on file open** (any method: dialog, drag-drop, CLI)
4. **Auto-filter deleted files** on list retrieval
5. **Add clear functionality** with confirmation
6. **Test persistence** and edge cases

### 2.2 Architecture Decisions

**Location**:
- AppSettings extensions: `src/ink/infrastructure/persistence/app_settings.py`
- Menu integration: `src/ink/presentation/main_window.py`

**Rationale**:
- AppSettings manages persistence (infrastructure layer)
- Main window manages UI presentation (presentation layer)
- Clear separation of concerns

**Design Pattern**: Observer pattern (implicit)
- File open events trigger list update
- Menu updates reactively on list change
- No tight coupling between file operations and menu

### 2.3 Key Components

```
Recent Files Management
├── AppSettings Extensions
│   ├── add_recent_file(file_path)
│   │   ├── Remove if exists (move to front)
│   │   ├── Insert at front
│   │   └── Trim to max size
│   ├── get_recent_files() -> List[str]
│   │   ├── Filter non-existent files
│   │   └── Auto-update if filtered
│   ├── clear_recent_files()
│   ├── get_max_recent_files() -> int
│   └── set_max_recent_files(count)
├── Main Window Integration
│   ├── _setup_menus()
│   │   └── Create "Open Recent" submenu
│   ├── _update_recent_files_menu()
│   │   ├── Clear menu
│   │   ├── Add action per file
│   │   ├── Add separator
│   │   └── Add "Clear Recent Files"
│   ├── _format_recent_file_name(path, index)
│   ├── _on_open_file_dialog()
│   ├── _on_open_recent_file(file_path)
│   ├── _open_file(file_path)
│   │   ├── Load netlist
│   │   ├── Add to recent files
│   │   └── Update menu
│   └── _on_clear_recent_files()
└── Menu Structure
    ├── Numbered items (1-9 with shortcuts)
    ├── Plain numbers (10+)
    └── Separator + Clear action
```

---

## 3. Key Design Decisions

### 3.1 Decision: Where to store recent files list

**Options**:
- A) In QSettings as string list
- B) In separate JSON file
- C) In SQLite database
- D) In QSettings with custom serialization

**Chosen**: A (QSettings as string list)

**Rationale**:
- Consistent with other settings (geometry, state)
- QSettings handles list type natively
- No additional files to manage
- Atomic updates with other settings

**Trade-offs**:
- Limited to string paths (sufficient for this use case)
- Size limited by QSettings (not an issue for 10 files)

### 3.2 Decision: When to update recent files list

**Options**:
- A) Only when file opened successfully
- B) When file dialog is opened (intent to open)
- C) When file is selected in dialog (before parse)
- D) After successful parse and display

**Chosen**: D (After successful parse and display)

**Rationale**:
- Only files that actually opened successfully appear in list
- Prevents invalid/corrupt files from cluttering list
- User sees only files they can reopen successfully

**Trade-offs**:
- Parse errors mean file won't be in recent list
- Acceptable: user shouldn't quick-open files that fail to parse

### 3.3 Decision: How to handle non-existent files

**Options**:
- A) Leave in list, show error on click
- B) Check existence on every menu open, remove dead entries
- C) Check existence in `get_recent_files()`, auto-remove
- D) Periodic background cleanup task

**Chosen**: C (Auto-remove in `get_recent_files()`)

**Rationale**:
- Lazy cleanup (only when accessed)
- Silent removal (no user action needed)
- Settings auto-updated if files removed
- Simple implementation

**Trade-offs**:
- Small performance cost on each get (file existence checks)
- Acceptable: only 10 files max, fast operation

### 3.4 Decision: Menu item format

**Options**:
- A) Full path: `/home/user/long/path/to/file.ckt`
- B) Filename only: `file.ckt`
- C) Numbered filename: `1. file.ckt`
- D) Filename with tooltip showing full path

**Chosen**: C + D (Numbered filename with tooltip)

**Rationale**:
- Numbered items are familiar (many IDEs, editors use this)
- Keyboard shortcuts (Alt+1 through Alt+9) are convenient
- Filename usually sufficient to identify file
- Tooltip shows full path for disambiguation
- Clean, compact menu appearance

**Trade-offs**:
- May be ambiguous if multiple files have same name
- Acceptable: can add parent directory in future if needed

### 3.5 Decision: Maximum recent files count

**Options**:
- A) Fixed at 10
- B) User-configurable (with UI setting)
- C) User-configurable (manual settings edit only)
- D) Unlimited

**Chosen**: A (Fixed at 10 for MVP)

**Rationale**:
- Industry standard (VS Code, many editors use 10)
- Keeps menu compact
- 10 files covers >95% of user workflows
- Can make configurable in future if requested

**Trade-offs**:
- Not flexible for power users who want more
- Acceptable for MVP: can add preference UI later

### 3.6 Decision: Duplicate file handling

**Options**:
- A) Allow duplicates (file appears multiple times)
- B) Remove old entry, add new at front
- C) Don't add if already in list
- D) Update timestamp but keep position

**Chosen**: B (Move to front)

**Rationale**:
- Most recent use should be at top (recency principle)
- No duplicates clutter menu
- Matches user expectation (most IDEs work this way)

**Trade-offs**:
- Can't see "first opened" vs "last opened"
- Acceptable: recent usage is more relevant

---

## 4. Dependencies and Integration Points

### 4.1 External Dependencies

- **PySide6.QtWidgets.QMenu**: Recent files submenu
- **PySide6.QtWidgets.QAction**: Menu items
- **PySide6.QtWidgets.QFileDialog**: File open dialog
- **PySide6.QtWidgets.QMessageBox**: Error dialogs
- **Python pathlib.Path**: File path handling and existence checks

### 4.2 Internal Dependencies

**Upstream**:
- E06-F06-T01 (QSettings Infrastructure) - REQUIRED
  - Must be implemented first
  - Provides `AppSettings` class to extend

**Downstream**: None (self-contained feature)

**Parallel**:
- E06-F06-T02 (Window Geometry) - Independent, can be implemented in parallel

**Future Consumers**:
- File > Reopen functionality
- Session management (may want to save recent files per session)

### 4.3 Integration Points

**AppSettings Extension**:
```python
class AppSettings:
    # New methods for T03
    def add_recent_file(self, file_path: str): ...
    def get_recent_files(self) -> List[str]: ...
    def clear_recent_files(): ...
    def get_max_recent_files() -> int: ...
    def set_max_recent_files(count: int): ...
```

**Main Window Integration**:
```python
class InkMainWindow(QMainWindow):
    def _setup_menus(self):
        # Create File > Open Recent submenu
        self.recent_files_menu = file_menu.addMenu("Open &Recent")

    def _open_file(self, file_path: str):
        # ... parse and display netlist ...

        # Success - add to recent files
        self.app_settings.add_recent_file(file_path)
        self._update_recent_files_menu()
```

**File Open Workflow**:
```
User Action → _on_open_file_dialog() → QFileDialog
                                      ↓
                                file_path selected
                                      ↓
                                _open_file(file_path)
                                      ↓
                            Parse netlist (CDLParser)
                                      ↓
                              Display on canvas
                                      ↓
                      app_settings.add_recent_file(file_path)
                                      ↓
                          _update_recent_files_menu()
```

---

## 5. Testing Strategy

### 5.1 Unit Tests (AppSettings)

```python
class TestRecentFiles:
    def test_add_recent_file():
        """Test adding a file to recent list."""

    def test_recent_files_order():
        """Test newest file is first."""

    def test_duplicate_moves_to_front():
        """Test re-opening file moves it to front."""

    def test_max_files_limit():
        """Test list trimmed to 10 files."""

    def test_nonexistent_files_filtered():
        """Test deleted files removed automatically."""

    def test_clear_recent_files():
        """Test clearing the list."""

    def test_change_max_recent_files():
        """Test changing max count trims list."""

    def test_empty_list_behavior():
        """Test behavior with no recent files."""
```

### 5.2 Integration Tests (Main Window)

```python
class TestRecentFilesMenu:
    def test_recent_files_menu_updates(qtbot, main_window):
        """Test menu updates when file opened."""

    def test_recent_file_click_opens_file(qtbot, main_window):
        """Test clicking recent file menu item."""

    def test_menu_shows_no_files_placeholder(qtbot, main_window):
        """Test empty state display."""

    def test_clear_recent_files_action(qtbot, main_window):
        """Test clear functionality."""

    def test_menu_numbering(qtbot, main_window):
        """Test files numbered 1-9."""

    def test_nonexistent_file_error(qtbot, main_window):
        """Test clicking deleted file shows error."""
```

### 5.3 Manual Testing Scenarios

**Basic Functionality**:
1. Open file via dialog → Verify appears in recent files menu
2. Open same file again → Verify moves to top
3. Open 15 different files → Verify only 10 shown
4. Close and reopen app → Verify recent files persisted

**Menu Interaction**:
1. Click recent file → Verify opens immediately
2. Press Alt+1 → Verify opens first recent file
3. Hover over menu item → Verify tooltip shows full path (if implemented)

**Edge Cases**:
1. Delete a recent file (outside app) → Reopen app → Verify file removed from list
2. Click deleted file in menu → Verify error dialog shown
3. Clear recent files → Verify menu shows "No Recent Files"
4. Open 10 files, then open duplicate → Verify still 10 files, duplicate at top

**Path Handling**:
1. Open file with spaces in name → Verify displays correctly
2. Open file with long path → Verify truncated/tooltip works
3. Open file via symlink → Verify resolved path stored

### 5.4 Test Data

**Valid Files**:
```python
temp_files = [
    "design1.ckt",
    "design2.ckt",
    "my design with spaces.ckt",
    "very/deep/path/to/netlist.ckt",
]
```

**Edge Cases**:
```python
edge_cases = [
    "nonexistent.ckt",  # Deleted file
    "",                  # Empty path
    "/path/to/symlink.ckt",  # Symlink
]
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| **Path resolution issues** | Medium | Normalize paths with `Path.resolve()`; test symlinks |
| **File no longer exists** | Low | Auto-filter on `get_recent_files()`; show error on click |
| **Very long file paths** | Low | Truncate display; show full path in tooltip |
| **Menu doesn't update** | Medium | Call `_update_recent_files_menu()` after every file open |
| **Duplicate filenames** | Medium | Consider showing parent dir; defer to future if MVP unclear |
| **Settings corruption** | Low | QSettings handles atomicity; recent files not critical data |

### 6.2 Implementation Challenges

**Challenge**: Ensuring menu updates after all file open paths
- **Solution**: Centralize file opening in `_open_file()` method; all paths call this

**Challenge**: Testing file existence efficiently
- **Solution**: `Path.exists()` is fast; 10 files = <1ms overhead

**Challenge**: Path normalization across platforms
- **Solution**: Use `pathlib.Path.resolve()` for canonical paths

**Challenge**: Menu item shortcuts (Alt+1 through Alt+9)
- **Solution**: Use `&` prefix in menu text: `"&1. filename.ckt"`

**Challenge**: Long filenames overflowing menu
- **Solution**: Qt auto-truncates; consider tooltip for full path

### 6.3 UX Considerations

**Menu Clarity**:
- Show filename only (most users recognize by filename)
- Consider tooltip with full path if users request it
- Number items for quick keyboard access

**Error Handling**:
- If file doesn't exist, show clear error message
- Auto-remove from list so user doesn't click again
- Don't interrupt workflow (non-blocking dialog)

**Empty State**:
- Show "No Recent Files" placeholder (disabled) when list empty
- Hide "Clear Recent Files" action when list empty (implemented: always show separator)

### 6.4 Performance Considerations

- **Menu Update Speed**: Rebuilding menu with 10 items is <1ms
- **File Existence Checks**: 10 × `Path.exists()` is ~1ms
- **Settings Write**: Saving list on every file open is <1ms
- **Startup Time**: Loading recent files list is <1ms

All operations are negligible; no performance concerns.

### 6.5 Platform Considerations

**Path Separators**:
- Linux/macOS: `/`
- Windows: `\`
- `pathlib.Path` handles cross-platform automatically

**Case Sensitivity**:
- Linux: Case-sensitive paths
- Windows/macOS: Case-insensitive but case-preserving
- Store paths as-is; let OS handle comparison

---

## 7. Pre-Implementation Checklist

- [ ] Verify T01 (QSettings Infrastructure) is complete
- [ ] Review Qt documentation for `QMenu` and `QAction`
- [ ] Review pathlib documentation for `Path.resolve()` and `Path.exists()`
- [ ] Plan menu structure (numbering, separators, clear action)
- [ ] Design file open centralization (single `_open_file()` method)
- [ ] Prepare test fixtures with temporary files
- [ ] Document path normalization strategy
- [ ] Plan error message text for missing files

---

## 8. Open Questions

1. **Should we show full path in tooltip?**
   - Decision: Yes, add in implementation (low effort, high value)

2. **Should we show file modification date/size?**
   - Decision: No for MVP; can add in future if requested

3. **Should we allow pinning favorite files?**
   - Decision: No for MVP; P1 feature if users request it

4. **Should we have separate recent files per workspace/project?**
   - Decision: No for MVP; single global list is simpler

5. **Should we confirm before clearing recent files?**
   - Decision: No confirmation needed; low-risk operation, can reopen files

6. **Should we handle relative paths?**
   - Decision: Convert all to absolute paths with `Path.resolve()`

7. **Should we show parent directory if filenames are identical?**
   - Decision: Defer to future; unlikely in practice for MVP

---

## 9. Success Criteria

### 9.1 Functional Success

- [ ] Recent files list maintains up to 10 files
- [ ] Files ordered newest first
- [ ] Duplicate files move to front (no duplicates in list)
- [ ] Non-existent files automatically removed
- [ ] Recent files menu shows all files
- [ ] Menu items numbered 1-9 with Alt+N shortcuts
- [ ] Clicking menu item opens file
- [ ] Opening file (any method) adds to recent list
- [ ] "Clear Recent Files" action empties list
- [ ] "No Recent Files" placeholder shown when empty
- [ ] Recent files persist across application restarts
- [ ] Tooltips show full path (optional, nice-to-have)

### 9.2 Quality Success

- [ ] All unit tests pass (AppSettings methods)
- [ ] All integration tests pass (menu interaction)
- [ ] Manual test scenarios completed
- [ ] No console warnings or errors
- [ ] Code documented with clear comments
- [ ] Type hints for all new methods
- [ ] Error handling for all edge cases

### 9.3 User Experience Success

- [ ] Menu updates immediately after file opens
- [ ] No visible delay when opening recent files
- [ ] Error messages are clear and actionable
- [ ] Menu appearance is clean and professional
- [ ] Keyboard shortcuts work as expected

---

## 10. Post-Implementation Notes

_This section will be filled after implementation with lessons learned, actual challenges encountered, and deviations from this plan._

---

## Appendix A: Code Skeleton

```python
# src/ink/infrastructure/persistence/app_settings.py

class AppSettings:
    # ... existing code from T01 ...

    def add_recent_file(self, file_path: str):
        """Add file to recent files list.

        The file is added to the front of the list. If it already exists,
        it's moved to the front. List is trimmed to max size.
        """
        # TODO: Implement
        # 1. Get current list
        # 2. Remove if exists
        # 3. Insert at front
        # 4. Trim to max
        # 5. Save back
        pass

    def get_recent_files(self) -> List[str]:
        """Get list of recent files.

        Automatically filters out non-existent files and updates
        the stored list if any files were removed.
        """
        # TODO: Implement
        # 1. Get stored list
        # 2. Filter non-existent
        # 3. Update if changed
        # 4. Return list
        pass

    def clear_recent_files(self):
        """Clear recent files list."""
        # TODO: Implement
        pass

    def get_max_recent_files(self) -> int:
        """Get maximum number of recent files to remember."""
        # TODO: Implement
        pass

    def set_max_recent_files(self, max_count: int):
        """Set maximum number of recent files to remember."""
        # TODO: Implement with validation
        pass
```

```python
# src/ink/presentation/main_window.py

class InkMainWindow(QMainWindow):
    def _setup_menus(self):
        """Setup menu bar."""
        menubar = self.menuBar()
        file_menu = menubar.addMenu("&File")

        # Open action
        open_action = file_menu.addAction("&Open...")
        open_action.setShortcut("Ctrl+O")
        open_action.triggered.connect(self._on_open_file_dialog)

        # Recent files submenu
        self.recent_files_menu = file_menu.addMenu("Open &Recent")

        # TODO: Add Exit, etc.

    def _update_recent_files_menu(self):
        """Update recent files menu with current list."""
        # TODO: Implement
        # 1. Clear menu
        # 2. Get recent files
        # 3. Add action per file
        # 4. Add separator
        # 5. Add clear action
        pass

    def _format_recent_file_name(self, file_path: str, index: int) -> str:
        """Format recent file name for menu display."""
        # TODO: Implement
        # Return "&1. filename.ckt" format
        pass

    def _on_open_recent_file(self, file_path: str):
        """Handle opening a recent file."""
        # TODO: Implement
        # 1. Check if exists
        # 2. If yes: _open_file()
        # 3. If no: show error, update menu
        pass

    def _open_file(self, file_path: str):
        """Open a netlist file."""
        # TODO: Implement
        # 1. Parse netlist
        # 2. Display on canvas
        # 3. Add to recent files
        # 4. Update menu
        # 5. Update window title
        pass

    def _on_clear_recent_files(self):
        """Handle Clear Recent Files action."""
        # TODO: Implement
        pass
```

---

## Appendix B: Menu Structure Visual

```
┌─────────────────────────────────┐
│ File                        ▼   │
├─────────────────────────────────┤
│ Open...             Ctrl+O      │
│ Open Recent              ▶   ┌──────────────────────────────┐
│                              │ &1. design1.ckt               │
│ ───────────────────          │ &2. testbench.ckt             │
│ Exit                Ctrl+Q   │ &3. my_netlist.ckt            │
└─────────────────────────────────│ &4. another_design.ckt      │
                                 │ 5. fifth_file.ckt            │
                                 │ ──────────────────────────── │
                                 │ Clear Recent Files           │
                                 └──────────────────────────────┘

Empty state:
┌─────────────────────────────────┐
│ File                        ▼   │
├─────────────────────────────────┤
│ Open...             Ctrl+O      │
│ Open Recent              ▶   ┌──────────────────────────────┐
│                              │ No Recent Files (disabled)   │
│ ───────────────────          └──────────────────────────────┘
│ Exit                Ctrl+Q   │
└─────────────────────────────────┘
```

---

## Appendix C: Test Outline

```python
# tests/unit/infrastructure/persistence/test_recent_files.py

class TestRecentFiles:
    @pytest.fixture
    def settings(self, tmp_path):
        """Create isolated settings instance."""

    @pytest.fixture
    def temp_files(self, tmp_path):
        """Create 15 temporary test files."""

    def test_add_recent_file():
        """Single file addition."""

    def test_recent_files_order():
        """Newest first ordering."""

    def test_duplicate_moves_to_front():
        """Re-opening moves to top."""

    def test_max_files_limit():
        """List trimmed to 10."""

    def test_nonexistent_files_filtered():
        """Deleted files removed."""

    def test_clear_recent_files():
        """Clearing empties list."""

    def test_change_max_recent_files():
        """Changing max trims list."""

# tests/integration/ui/test_recent_files_menu.py

class TestRecentFilesMenu:
    def test_menu_updates_on_file_open():
        """Menu shows newly opened file."""

    def test_menu_item_click_opens_file():
        """Clicking menu item works."""

    def test_empty_state_placeholder():
        """Empty state shows placeholder."""

    def test_clear_action():
        """Clear action empties menu."""

    def test_keyboard_shortcuts():
        """Alt+1 through Alt+9 work."""
```
