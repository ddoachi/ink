---
id: E06-F06-T03
title: Recent Files Management
type: Task
priority: P0 (MVP)
status: Draft
parent: E06-F06
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Small
tags:
  - ui
  - persistence
  - files
clickup_task_id: '86evzm370'
---

# Spec: E06-F06-T03 - Recent Files Management

## 1. Overview

### 1.1 Problem Statement

Users frequently work with the same netlist files and need quick access to recently opened files. Without a recent files list, users must navigate through file dialogs repeatedly to open the same files, wasting time and reducing productivity.

### 1.2 Goals

- Maintain list of up to 10 most recently opened files
- Update list automatically when files are opened
- Display recent files in File menu
- Allow direct opening of recent files via menu
- Handle non-existent files gracefully (auto-remove from list)
- Provide "Clear Recent Files" functionality
- Persist recent files list across application sessions

---

## 2. Technical Requirements

### 2.1 AppSettings Extensions

Add recent files methods to `AppSettings` class:

```python
# src/ink/infrastructure/persistence/app_settings.py

from pathlib import Path
from typing import List

class AppSettings:
    # ... existing code ...

    def add_recent_file(self, file_path: str):
        """Add file to recent files list.

        The file is added to the front of the list. If it already exists,
        it's moved to the front. List is trimmed to max size.

        Args:
            file_path: Absolute path to file
        """
        recent = self.get_recent_files()

        # Remove if already exists (will re-add at front)
        if file_path in recent:
            recent.remove(file_path)

        # Add to front
        recent.insert(0, file_path)

        # Trim to max size
        max_recent = self.get_max_recent_files()
        recent = recent[:max_recent]

        # Save back
        self.set_value(self.KEY_RECENT_FILES, recent)

    def get_recent_files(self) -> List[str]:
        """Get list of recent files.

        Automatically filters out non-existent files and updates
        the stored list if any files were removed.

        Returns:
            List of absolute file paths (newest first)
        """
        files = self.get_value(self.KEY_RECENT_FILES, [], type=list)

        # Ensure all entries are strings
        files = [str(f) for f in files if f]

        # Filter out non-existent files
        existing_files = [f for f in files if Path(f).exists()]

        # Update settings if any files were removed
        if len(existing_files) < len(files):
            self.set_value(self.KEY_RECENT_FILES, existing_files)

        return existing_files

    def clear_recent_files(self):
        """Clear recent files list."""
        self.set_value(self.KEY_RECENT_FILES, [])

    def get_max_recent_files(self) -> int:
        """Get maximum number of recent files to remember.

        Returns:
            Maximum recent files count (default: 10)
        """
        return self.get_value(
            self.KEY_MAX_RECENT,
            self.DEFAULT_MAX_RECENT,
            type=int
        )

    def set_max_recent_files(self, max_count: int):
        """Set maximum number of recent files to remember.

        Args:
            max_count: Maximum count (must be >= 1)
        """
        if max_count < 1:
            raise ValueError("max_count must be >= 1")

        self.set_value(self.KEY_MAX_RECENT, max_count)

        # Trim existing list if needed
        recent = self.get_value(self.KEY_RECENT_FILES, [], type=list)
        if len(recent) > max_count:
            self.set_value(self.KEY_RECENT_FILES, recent[:max_count])
```

### 2.2 Main Window Integration

Update `InkMainWindow` to maintain recent files menu:

```python
# src/ink/presentation/main_window.py

class InkMainWindow(QMainWindow):
    def __init__(self, app_settings: AppSettings):
        super().__init__()
        self.app_settings = app_settings

        # ... existing setup code ...

        # Build initial recent files menu
        self._update_recent_files_menu()

    def _setup_menus(self):
        """Setup menu bar."""
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu("&File")

        # Open action
        open_action = file_menu.addAction("&Open...")
        open_action.setShortcut("Ctrl+O")
        open_action.triggered.connect(self._on_open_file_dialog)

        # Recent files submenu
        self.recent_files_menu = file_menu.addMenu("Open &Recent")

        file_menu.addSeparator()

        # Exit action
        exit_action = file_menu.addAction("E&xit")
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)

    def _update_recent_files_menu(self):
        """Update recent files menu with current list."""
        self.recent_files_menu.clear()

        recent_files = self.app_settings.get_recent_files()

        if recent_files:
            # Add action for each recent file
            for i, file_path in enumerate(recent_files):
                # Show filename and partial path
                display_name = self._format_recent_file_name(file_path, i)

                action = self.recent_files_menu.addAction(display_name)
                action.setData(file_path)  # Store full path in action data
                action.triggered.connect(
                    lambda checked=False, path=file_path: self._on_open_recent_file(path)
                )

            self.recent_files_menu.addSeparator()

            # Add "Clear Recent Files" action
            clear_action = self.recent_files_menu.addAction("Clear Recent Files")
            clear_action.triggered.connect(self._on_clear_recent_files)
        else:
            # Show "No Recent Files" placeholder
            no_files_action = self.recent_files_menu.addAction("No Recent Files")
            no_files_action.setEnabled(False)

    def _format_recent_file_name(self, file_path: str, index: int) -> str:
        """Format recent file name for menu display.

        Args:
            file_path: Full file path
            index: Index in recent files list (0-based)

        Returns:
            Formatted display name
        """
        path = Path(file_path)

        # Use index+1 for menu numbering (1-based)
        number = index + 1

        # Show: "1. filename.ckt"
        if number <= 9:
            return f"&{number}. {path.name}"
        else:
            return f"{number}. {path.name}"

    def _on_open_file_dialog(self):
        """Handle File > Open action."""
        from PySide6.QtWidgets import QFileDialog

        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Open Netlist File",
            "",
            "Netlist Files (*.ckt *.cdl *.sp);;All Files (*)"
        )

        if file_path:
            self._open_file(file_path)

    def _on_open_recent_file(self, file_path: str):
        """Handle opening a recent file.

        Args:
            file_path: Absolute path to file
        """
        if Path(file_path).exists():
            self._open_file(file_path)
        else:
            # File no longer exists - show error and refresh menu
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "File Not Found",
                f"The file no longer exists:\n{file_path}"
            )
            # Menu will be auto-updated on next get_recent_files() call
            self._update_recent_files_menu()

    def _open_file(self, file_path: str):
        """Open a netlist file.

        Args:
            file_path: Absolute path to file
        """
        try:
            # ... actual file opening logic ...

            # Success - add to recent files
            self.app_settings.add_recent_file(file_path)
            self._update_recent_files_menu()

            # Update window title
            self.setWindowTitle(f"Ink - {Path(file_path).name}")

        except Exception as e:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.critical(
                self,
                "Error Opening File",
                f"Failed to open file:\n{file_path}\n\nError: {str(e)}"
            )

    def _on_clear_recent_files(self):
        """Handle Clear Recent Files action."""
        self.app_settings.clear_recent_files()
        self._update_recent_files_menu()
```

### 2.3 Recent Files Menu Structure

```
File
├── Open... (Ctrl+O)
├── Open Recent ►
│   ├── &1. design1.ckt
│   ├── &2. design2.ckt
│   ├── &3. design3.ckt
│   ├── ...
│   ├── ──────────────
│   └── Clear Recent Files
├── ─────────────
└── Exit (Ctrl+Q)
```

If no recent files:

```
File
├── Open... (Ctrl+O)
├── Open Recent ►
│   └── No Recent Files (disabled)
├── ─────────────
└── Exit (Ctrl+Q)
```

---

## 3. Implementation Details

### 3.1 File Path Storage

- Store **absolute paths** only
- Normalize paths to resolve symlinks
- Handle cross-platform path separators

```python
def _normalize_file_path(self, file_path: str) -> str:
    """Normalize file path for storage.

    Args:
        file_path: File path (relative or absolute)

    Returns:
        Absolute, resolved path
    """
    return str(Path(file_path).resolve())
```

### 3.2 Menu Shortcuts

Files 1-9 get keyboard shortcuts:
- File 1: `Alt+1` or `&1.` in menu
- File 2: `Alt+2` or `&2.` in menu
- ...

### 3.3 Long Path Handling

For very long paths, consider showing only filename in menu and full path in tooltip:

```python
action.setToolTip(file_path)  # Full path on hover
```

---

## 4. Testing Requirements

### 4.1 Unit Tests

```python
# tests/unit/infrastructure/persistence/test_recent_files.py

import pytest
from pathlib import Path
from ink.infrastructure.persistence.app_settings import AppSettings

class TestRecentFiles:
    @pytest.fixture
    def settings(self, tmp_path):
        """Create temporary settings."""
        from PySide6.QtCore import QSettings
        QSettings.setPath(
            QSettings.Format.IniFormat,
            QSettings.Scope.UserScope,
            str(tmp_path)
        )
        return AppSettings()

    @pytest.fixture
    def temp_files(self, tmp_path):
        """Create temporary test files."""
        files = []
        for i in range(15):
            file = tmp_path / f"test{i}.ckt"
            file.write_text(f"content {i}")
            files.append(str(file))
        return files

    def test_add_recent_file(self, settings, temp_files):
        """Test adding a recent file."""
        settings.add_recent_file(temp_files[0])
        recent = settings.get_recent_files()
        assert len(recent) == 1
        assert recent[0] == temp_files[0]

    def test_recent_files_order(self, settings, temp_files):
        """Test recent files are ordered newest first."""
        settings.add_recent_file(temp_files[0])
        settings.add_recent_file(temp_files[1])
        settings.add_recent_file(temp_files[2])

        recent = settings.get_recent_files()
        assert recent[0] == temp_files[2]  # Most recent
        assert recent[1] == temp_files[1]
        assert recent[2] == temp_files[0]

    def test_duplicate_moves_to_front(self, settings, temp_files):
        """Test re-opening file moves it to front."""
        settings.add_recent_file(temp_files[0])
        settings.add_recent_file(temp_files[1])
        settings.add_recent_file(temp_files[0])  # Re-add

        recent = settings.get_recent_files()
        assert recent[0] == temp_files[0]  # Moved to front
        assert recent[1] == temp_files[1]
        assert len(recent) == 2  # No duplicate

    def test_max_recent_files_limit(self, settings, temp_files):
        """Test list is trimmed to max size."""
        # Add 15 files (limit is 10)
        for file in temp_files:
            settings.add_recent_file(file)

        recent = settings.get_recent_files()
        assert len(recent) == 10  # Trimmed to max
        assert recent[0] == temp_files[14]  # Most recent
        assert recent[9] == temp_files[5]   # Oldest in list

    def test_nonexistent_files_filtered(self, settings, temp_files):
        """Test non-existent files are removed."""
        settings.add_recent_file(temp_files[0])
        settings.add_recent_file(temp_files[1])

        # Delete one file
        Path(temp_files[0]).unlink()

        recent = settings.get_recent_files()
        assert len(recent) == 1
        assert recent[0] == temp_files[1]

    def test_clear_recent_files(self, settings, temp_files):
        """Test clearing recent files."""
        settings.add_recent_file(temp_files[0])
        settings.add_recent_file(temp_files[1])
        settings.clear_recent_files()

        recent = settings.get_recent_files()
        assert len(recent) == 0

    def test_change_max_recent_files(self, settings, temp_files):
        """Test changing max recent files count."""
        # Add 10 files
        for i in range(10):
            settings.add_recent_file(temp_files[i])

        # Reduce max to 5
        settings.set_max_recent_files(5)

        recent = settings.get_recent_files()
        assert len(recent) == 5
```

### 4.2 Integration Tests

```python
# tests/integration/ui/test_recent_files_menu.py

def test_recent_files_menu_updates(qtbot, main_window, temp_files):
    """Test recent files menu updates when files opened."""
    # Initially no recent files
    assert main_window.recent_files_menu.isEmpty()

    # Open a file
    main_window._open_file(temp_files[0])

    # Menu should have one entry
    actions = main_window.recent_files_menu.actions()
    assert len(actions) == 2  # File + Clear separator + Clear action
    assert "test0.ckt" in actions[0].text()

def test_recent_file_menu_click(qtbot, main_window, temp_files):
    """Test clicking recent file opens it."""
    main_window._open_file(temp_files[0])

    # Click first recent file action
    action = main_window.recent_files_menu.actions()[0]
    action.trigger()

    # File should be opened (re-added to recent)
    recent = main_window.app_settings.get_recent_files()
    assert recent[0] == temp_files[0]
```

---

## 5. Acceptance Criteria

- [ ] `add_recent_file()`, `get_recent_files()`, `clear_recent_files()` methods added to `AppSettings`
- [ ] Recent files list maintains up to 10 files
- [ ] Recent files ordered newest first
- [ ] Duplicate files moved to front (not duplicated)
- [ ] Non-existent files automatically filtered out
- [ ] Recent files menu in File menu
- [ ] Recent files menu shows up to 10 files
- [ ] Recent files menu items numbered 1-9 with shortcuts
- [ ] Clicking recent file opens it
- [ ] Opening file adds it to recent list
- [ ] "Clear Recent Files" action works
- [ ] "No Recent Files" placeholder shown when list empty
- [ ] Recent files list persists across restarts
- [ ] Long filenames displayed correctly in menu
- [ ] Tooltip shows full path on hover (optional)

---

## 6. Dependencies

- **Upstream**: E06-F06-T01 (QSettings Infrastructure)
- **Downstream**: None
- **External**:
  - PySide6 (`QMenu`, `QAction`)
  - Python `pathlib.Path`

---

## 7. Notes

### 7.1 Platform Considerations

- Windows: Paths use backslashes, but `Path` handles this
- Linux/macOS: Paths use forward slashes
- Store normalized absolute paths for consistency

### 7.2 Future Enhancements

- Show file path in tooltip
- Show file size/date in submenu
- Pin favorite files to top
- Separate recent files per project

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E06-F06 split |
