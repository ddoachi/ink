---
id: E06-F06-T04
title: Settings Migration & Reset
type: Task
priority: P0 (MVP)
status: Implemented
parent: E06-F06
created: 2025-12-26
implemented: 2025-12-26
estimated_hours: 3
actual_hours: 2
effort: Small
tags:
  - infrastructure
  - persistence
  - migration
clickup_task_id: '86evzm37e'
---

# Spec: E06-F06-T04 - Settings Migration & Reset

## 1. Overview

### 1.1 Problem Statement

As the application evolves, settings schemas may change (new keys, renamed keys, changed formats). Without a migration system, users may experience crashes or data loss when upgrading. Additionally, users need the ability to reset settings to defaults when troubleshooting issues.

### 1.2 Goals

- Implement settings version tracking
- Provide migration framework for future schema changes
- Allow users to reset all settings to defaults
- Handle corrupted or incompatible settings gracefully
- Provide settings file path for debugging/support

---

## 2. Technical Requirements

### 2.1 Settings Versioning

Add version tracking to `AppSettings`:

```python
# src/ink/infrastructure/persistence/app_settings.py

class AppSettings:
    # ... existing constants ...

    # Settings schema version
    CURRENT_VERSION = 1

    def __init__(self):
        """Initialize settings with platform-native storage."""
        self.settings = QSettings("InkProject", "Ink")

        # Check and migrate settings if needed
        self._migrate_if_needed()

        # Initialize defaults on first run
        self._initialize_defaults()

    def _migrate_if_needed(self):
        """Migrate settings from older versions if needed.

        Checks stored settings version and applies migrations
        sequentially to bring settings up to current version.
        """
        stored_version = self.get_value(self.KEY_SETTINGS_VERSION, 0, type=int)

        if stored_version < self.CURRENT_VERSION:
            self._migrate_settings(stored_version, self.CURRENT_VERSION)
            self.set_value(self.KEY_SETTINGS_VERSION, self.CURRENT_VERSION)
            self.sync()

    def _migrate_settings(self, from_version: int, to_version: int):
        """Perform settings migration between versions.

        Args:
            from_version: Source settings version (0 = no settings)
            to_version: Target settings version

        Migrations are applied sequentially:
        0 -> 1, 1 -> 2, 2 -> 3, etc.
        """
        # Apply migrations sequentially
        for version in range(from_version, to_version):
            migration_method = f"_migrate_v{version}_to_v{version + 1}"

            if hasattr(self, migration_method):
                getattr(self, migration_method)()

    def _migrate_v0_to_v1(self):
        """Migrate from version 0 (no settings) to version 1.

        This is the initial migration - no actual changes needed,
        just establishing the baseline.
        """
        # Version 1 is the initial schema
        # No migration needed
        pass

    def _initialize_defaults(self):
        """Initialize default settings on first run."""
        if not self.has_key(self.KEY_SETTINGS_VERSION):
            # First run - set all defaults
            self.set_value(self.KEY_SETTINGS_VERSION, self.CURRENT_VERSION)
            self.set_value(self.KEY_MAX_RECENT, self.DEFAULT_MAX_RECENT)
            self.set_value(self.KEY_RECENT_FILES, [])
            self.sync()

    def get_settings_version(self) -> int:
        """Get current settings schema version.

        Returns:
            Settings version (0 if not set)
        """
        return self.get_value(self.KEY_SETTINGS_VERSION, 0, type=int)
```

### 2.2 Settings Reset

Add reset functionality:

```python
# src/ink/infrastructure/persistence/app_settings.py

class AppSettings:
    # ... existing code ...

    def reset_all_settings(self):
        """Reset all settings to defaults.

        Clears all stored settings and re-initializes defaults.
        This is useful for troubleshooting or user preference reset.
        """
        # Clear everything
        self.settings.clear()

        # Re-initialize defaults
        self._initialize_defaults()

        self.sync()

    def reset_window_geometry(self):
        """Reset only window geometry and state."""
        self.remove_key(self.KEY_WINDOW_GEOMETRY)
        self.remove_key(self.KEY_WINDOW_STATE)
        self.sync()

    def reset_recent_files(self):
        """Reset recent files list."""
        self.clear_recent_files()
        self.sync()
```

### 2.3 Settings Diagnostics

Add diagnostic methods for debugging:

```python
# src/ink/infrastructure/persistence/app_settings.py

class AppSettings:
    # ... existing code ...

    def get_settings_file_path(self) -> str:
        """Get path to settings file (for debugging/support).

        Returns:
            Absolute path to settings file
        """
        return self.settings.fileName()

    def get_all_settings(self) -> dict:
        """Get all settings as dictionary (for debugging).

        Returns:
            Dictionary of all settings
        """
        result = {}
        for key in self.settings.allKeys():
            result[key] = self.settings.value(key)
        return result

    def export_settings(self, file_path: str):
        """Export settings to file (for backup/debugging).

        Args:
            file_path: Path to export file
        """
        import json
        from pathlib import Path

        settings_dict = self.get_all_settings()

        # Convert QByteArray to base64 for JSON serialization
        from PySide6.QtCore import QByteArray
        for key, value in settings_dict.items():
            if isinstance(value, QByteArray):
                import base64
                settings_dict[key] = {
                    "_type": "QByteArray",
                    "_data": base64.b64encode(bytes(value)).decode('utf-8')
                }

        with open(file_path, 'w') as f:
            json.dump(settings_dict, f, indent=2)

    def is_corrupted(self) -> bool:
        """Check if settings appear corrupted.

        Returns:
            True if settings seem corrupted
        """
        try:
            # Try to read critical settings
            self.get_settings_version()
            self.get_recent_files()
            return False
        except Exception:
            return True
```

### 2.4 Main Window Integration

Add reset action to menu:

```python
# src/ink/presentation/main_window.py

class InkMainWindow(QMainWindow):
    def _setup_menus(self):
        """Setup menu bar."""
        # ... existing menus ...

        # Help menu
        help_menu = menubar.addMenu("&Help")

        # Settings submenu
        help_menu.addSeparator()

        settings_menu = help_menu.addMenu("&Settings")

        reset_geometry_action = settings_menu.addAction("Reset Window Layout")
        reset_geometry_action.triggered.connect(self._on_reset_geometry)

        reset_recent_action = settings_menu.addAction("Clear Recent Files")
        reset_recent_action.triggered.connect(self._on_clear_recent_files)

        settings_menu.addSeparator()

        reset_all_action = settings_menu.addAction("Reset All Settings...")
        reset_all_action.triggered.connect(self._on_reset_all_settings)

        show_settings_action = settings_menu.addAction("Show Settings File Location")
        show_settings_action.triggered.connect(self._on_show_settings_location)

    def _on_reset_geometry(self):
        """Reset window geometry to defaults."""
        from PySide6.QtWidgets import QMessageBox

        reply = QMessageBox.question(
            self,
            "Reset Window Layout",
            "Reset window size and panel layout to defaults?\n\n"
            "This will restart the application.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.app_settings.reset_window_geometry()
            self._restart_application()

    def _on_reset_all_settings(self):
        """Reset all settings to defaults."""
        from PySide6.QtWidgets import QMessageBox

        reply = QMessageBox.question(
            self,
            "Reset All Settings",
            "Reset all settings to defaults?\n\n"
            "This will:\n"
            "• Clear window layout\n"
            "• Clear recent files\n"
            "• Reset all preferences\n\n"
            "This will restart the application.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.app_settings.reset_all_settings()
            self._restart_application()

    def _on_show_settings_location(self):
        """Show settings file location."""
        from PySide6.QtWidgets import QMessageBox

        settings_path = self.app_settings.get_settings_file_path()

        QMessageBox.information(
            self,
            "Settings File Location",
            f"Settings are stored at:\n\n{settings_path}"
        )

    def _restart_application(self):
        """Restart the application."""
        from PySide6.QtWidgets import QApplication
        from PySide6.QtCore import QProcess
        import sys

        QApplication.quit()
        QProcess.startDetached(sys.executable, sys.argv)
```

### 2.5 Corrupted Settings Handling

Add startup check for corrupted settings:

```python
# src/ink/presentation/app.py (or main.py)

def main():
    """Application entry point."""
    from PySide6.QtWidgets import QApplication, QMessageBox
    import sys

    app = QApplication(sys.argv)
    app.setApplicationName("Ink")
    app.setOrganizationName("InkProject")

    # Initialize settings
    app_settings = AppSettings()

    # Check for corrupted settings
    if app_settings.is_corrupted():
        reply = QMessageBox.question(
            None,
            "Corrupted Settings",
            "Application settings appear corrupted.\n\n"
            "Reset settings to defaults?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            app_settings.reset_all_settings()

    # Create and show main window
    window = InkMainWindow(app_settings=app_settings)
    window.show()

    sys.exit(app.exec())
```

---

## 3. Future Migration Examples

### 3.1 Example: Renaming a Key (v1 → v2)

```python
def _migrate_v1_to_v2(self):
    """Migrate from version 1 to version 2.

    Changes:
    - Rename "geometry/window" to "window/geometry"
    - Rename "geometry/state" to "window/state"
    """
    # Rename keys
    if self.has_key("geometry/window"):
        value = self.get_value("geometry/window")
        self.set_value("window/geometry", value)
        self.remove_key("geometry/window")

    if self.has_key("geometry/state"):
        value = self.get_value("geometry/state")
        self.set_value("window/state", value)
        self.remove_key("geometry/state")
```

### 3.2 Example: Changing Data Format (v2 → v3)

```python
def _migrate_v2_to_v3(self):
    """Migrate from version 2 to version 3.

    Changes:
    - Convert recent files from list of strings to list of dicts
      with additional metadata (timestamp, size, etc.)
    """
    recent_files = self.get_value("files/recent", [], type=list)

    # Convert to new format
    new_format = []
    for file_path in recent_files:
        new_format.append({
            "path": file_path,
            "timestamp": None,  # No historical data
            "size": None
        })

    self.set_value("files/recent", new_format)
```

---

## 4. Testing Requirements

### 4.1 Unit Tests

```python
# tests/unit/infrastructure/persistence/test_settings_migration.py

import pytest
from ink.infrastructure.persistence.app_settings import AppSettings

class TestSettingsMigration:
    @pytest.fixture
    def settings(self, tmp_path):
        """Create temporary settings."""
        from PySide6.QtCore import QSettings
        QSettings.setPath(
            QSettings.Format.IniFormat,
            QSettings.Scope.UserScope,
            str(tmp_path)
        )
        return AppSettings()

    def test_version_initialized_on_first_run(self, settings):
        """Test version is set on first run."""
        version = settings.get_settings_version()
        assert version == settings.CURRENT_VERSION

    def test_reset_all_settings(self, settings):
        """Test resetting all settings."""
        # Add some settings
        settings.set_value("test/key", "value")
        settings.add_recent_file("/tmp/test.ckt")

        # Reset
        settings.reset_all_settings()

        # Verify cleared
        assert not settings.has_key("test/key")
        assert len(settings.get_recent_files()) == 0

        # Verify defaults re-initialized
        assert settings.get_settings_version() == settings.CURRENT_VERSION
        assert settings.get_max_recent_files() == settings.DEFAULT_MAX_RECENT

    def test_reset_window_geometry(self, settings):
        """Test resetting window geometry only."""
        from PySide6.QtCore import QByteArray

        # Set geometry
        settings.save_window_geometry(QByteArray(b"test"))
        settings.set_value("other/key", "value")

        # Reset geometry
        settings.reset_window_geometry()

        # Geometry cleared, other settings intact
        assert settings.load_window_geometry() is None
        assert settings.get_value("other/key") == "value"

    def test_get_settings_file_path(self, settings):
        """Test getting settings file path."""
        path = settings.get_settings_file_path()
        assert isinstance(path, str)
        assert len(path) > 0

    def test_get_all_settings(self, settings):
        """Test getting all settings."""
        settings.set_value("test/key1", "value1")
        settings.set_value("test/key2", "value2")

        all_settings = settings.get_all_settings()
        assert "test/key1" in all_settings
        assert "test/key2" in all_settings

    def test_is_corrupted_returns_false_for_valid(self, settings):
        """Test is_corrupted returns False for valid settings."""
        assert not settings.is_corrupted()

    def test_export_settings(self, settings, tmp_path):
        """Test exporting settings to file."""
        settings.set_value("test/key", "value")

        export_path = tmp_path / "settings_export.json"
        settings.export_settings(str(export_path))

        assert export_path.exists()

        # Verify JSON format
        import json
        with open(export_path) as f:
            data = json.load(f)
            assert "test/key" in data
```

### 4.2 Integration Tests

```python
# tests/integration/persistence/test_settings_reset.py

def test_reset_settings_menu_action(qtbot, main_window):
    """Test reset settings menu action."""
    # Add some settings
    main_window.app_settings.set_value("test/key", "value")

    # Find and trigger reset action
    # (Implementation depends on menu structure)

    # Verify settings cleared
    assert not main_window.app_settings.has_key("test/key")
```

---

## 5. Acceptance Criteria

- [x] Settings version tracking implemented
- [x] Version stored in settings on first run
- [x] Migration framework with sequential migration support
- [x] `reset_all_settings()` clears all settings and re-initializes defaults
- [x] `reset_window_geometry()` clears only window geometry
- [x] `reset_recent_files()` clears recent files list
- [x] Settings file path accessible via `get_settings_file_path()`
- [x] `get_all_settings()` returns dictionary of all settings
- [x] `export_settings()` exports to JSON file
- [x] `is_corrupted()` detects corrupted settings
- [x] Reset actions in Help > Settings menu
- [x] Reset confirms with user before executing
- [x] Reset informs user to restart (does not auto-restart for cleaner UX)
- [ ] Corrupted settings detected at startup with recovery option (deferred - requires main.py entry point)
- [x] Future migration examples documented in spec

---

## 6. Dependencies

- **Upstream**: E06-F06-T01 (QSettings Infrastructure)
- **Downstream**: None
- **External**: PySide6 (`QSettings`, `QMessageBox`, `QProcess`)

---

## 7. Notes

### 7.1 Migration Best Practices

1. **Sequential**: Apply migrations in order (v0→v1, v1→v2, etc.)
2. **Backward Compatible**: Never break old settings completely
3. **Tested**: Test each migration path thoroughly
4. **Documented**: Document what changed in each version

### 7.2 When to Increment Version

Increment version when:
- Renaming settings keys
- Changing data format (string → dict, etc.)
- Removing deprecated settings
- Adding required settings

Don't increment for:
- Adding new optional settings
- Changing default values

### 7.3 Restart Requirement

Settings reset requires restart because:
- Qt caches QSettings values
- Main window already constructed with old geometry
- Cleanest way to apply defaults

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E06-F06 split |
