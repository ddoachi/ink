# Pre-Implementation Documentation: E06-F06-T01 - QSettings Infrastructure

**Task ID**: E06-F06-T01
**Generated**: 2025-12-26
**Status**: Pre-Implementation

---

## 1. Overview and Problem Context

### 1.1 Problem Statement

The Ink application needs a robust, platform-native settings persistence layer to store user preferences across sessions. Without centralized settings management, each component would need to implement its own persistence logic, leading to inconsistency, code duplication, and potential data corruption.

### 1.2 Current State

- No settings infrastructure exists yet
- This is foundational infrastructure for all persistence features
- No user preferences can currently be saved across sessions

### 1.3 Desired State

A clean, well-tested `AppSettings` class that:
- Provides a simple API over Qt's `QSettings`
- Uses platform-native storage (Linux: INI, Windows: Registry, macOS: plist)
- Defines all settings keys as class constants
- Handles type conversion and default values
- Is easily mockable for testing
- Serves as a single source of truth for application settings

---

## 2. Implementation Approach

### 2.1 High-Level Strategy

1. **Create AppSettings class** wrapping `QSettings` with organization "InkProject" and application "Ink"
2. **Define settings key constants** organized by category (geometry, files, meta)
3. **Implement generic get/set methods** with type conversion support
4. **Add utility methods** for key existence checks, removal, and enumeration
5. **Include debugging support** with file path access
6. **Initialize defaults** on first run using version tracking

### 2.2 Architecture Decisions

**Location**: `src/ink/infrastructure/persistence/app_settings.py`

**Rationale**:
- Infrastructure layer (adapter to external Qt framework)
- Persistence subdirectory groups all storage-related code
- Domain layer remains pure Python with no Qt dependencies

**Design Pattern**: Simple wrapper/facade pattern
- Thin layer over `QSettings`
- Adds type safety and convenience methods
- Provides constant-based key management

### 2.3 Key Components

```
AppSettings
├── Settings Keys (class constants)
│   ├── KEY_WINDOW_GEOMETRY
│   ├── KEY_WINDOW_STATE
│   ├── KEY_RECENT_FILES
│   ├── KEY_MAX_RECENT
│   └── KEY_SETTINGS_VERSION
├── Generic Methods
│   ├── get_value(key, default, type)
│   ├── set_value(key, value)
│   ├── has_key(key)
│   ├── remove_key(key)
│   └── get_all_keys()
├── Utility Methods
│   ├── get_settings_file_path()
│   └── sync()
└── Initialization
    └── _initialize_defaults()
```

---

## 3. Key Design Decisions

### 3.1 Decision: Use QSettings directly vs custom storage

**Options**:
- A) Use Qt's `QSettings` (platform-native)
- B) Custom JSON file storage
- C) SQLite database

**Chosen**: A (QSettings)

**Rationale**:
- Platform-native storage is more robust and follows OS conventions
- Automatic handling of file locking, atomic writes
- Built-in support in PySide6 (no additional dependencies)
- Users can find settings in standard OS locations
- Mature, well-tested implementation

**Trade-offs**:
- Less portable across platforms (different formats)
- Harder to manually edit than JSON
- Tied to Qt framework

### 3.2 Decision: Hierarchical vs flat key structure

**Options**:
- A) Hierarchical keys with `/` separator: `"geometry/window"`
- B) Flat keys with underscores: `"geometry_window"`

**Chosen**: A (Hierarchical)

**Rationale**:
- Natural grouping of related settings
- QSettings optimizes hierarchical access
- Easier to manage in Qt config tools
- Can use `beginGroup()` for batch operations (future)

### 3.3 Decision: Type conversion in get_value

**Options**:
- A) Always return QVariant, let caller convert
- B) Accept optional `type` parameter for conversion
- C) Separate typed methods (`get_int`, `get_string`, etc.)

**Chosen**: B (Optional type parameter)

**Rationale**:
- Flexible: supports both dynamic and typed usage
- Matches QSettings API (`value(key, default, type=...)`)
- Single method reduces API surface
- Type hints provide safety at call sites

### 3.4 Decision: When to initialize defaults

**Options**:
- A) In `__init__()` on every instantiation
- B) Lazily on first get/set
- C) Check version key and initialize once

**Chosen**: C (Version-based initialization)

**Rationale**:
- Runs only on first application launch
- Version tracking enables future migrations
- Explicit and predictable behavior
- Minimal overhead on subsequent runs

---

## 4. Dependencies and Integration Points

### 4.1 External Dependencies

- **PySide6.QtCore.QSettings**: Core settings storage class
- **PySide6.QtCore.QByteArray**: For geometry/state data (T02)
- **Python pathlib**: For file path handling (T03)

### 4.2 Internal Dependencies

**Upstream**: None (foundational infrastructure)

**Downstream**:
- E06-F06-T02 (Window Geometry Persistence) - will add domain-specific methods
- E06-F06-T03 (Recent Files Management) - will add recent files methods
- Future settings consumers (themes, shortcuts, preferences)

### 4.3 Integration Points

**Dependency Injection**:
```python
# In main application (presentation/app.py)
app_settings = AppSettings()
main_window = InkMainWindow(app_settings=app_settings)
```

**Testing Isolation**:
```python
# Tests use temporary settings location
QSettings.setPath(
    QSettings.Format.IniFormat,
    QSettings.Scope.UserScope,
    str(tmp_path)
)
```

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Core Functionality**:
- Set and retrieve values
- Default values when key doesn't exist
- Type conversion (int, bool, list, QByteArray)
- Key existence checks
- Key removal
- Enumerate all keys
- Settings file path access

**Edge Cases**:
- Invalid type conversions
- Empty/null values
- Very long strings
- Special characters in keys/values
- Concurrent access (if applicable)

**Fixtures**:
```python
@pytest.fixture
def settings(tmp_path):
    """Isolated settings instance for each test."""
    QSettings.setPath(
        QSettings.Format.IniFormat,
        QSettings.Scope.UserScope,
        str(tmp_path)
    )
    return AppSettings()
```

### 5.2 Integration Testing

**Persistence Verification**:
- Settings survive object destruction
- Multiple AppSettings instances share state
- sync() forces immediate write

**Platform Testing** (manual):
- Linux: Verify `~/.config/InkProject/Ink.conf` created
- Windows: Check registry at `HKEY_CURRENT_USER\Software\InkProject\Ink`
- macOS: Check `~/Library/Preferences/com.InkProject.Ink.plist`

### 5.3 Test Data

Use realistic settings data:
```python
test_data = {
    "strings": ["value1", "long/path/to/file.ckt"],
    "integers": [0, 42, -1, 1000000],
    "booleans": [True, False],
    "lists": [[], ["a", "b", "c"], [1, 2, 3]],
}
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| **Settings corruption** | Medium | QSettings handles atomic writes; add migration logic in T04 |
| **Platform differences** | Low | QSettings abstracts platform details; test on each OS |
| **Type conversion failures** | Medium | Validate types at boundaries; provide sensible defaults |
| **Concurrent access** | Low | Single-user desktop app; QSettings handles locking |
| **Settings location changes** | Low | Qt determines location; document in code comments |

### 6.2 Implementation Challenges

**Challenge**: Testing platform-specific behavior
- **Solution**: Use temporary paths in tests; manual verification on each platform

**Challenge**: Mocking QSettings for downstream tests
- **Solution**: AppSettings is simple enough to use real instance with temp path

**Challenge**: Settings schema evolution
- **Solution**: Version key enables future migrations (handled in T04)

### 6.3 Performance Considerations

- **Read Performance**: QSettings caches in memory; fast repeated access
- **Write Performance**: Lazy write on destruction; use `sync()` only when necessary
- **Startup Time**: Minimal (<1ms on modern systems)

### 6.4 Security Considerations

- **Sensitive Data**: Don't store passwords or tokens (out of scope for MVP)
- **File Permissions**: QSettings uses OS defaults (user-only read/write)
- **Validation**: Sanitize file paths from recent files (T03)

---

## 7. Pre-Implementation Checklist

- [ ] Review QSettings documentation for platform-specific behaviors
- [ ] Confirm PySide6 version supports all required QSettings features
- [ ] Design settings key naming convention (hierarchical with `/`)
- [ ] Plan for settings version migration (coordinate with T04)
- [ ] Set up test fixtures for isolated settings testing
- [ ] Document platform storage locations in code comments
- [ ] Prepare for downstream tasks (T02, T03) that extend this class

---

## 8. Open Questions

1. **Should we support settings import/export?**
   - Decision: Out of scope for MVP; add in P1 if needed

2. **How to handle settings corruption?**
   - Decision: Let QSettings handle; add reset functionality in T04

3. **Should settings be human-readable?**
   - Decision: Linux INI format is readable; others less so; acceptable for MVP

4. **Max size limit for settings?**
   - Decision: No explicit limit; QSettings handles reasonable sizes

5. **Support for settings groups?**
   - Decision: Use hierarchical keys; `beginGroup()`/`endGroup()` available if needed later

---

## 9. Success Criteria

### 9.1 Functional Success

- [ ] AppSettings class created and tested
- [ ] All generic methods (get, set, has, remove, list) working
- [ ] Type conversion functioning for all basic types
- [ ] Default initialization on first run
- [ ] Settings persist across application restarts
- [ ] Settings file path accessible for debugging

### 9.2 Quality Success

- [ ] 100% unit test coverage for AppSettings
- [ ] All tests pass on Linux (primary platform)
- [ ] Code follows project style guide (PEP 8, type hints)
- [ ] Documentation complete (docstrings, comments)
- [ ] No hardcoded paths (platform-native only)

### 9.3 Integration Success

- [ ] AppSettings can be instantiated in main application
- [ ] Ready for extension by T02 (window geometry methods)
- [ ] Ready for extension by T03 (recent files methods)
- [ ] Mock-friendly for downstream component testing

---

## 10. Post-Implementation Notes

_This section will be filled after implementation with lessons learned, actual challenges encountered, and deviations from this plan._

---

## Appendix A: Code Skeleton

```python
# src/ink/infrastructure/persistence/app_settings.py

from PySide6.QtCore import QSettings, QByteArray
from typing import Any, List


class AppSettings:
    """Application settings manager using QSettings.

    Provides centralized access to persisted application settings
    using Qt's platform-native storage mechanism.

    Platform storage locations:
    - Linux: ~/.config/InkProject/Ink.conf (INI format)
    - Windows: HKEY_CURRENT_USER\\Software\\InkProject\\Ink (Registry)
    - macOS: ~/Library/Preferences/com.InkProject.Ink.plist
    """

    # Settings keys - organized by category
    KEY_WINDOW_GEOMETRY = "geometry/window"
    KEY_WINDOW_STATE = "geometry/state"
    KEY_RECENT_FILES = "files/recent"
    KEY_MAX_RECENT = "files/max_recent"
    KEY_SETTINGS_VERSION = "meta/version"

    # Constants
    CURRENT_VERSION = 1
    DEFAULT_MAX_RECENT = 10

    def __init__(self):
        """Initialize settings with platform-native storage."""
        self.settings = QSettings("InkProject", "Ink")
        self._initialize_defaults()

    def _initialize_defaults(self):
        """Initialize default settings on first run."""
        # TODO: Implement version check and defaults
        pass

    def get_value(self, key: str, default: Any = None, value_type: type = None) -> Any:
        """Get a setting value."""
        # TODO: Implement with type conversion
        pass

    def set_value(self, key: str, value: Any):
        """Set a setting value."""
        # TODO: Implement
        pass

    # ... additional methods ...
```

---

## Appendix B: Test Outline

```python
# tests/unit/infrastructure/persistence/test_app_settings.py

class TestAppSettings:
    """Test suite for AppSettings class."""

    def test_initialization():
        """Test settings object creation."""

    def test_set_get_string():
        """Test string storage and retrieval."""

    def test_set_get_with_type_conversion():
        """Test automatic type conversion."""

    def test_default_values():
        """Test default value handling."""

    def test_has_key():
        """Test key existence checks."""

    def test_remove_key():
        """Test key deletion."""

    def test_get_all_keys():
        """Test key enumeration."""

    def test_settings_persistence():
        """Test settings survive object recreation."""

    def test_first_run_initialization():
        """Test default initialization on first run."""
```
