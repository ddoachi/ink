# E06-F04-T01 - Status Bar Setup: Pre-Implementation Documentation

## Document Information
- **Task**: E06-F04-T01 - Status Bar Setup
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview and Context

### 1.1 Problem Statement

The Ink application requires a persistent status bar at the bottom of the main window to provide users with real-time contextual information about the current schematic view. This task establishes the foundational infrastructure that subsequent tasks will populate with dynamic data.

The status bar must provide visual structure for four distinct information sections:
1. File name display (left-aligned, with tooltip for full path)
2. Zoom level indicator
3. Selection count display
4. Object count summary (visible cells/nets)

### 1.2 User Impact

Without a status bar, users lack passive awareness of critical context:
- Which file is currently loaded
- Current zoom level when navigating schematics
- How many objects are selected during multi-select operations
- Size of the currently visible schematic (cell/net count)

This missing context forces users to perform explicit actions (e.g., checking window title, counting selections manually) to obtain information that should be immediately visible.

### 1.3 Success Criteria

The status bar infrastructure is successful when:
- All four status widget slots are visible and properly spaced on application launch
- Visual separators clearly delineate information sections
- Status bar maintains stable layout during window resize operations
- Widget minimum widths prevent text truncation at reasonable window sizes
- No runtime errors occur during status bar creation or display

---

## 2. Implementation Approach

### 2.1 High-Level Strategy

**Architecture**: Presentation layer component integrated into `InkMainWindow`

The status bar will be implemented as a standard Qt `QStatusBar` widget with four permanent `QLabel` widgets, each representing a distinct information category. This approach follows Qt best practices and provides:

1. **Separation of concerns**: Status bar setup logic isolated in dedicated method
2. **Extensibility**: Easy addition of new status widgets in future
3. **Testability**: Widget creation logic can be unit tested independently
4. **Qt integration**: Leverages native QStatusBar widget lifecycle and resizing

**Implementation Pattern**:
```
_setup_status_bar() → Creates QStatusBar and permanent widgets
_create_separator() → Factory method for visual separators
Instance attributes → Store widget references for later updates
```

### 2.2 Component Design

**Main Window Integration**:
- `_setup_status_bar()` called during `InkMainWindow.__init__()` after central widget setup
- Status bar attached via `QMainWindow.setStatusBar()`
- All status labels stored as instance attributes (`self.file_label`, etc.)

**Widget Architecture**:
```
QStatusBar (attached to main window)
  ├─ file_label (QLabel, 200px min width)
  ├─ separator_1 (QLabel with "│")
  ├─ zoom_label (QLabel, 100px min width)
  ├─ separator_2 (QLabel with "│")
  ├─ selection_label (QLabel, 100px min width)
  ├─ separator_3 (QLabel with "│")
  └─ object_count_label (QLabel, 150px min width)
```

**Visual Design**:
- Separators use gray color for subtle visual division
- Left-aligned text in all labels for consistency
- Permanent widgets ensure fixed positioning (not displaced by temporary messages)
- Minimum widths prevent layout collapse but allow expansion

### 2.3 Alternative Approaches Considered

**Alternative 1: Single label with formatted string**
- **Rejected**: Difficult to update individual sections, poor layout control
- **Trade-off**: Simpler code but inflexible for dynamic updates

**Alternative 2: Custom QWidget subclass for status bar**
- **Rejected**: Over-engineered for MVP, adds unnecessary abstraction
- **Trade-off**: More control over layout but higher maintenance cost

**Alternative 3: Temporary status bar messages instead of permanent widgets**
- **Rejected**: Information would disappear, defeating purpose of persistent context
- **Trade-off**: Simpler API but poor UX for persistent status

---

## 3. Key Design Decisions

### 3.1 Widget Minimum Widths

**Decision**: Set explicit minimum widths for all status labels

| Widget | Min Width | Rationale |
|--------|-----------|-----------|
| `file_label` | 200px | Accommodate typical filenames (e.g., "circuit_design_v2.ckt") |
| `zoom_label` | 100px | Sufficient for "Zoom: 1000%" (max zoom) |
| `selection_label` | 100px | Sufficient for "Selected: 9999" (large selections) |
| `object_count_label` | 150px | Sufficient for "Cells: 9999 / Nets: 9999" |

**Rationale**:
- Prevents text truncation during window resize
- Maintains readable text even at minimum window size
- Allows expansion when window grows
- Chosen based on maximum expected text lengths

**Alternative Considered**: Dynamic width based on content
- **Rejected**: Causes layout "jumping" as content changes
- **Trade-off**: Fixed widths provide stable, predictable layout

### 3.2 Separator Style

**Decision**: Use Unicode pipe character (│) with gray color

**Rationale**:
- Visual clarity without adding complex widgets
- Lightweight (plain text, no custom rendering)
- Cross-platform compatibility (Unicode widely supported)
- Subtle appearance (gray) doesn't compete with content

**Alternatives Considered**:
- **QFrame separators**: Heavier, inconsistent appearance across platforms
- **Custom painted lines**: Over-engineered for simple visual separator
- **Double-space without separator**: Insufficient visual separation

### 3.3 Permanent vs Temporary Widgets

**Decision**: Use `addPermanentWidget()` for all status labels

**Rationale**:
- Ensures status widgets always visible (not displaced by messages)
- Right-aligned permanent widgets follow Qt conventions
- Consistent positioning regardless of other status bar activity

**Note**: Left side of status bar remains available for temporary messages via `showMessage()` if needed in future.

### 3.4 Initial Placeholder Text

**Decision**: Show meaningful placeholder text on launch

| Widget | Initial Text | Purpose |
|--------|--------------|---------|
| `file_label` | "No file loaded" | Indicates application state |
| `zoom_label` | "Zoom: 100%" | Shows default zoom level |
| `selection_label` | "Selected: 0" | Shows empty selection |
| `object_count_label` | "Cells: 0 / Nets: 0" | Shows empty schematic |

**Rationale**:
- Provides immediate visual feedback on application state
- Establishes expected text format for users
- Avoids empty/confusing status bar on launch
- Matches actual application state (no file loaded, nothing selected)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E06-F01: Main Window Shell**
- **Required**: `InkMainWindow` class must exist with `__init__()` method
- **Integration**: Status bar setup called during window initialization
- **Risk**: Low - main window is foundational component

**PySide6 Framework**
- **Required**: `QStatusBar`, `QLabel`, `QMainWindow` classes
- **Version**: PySide6 6.x
- **Risk**: None - stable Qt API

### 4.2 Downstream Dependencies

**E06-F04-T02: Selection Status Display**
- **Provides**: `self.selection_label` widget reference
- **Contract**: Label must exist before selection updates can occur

**E06-F04-T03: Zoom Level Display**
- **Provides**: `self.zoom_label` widget reference
- **Contract**: Label must exist before zoom updates can occur

**E06-F04-T04: File and Object Count Display**
- **Provides**: `self.file_label`, `self.object_count_label` widget references
- **Contract**: Labels must exist before file/count updates can occur

### 4.3 Integration Sequence

**Initialization Order**:
```python
InkMainWindow.__init__():
    1. Setup central widget (canvas)
    2. Setup menu bar and toolbars
    3. _setup_status_bar()  # ← This task
    4. Setup services (file, selection, expansion)
    5. _connect_status_signals()  # ← Future tasks
```

**Critical Constraint**: Status bar must be created before signal connections in subsequent tasks.

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Test File**: `/home/joohan/dev/project-ink/ink/tests/unit/presentation/test_main_window_status.py`

**Test Coverage Areas**:

1. **Widget Creation**:
   - Status bar exists after `_setup_status_bar()` call
   - All four label widgets created as instance attributes
   - Widgets added to status bar

2. **Initial State**:
   - Placeholder text set correctly on all labels
   - Minimum widths configured properly
   - Separators present (count verification)

3. **Separator Styling**:
   - Gray color applied to separator labels
   - Correct separator character (│)
   - Three separators exist (between four widgets)

**Test Fixtures**:
```python
@pytest.fixture
def main_window(qtbot):
    """Create main window for testing."""
    window = InkMainWindow()
    qtbot.addWidget(window)
    return window
```

### 5.2 Manual Testing Checklist

**Visual Verification**:
1. Launch application
2. Verify status bar visible at bottom of window
3. Check all four sections display placeholder text
4. Verify separators appear between sections
5. Resize window to minimum width
6. Confirm status bar remains readable (no truncation)
7. Resize window to maximum width
8. Confirm status bar expands appropriately

**Layout Testing**:
1. Verify consistent spacing between widgets
2. Check vertical alignment of all text
3. Confirm separators have proper padding
4. Test on different display DPI settings (if applicable)

### 5.3 Acceptance Testing

**Criteria from Spec**:
- [ ] QStatusBar created and attached to main window
- [ ] Status bar visible at bottom of window on launch
- [ ] Four permanent widgets added to status bar
- [ ] Visual separators (│) displayed between widgets
- [ ] All status labels show initial placeholder text
- [ ] Minimum widths configured for all widgets
- [ ] Status bar maintains layout when window resized
- [ ] No runtime errors or warnings on status bar creation

**Additional Verification**:
- Screenshot comparison with design mockup
- Cross-platform testing (Linux primary, Windows/macOS if available)
- Accessibility check (screen reader compatibility)

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: Widget Initialization Order**
- **Impact**: Medium - Widgets might not display if created before window shown
- **Probability**: Low - Qt handles deferred rendering
- **Mitigation**: Create status bar after central widget, test thoroughly

**Risk 2: Minimum Width Sum Exceeds Window Minimum**
- **Impact**: Low - Horizontal scrollbar or truncation at very small sizes
- **Probability**: Low - Total min width (550px) reasonable for desktop app
- **Mitigation**: Set main window minimum width to accommodate status bar (650px+)

**Risk 3: Cross-Platform Layout Differences**
- **Impact**: Low - Separators or spacing may render differently
- **Probability**: Medium - Font metrics vary across platforms
- **Mitigation**: Test on target platforms, adjust spacing if needed

### 6.2 UX Risks

**Risk 1: Status Bar Too Prominent**
- **Impact**: Low - Distracts from schematic content
- **Probability**: Low - Status bars are conventional UI pattern
- **Mitigation**: Use subtle styling (no bold text, neutral colors)

**Risk 2: Placeholder Text Confusing**
- **Impact**: Low - Users might not understand initial state
- **Probability**: Low - "No file loaded" is clear
- **Mitigation**: User testing, update text if feedback indicates confusion

### 6.3 Integration Risks

**Risk 1: Future Tasks Assume Different Widget Names**
- **Impact**: High - Broken downstream integrations
- **Probability**: Low - Widget names documented in spec
- **Mitigation**: Document widget names prominently, enforce in code review

**Risk 2: Signal Connection Race Conditions**
- **Impact**: Medium - Status updates might fail if signals connected before widgets exist
- **Probability**: Low - Initialization order enforced in `__init__()`
- **Mitigation**: Assert widget existence in signal connection methods

---

## 7. Performance Considerations

### 7.1 Initialization Performance

**Expected Cost**: <5ms for status bar creation
- Widget creation: ~1ms (four QLabel instances)
- Layout management: ~2ms (QStatusBar internal layout)
- Styling application: ~1ms (separator colors)

**Measurement**: Add timing instrumentation in `_setup_status_bar()` during development

### 7.2 Runtime Performance

**Update Performance**: Not applicable (this task only creates static widgets)

**Memory Overhead**: Negligible
- Four QLabel widgets: ~2KB each
- QStatusBar container: ~5KB
- Total: <15KB memory impact

### 7.3 Rendering Performance

**Repaint Cost**: Handled by Qt rendering pipeline
- Status bar repaints only when content changes
- No custom painting → no performance concern
- Qt optimizes repaint regions automatically

---

## 8. Implementation Checklist

**Code Implementation**:
- [ ] Import `QStatusBar` and `QLabel` in `main_window.py`
- [ ] Implement `_setup_status_bar()` method
- [ ] Implement `_create_separator()` helper method
- [ ] Create `file_label` instance attribute with initial text
- [ ] Create `zoom_label` instance attribute with initial text
- [ ] Create `selection_label` instance attribute with initial text
- [ ] Create `object_count_label` instance attribute with initial text
- [ ] Set minimum widths on all labels
- [ ] Add separators between widgets
- [ ] Call `_setup_status_bar()` in `__init__()` at appropriate point

**Testing**:
- [ ] Write unit test for status bar creation
- [ ] Write unit test for initial text verification
- [ ] Write unit test for separator presence
- [ ] Write unit test for minimum width configuration
- [ ] Run manual visual verification checklist
- [ ] Test on minimum window size
- [ ] Verify no console errors or warnings

**Documentation**:
- [ ] Add docstring to `_setup_status_bar()` method
- [ ] Add docstring to `_create_separator()` method
- [ ] Document instance attributes in class docstring
- [ ] Update architecture documentation if needed

**Code Review**:
- [ ] Self-review against coding standards (PEP 8, type hints)
- [ ] Verify widget naming matches spec
- [ ] Check minimum widths are reasonable
- [ ] Confirm initialization order is correct
- [ ] Peer review completed

---

## 9. Open Questions

### 9.1 Resolved Questions

**Q1: Should separators be QFrame or text?**
- **Answer**: Text (QLabel with │) - simpler, cross-platform consistent
- **Decided**: 2025-12-26

**Q2: Fixed or dynamic widget widths?**
- **Answer**: Fixed minimum widths with expansion capability
- **Decided**: 2025-12-26

**Q3: Where to call status bar setup in initialization sequence?**
- **Answer**: After central widget, before service initialization
- **Decided**: 2025-12-26

### 9.2 Outstanding Questions

**Q1: Should status bar height be configurable?**
- **Current**: Use Qt default height
- **Future**: Consider user preference if feedback indicates need
- **Priority**: Low - defer to post-MVP

**Q2: Should status bar support theming?**
- **Current**: Use application default theme
- **Future**: E06-P1 includes theming feature
- **Priority**: P1 - will be addressed in theming epic

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E06/F04/T01/E06-F04-T01.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E06/F04/E06-F04.spec.md`
- **Qt Documentation**: [QStatusBar](https://doc.qt.io/qt-6/qstatusbar.html)
- **Qt Documentation**: [QLabel](https://doc.qt.io/qt-6/qlabel.html)
- **Architecture**: `/home/joohan/dev/project-ink/ink/docs/architecture/components.md`

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
