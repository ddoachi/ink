# E06-F04-T02 - Selection Status Display: Pre-Implementation Documentation

## Document Information
- **Task**: E06-F04-T02 - Selection Status Display
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview and Context

### 1.1 Problem Statement

During schematic exploration, users frequently perform multi-select operations to analyze groups of cells, nets, or pins. Without immediate visual feedback about selection count, users must manually count selected items or rely on memory - a cognitive burden that increases with selection size.

This task implements real-time selection count display in the status bar, providing users with instant awareness of how many objects are currently selected. The count updates automatically whenever the selection changes through any interaction method (click, Ctrl+click, box selection, keyboard shortcuts).

### 1.2 User Impact

**Current State**: Users have no passive awareness of selection count
- Multi-select operations require manual counting
- Uncertainty about whether Ctrl+click added or toggled items
- Box selection doesn't indicate how many items were selected
- Select All gives no feedback about total selection size

**Target State**: Real-time selection count display
- Immediate confirmation of selection operations
- Clear feedback for multi-select workflows
- Confidence in selection state before operations (delete, copy, etc.)
- Reduced cognitive load during complex selection tasks

### 1.3 Success Criteria

Implementation is successful when:
- Selection count displays "Selected: 0" on application launch
- Count updates within 100ms of any selection change
- Display format is consistent: "Selected: N"
- Count reflects total selected objects (cells + nets + pins)
- Updates work for all selection methods (click, box select, keyboard)
- No performance impact during rapid selection changes

---

## 2. Implementation Approach

### 2.1 High-Level Strategy

**Architecture**: Presentation layer component with application service integration

The implementation follows Qt's signal/slot pattern for reactive updates:

```
Selection Service (Application Layer)
    ↓ selection_changed signal (emits list of selected items)
Signal Connection Layer
    ↓ Lambda: extract count from list
Main Window (Presentation Layer)
    → update_selection_status(count: int)
    → Update selection_label text
```

**Key Principle**: Separation of concerns
- **Selection Service**: Manages selection state, emits change signals
- **Main Window**: Updates UI based on signals, no selection business logic
- **Signal Connection**: Thin translation layer between application and presentation

### 2.2 Component Design

**Update Method**: `update_selection_status(count: int)`
- **Input**: Integer count of selected objects
- **Output**: None (side effect: updates UI)
- **Behavior**: Formats count as "Selected: N" and updates label text

**Signal Connection**: `_connect_status_signals()`
- **Purpose**: Wire selection service signals to status update methods
- **Timing**: Called during `__init__()` after services initialized
- **Defensive**: Checks service existence with `hasattr()` before connecting

**Data Flow**:
```
User clicks cell on canvas
    ↓
Canvas emits selection event
    ↓
Selection service updates internal state
    ↓
Selection service emits selection_changed([cell1, cell2, ...])
    ↓
Signal handler extracts len(items)
    ↓
update_selection_status(2) called
    ↓
Status bar shows "Selected: 2"
```

### 2.3 Alternative Approaches Considered

**Alternative 1: Polling selection state**
- **Approach**: Timer-based periodic query of selection service
- **Rejected**: Inefficient, adds latency, wastes CPU cycles
- **Trade-off**: Simpler initial implementation but poor UX and performance

**Alternative 2: Direct canvas-to-status-bar coupling**
- **Approach**: Canvas directly calls status bar update method
- **Rejected**: Violates separation of concerns, couples UI components
- **Trade-off**: Fewer indirections but tight coupling, harder to test

**Alternative 3: Event bus pattern**
- **Approach**: Publish selection events to central event bus
- **Rejected**: Over-engineered for MVP, adds complexity
- **Trade-off**: More flexible but unnecessary abstraction for current needs

---

## 3. Key Design Decisions

### 3.1 Count Aggregation Strategy

**Decision**: Display total count of all selected object types

**Rationale**:
- Users care about "how many things are selected" not type breakdown
- Simpler display (single number vs "Cells: 2, Nets: 1, Pins: 3")
- Consistent with most GUI applications (file explorers, IDEs)

**Example Scenarios**:
| Selection | Display | Count Calculation |
|-----------|---------|-------------------|
| 1 cell | "Selected: 1" | Total objects: 1 |
| 2 cells + 1 net | "Selected: 3" | Total objects: 3 |
| 5 cells + 3 nets + 2 pins | "Selected: 10" | Total objects: 10 |

**Future Consideration**: If user feedback indicates need for type breakdown, add tooltip with details:
```
Display: "Selected: 10"
Tooltip: "Cells: 5, Nets: 3, Pins: 2"
```

### 3.2 Signal Connection Timing

**Decision**: Connect signals in `_connect_status_signals()` method called during `__init__()`

**Timing Sequence**:
```python
InkMainWindow.__init__():
    1. Setup central widget
    2. _setup_status_bar()  # Create widgets
    3. Setup services (selection_service, etc.)
    4. _connect_status_signals()  # Connect signals ← This task
```

**Rationale**:
- Status bar widgets must exist before connections (dependency)
- Services must be initialized before connection attempts
- Centralized connection method enables easy debugging
- Defensive `hasattr()` checks prevent errors if service missing

**Error Handling**:
```python
if hasattr(self, 'selection_service'):
    # Connect signal
else:
    # Log warning, skip connection (graceful degradation)
```

### 3.3 Lambda vs Method Reference

**Decision**: Use lambda to extract count from signal payload

**Implementation**:
```python
self.selection_service.selection_changed.connect(
    lambda items: self.update_selection_status(len(items))
)
```

**Rationale**:
- Signal emits list of items, but we only need count
- Lambda provides thin transformation layer
- Keeps `update_selection_status()` simple (only takes count)
- Avoids creating additional wrapper methods

**Alternative Considered**:
```python
def _on_selection_changed(self, items):
    self.update_selection_status(len(items))
```
- **Rejected**: Adds method for trivial transformation
- **Trade-off**: More explicit but more boilerplate

### 3.4 Update Latency Requirements

**Decision**: Target <100ms update latency from selection change to display

**Rationale**:
- 100ms is perceptual threshold for "instantaneous" feedback
- Qt signal/slot mechanism is synchronous (negligible overhead)
- Simple text update is <1ms operation

**Performance Verification**:
- Manual testing: Visual confirmation of immediate update
- No need for instrumentation (operation too fast to measure meaningfully)
- Integration test verifies signal connection works correctly

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E06-F04-T01: Status Bar Setup**
- **Required**: `self.selection_label` widget must exist
- **Contract**: Widget created before signal connections
- **Risk**: Low - enforced by initialization order

**E04-F01: Selection Service**
- **Required**: `SelectionService` class with `selection_changed` signal
- **Contract**: Signal emits list of selected objects
- **Signal Signature**: `selection_changed = Signal(list)`
- **Risk**: Medium - Selection service may not exist in MVP

**Mitigation for Missing Selection Service**:
```python
if hasattr(self, 'selection_service'):
    # Connect signal
else:
    logger.warning("Selection service not available, status updates disabled")
```

### 4.2 Downstream Dependencies

None - this task is a terminal node (provides UI feedback, doesn't enable other features)

### 4.3 Integration Points

**With Selection Service**:
- **Signal**: `selection_changed` emitted on any selection modification
- **Payload**: List of selected objects (cells, nets, pins)
- **Frequency**: Multiple times per second during box selection
- **Threading**: Same thread (Qt main thread)

**With Canvas**:
- **Indirect**: Canvas emits events → Selection service updates → Signal emitted
- **No direct coupling**: Status bar doesn't directly observe canvas

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Test File**: `/home/joohan/dev/project-ink/ink/tests/unit/presentation/test_main_window_selection_status.py`

**Test Categories**:

1. **Method Behavior Tests**:
   ```python
   def test_update_selection_status_zero(main_window):
       main_window.update_selection_status(0)
       assert main_window.selection_label.text() == "Selected: 0"

   def test_update_selection_status_single(main_window):
       main_window.update_selection_status(1)
       assert main_window.selection_label.text() == "Selected: 1"

   def test_update_selection_status_multiple(main_window):
       main_window.update_selection_status(42)
       assert main_window.selection_label.text() == "Selected: 42"
   ```

2. **Format Consistency Tests**:
   - Verify "Selected: " prefix present
   - Check space after colon
   - Confirm no trailing characters

3. **Edge Case Tests**:
   - Zero selection (cleared)
   - Single selection
   - Large selection (1000+ objects)
   - Rapid successive updates

### 5.2 Integration Testing Approach

**Test File**: `/home/joohan/dev/project-ink/ink/tests/integration/presentation/test_selection_status_integration.py`

**Test Scenarios**:

1. **Signal Connection Test**:
   ```python
   def test_selection_signal_updates_status(main_window, selection_service):
       # Emit signal with 3 items
       mock_items = [Mock(), Mock(), Mock()]
       selection_service.selection_changed.emit(mock_items)

       # Verify status updated
       assert main_window.selection_label.text() == "Selected: 3"
   ```

2. **Selection Cleared Test**:
   ```python
   def test_selection_cleared_updates_status(main_window, selection_service):
       # Set initial selection
       selection_service.selection_changed.emit([Mock(), Mock()])

       # Clear selection
       selection_service.selection_changed.emit([])

       assert main_window.selection_label.text() == "Selected: 0"
   ```

3. **Rapid Selection Changes**:
   ```python
   def test_rapid_selection_changes(main_window, selection_service):
       # Simulate box selection (many rapid updates)
       for count in range(1, 11):
           items = [Mock() for _ in range(count)]
           selection_service.selection_changed.emit(items)

       # Final state should be correct
       assert main_window.selection_label.text() == "Selected: 10"
   ```

### 5.3 Manual Testing Checklist

**Basic Selection**:
1. Launch app, load file
2. Verify "Selected: 0" displayed
3. Click cell → verify "Selected: 1"
4. Click empty area → verify "Selected: 0"

**Multi-Select**:
1. Ctrl+Click cell 1 → verify "Selected: 1"
2. Ctrl+Click cell 2 → verify "Selected: 2"
3. Ctrl+Click cell 3 → verify "Selected: 3"
4. Esc → verify "Selected: 0"

**Box Selection**:
1. Drag box over multiple cells
2. Verify count updates during drag (if progressive)
3. Verify final count matches selected cells

**Keyboard Shortcuts**:
1. Ctrl+A (Select All) → verify total count
2. Esc (Deselect All) → verify "Selected: 0"

**Mixed Selection**:
1. Select 2 cells + 1 net
2. Verify "Selected: 3" (total count)

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: Selection Service Not Implemented**
- **Impact**: High - Feature cannot function without selection service
- **Probability**: Medium - Selection service is E04-F01, may not be complete
- **Mitigation**: Defensive connection with `hasattr()` check, graceful degradation
- **Fallback**: Status shows "Selected: 0" always, no updates

**Risk 2: Signal/Slot Connection Failure**
- **Impact**: Medium - Updates won't work, but no crashes
- **Probability**: Low - Qt signal/slot mechanism is robust
- **Mitigation**: Integration tests verify connections, log warnings on failure

**Risk 3: Performance Impact from High-Frequency Updates**
- **Impact**: Low - UI lag during rapid selection changes
- **Probability**: Low - Text update is trivial operation
- **Mitigation**: Qt automatically coalesces rapid updates, no explicit throttling needed

### 6.2 UX Risks

**Risk 1: Users Expect Type Breakdown**
- **Impact**: Low - Users want more detail than total count
- **Probability**: Medium - Power users may want "Cells: 2, Nets: 1"
- **Mitigation**: Start simple, add tooltip with breakdown if feedback indicates need

**Risk 2: Large Selections Create Long Text**
- **Impact**: Low - "Selected: 123456" might exceed widget width
- **Probability**: Very Low - Selections >1000 are rare
- **Mitigation**: Widget minimum width (100px) accommodates "Selected: 99999"

### 6.3 Integration Risks

**Risk 1: Selection Service Signal Signature Changes**
- **Impact**: High - Connection breaks if signal payload changes
- **Probability**: Low - Signal contract defined in spec
- **Mitigation**: Type annotations, integration tests catch changes early

**Risk 2: Initialization Order Violation**
- **Impact**: High - AttributeError if widgets/services not created
- **Probability**: Low - Initialization order documented and enforced
- **Mitigation**: Assertions in `_connect_status_signals()` to verify prerequisites

---

## 7. Performance Considerations

### 7.1 Update Performance

**Operation Cost**: <1ms per update
- Extract count from list: O(1) - `len()` on Python list
- String formatting: ~0.1ms - "Selected: {count}"
- QLabel setText(): ~0.5ms - Qt text rendering update

**Signal Overhead**: ~0.01ms
- Qt signal emission and slot invocation
- Direct function call-like performance

**Total Latency**: <2ms from signal emission to display update

### 7.2 High-Frequency Update Handling

**Scenario**: Box selection emits 100+ signals during drag

**Qt Optimization**: Event loop automatically coalesces updates
- Multiple setText() calls within event loop batch → single repaint
- No explicit throttling needed
- User sees smooth count increment

**Measurement**: Not needed - operation too fast to impact UX

### 7.3 Memory Overhead

**Per Update**: Negligible
- Temporary string allocation: ~50 bytes
- String immediately garbage collected after setText()
- No persistent allocations

---

## 8. Implementation Checklist

**Code Implementation**:
- [ ] Implement `update_selection_status(count: int)` method in `main_window.py`
- [ ] Add docstring with parameter and behavior description
- [ ] Add type hints for method signature
- [ ] Implement `_connect_status_signals()` method (or extend existing)
- [ ] Add `hasattr()` check for selection_service existence
- [ ] Connect `selection_service.selection_changed` signal with lambda
- [ ] Extract count from signal payload: `len(items)`
- [ ] Call `update_selection_status()` from lambda
- [ ] Call `_connect_status_signals()` in `__init__()` after service setup
- [ ] Add logging for signal connection (debug level)

**Testing**:
- [ ] Write unit test for zero count
- [ ] Write unit test for single count
- [ ] Write unit test for multiple counts (5, 42, 100)
- [ ] Write unit test for format consistency
- [ ] Write integration test for signal connection
- [ ] Write integration test for selection cleared
- [ ] Write integration test for rapid updates
- [ ] Run manual testing checklist
- [ ] Verify no console errors or warnings

**Documentation**:
- [ ] Add docstring to `update_selection_status()` method
- [ ] Document signal connection in `_connect_status_signals()` docstring
- [ ] Update class docstring if needed
- [ ] Add inline comments for lambda (if not obvious)

**Code Review**:
- [ ] Verify defensive `hasattr()` check present
- [ ] Check type hints on all new methods
- [ ] Confirm initialization order correct
- [ ] Verify signal connection matches spec
- [ ] Peer review completed

---

## 9. Open Questions

### 9.1 Resolved Questions

**Q1: Should we display type breakdown (cells vs nets)?**
- **Answer**: No, display total count only for MVP
- **Rationale**: Simpler UX, consistent with industry patterns
- **Future**: Add tooltip if user feedback indicates need
- **Decided**: 2025-12-26

**Q2: How to handle missing selection service?**
- **Answer**: Graceful degradation with `hasattr()` check and warning log
- **Decided**: 2025-12-26

**Q3: Update immediately or debounce rapid changes?**
- **Answer**: Update immediately, Qt handles coalescing automatically
- **Decided**: 2025-12-26

### 9.2 Outstanding Questions

**Q1: Should large selections (1000+) show abbreviated format?**
- **Current**: Display full number "Selected: 1234"
- **Future**: Consider "Selected: 1.2K" if feedback indicates need
- **Priority**: Low - defer until user feedback

**Q2: Should selection count be clickable (e.g., to show selection list)?**
- **Current**: Static display only
- **Future**: Could open selection panel on click
- **Priority**: P1 - potential enhancement after MVP

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E06/F04/T02/E06-F04-T02.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E06/F04/E06-F04.spec.md`
- **Upstream Dependency**: `/home/joohan/dev/project-ink/ink/specs/E06/F04/T01/E06-F04-T01.spec.md`
- **Selection Service**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Qt Signals/Slots**: [Qt Signal & Slot Documentation](https://doc.qt.io/qt-6/signalsandslots.html)

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
