# E02-F02-T04 - LayoutEngine Protocol and Integration: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F02-T04
- **Task**: LayoutEngine Protocol and Integration
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task creates the integration layer that unifies the three Sugiyama algorithm phases (T01-T03) into a cohesive layout engine. It implements the `LayoutEngine` protocol defined in the domain layer and provides the `SugiyamaLayoutEngine` implementation in the infrastructure layer, following DDD/Clean Architecture principles.

**Core Deliverables:**
- `LayoutEngine` protocol definition in domain layer
- `SugiyamaLayoutEngine` implementation in infrastructure layer
- Phase orchestration (layer assignment → crossing minimization → coordinate assignment)
- Configuration management and error handling
- Optional layout result caching for performance

**Success Metrics:**
- Clean separation between domain protocol and infrastructure implementation
- All three phases orchestrated correctly
- Performance: <2s for 1000 cells, <30s for 10,000 cells
- Configurable parameters working
- Graceful error handling with descriptive messages

### 1.2 Problem Context

Currently, we have three independent algorithm modules:
- `layer_assignment.py` - Assigns cells to layers
- `crossing_minimization.py` - Optimizes cell ordering
- `coordinate_assignment.py` - Computes X/Y positions

But the **application layer** needs:
- A unified interface to compute layouts
- No knowledge of algorithm internals
- Ability to swap layout algorithms (future: force-directed, Dot, etc.)
- Configuration and error handling

**The Solution**: Define a `LayoutEngine` protocol in the domain layer (interface) and implement it in the infrastructure layer (concrete implementation). This follows DDD's Dependency Inversion Principle:

```
Application Layer (uses LayoutEngine protocol)
       ↓
Domain Layer (defines LayoutEngine protocol)
       ↑ (implements)
Infrastructure Layer (SugiyamaLayoutEngine)
```

---

## 2. Implementation Approach

### 2.1 Architecture: Protocol Pattern (DDD)

**Decision**: Use Protocol pattern to define interface in domain layer, implement in infrastructure.

**Rationale:**
- Adheres to Clean Architecture (dependencies point inward)
- Enables future alternative implementations (force-directed, Dot)
- Makes application layer independent of layout algorithm choice
- Facilitates testing with mock implementations

**Layer Breakdown:**

| Layer | Artifact | Purpose |
|-------|----------|---------|
| **Domain** | `LayoutEngine` protocol | Defines contract for layout computation |
| **Infrastructure** | `SugiyamaLayoutEngine` class | Concrete implementation using Sugiyama algorithm |
| **Application** | Uses `LayoutEngine` | Dependency injection, no knowledge of Sugiyama |

### 2.2 LayoutEngine Protocol Design

**Location**: `src/ink/domain/services/layout_engine.py`

```python
from typing import Protocol, Dict, Set, Optional
from ink.domain.value_objects.position import Position
from ink.domain.value_objects.identifiers import CellId

class LayoutEngine(Protocol):
    """
    Protocol for layout computation engines.

    Implementations compute 2D positions for circuit cells
    based on graph structure and layout algorithms.
    """

    def compute_layout(
        self,
        graph: "Graph",
        visible_cells: Optional[Set[CellId]] = None
    ) -> Dict[CellId, Position]:
        """
        Compute positions for cells in the graph.

        Args:
            graph: Circuit graph with cells and edges
            visible_cells: Optional subset of cells to layout (None = all cells)

        Returns:
            Dictionary mapping cell IDs to 2D positions

        Raises:
            LayoutError: If layout computation fails
        """
        ...
```

**Design Choices:**
- **Simple interface**: Single method `compute_layout()`
- **Graph agnostic**: Accepts generic `Graph` (NetworkX in practice)
- **Incremental support**: `visible_cells` parameter for expansion use cases
- **Error handling**: Raises `LayoutError` on failures

### 2.3 SugiyamaLayoutEngine Implementation

**Location**: `src/ink/infrastructure/layout/sugiyama_engine.py`

**Class Structure:**

```python
@dataclass
class SugiyamaLayoutEngine:
    """
    Sugiyama hierarchical layout algorithm implementation.

    Implements the LayoutEngine protocol using a three-phase approach:
    1. Layer assignment based on longest path from sources
    2. Crossing minimization via barycentric method
    3. Coordinate assignment with configurable spacing
    """

    config: LayoutConfig

    def __init__(self, config: Optional[LayoutConfig] = None):
        self.config = config or LayoutConfig()
        self._cache: Dict[str, Dict[CellId, Position]] = {}

    def compute_layout(
        self,
        graph: nx.DiGraph,
        visible_cells: Optional[Set[CellId]] = None
    ) -> Dict[CellId, Position]:
        """Orchestrate three-phase layout computation."""
        # Implementation details below...
```

**Phase Orchestration:**

```python
def compute_layout(self, graph, visible_cells=None):
    # 1. Validation
    if not graph.nodes():
        return {}

    if visible_cells is not None:
        graph = graph.subgraph(visible_cells).copy()

    self._validate_graph(graph)

    # 2. Check cache
    cache_key = self._compute_cache_key(graph)
    if self.config.enable_cache and cache_key in self._cache:
        return self._cache[cache_key]

    try:
        # 3. Phase 1: Layer Assignment
        layer_assignment = self._assign_layers(graph)

        # 4. Phase 2: Crossing Minimization
        layer_order = self._minimize_crossings(graph, layer_assignment)

        # 5. Phase 3: Coordinate Assignment
        coord_assignment = self._assign_coordinates(graph, layer_assignment, layer_order)

        # 6. Cache and return
        if self.config.enable_cache:
            self._cache[cache_key] = coord_assignment.position_map

        return coord_assignment.position_map

    except Exception as e:
        raise LayoutError(f"Layout computation failed: {e}") from e
```

### 2.4 Configuration Management

**LayoutConfig Dataclass:**

```python
@dataclass
class LayoutConfig:
    """Configuration for Sugiyama layout engine."""

    layer_spacing: float = 200.0          # Horizontal spacing (px)
    cell_spacing: float = 100.0           # Vertical spacing (px)
    max_iterations: int = 10              # Crossing minimization iterations
    direction: str = "LR"                 # Layout direction (LR or TB)
    enable_cache: bool = True             # Enable result caching

    def __post_init__(self):
        """Validate configuration parameters."""
        if self.layer_spacing <= 0:
            raise ValueError("layer_spacing must be positive")
        if self.cell_spacing <= 0:
            raise ValueError("cell_spacing must be positive")
        if self.max_iterations < 1:
            raise ValueError("max_iterations must be >= 1")
        if self.direction not in ("LR", "TB"):
            raise ValueError("direction must be 'LR' or 'TB'")
```

**Configuration Override:**

```python
# Create engine with default config
engine = SugiyamaLayoutEngine()

# Or with custom config
custom_config = LayoutConfig(
    layer_spacing=250.0,
    cell_spacing=120.0,
    max_iterations=15
)
engine = SugiyamaLayoutEngine(custom_config)

# Compute layout
positions = engine.compute_layout(graph)
```

### 2.5 Caching Strategy

**Cache Key Generation:**

```python
def _compute_cache_key(self, graph: nx.DiGraph) -> str:
    """
    Compute cache key for layout results.

    Simple implementation: hash of node set and edge set.
    Future: Include graph metadata, cell types, etc.
    """
    nodes = tuple(sorted(graph.nodes()))
    edges = tuple(sorted(graph.edges()))
    return f"{hash(nodes)}_{hash(edges)}"
```

**Cache Management:**

```python
def clear_cache(self) -> None:
    """Clear layout result cache."""
    self._cache.clear()

def get_cache_stats(self) -> Dict[str, int]:
    """Return cache statistics."""
    return {
        "size": len(self._cache),
        "total_cells": sum(len(positions) for positions in self._cache.values())
    }
```

**Cache Invalidation**: Caller's responsibility to clear cache when graph changes.

---

## 3. Key Design Decisions

### Decision 1: Protocol in Domain vs. Infrastructure

**Choice**: Define `LayoutEngine` protocol in **domain layer**

**Rationale:**
- Domain layer defines contracts (interfaces), not implementations
- Application layer depends on domain protocol, not infrastructure
- Follows Dependency Inversion Principle
- Enables testing with mock implementations

**Alternative Rejected**: Define protocol in infrastructure → violates Clean Architecture

### Decision 2: Caching Strategy

**Choice**: Optional in-memory cache with manual invalidation

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| No caching | Simple, no stale data | Repeated computation | Rejected - performance impact |
| In-memory cache | Fast, simple | Manual invalidation needed | **Selected** |
| Persistent cache | Survives sessions | Complexity, serialization | Deferred to P1 |
| LRU cache | Auto eviction | May evict frequently used layouts | Deferred to P1 |

**Rationale**: In-memory cache provides 90% of the benefit with 10% of the complexity. Since graphs rarely change during a session, manual invalidation is acceptable.

### Decision 3: Error Handling Strategy

**Choice**: Raise `LayoutError` with descriptive messages, log phase progress

**Error Types:**
- `LayoutError`: Base exception for all layout failures
- Specific errors: `GraphValidationError`, `LayerAssignmentError`, etc. (future)

**Logging Strategy:**
```python
# Log phase completion
print(f"Layer assignment: {layer_count} layers, {feedback_edge_count} feedback edges")
print(f"Crossing minimization: {crossing_count} crossings")
print(f"Coordinate assignment: {cell_count} cells positioned")
```

**Future**: Replace `print()` with proper logging (`logging` module).

### Decision 4: Cell Dimension Integration

**Choice**: Placeholder implementation for MVP, integrate with E02-F01 later

**Temporary Implementation:**
```python
def _get_cell_dimensions(self, graph: nx.DiGraph) -> Dict[CellId, Tuple[float, float]]:
    """
    Get cell dimensions from graph metadata.

    TODO: Integrate with E02-F01 symbol rendering for actual dimensions.
    For now, use default dimensions.
    """
    return {
        cell: (80.0, 60.0)  # Default width, height
        for cell in graph.nodes()
    }
```

**Future Integration Point**: Call symbol provider service to get actual dimensions.

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E02-F02-T01: Layer Assignment**
- Provides `assign_layers()` function
- Returns `LayerAssignment` dataclass
- **Integration**: Call from `_assign_layers()` method

**E02-F02-T02: Crossing Minimization**
- Provides `minimize_crossings()` function
- Returns `LayerOrder` dataclass
- **Integration**: Call from `_minimize_crossings()` method

**E02-F02-T03: Coordinate Assignment**
- Provides `assign_coordinates()` function
- Returns `CoordinateAssignment` dataclass
- **Integration**: Call from `_assign_coordinates()` method

**E01-F02: Graph Construction**
- Provides NetworkX `DiGraph` structure
- **Integration**: Accept as parameter to `compute_layout()`

**E02-F01: Cell Symbol Rendering (Future)**
- Will provide cell dimensions
- **Integration**: Call `_get_cell_dimensions()` (currently placeholder)

### 4.2 Downstream Consumers

**Application Layer: ExpansionService**
- Uses `LayoutEngine` protocol for computing layouts during expansion
- **Integration**: Dependency injection via constructor

**Application Layer: FileService**
- Uses `LayoutEngine` for initial netlist layout
- **Integration**: Dependency injection via constructor

**E02-F03: Net Routing**
- Consumes layout positions for routing endpoints
- **Integration**: Receives `position_map` from layout result

**Presentation Layer: SchematicCanvas**
- Renders cells at computed positions
- **Integration**: Consumes `position_map` for rendering

### 4.3 Dependency Injection

**Application Layer Usage:**

```python
# In application service
class ExpansionService:
    def __init__(self, layout_engine: LayoutEngine):
        self._layout_engine = layout_engine

    def expand_cells(self, cells: Set[CellId]) -> None:
        # Compute layout for expanded subgraph
        positions = self._layout_engine.compute_layout(
            graph=self._graph,
            visible_cells=self._visible_cells
        )
        # Update rendering...
```

**Composition Root (Application Initialization):**

```python
# In main.py or app.py
def create_app() -> Application:
    # Infrastructure layer
    layout_config = LayoutConfig(layer_spacing=200, cell_spacing=100)
    layout_engine = SugiyamaLayoutEngine(layout_config)

    # Application layer
    expansion_service = ExpansionService(layout_engine)
    file_service = FileService(layout_engine)

    # Presentation layer
    main_window = MainWindow(expansion_service, file_service)

    return Application(main_window)
```

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Test Coverage Goals**: >85%

**Test Cases:**

```python
# Test 1: Protocol compliance
def test_sugiyama_engine_implements_protocol():
    """Verify SugiyamaLayoutEngine implements LayoutEngine protocol"""
    from ink.domain.services.layout_engine import LayoutEngine

    engine = SugiyamaLayoutEngine()
    assert isinstance(engine, LayoutEngine)  # Protocol check

# Test 2: Empty graph
def test_sugiyama_engine_empty_graph():
    """Empty graph should return empty position map"""
    engine = SugiyamaLayoutEngine()
    graph = nx.DiGraph()

    result = engine.compute_layout(graph)

    assert result == {}

# Test 3: Simple graph
def test_sugiyama_engine_simple_graph():
    """Simple graph should compute positions for all cells"""
    engine = SugiyamaLayoutEngine()
    graph = nx.DiGraph([("A", "B"), ("B", "C")])

    result = engine.compute_layout(graph)

    assert len(result) == 3
    assert all(isinstance(pos, Position) for pos in result.values())
    # Verify left-to-right flow
    assert result["A"].x < result["B"].x < result["C"].x

# Test 4: Configuration override
def test_sugiyama_engine_custom_config():
    """Custom configuration should be applied"""
    config = LayoutConfig(layer_spacing=300.0, cell_spacing=150.0)
    engine = SugiyamaLayoutEngine(config)
    graph = nx.DiGraph([("A", "B")])

    result = engine.compute_layout(graph)

    # Verify custom layer spacing applied
    assert result["B"].x == 300.0  # Layer 1 at 300px

# Test 5: Caching
def test_sugiyama_engine_caching():
    """Cached results should be returned on second call"""
    engine = SugiyamaLayoutEngine(LayoutConfig(enable_cache=True))
    graph = nx.DiGraph([("A", "B"), ("B", "C")])

    # First call - compute
    result1 = engine.compute_layout(graph)

    # Second call - cached (should be same object)
    result2 = engine.compute_layout(graph)

    assert result1 == result2
    assert engine.get_cache_stats()["size"] == 1

# Test 6: Cache clearing
def test_sugiyama_engine_cache_clear():
    """Cache should be clearable"""
    engine = SugiyamaLayoutEngine(LayoutConfig(enable_cache=True))
    graph = nx.DiGraph([("A", "B")])

    engine.compute_layout(graph)
    assert engine.get_cache_stats()["size"] == 1

    engine.clear_cache()
    assert engine.get_cache_stats()["size"] == 0

# Test 7: Error handling
def test_sugiyama_engine_invalid_graph():
    """Invalid graph should raise LayoutError"""
    engine = SugiyamaLayoutEngine()
    invalid_graph = "not a graph"  # Wrong type

    with pytest.raises(LayoutError):
        engine.compute_layout(invalid_graph)

# Test 8: visible_cells parameter
def test_sugiyama_engine_visible_cells():
    """visible_cells should filter graph to subset"""
    engine = SugiyamaLayoutEngine()
    graph = nx.DiGraph([("A", "B"), ("B", "C"), ("C", "D")])

    # Layout only A, B, C
    result = engine.compute_layout(graph, visible_cells={"A", "B", "C"})

    assert len(result) == 3
    assert "D" not in result

# Test 9: Configuration validation
def test_layout_config_validation():
    """Invalid configuration should raise ValueError"""
    with pytest.raises(ValueError):
        LayoutConfig(layer_spacing=-100)  # Negative spacing

    with pytest.raises(ValueError):
        LayoutConfig(max_iterations=0)  # Zero iterations

    with pytest.raises(ValueError):
        LayoutConfig(direction="INVALID")  # Invalid direction
```

### 5.2 Integration Tests

```python
def test_sugiyama_engine_full_pipeline():
    """Test complete pipeline with real netlist"""
    from ink.infrastructure.parsing.cdl_parser import CDLParser

    # Parse netlist
    parser = CDLParser()
    design = parser.parse_file("examples/adder_4bit.ckt")
    graph = build_graph_from_design(design)

    # Create engine
    engine = SugiyamaLayoutEngine()

    # Compute layout
    positions = engine.compute_layout(graph)

    # Verify all cells positioned
    assert len(positions) == len(graph.nodes())

    # Verify positions are valid
    for cell, pos in positions.items():
        assert isinstance(pos, Position)
        assert pos.x >= 0
        assert -10000 < pos.y < 10000

# Test with different configurations
def test_sugiyama_engine_configuration_variations():
    """Test various configuration combinations"""
    graph = generate_test_graph(num_nodes=100, avg_degree=3)

    configs = [
        LayoutConfig(layer_spacing=150, cell_spacing=80),
        LayoutConfig(layer_spacing=300, cell_spacing=150),
        LayoutConfig(max_iterations=5),
        LayoutConfig(max_iterations=20),
    ]

    for config in configs:
        engine = SugiyamaLayoutEngine(config)
        result = engine.compute_layout(graph)
        assert len(result) == 100  # All cells positioned
```

### 5.3 Performance Tests

```python
def test_sugiyama_engine_performance_1k_cells():
    """1000 cells should complete in <2s"""
    graph = generate_random_dag(num_nodes=1000, avg_degree=3)
    engine = SugiyamaLayoutEngine()

    start = time()
    result = engine.compute_layout(graph)
    duration = time() - start

    assert duration < 2.0, f"Took {duration:.3f}s, expected <2s"
    assert len(result) == 1000

def test_sugiyama_engine_performance_10k_cells():
    """10,000 cells should complete in <30s"""
    graph = generate_random_dag(num_nodes=10000, avg_degree=3)
    engine = SugiyamaLayoutEngine()

    start = time()
    result = engine.compute_layout(graph)
    duration = time() - start

    assert duration < 30.0, f"Took {duration:.3f}s, expected <30s"
    assert len(result) == 10000

def test_sugiyama_engine_cache_performance():
    """Cached layout should be instant"""
    graph = generate_random_dag(num_nodes=1000, avg_degree=3)
    engine = SugiyamaLayoutEngine(LayoutConfig(enable_cache=True))

    # First call - compute
    start = time()
    result1 = engine.compute_layout(graph)
    first_duration = time() - start

    # Second call - cached
    start = time()
    result2 = engine.compute_layout(graph)
    cached_duration = time() - start

    # Cached should be at least 100x faster
    assert cached_duration < first_duration / 100
```

### 5.4 Architectural Tests

```python
def test_protocol_in_domain_layer():
    """Verify LayoutEngine protocol is in domain layer"""
    from ink.domain.services.layout_engine import LayoutEngine
    import inspect

    module = inspect.getmodule(LayoutEngine)
    assert "domain" in module.__file__
    assert "infrastructure" not in module.__file__

def test_implementation_in_infrastructure_layer():
    """Verify SugiyamaLayoutEngine is in infrastructure layer"""
    from ink.infrastructure.layout.sugiyama_engine import SugiyamaLayoutEngine
    import inspect

    module = inspect.getmodule(SugiyamaLayoutEngine)
    assert "infrastructure" in module.__file__
    assert "domain" not in module.__file__

def test_no_infrastructure_imports_in_domain():
    """Domain layer should not import from infrastructure"""
    import ast
    domain_file = "src/ink/domain/services/layout_engine.py"

    with open(domain_file) as f:
        tree = ast.parse(f.read())

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                assert "infrastructure" not in alias.name
        elif isinstance(node, ast.ImportFrom):
            assert "infrastructure" not in node.module
```

---

## 6. Risks and Considerations

### Risk 1: Phase Integration Bugs

**Impact**: High
**Probability**: Medium
**Concern**: Data flowing between phases might have format mismatches

**Mitigation:**
- Comprehensive integration tests
- Type hints enforce correct data structures
- Validate phase outputs with assertions
- Unit test each phase wrapper method

### Risk 2: Performance Degradation from Orchestration

**Impact**: Medium
**Probability**: Low
**Concern**: Orchestration overhead might slow down overall layout

**Mitigation:**
- Profile each phase independently
- Orchestration is O(1) overhead, negligible
- Focus optimization on algorithm phases
- Performance tests validate overall targets

### Risk 3: Cache Invalidation Errors

**Impact**: Medium
**Probability**: Medium
**Concern**: Stale cached layouts might be returned after graph changes

**Mitigation:**
- Document cache invalidation responsibility (caller's job)
- Provide `clear_cache()` method
- Future: Automatic invalidation with graph hashing
- Add cache stats for debugging

### Risk 4: Configuration Complexity

**Impact**: Low
**Probability**: Low
**Concern**: Too many configuration parameters could confuse users

**Mitigation:**
- Sensible defaults for all parameters
- Validation in `LayoutConfig.__post_init__()`
- Documentation with examples
- Future: Configuration presets (compact, spacious, etc.)

### Risk 5: Protocol Type Checking

**Impact**: Low
**Probability**: Low
**Concern**: `Protocol` type checking only works with mypy, not runtime

**Mitigation:**
- Use mypy in CI/CD pipeline
- Runtime checks not critical (development-time issue)
- Consider `runtime_checkable` decorator if needed

---

## 7. Open Questions

### Q1: Should caching be enabled by default?

**Context**: Cache provides performance benefit but adds complexity

**Recommendation**: Yes - enable by default, users can opt-out

**Decision Needed By**: Before implementation

---

### Q2: Should we support incremental layout updates?

**Context**: When expanding cells, recompute only affected subgraph

**Recommendation**: Defer to P1 - full recomputation acceptable for MVP

**Decision Needed By**: P1 planning

---

### Q3: How to integrate cell dimensions from E02-F01?

**Context**: Need actual cell dimensions for accurate layout

**Options:**
- Pass symbol provider as constructor parameter
- Call symbol provider in `_get_cell_dimensions()`
- Store dimensions in graph metadata

**Recommendation**: Option 2 - call symbol provider service

**Decision Needed By**: After E02-F01 completion

---

## 8. Success Criteria

### Acceptance Criteria

- [ ] `LayoutEngine` protocol defined in domain layer
- [ ] `SugiyamaLayoutEngine` implements protocol correctly
- [ ] All three algorithm phases orchestrated properly
- [ ] Configuration parameters applied correctly
- [ ] Empty graphs handled without error
- [ ] Invalid graphs raise descriptive `LayoutError`
- [ ] Performance: <2s for 1K cells, <30s for 10K cells
- [ ] Layout caching works correctly (if enabled)
- [ ] Cache can be cleared manually
- [ ] Integration with E02-F01 cell dimensions (placeholder for MVP)
- [ ] Unit test coverage >85%
- [ ] No domain layer imports in infrastructure (architectural test)

### Definition of Done

- [ ] `LayoutEngine` protocol implemented in `domain/services/layout_engine.py`
- [ ] `SugiyamaLayoutEngine` implemented in `infrastructure/layout/sugiyama_engine.py`
- [ ] `LayoutConfig` dataclass implemented
- [ ] `LayoutError` exception defined
- [ ] All three phases integrated
- [ ] Caching implemented
- [ ] Configuration validation implemented
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Performance tests validated
- [ ] Architectural tests passing
- [ ] Code reviewed and approved
- [ ] Documentation complete with usage examples

---

## 9. Implementation Checklist

### Phase 1: Domain Protocol (1 hour)
- [ ] Create `domain/services/layout_engine.py`
- [ ] Define `LayoutEngine` protocol
- [ ] Define `LayoutError` exception
- [ ] Add type hints and docstrings
- [ ] Verify no infrastructure imports

### Phase 2: Configuration (1 hour)
- [ ] Create `LayoutConfig` dataclass
- [ ] Add parameter validation in `__post_init__()`
- [ ] Add sensible defaults
- [ ] Write unit tests for configuration

### Phase 3: Basic Implementation (2 hours)
- [ ] Create `infrastructure/layout/sugiyama_engine.py`
- [ ] Define `SugiyamaLayoutEngine` class
- [ ] Implement `__init__()` with config
- [ ] Implement basic `compute_layout()` method
- [ ] Add graph validation

### Phase 4: Phase Integration (3 hours)
- [ ] Implement `_assign_layers()` wrapper
- [ ] Implement `_minimize_crossings()` wrapper
- [ ] Implement `_assign_coordinates()` wrapper
- [ ] Integrate cell dimensions (placeholder)
- [ ] Add phase logging

### Phase 5: Caching (2 hours)
- [ ] Implement cache key generation
- [ ] Add cache check/store logic
- [ ] Implement `clear_cache()` method
- [ ] Implement `get_cache_stats()` method
- [ ] Write cache tests

### Phase 6: Error Handling (1 hour)
- [ ] Add try/catch in `compute_layout()`
- [ ] Raise `LayoutError` with context
- [ ] Add validation for empty graphs
- [ ] Handle `visible_cells` parameter

### Phase 7: Testing (3 hours)
- [ ] Write unit tests (protocol, config, caching)
- [ ] Write integration tests (full pipeline)
- [ ] Write performance tests (1k, 10k cells)
- [ ] Write architectural tests (layer separation)
- [ ] Achieve >85% coverage

### Phase 8: Documentation (1 hour)
- [ ] Write module docstrings
- [ ] Document protocol and implementation
- [ ] Add usage examples
- [ ] Document configuration parameters

**Total Estimated Time**: 10-12 hours (matches spec estimate)

---

## 10. References

### Architecture References
- Martin, Robert C., "Clean Architecture" - Dependency Inversion Principle
- Evans, Eric, "Domain-Driven Design" - Layered Architecture
- PEP 544 - Protocols: Structural subtyping (static duck typing)

### Implementation References
- Python `typing.Protocol`: https://docs.python.org/3/library/typing.html#typing.Protocol
- Dependency Injection in Python: https://python-dependency-injector.ets-labs.org/

### Internal References
- [Parent Feature Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/E02-F02.spec.md)
- [Architecture: DDD Architecture](/home/joohan/dev/project-ink/ink/docs/architecture/ddd-architecture.md)
- [Architecture: Layer Architecture](/home/joohan/dev/project-ink/ink/docs/architecture/layer-architecture.md)
- [Layer Assignment Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T01/E02-F02-T01.spec.md)
- [Crossing Minimization Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T02/E02-F02-T02.spec.md)
- [Coordinate Assignment Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T03/E02-F02-T03.spec.md)

---

**Document Status**: Ready for Implementation
**Next Steps**: Review with team, verify architectural decisions, begin implementation after T01-T03 completion
