---
id: E02-F02-T04
title: LayoutEngine Protocol and Integration
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F02
created: 2025-12-26
estimated_hours: 10
actual_hours:
effort: Medium
tags:
  - integration
  - architecture
  - protocol
---

# Spec: E02-F02-T04 - LayoutEngine Protocol and Integration

## 1. Overview

### 1.1 Problem Statement

The Sugiyama layout algorithm is implemented across three separate modules (layer assignment, crossing minimization, coordinate assignment), but the application layer needs a unified interface to compute layouts. The domain layer defines a `LayoutEngine` protocol that must be implemented in the infrastructure layer, orchestrating the three algorithm phases and providing a clean API for layout computation.

### 1.2 Goals

- Define `LayoutEngine` protocol in domain layer
- Implement `SugiyamaLayoutEngine` in infrastructure layer
- Orchestrate layer assignment, crossing minimization, and coordinate assignment
- Provide configuration options for layout parameters
- Support incremental layout updates for expansion operations
- Ensure proper error handling and validation

---

## 2. Executive Summary

This task creates the integration layer for the Sugiyama layout engine, implementing the `LayoutEngine` protocol defined in the domain layer. The `SugiyamaLayoutEngine` class orchestrates the three algorithm phases, manages configuration, and provides a unified interface for layout computation that can be used by the application layer.

---

## 3. Execution Flow

```
1. Initialize SugiyamaLayoutEngine
   → Input: layout_config (spacing, iterations, etc.)
   → Validate configuration parameters
   → If invalid config: ERROR "Invalid layout configuration: {details}"

2. Receive layout computation request
   → Input: compute_layout(graph, visible_cells)
   → Validate graph structure
   → If empty graph: Return empty position_map
   → If invalid graph: ERROR "Invalid graph structure"

3. Execute Phase 1: Layer Assignment
   → Call layer_assignment.assign_layers(graph)
   → Receive LayerAssignment(layer_map, reverse_edges, layer_count)
   → If assignment fails: ERROR "Layer assignment failed: {reason}"
   → Log: "Layer assignment complete: {layer_count} layers, {reverse_edge_count} feedback edges"

4. Execute Phase 2: Crossing Minimization
   → Call crossing_minimization.minimize_crossings(graph, layer_map, config.max_iterations)
   → Receive LayerOrder(layer_order, crossing_count)
   → If minimization fails: ERROR "Crossing minimization failed: {reason}"
   → Log: "Crossing minimization complete: {crossing_count} crossings"

5. Execute Phase 3: Coordinate Assignment
   → Get cell dimensions from symbol provider
   → Call coordinate_assignment.assign_coordinates(layer_map, layer_order, cell_dims, config)
   → Receive CoordinateAssignment(position_map, bounding_box)
   → If assignment fails: ERROR "Coordinate assignment failed: {reason}"
   → Log: "Coordinate assignment complete: {cell_count} cells positioned"

6. Cache layout results (optional)
   → Store position_map for incremental updates
   → Cache key: graph_hash + visible_cells_hash
   → If cache hit on future calls: Return cached results

7. Return layout results
   → Return: SUCCESS with position_map
   → Include metadata: bounding_box, layer_count, crossing_count
```

---

## 4. User Stories

### Primary User Story
**As a** application service
**I want to** compute cell positions using a unified layout engine
**So that** I can render schematics without knowing layout algorithm details

### Additional Stories
- **As a** developer, **I want to** configure layout parameters, **So that** I can tune layout quality vs performance
- **As a** user, **I want to** fast incremental layout updates, **So that** expansion operations are responsive
- **As a** developer, **I want to** swap layout algorithms easily, **So that** I can experiment with alternatives

---

## 5. Acceptance Scenarios

### Scenario 1: Full Layout Computation
**Given** a circuit graph with 100 cells
**When** `compute_layout(graph)` is called
**Then** all three phases execute, position_map returned with 100 entries

### Scenario 2: Empty Graph
**Given** an empty graph with no cells
**When** `compute_layout(graph)` is called
**Then** returns empty position_map without error

### Scenario 3: Configuration Override
**Given** a layout engine with default config
**When** `compute_layout(graph, config_override)` is called with custom spacing
**Then** custom spacing applied in coordinate assignment phase

### Scenario 4: Incremental Update
**Given** a previously computed layout with 50 cells visible
**When** 10 new cells are added and `compute_layout` called
**Then** only new cells repositioned, existing cells remain stable (if supported)

### Scenario 5: Error Handling
**Given** a graph with invalid structure (e.g., missing node data)
**When** `compute_layout(graph)` is called
**Then** raises descriptive error, no partial layout returned

---

## 6. Requirements

### Functional Requirements
- **FR-001**: MUST implement `LayoutEngine` protocol from domain layer
- **FR-002**: MUST orchestrate layer assignment, crossing minimization, coordinate assignment
- **FR-003**: MUST support configurable layout parameters (spacing, iterations)
- **FR-004**: MUST validate input graph structure before processing
- **FR-005**: MUST return complete position map for all visible cells
- **FR-006**: MUST handle empty graphs gracefully
- **FR-007**: SHOULD support layout result caching for performance

### Non-Functional Requirements
- **NFR-001**: Performance: Complete layout for 1000 cells in <2 seconds
- **NFR-002**: Performance: Complete layout for 10,000 cells in <30 seconds
- **NFR-003**: Reliability: Fail gracefully with descriptive errors
- **NFR-004**: Maintainability: Clean separation between algorithm phases
- **NFR-005**: Testability: Each phase testable independently

### Technical Constraints
- **TC-001**: Must adhere to DDD architecture (Protocol in domain, implementation in infrastructure)
- **TC-002**: Must work with NetworkX graph structure
- **TC-003**: Must integrate with cell symbol dimensions from E02-F01
- **TC-004**: Must be usable from application layer services

---

## 7. Key Entities

### Protocol: LayoutEngine (Domain Layer)
- **Description**: Interface for layout computation engines
- **Location**: `src/ink/domain/services/layout_engine.py`
- **Methods**:
  - `compute_layout(graph: Graph, visible_cells: Optional[Set[CellId]] = None) -> Dict[CellId, Position]`
- **Relationships**: Implemented by `SugiyamaLayoutEngine`

### Class: SugiyamaLayoutEngine (Infrastructure Layer)
- **Description**: Sugiyama algorithm implementation of LayoutEngine protocol
- **Location**: `src/ink/infrastructure/layout/sugiyama_engine.py`
- **Key Attributes**:
  - `config: LayoutConfig`
  - `_cache: Optional[Dict]` - Layout result cache
- **Methods**:
  - `__init__(config: LayoutConfig)`
  - `compute_layout(graph, visible_cells) -> Dict[CellId, Position]`
  - `_assign_layers(graph) -> LayerAssignment`
  - `_minimize_crossings(graph, layer_map) -> LayerOrder`
  - `_assign_coordinates(layer_map, layer_order) -> CoordinateAssignment`
- **Relationships**: Uses T01, T02, T03 algorithm modules

### Entity: LayoutConfig
- **Description**: Configuration for Sugiyama layout engine
- **Location**: `src/ink/infrastructure/layout/sugiyama_engine.py`
- **Key Attributes**:
  - `layer_spacing: float` (default: 200.0)
  - `cell_spacing: float` (default: 100.0)
  - `max_iterations: int` (default: 10)
  - `direction: str` (default: "LR")
  - `enable_cache: bool` (default: True)
- **Relationships**: Input to SugiyamaLayoutEngine

---

## 8. Dependencies

### Upstream Dependencies
- [x] E02-F02-T01: Layer assignment implementation
- [x] E02-F02-T02: Crossing minimization implementation
- [x] E02-F02-T03: Coordinate assignment implementation
- [x] E02-F01: Cell symbol dimensions
- [x] E01-F02: Graph construction provides NetworkX DiGraph

### Downstream Impact
- [ ] Application layer: ExpansionService uses LayoutEngine
- [ ] E02-F03: Net routing uses layout results
- [ ] E03: Incremental expansion uses layout updates
- [ ] Presentation layer: SchematicCanvas renders using positions

---

## 9. Implementation Details

### Domain Layer Protocol Definition

```python
# src/ink/domain/services/layout_engine.py

from typing import Protocol, Dict, Set, Optional
from ink.domain.value_objects.position import Position
from ink.domain.value_objects.identifiers import CellId


class LayoutEngine(Protocol):
    """
    Protocol for layout computation engines.

    Implementations compute 2D positions for circuit cells
    based on graph structure and layout algorithms.
    """

    def compute_layout(
        self,
        graph: "Graph",
        visible_cells: Optional[Set[CellId]] = None
    ) -> Dict[CellId, Position]:
        """
        Compute positions for cells in the graph.

        Args:
            graph: Circuit graph with cells and edges
            visible_cells: Optional set of cells to layout (None = all cells)

        Returns:
            Dictionary mapping cell IDs to 2D positions

        Raises:
            LayoutError: If layout computation fails
        """
        ...
```

### Infrastructure Layer Implementation

```python
# src/ink/infrastructure/layout/sugiyama_engine.py

from dataclasses import dataclass
from typing import Dict, Set, Optional
import networkx as nx

from ink.domain.services.layout_engine import LayoutEngine
from ink.domain.value_objects.position import Position
from ink.domain.value_objects.identifiers import CellId

from .layer_assignment import assign_layers, LayerAssignment
from .crossing_minimization import minimize_crossings, LayerOrder
from .coordinate_assignment import assign_coordinates, CoordinateAssignment, LayoutConfig


class LayoutError(Exception):
    """Raised when layout computation fails."""
    pass


@dataclass
class SugiyamaLayoutEngine:
    """
    Sugiyama hierarchical layout algorithm implementation.

    Implements the LayoutEngine protocol using a three-phase approach:
    1. Layer assignment based on longest path from sources
    2. Crossing minimization via barycentric method
    3. Coordinate assignment with configurable spacing
    """

    config: LayoutConfig

    def __init__(self, config: Optional[LayoutConfig] = None):
        """
        Initialize Sugiyama layout engine.

        Args:
            config: Layout configuration parameters
        """
        self.config = config or LayoutConfig()
        self._cache: Dict[str, Dict[CellId, Position]] = {}

    def compute_layout(
        self,
        graph: nx.DiGraph,
        visible_cells: Optional[Set[CellId]] = None
    ) -> Dict[CellId, Position]:
        """
        Compute positions for cells using Sugiyama algorithm.

        Args:
            graph: Circuit graph (NetworkX DiGraph)
            visible_cells: Optional subset of cells to layout

        Returns:
            Dictionary mapping cell IDs to positions

        Raises:
            LayoutError: If layout computation fails
        """
        # Handle empty graph
        if not graph.nodes():
            return {}

        # Filter graph to visible cells if specified
        if visible_cells is not None:
            graph = graph.subgraph(visible_cells).copy()

        # Validate graph
        self._validate_graph(graph)

        # Check cache
        cache_key = self._compute_cache_key(graph)
        if self.config.enable_cache and cache_key in self._cache:
            return self._cache[cache_key]

        try:
            # Phase 1: Layer Assignment
            layer_assignment = self._assign_layers(graph)
            print(f"Layer assignment: {layer_assignment.layer_count} layers, "
                  f"{len(layer_assignment.reverse_edges)} feedback edges")

            # Phase 2: Crossing Minimization
            layer_order = self._minimize_crossings(graph, layer_assignment)
            print(f"Crossing minimization: {layer_order.crossing_count} crossings")

            # Phase 3: Coordinate Assignment
            coordinate_assignment = self._assign_coordinates(
                graph, layer_assignment, layer_order
            )
            print(f"Coordinate assignment: {len(coordinate_assignment.position_map)} cells positioned")

            # Cache results
            if self.config.enable_cache:
                self._cache[cache_key] = coordinate_assignment.position_map

            return coordinate_assignment.position_map

        except Exception as e:
            raise LayoutError(f"Layout computation failed: {e}") from e

    def _assign_layers(self, graph: nx.DiGraph) -> LayerAssignment:
        """Phase 1: Assign cells to layers."""
        return assign_layers(graph)

    def _minimize_crossings(
        self,
        graph: nx.DiGraph,
        layer_assignment: LayerAssignment
    ) -> LayerOrder:
        """Phase 2: Minimize edge crossings."""
        return minimize_crossings(
            graph,
            layer_assignment.layer_map,
            max_iterations=self.config.max_iterations
        )

    def _assign_coordinates(
        self,
        graph: nx.DiGraph,
        layer_assignment: LayerAssignment,
        layer_order: LayerOrder
    ) -> CoordinateAssignment:
        """Phase 3: Assign X/Y coordinates."""
        # Get cell dimensions (placeholder - will integrate with E02-F01)
        cell_dimensions = self._get_cell_dimensions(graph)

        return assign_coordinates(
            layer_assignment.layer_map,
            layer_order.layer_order,
            cell_dimensions,
            self.config
        )

    def _get_cell_dimensions(self, graph: nx.DiGraph) -> Dict[CellId, tuple[float, float]]:
        """
        Get cell dimensions from graph metadata.

        TODO: Integrate with E02-F01 symbol rendering for actual dimensions.
        For now, use default dimensions.
        """
        return {
            cell: (80.0, 60.0)  # Default width, height
            for cell in graph.nodes()
        }

    def _validate_graph(self, graph: nx.DiGraph) -> None:
        """
        Validate graph structure before layout.

        Raises:
            LayoutError: If graph is invalid
        """
        if not isinstance(graph, nx.DiGraph):
            raise LayoutError("Graph must be a NetworkX DiGraph")

        # Add additional validation as needed

    def _compute_cache_key(self, graph: nx.DiGraph) -> str:
        """
        Compute cache key for layout results.

        Simple implementation: hash of node set and edge set.
        """
        nodes = tuple(sorted(graph.nodes()))
        edges = tuple(sorted(graph.edges()))
        return f"{hash(nodes)}_{hash(edges)}"

    def clear_cache(self) -> None:
        """Clear layout result cache."""
        self._cache.clear()
```

### Configuration Management

```python
# Example usage from application layer

from ink.infrastructure.layout.sugiyama_engine import SugiyamaLayoutEngine, LayoutConfig

# Create engine with custom configuration
config = LayoutConfig(
    layer_spacing=250.0,      # Wider layer spacing
    cell_spacing=120.0,       # More vertical spacing
    max_iterations=15,        # More crossing reduction iterations
    enable_cache=True         # Enable caching
)

engine = SugiyamaLayoutEngine(config)
positions = engine.compute_layout(circuit_graph)
```

---

## 10. Acceptance Criteria

- [ ] `LayoutEngine` protocol defined in domain layer
- [ ] `SugiyamaLayoutEngine` implements protocol correctly
- [ ] All three algorithm phases orchestrated properly
- [ ] Configuration parameters applied correctly
- [ ] Empty graphs handled without error
- [ ] Invalid graphs raise descriptive errors
- [ ] Performance: <2s for 1K cells, <30s for 10K cells
- [ ] Layout caching works correctly (if enabled)
- [ ] Integration with E02-F01 symbol dimensions

---

## 11. Testing Strategy

### Unit Tests
- Test protocol compliance
- Test each phase integration
- Test configuration handling
- Test error handling
- Test cache functionality
- Test empty/single-cell graphs

### Integration Tests
- Test full layout pipeline with real graphs
- Test with various graph topologies
- Test configuration overrides
- Test cache hit/miss scenarios
- Test integration with NetworkX adapter
- Test integration with symbol dimensions

### Performance Tests
- Benchmark 1K, 10K, 100K cell graphs
- Measure phase execution times
- Profile cache effectiveness
- Verify overall performance targets

### Architectural Tests
- Verify protocol in domain layer
- Verify implementation in infrastructure layer
- Test dependency injection compatibility
- Verify no domain layer imports in infrastructure

---

## 12. Success Criteria

### Acceptance Criteria
- [ ] Protocol properly defined in domain layer
- [ ] Implementation correctly orchestrates all phases
- [ ] Configuration system working
- [ ] Performance targets met (<2s for 1K cells)
- [ ] Zero critical integration bugs
- [ ] 85% test coverage

### Definition of Done
- [ ] `LayoutEngine` protocol implemented in `domain/services/`
- [ ] `SugiyamaLayoutEngine` implemented in `infrastructure/layout/`
- [ ] Unit and integration tests passing
- [ ] Performance tests validated
- [ ] Documentation complete
- [ ] Code reviewed and approved
- [ ] Integration with application layer verified

---

## 13. Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Phase integration bugs | Medium | High | Comprehensive integration tests |
| Performance degradation from orchestration | Low | Medium | Profile each phase, optimize bottlenecks |
| Cache invalidation errors | Low | Medium | Clear cache invalidation strategy |
| Configuration complexity | Low | Low | Sensible defaults, validation |

---

## 14. Notes and Clarifications

### Design Decisions
- 2025-12-26: Protocol in domain layer ensures clean architecture compliance
- 2025-12-26: Caching optional (configurable) to support different use cases
- 2025-12-26: Cell dimension integration deferred to E02-F01 completion
- 2025-12-26: Simple cache key using node/edge hashes (can be improved later)

### Integration Points
- Application layer: `ExpansionService` will use `LayoutEngine` protocol
- Domain layer: Protocol defines contract, no implementation
- Infrastructure layer: `SugiyamaLayoutEngine` provides concrete implementation
- Presentation layer: Uses layout results for rendering

### Future Enhancements
- Incremental layout updates (only recompute changed regions)
- Multiple layout algorithm implementations (force-directed, orthogonal)
- Advanced caching strategies (partial graph caching)
- Layout quality metrics and reporting

---

## 15. Artifacts

### Input Documents
- [Parent Feature Spec](../E02-F02.spec.md)
- [Architecture: DDD Architecture](../../../../docs/architecture/ddd-architecture.md)
- [Architecture: Layer Architecture](../../../../docs/architecture/layer-architecture.md)

### Output Artifacts
- [ ] `domain/services/layout_engine.py` - Protocol definition
- [ ] `infrastructure/layout/sugiyama_engine.py` - Implementation
- [ ] `test_sugiyama_engine.py` - Unit and integration tests
- [ ] Module docstring documentation
- [ ] Configuration examples

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F02 split |
