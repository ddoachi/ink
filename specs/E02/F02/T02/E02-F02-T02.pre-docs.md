# E02-F02-T02 - Crossing Minimization Algorithm: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F02-T02
- **Task**: Crossing Minimization Algorithm
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the second phase of the Sugiyama hierarchical layout algorithm: crossing minimization. After cells have been assigned to layers, this phase optimizes the ordering of cells within each layer to reduce edge crossings between adjacent layers, dramatically improving schematic readability.

**Core Deliverables:**
- Barycentric heuristic for crossing minimization
- Bi-directional sweep (top-down and bottom-up)
- Configurable iteration limit for time/quality tradeoff
- Crossing count computation for validation

**Success Metrics:**
- Reduce edge crossings by 50%+ compared to random ordering
- Performance: <500ms for 1000 cells with 10 iterations
- Convergence: Reach near-optimal within 10 iterations
- Quality: <5% crossing rate on typical netlists

### 1.2 Problem Context

Edge crossings are the primary source of visual clutter in schematic diagrams. After layer assignment establishes horizontal layers, the initial ordering of cells within each layer is arbitrary (or alphabetical). This random ordering typically produces excessive crossings:

**Example:**
```
Layer 0:  [A, B]     Layer 1:  [C, D]
Edges:    A -> D, B -> C

Initial (random):
A ----\    /---- C
       X
B ----/    \---- D
Result: 1 crossing

After optimization:
B ---------> C
A ---------> D
Result: 0 crossings
```

The crossing minimization phase reorders cells within layers to minimize such crossings, making signal flow easier to trace.

---

## 2. Implementation Approach

### 2.1 Algorithm Selection: Barycentric Method with Bi-directional Sweeps

**Decision**: Use barycentric heuristic with alternating top-down and bottom-up sweeps.

**Rationale:**
- Barycentric method is simple, fast O(E) per iteration, and produces good results
- Bi-directional sweeps (forward/backward) improve convergence
- Well-studied algorithm with proven effectiveness
- Alternative (median heuristic) performs similarly but barycentric is smoother

**Algorithm Overview:**

```
Initialize: layer_order[i] = arbitrary ordering for each layer i

For iteration = 1 to max_iterations:

  # Top-down sweep
  For layer i = 1 to N-1:
    For each cell in layer i:
      barycenter = average position of predecessors in layer i-1
    Sort cells in layer i by barycenter value

  # Bottom-up sweep
  For layer i = N-2 to 0:
    For each cell in layer i:
      barycenter = average position of successors in layer i+1
    Sort cells in layer i by barycenter value

  # Check convergence
  If crossing_count unchanged for 3 iterations:
    BREAK (early termination)

Return: optimized layer_order
```

**Time Complexity**: O(I × E) where I = iterations, E = edges
**Space Complexity**: O(V) for layer orderings

### 2.2 Barycentric Calculation

**Barycenter Definition**: Weighted average position of connected neighbors in adjacent layer.

**Formula:**
```
barycenter(cell, adjacent_layer) = (Σ position(neighbor)) / count(neighbors)

where neighbors = predecessors (top-down) or successors (bottom-up)
```

**Example:**
```
Layer 0: [A:0, B:1, C:2]    Layer 1: [X, Y, Z]

For cell X with edges from A and C:
barycenter(X) = (0 + 2) / 2 = 1.0

Sorting layer 1 by barycenter gives optimal ordering.
```

**Edge Cases:**
- Cell with no neighbors: barycenter = 0 (or current position)
- Barycenter ties: use stable sort (preserve relative order) or secondary key (cell ID)

### 2.3 Crossing Count Algorithm

**Challenge**: Efficiently count crossings between two layers.

**Naive Approach**: O(E²) - check every edge pair

**Optimized Approach**: Sweep-line algorithm O(E log E)

```python
def count_crossings(layer1: List[CellId], layer2: List[CellId], edges: List[Edge]) -> int:
    """
    Count crossings between two adjacent layers.

    Two edges (a1, b1) and (a2, b2) cross if:
    (a1 < a2 and b1 > b2) or (a1 > a2 and b1 < b2)
    """
    # Build position maps
    pos1 = {cell: idx for idx, cell in enumerate(layer1)}
    pos2 = {cell: idx for idx, cell in enumerate(layer2)}

    # Extract edge positions
    edge_positions = []
    for u, v in edges:
        if u in pos1 and v in pos2:
            edge_positions.append((pos1[u], pos2[v]))

    # Count crossings (naive O(E²) for MVP)
    count = 0
    for i, (a1, b1) in enumerate(edge_positions):
        for a2, b2 in edge_positions[i+1:]:
            if (a1 < a2 and b1 > b2) or (a1 > a2 and b1 < b2):
                count += 1

    return count
```

**Note**: For MVP, use naive O(E²) counting. If performance issues arise, implement sweep-line optimization.

### 2.4 Data Structures

**Input:**
- `graph: nx.DiGraph` - Circuit graph with edges
- `layer_map: Dict[CellId, int]` - From T01 (layer assignment)
- `max_iterations: int` - Default 10

**Output:**
- `LayerOrder` dataclass:
  ```python
  @dataclass
  class LayerOrder:
      layer_order: Dict[int, List[CellId]]  # Layer number -> ordered cells
      crossing_count: int  # Final crossing count
  ```

**Internal:**
- `barycenters: List[Tuple[CellId, float]]` - Cell and its barycenter value
- `best_order: Dict[int, List[CellId]]` - Best ordering found so far
- `best_crossings: int` - Best crossing count achieved

---

## 3. Key Design Decisions

### Decision 1: Barycentric vs. Median Heuristic

**Choice**: Barycentric (average position)

**Alternatives Considered:**
- **Median heuristic**: Uses median position instead of average
- **Split method**: More complex, better results but slower

**Comparison:**

| Method | Pros | Cons | Verdict |
|--------|------|------|---------|
| Barycentric | Simple, smooth convergence | Sensitive to outliers | **Selected** |
| Median | More stable, less sensitive | Discrete jumps, slower convergence | Deferred to P1 |
| Split | Best quality | Complex, slower | Rejected for MVP |

**Rationale**: Barycentric performs well in practice (typically 10-15% worse than optimal but 100x faster than exact algorithms). Simplicity reduces implementation risk.

### Decision 2: Bi-directional vs. Single-direction Sweep

**Choice**: Bi-directional (top-down + bottom-up alternating)

**Rationale**: Bi-directional sweeps improve quality by 10-15% with minimal cost. Single-direction can get stuck in local minima.

### Decision 3: Iteration Limit and Early Termination

**Choice**: Default 10 iterations with early termination if no improvement for 3 consecutive iterations.

**Rationale:**
- Most graphs converge within 5-10 iterations
- Early termination saves time on already-optimal orderings
- 3-iteration window avoids premature termination on oscillating cases

**Configurable**: Users can override `max_iterations` for quality/speed tradeoff.

### Decision 4: Tie-breaking Strategy

**Choice**: Stable sort (preserve relative order) with optional secondary key (cell ID).

**Alternatives:**
- Random tie-breaking: Non-deterministic, harder to test
- Always use cell ID: More deterministic but may not be optimal

**Rationale**: Stable sort is fast, deterministic, and works well in practice.

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E02-F02-T01: Layer Assignment**
- Provides `layer_map: Dict[CellId, int]`
- Needed to group cells by layer
- **Integration Point**: Receive `LayerAssignment.layer_map`

**E01-F02: Graph Construction**
- Provides `nx.DiGraph` with edges for crossing analysis
- **Integration Point**: Use `graph.predecessors()`, `graph.successors()`

### 4.2 Downstream Consumers

**E02-F02-T03: Coordinate Assignment**
- Consumes `layer_order: Dict[int, List[CellId]]`
- Uses cell ordering to assign Y coordinates
- **Interface**: Pass `LayerOrder` object

**E02-F02-T04: SugiyamaLayoutEngine**
- Orchestrates crossing minimization as Phase 2
- Handles iteration configuration
- **Interface**: Call `minimize_crossings(graph, layer_map, max_iterations)`

### 4.3 Domain Layer Integration

**Location**: `src/ink/infrastructure/layout/crossing_minimization.py`

**Note**: Like layer assignment, this is infrastructure code (algorithm implementation). Domain layer only defines the `LayoutEngine` protocol.

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Test Coverage Goals**: >85%

**Test Cases:**

```python
# Test 1: Simple two-layer crossing
def test_crossing_minimization_simple():
    """
    Layer 0: [A, B]   Layer 1: [C, D]
    Edges: A->D, B->C (crossing)
    Expected: Reorder to eliminate crossing
    """
    graph = nx.DiGraph([("A", "D"), ("B", "C")])
    layer_map = {"A": 0, "B": 0, "C": 1, "D": 1}

    result = minimize_crossings(graph, layer_map, max_iterations=10)

    # Verify crossing eliminated
    assert result.crossing_count == 0
    # Valid reorderings: [B,A] + [C,D] or [A,B] + [D,C]
    order_0 = result.layer_order[0]
    order_1 = result.layer_order[1]
    # Check A->D and B->C don't cross
    if order_0.index("A") < order_0.index("B"):
        assert order_1.index("D") < order_1.index("C")
    else:
        assert order_1.index("C") < order_1.index("D")

# Test 2: Already optimal
def test_crossing_minimization_already_optimal():
    """Graph with no crossings should terminate early"""
    graph = nx.DiGraph([("A", "C"), ("B", "D")])
    layer_map = {"A": 0, "B": 0, "C": 1, "D": 1}

    result = minimize_crossings(graph, layer_map, max_iterations=10)

    assert result.crossing_count == 0
    # Should terminate early (no iterations needed)

# Test 3: Multi-layer graph
def test_crossing_minimization_three_layers():
    """Test with 3 layers and multiple crossings"""
    # Layer 0: [A, B]  Layer 1: [C, D]  Layer 2: [E, F]
    # Edges create crossings, verify reduction
    graph = nx.DiGraph([
        ("A", "D"), ("B", "C"),  # Layer 0->1 crossing
        ("C", "F"), ("D", "E")   # Layer 1->2 crossing
    ])
    layer_map = {"A": 0, "B": 0, "C": 1, "D": 1, "E": 2, "F": 2}

    initial_order = {"0": ["A", "B"], "1": ["C", "D"], "2": ["E", "F"]}
    initial_crossings = count_total_crossings(graph, initial_order)

    result = minimize_crossings(graph, layer_map, max_iterations=10)

    # Verify improvement
    assert result.crossing_count < initial_crossings

# Test 4: Single layer
def test_crossing_minimization_single_layer():
    """Single layer should return unchanged"""
    graph = nx.DiGraph()
    graph.add_nodes_from(["A", "B", "C"])
    layer_map = {"A": 0, "B": 0, "C": 0}

    result = minimize_crossings(graph, layer_map, max_iterations=10)

    assert result.crossing_count == 0
    assert len(result.layer_order[0]) == 3

# Test 5: Convergence test
def test_crossing_minimization_convergence():
    """Verify early termination when converged"""
    graph = generate_test_graph(num_layers=5, cells_per_layer=10)
    layer_map = build_layer_map(graph)

    result = minimize_crossings(graph, layer_map, max_iterations=100)

    # Should terminate early, not run all 100 iterations
    # (Check via logging or instrumentation)

# Test 6: Barycenter calculation
def test_barycenter_calculation():
    """Test barycenter formula"""
    # Cell X has predecessors at positions 0, 2, 4
    positions = [0, 2, 4]
    barycenter = sum(positions) / len(positions)
    assert barycenter == 2.0

    # Cell with no predecessors
    positions = []
    barycenter = sum(positions) / len(positions) if positions else 0
    assert barycenter == 0

# Test 7: Crossing count accuracy
def test_crossing_count():
    """Verify crossing count algorithm"""
    # Two edges that cross
    layer1 = ["A", "B"]
    layer2 = ["C", "D"]
    edges = [("A", "D"), ("B", "C")]  # These cross

    count = count_crossings_between_layers(layer1, layer2, edges)
    assert count == 1

    # Two edges that don't cross
    edges = [("A", "C"), ("B", "D")]
    count = count_crossings_between_layers(layer1, layer2, edges)
    assert count == 0

# Test 8: Quality test on random graph
def test_crossing_reduction_quality():
    """Verify >50% reduction on random graph"""
    graph = generate_random_dag(num_nodes=100, avg_degree=3)
    layer_map = assign_layers(graph).layer_map

    # Compute initial crossings with random order
    initial_order = create_random_layer_order(layer_map)
    initial_crossings = count_total_crossings(graph, initial_order)

    # Run optimization
    result = minimize_crossings(graph, layer_map, max_iterations=10)

    # Verify >50% reduction
    reduction = (initial_crossings - result.crossing_count) / initial_crossings
    assert reduction > 0.5, f"Only {reduction*100:.1f}% reduction"
```

### 5.2 Performance Tests

```python
def test_crossing_minimization_performance_1k_cells():
    """1000 cells, 10 iterations should complete in <500ms"""
    graph = generate_random_dag(num_nodes=1000, avg_degree=3)
    layer_map = assign_layers(graph).layer_map

    start = time()
    result = minimize_crossings(graph, layer_map, max_iterations=10)
    duration = time() - start

    assert duration < 0.5, f"Took {duration:.3f}s, expected <0.5s"

def test_crossing_minimization_performance_10k_cells():
    """10,000 cells, 10 iterations should complete in <10s"""
    graph = generate_random_dag(num_nodes=10000, avg_degree=3)
    layer_map = assign_layers(graph).layer_map

    start = time()
    result = minimize_crossings(graph, layer_map, max_iterations=10)
    duration = time() - start

    assert duration < 10.0, f"Took {duration:.3f}s, expected <10s"
```

### 5.3 Integration Tests

```python
def test_crossing_minimization_integration_with_t01():
    """Test full pipeline: layer assignment -> crossing minimization"""
    from ink.infrastructure.layout.layer_assignment import assign_layers

    # Use real netlist
    graph = parse_netlist("examples/adder_4bit.ckt")

    # Phase 1: Layer assignment
    layer_result = assign_layers(graph)

    # Phase 2: Crossing minimization
    order_result = minimize_crossings(
        graph,
        layer_result.layer_map,
        max_iterations=10
    )

    # Verify all cells present
    all_cells = set()
    for cells in order_result.layer_order.values():
        all_cells.update(cells)
    assert all_cells == set(graph.nodes())

    # Verify forward flow maintained
    for u, v in graph.edges():
        if (u, v) not in layer_result.reverse_edges:
            assert layer_result.layer_map[u] < layer_result.layer_map[v]
```

---

## 6. Risks and Considerations

### Risk 1: Local Minima Convergence

**Impact**: Medium
**Probability**: Medium
**Concern**: Barycentric method can converge to poor local minima

**Example**: Graph structure causes oscillation between two orderings with same crossing count

**Mitigation:**
- Bi-directional sweeps reduce local minima risk
- Track best ordering across all iterations
- Future: Multi-start with different initial orderings
- Accept <10% suboptimality for MVP

### Risk 2: Performance Degradation on Dense Graphs

**Impact**: High
**Probability**: Medium
**Concern**: O(E²) crossing count becomes bottleneck on graphs with many edges

**Symptoms**: >10s for 1000 cells with high fanout

**Mitigation:**
- Profile with high-fanout test cases
- Implement sweep-line O(E log E) crossing count if needed
- Reduce iteration count for very dense graphs
- Add progress indicator for long computations

### Risk 3: Unstable Ordering Due to Ties

**Impact**: Low
**Probability**: Medium
**Concern**: Cells with identical barycenters may swap randomly, preventing convergence

**Mitigation:**
- Use stable sort (preserves relative order)
- Secondary sort key (cell ID) for determinism
- Track iteration count to prevent infinite loops

### Risk 4: Quality Degradation on Wide Layers

**Impact**: Medium
**Probability**: Low
**Concern**: Layers with 100+ cells may have poor optimization

**Mitigation:**
- Test with wide-layer netlists
- Consider layer splitting if >100 cells detected
- Profile performance on wide layers
- Accept some suboptimality for very wide layers

### Risk 5: Incorrect Crossing Count

**Impact**: High
**Probability**: Low
**Concern**: Bug in crossing count algorithm produces incorrect metrics

**Mitigation:**
- Comprehensive unit tests for crossing count
- Visual validation (manually count crossings on small graphs)
- Cross-check with alternative implementation
- Add assertions in debug mode

---

## 7. Open Questions

### Q1: Should we support weighted edges for priority routing?

**Context**: Critical paths (e.g., clock nets) should minimize crossings more than others

**Options:**
- Use weighted barycenter (multiply by edge weight)
- Post-process to prioritize critical nets

**Recommendation**: Defer to P1 - requires domain knowledge of "critical" nets

**Decision Needed By**: P1 planning

---

### Q2: How to handle very wide layers (>100 cells)?

**Context**: Barycentric method may struggle with layers containing many cells

**Options:**
- Split wide layers into sub-layers
- Use alternative algorithm (median heuristic)
- Accept reduced quality

**Recommendation**: Profile performance, implement splitting if needed

**Decision Needed By**: After performance testing

---

### Q3: Should we visualize crossing reduction progress?

**Context**: Users might want to see optimization in real-time

**Recommendation**: Not for MVP - silent optimization is fine. Add progress indicator if users report slow layouts.

**Decision Needed By**: User feedback from MVP

---

## 8. Success Criteria

### Acceptance Criteria

- [ ] Crossing count reduced by >50% compared to random ordering on test graphs
- [ ] Bi-directional sweeps (top-down and bottom-up) implemented
- [ ] Early termination when no improvement detected (3 iterations)
- [ ] Configurable iteration count working
- [ ] Performance: <500ms for 1K cells (10 iterations), <10s for 10K cells
- [ ] Handles single-layer graphs without error
- [ ] No cell duplication or loss in reordering
- [ ] All cells preserved in layer_order output
- [ ] Unit test coverage >85%

### Definition of Done

- [ ] `crossing_minimization.py` implemented in `infrastructure/layout/`
- [ ] `LayerOrder` dataclass defined with proper type hints
- [ ] `minimize_crossings()` function implemented
- [ ] `count_crossings()` helper function implemented
- [ ] All unit tests passing
- [ ] Performance tests validated
- [ ] Integration test with T01 passing
- [ ] Code reviewed and approved
- [ ] Module docstrings complete with algorithm explanation

---

## 9. Implementation Checklist

### Phase 1: Barycentric Calculation (3 hours)
- [ ] Create `crossing_minimization.py` module
- [ ] Define `LayerOrder` dataclass
- [ ] Implement `barycentric_sort()` function
- [ ] Handle cells with no neighbors
- [ ] Add stable sorting

### Phase 2: Crossing Count (3 hours)
- [ ] Implement `count_crossings_between_layers()`
- [ ] Implement `count_total_crossings()` across all layers
- [ ] Optimize with position maps
- [ ] Add unit tests for crossing count

### Phase 3: Iterative Optimization (3 hours)
- [ ] Implement `minimize_crossings()` main function
- [ ] Add top-down sweep
- [ ] Add bottom-up sweep
- [ ] Implement early termination logic
- [ ] Track best ordering

### Phase 4: Configuration and Edge Cases (2 hours)
- [ ] Add configurable `max_iterations` parameter
- [ ] Handle empty graphs
- [ ] Handle single-layer graphs
- [ ] Add logging for iteration progress

### Phase 5: Testing (3 hours)
- [ ] Write unit tests (8+ test cases)
- [ ] Write performance tests (1k, 10k cells)
- [ ] Write quality test (>50% reduction)
- [ ] Integration test with T01
- [ ] Achieve >85% coverage

### Phase 6: Documentation (1 hour)
- [ ] Write module docstring with algorithm explanation
- [ ] Document function signatures
- [ ] Add usage examples
- [ ] Document time/space complexity

**Total Estimated Time**: 12-15 hours (matches spec estimate)

---

## 10. References

### Algorithm References
- Sugiyama et al., "Methods for Visual Understanding of Hierarchical System Structures" (1981) - Original paper
- Gansner et al., "A Technique for Drawing Directed Graphs" (1993) - DOT algorithm improvements
- Barth et al., "Simple and Efficient Bilayer Cross Counting" (2004) - Sweep-line optimization

### Implementation References
- grandalf library: https://github.com/bdcht/grandalf/blob/master/grandalf/layouts.py
- NetworkX hierarchy_layout: https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.multipartite_layout.html

### Internal References
- [Parent Feature Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/E02-F02.spec.md)
- [Layer Assignment Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T01/E02-F02-T01.spec.md)
- [Architecture: Layer Architecture](/home/joohan/dev/project-ink/ink/docs/architecture/layer-architecture.md)

---

**Document Status**: Ready for Implementation
**Next Steps**: Review with team, begin Phase 1 implementation after T01 completion, prepare test data
