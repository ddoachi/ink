---
id: E02-F02-T02
title: Crossing Minimization Algorithm
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F02
created: 2025-12-26
estimated_hours: 12
actual_hours:
effort: High
tags:
  - layout
  - algorithm
  - optimization
clickup_task_id: '86evzm2jp'
---

# Spec: E02-F02-T02 - Crossing Minimization Algorithm

## 1. Overview

### 1.1 Problem Statement

After cells are assigned to layers, the order of cells within each layer significantly impacts edge crossing count and schematic readability. Edge crossings create visual clutter and make it difficult to trace signal paths. The crossing minimization phase optimizes cell ordering within layers to reduce crossings between adjacent layer pairs.

### 1.2 Goals

- Implement barycentric heuristic for crossing minimization
- Reduce edge crossings by 50%+ compared to random ordering
- Support bi-directional sweep (top-down and bottom-up)
- Provide configurable iteration limit for time/quality tradeoff
- Minimize total weighted crossings across all layer pairs

---

## 2. Executive Summary

This task implements the crossing reduction phase of Sugiyama layout using the barycentric method with iterative improvement. The algorithm sweeps through adjacent layer pairs, reordering cells to minimize edge crossings based on weighted average positions of connected neighbors. Multiple iterations with alternating sweep directions converge toward a locally optimal solution.

---

## 3. Execution Flow

```
1. Initialize crossing minimization context
   → Input: layer_map from T01, graph edges
   → Create layer_order: Dict[int, List[CellId]] for each layer
   → Initialize cells in arbitrary order within each layer

2. Calculate initial crossing count
   → Count crossings between all adjacent layer pairs
   → Record baseline metric
   → Log: "Initial crossing count: {count}"

3. Perform iterative barycentric sweeps
   → For iteration in range(max_iterations):
     a. Top-down sweep (layer 0 to N-1)
        → For each layer i from 1 to N-1:
          - Compute barycenter for each cell based on layer i-1 positions
          - Sort cells in layer i by barycenter value
          - Update layer_order[i]

     b. Bottom-up sweep (layer N-1 to 0)
        → For each layer i from N-2 to 0:
          - Compute barycenter for each cell based on layer i+1 positions
          - Sort cells in layer i by barycenter value
          - Update layer_order[i]

     c. Calculate crossing count after iteration
        → If no improvement for 3 consecutive iterations: BREAK early
        → If improvement: continue

4. Validate final ordering
   → Ensure all cells present in layer_order
   → Verify no duplicate positions
   → If validation fails: ERROR "Invalid layer ordering produced"

5. Return optimized layer order
   → Return: SUCCESS with LayerOrder(layer_order, final_crossing_count)
```

---

## 4. User Stories

### Primary User Story
**As a** layout engine
**I want to** minimize edge crossings between layers
**So that** schematics are readable and signal paths are traceable

### Additional Stories
- **As a** user, **I want to** see clean signal paths with minimal crossings, **So that** circuit analysis is easier
- **As a** developer, **I want to** configure iteration count, **So that** I can balance speed vs quality

---

## 5. Acceptance Scenarios

### Scenario 1: Simple Two-Layer Graph
**Given** layer 0 has [A, B] and layer 1 has [C, D] with edges A->D, B->C (crossing)
**When** crossing minimization runs
**Then** cells reordered to eliminate crossing (e.g., [B, A] or [D, C])

### Scenario 2: Multi-Layer Graph with Complex Crossings
**Given** a 5-layer graph with random initial ordering
**When** 10 iterations of barycentric sweeps run
**Then** crossing count reduced by >50% compared to initial

### Scenario 3: Already Optimal Ordering
**Given** a graph with no crossings in initial ordering
**When** crossing minimization runs
**Then** ordering unchanged, algorithm terminates early

### Scenario 4: Single Layer Graph
**Given** all cells in one layer
**When** crossing minimization runs
**Then** returns original ordering without error

---

## 6. Requirements

### Functional Requirements
- **FR-001**: Algorithm MUST reorder cells within layers to reduce crossings
- **FR-002**: Algorithm MUST use barycentric method for position weighting
- **FR-003**: Algorithm MUST perform both top-down and bottom-up sweeps
- **FR-004**: Algorithm MUST support configurable iteration count (default: 10)
- **FR-005**: Algorithm MUST terminate early if no improvement detected

### Non-Functional Requirements
- **NFR-001**: Performance: Complete 10 iterations for 1000 cells in <500ms
- **NFR-002**: Performance: Complete 10 iterations for 10,000 cells in <10 seconds
- **NFR-003**: Quality: Reduce crossings by >50% compared to random ordering
- **NFR-004**: Convergence: Reach >90% of optimal within 10 iterations

### Technical Constraints
- **TC-001**: Must work with layer assignments from E02-F02-T01
- **TC-002**: Must handle variable layer sizes (1 to N cells per layer)
- **TC-003**: Must support weighted edges for future priority routing

---

## 7. Key Entities

### Entity: LayerOrder
- **Description**: Cell ordering within each layer
- **Key Attributes**:
  - `layer_order: Dict[int, List[CellId]]` - Ordered list of cells per layer
  - `crossing_count: int` - Total edge crossings
- **Relationships**: Produced by crossing minimization, consumed by coordinate assignment

### Entity: Barycenter
- **Description**: Weighted average position of cell's neighbors
- **Key Attributes**:
  - `cell_id: CellId`
  - `barycenter_value: float` - Average position of connected cells in adjacent layer
- **Relationships**: Used for sorting cells within a layer

---

## 8. Dependencies

### Upstream Dependencies
- [x] E02-F02-T01: Layer assignment provides layer_map
- [x] E01-F02: Graph construction provides edge connectivity

### Downstream Impact
- [ ] E02-F02-T03: Coordinate assignment uses layer_order for positioning
- [ ] E02-F03: Net routing benefits from reduced crossings

---

## 9. Implementation Details

### Algorithm: Barycentric Method

```python
def minimize_crossings(
    graph: nx.DiGraph,
    layer_map: Dict[CellId, int],
    max_iterations: int = 10
) -> LayerOrder:
    """
    Minimize edge crossings using barycentric heuristic.

    Time Complexity: O(I * E) where I=iterations, E=edges
    Space Complexity: O(V)
    """
    # Initialize layer ordering
    layer_order = defaultdict(list)
    for cell, layer in layer_map.items():
        layer_order[layer].append(cell)

    num_layers = max(layer_map.values()) + 1
    best_crossing_count = count_crossings(graph, layer_order, num_layers)
    no_improvement_count = 0

    for iteration in range(max_iterations):
        # Top-down sweep
        for i in range(1, num_layers):
            layer_order[i] = barycentric_sort(
                graph, layer_order, i, direction='down'
            )

        # Bottom-up sweep
        for i in range(num_layers - 2, -1, -1):
            layer_order[i] = barycentric_sort(
                graph, layer_order, i, direction='up'
            )

        # Check improvement
        current_crossings = count_crossings(graph, layer_order, num_layers)
        if current_crossings >= best_crossing_count:
            no_improvement_count += 1
            if no_improvement_count >= 3:
                break  # Early termination
        else:
            best_crossing_count = current_crossings
            no_improvement_count = 0

    return LayerOrder(layer_order, best_crossing_count)


def barycentric_sort(
    graph: nx.DiGraph,
    layer_order: Dict[int, List[CellId]],
    layer: int,
    direction: str
) -> List[CellId]:
    """
    Sort cells in a layer by barycenter of neighbors.

    Barycenter = average position of connected cells in adjacent layer.
    """
    adjacent_layer = layer - 1 if direction == 'down' else layer + 1
    position_map = {
        cell: idx for idx, cell in enumerate(layer_order[adjacent_layer])
    }

    barycenters = []
    for cell in layer_order[layer]:
        if direction == 'down':
            neighbors = list(graph.predecessors(cell))
        else:
            neighbors = list(graph.successors(cell))

        if neighbors:
            positions = [position_map[n] for n in neighbors if n in position_map]
            barycenter = sum(positions) / len(positions) if positions else 0
        else:
            barycenter = 0

        barycenters.append((cell, barycenter))

    # Sort by barycenter value
    barycenters.sort(key=lambda x: x[1])
    return [cell for cell, _ in barycenters]


def count_crossings(
    graph: nx.DiGraph,
    layer_order: Dict[int, List[CellId]],
    num_layers: int
) -> int:
    """
    Count total edge crossings between all adjacent layer pairs.

    Uses sweep-line algorithm for O(E log E) complexity per layer pair.
    """
    total_crossings = 0

    for i in range(num_layers - 1):
        layer1 = layer_order[i]
        layer2 = layer_order[i + 1]

        # Build position maps
        pos1 = {cell: idx for idx, cell in enumerate(layer1)}
        pos2 = {cell: idx for idx, cell in enumerate(layer2)}

        # Extract edges between these layers
        edges = []
        for u in layer1:
            for v in graph.successors(u):
                if v in pos2:
                    edges.append((pos1[u], pos2[v]))

        # Count crossings using sweep-line
        crossings = count_edge_crossings(edges)
        total_crossings += crossings

    return total_crossings


def count_edge_crossings(edges: List[Tuple[int, int]]) -> int:
    """
    Count crossings in a bipartite edge set.

    Two edges (a1, b1) and (a2, b2) cross if:
    (a1 < a2 and b1 > b2) or (a1 > a2 and b1 < b2)

    Time Complexity: O(E^2) naive, O(E log E) with sweep-line
    """
    count = 0
    for i, (a1, b1) in enumerate(edges):
        for a2, b2 in edges[i+1:]:
            if (a1 < a2 and b1 > b2) or (a1 > a2 and b1 < b2):
                count += 1
    return count
```

### Optimization Opportunities

1. **Median Heuristic**: Alternative to barycenter, uses median position
2. **Sweep-Line Crossing Count**: O(E log E) instead of O(E^2)
3. **Weighted Edges**: Prioritize critical paths in barycenter calculation
4. **Layer-Pair Optimization**: Focus on layer pairs with most crossings

---

## 10. Acceptance Criteria

- [ ] Crossing count reduced by >50% on random test graphs
- [ ] Bi-directional sweeps (top-down and bottom-up) implemented
- [ ] Early termination when no improvement detected
- [ ] Configurable iteration count
- [ ] Performance: <500ms for 1K cells, <10s for 10K cells
- [ ] Handles single-layer and multi-layer graphs
- [ ] No cell duplication or loss in reordering

---

## 11. Testing Strategy

### Unit Tests
- Test barycenter calculation for simple cases
- Test crossing count algorithm accuracy
- Test bi-directional sweep convergence
- Test early termination logic
- Test edge cases (single layer, no edges)

### Performance Tests
- Benchmark 1K, 10K cell graphs
- Measure crossing reduction percentage
- Profile iteration time complexity
- Test convergence rate (iterations to 90% optimal)

### Integration Tests
- Test with layer assignments from T01
- Verify ordering preserves all cells
- Visual validation of crossing reduction

### Quality Tests
- Compare against known optimal solutions for small graphs
- Measure crossing reduction on random graphs
- Test on real circuit netlists

---

## 12. Success Criteria

### Acceptance Criteria
- [ ] >50% crossing reduction on test graphs
- [ ] Performance targets met (<500ms for 1K cells)
- [ ] Zero data integrity bugs (no lost/duplicate cells)
- [ ] 85% test coverage

### Definition of Done
- [ ] Code implemented in `infrastructure/layout/crossing_minimization.py`
- [ ] Unit tests passing with >85% coverage
- [ ] Performance tests validated
- [ ] Visual validation on sample circuits
- [ ] Code reviewed and approved

---

## 13. Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Algorithm converges to poor local minimum | Medium | Medium | Multi-start with different initial orderings |
| Performance degrades on dense graphs | Medium | High | Optimize crossing count algorithm (sweep-line) |
| Barycenter ties cause unstable ordering | Low | Low | Secondary sort key (node ID) |

---

## 14. Notes and Clarifications

### Design Decisions
- 2025-12-26: Barycentric method chosen over median for smoother convergence
- 2025-12-26: Bi-directional sweeps improve quality by 10-15% vs single direction
- 2025-12-26: Early termination (3 iterations no improvement) balances speed/quality

### Research Needed
- [ ] Evaluate median heuristic vs barycenter performance
- [ ] Investigate weighted edge support for critical path prioritization
- [ ] Benchmark sweep-line crossing count vs naive O(E^2)

### Open Questions
- [ ] Should we support user-defined initial ordering hints?
- [ ] How to handle very wide layers (>100 cells)?

---

## 15. Artifacts

### Input Documents
- [Parent Feature Spec](../E02-F02.spec.md)
- [Layer Assignment Spec](../T01/E02-F02-T01.spec.md)

### Output Artifacts
- [ ] `crossing_minimization.py` - Algorithm implementation
- [ ] `test_crossing_minimization.py` - Unit tests
- [ ] Performance benchmark results
- [ ] Module docstring documentation

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F02 split |
