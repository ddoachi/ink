# E02-F02-T01: Layer Assignment Algorithm - Post-Implementation Documentation

## 1. Implementation Summary

**Spec ID**: E02-F02-T01
**Title**: Layer Assignment Algorithm
**Status**: Completed
**Implementation Date**: 2025-12-28

### What Was Built

A `LayerAssignmentAlgorithm` class that assigns cells to horizontal layers in the Sugiyama hierarchical layout algorithm. The algorithm processes circuit graphs to determine logical depth of each cell from primary inputs, enabling left-to-right signal flow visualization.

### Key Deliverables

| Deliverable | Location | Description |
|-------------|----------|-------------|
| `LayerAssignment` dataclass | `src/ink/infrastructure/layout/layer_assignment.py:47` | Immutable result container |
| `LayerAssignmentAlgorithm` class | `src/ink/infrastructure/layout/layer_assignment.py:79` | Main algorithm implementation |
| Unit tests | `tests/unit/infrastructure/layout/test_layer_assignment.py` | 40 comprehensive TDD tests |

---

## 2. Technical Decisions

### 2.1 Iterative DFS for Cycle Detection

**Decision**: Use iterative DFS with explicit stack instead of recursive DFS
**Rationale**:
- Python's default recursion limit is ~1000
- Performance test requires 10,000 node chain graphs
- Iterative approach handles arbitrary graph depth
- Same O(V+E) time complexity as recursive version

### 2.2 Longest-Path Layer Assignment

**Decision**: Use longest-path from sources (not shortest-path)
**Rationale**:
- Ensures nodes are placed at maximum depth from inputs
- Minimizes total layer span (layer_count)
- Creates cleaner visual representation with proper signal flow
- Formula: `layer[node] = max(layer[predecessor]) + 1`

### 2.3 Feedback Edge Reversal Strategy

**Decision**: Temporarily reverse back edges to create DAG
**Rationale**:
- Enables topological sort on cyclic graphs
- Original graph is not modified (new working copy created)
- Reversed edges are tracked in `reverse_edges` set
- Downstream algorithms can use this for routing decisions

### 2.4 Immutable Result Container

**Decision**: Use frozen dataclass for `LayerAssignment`
**Rationale**:
- Prevents accidental modification of results
- Safe to share between components
- Clear API contract: results are final
- Enables hashability for caching if needed

---

## 3. Architecture Patterns

### 3.1 Algorithm Flow

```
┌──────────────────────────────────────────────────────────────────┐
│                     assign_layers(graph)                          │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌─────────────────┐                                             │
│  │  Empty graph?   │──yes──> Return empty LayerAssignment        │
│  └────────┬────────┘                                             │
│           │ no                                                   │
│           ▼                                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │  Step 1: Find Feedback Edges (Iterative DFS)                │ │
│  │  - Color nodes: WHITE → GRAY → BLACK                        │ │
│  │  - Back edges (GRAY → GRAY) are feedback edges              │ │
│  └─────────────────────────────────────────────────────────────┘ │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │  Step 2: Create Acyclic Working Graph                       │ │
│  │  - Copy all nodes and edges                                 │ │
│  │  - Reverse feedback edges (u,v) → (v,u)                     │ │
│  └─────────────────────────────────────────────────────────────┘ │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │  Step 3: Compute Longest-Path Layers                        │ │
│  │  - Sources (in_degree=0) → layer 0                          │ │
│  │  - Topological sort order                                   │ │
│  │  - layer[n] = max(layer[pred]) + 1                          │ │
│  └─────────────────────────────────────────────────────────────┘ │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────────────────────────────────────────────────┐ │
│  │  Return LayerAssignment(layer_map, reverse_edges, count)    │ │
│  └─────────────────────────────────────────────────────────────┘ │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

### 3.2 Iterative DFS State Machine

```
┌─────────────────────────────────────────────────────────────────┐
│                   Iterative DFS with Colors                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Stack entry: (node, successors_iterator, is_entering)          │
│                                                                  │
│                    ┌────────────────────────────────────┐       │
│                    │         WHITE (unvisited)          │       │
│                    └──────────────────┬─────────────────┘       │
│                                       │ pop from stack          │
│                                       │ (is_entering=True)      │
│                                       ▼                         │
│                    ┌────────────────────────────────────┐       │
│                    │          GRAY (visiting)           │       │
│                    │  - Check all successors            │       │
│                    │  - If GRAY: back edge found!       │       │
│                    │  - If WHITE: push to stack         │       │
│                    │  - Push self back (is_entering=F)  │       │
│                    └──────────────────┬─────────────────┘       │
│                                       │ pop from stack          │
│                                       │ (is_entering=False)     │
│                                       ▼                         │
│                    ┌────────────────────────────────────┐       │
│                    │         BLACK (finished)           │       │
│                    │  - All descendants processed       │       │
│                    └────────────────────────────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. Code Quality Metrics

### 4.1 Test Coverage

| Category | Tests | Coverage |
|----------|-------|----------|
| Data Structure | 4 | `LayerAssignment` attributes and immutability |
| Instantiation | 2 | Algorithm creation and method presence |
| Empty/Single Node | 2 | Edge case handling |
| Simple DAG | 4 | Chain, diamond, multiple sources, wide graphs |
| Longest Path | 2 | Unbalanced paths, non-negative layers |
| Edge Direction | 2 | Forward edge validation |
| Cycle Detection | 4 | Simple cycles, sequential circuits, feedback |
| Disconnected | 3 | Multiple components handling |
| Layer Count | 3 | Correct count calculation |
| Complex Graphs | 3 | Multi-fanout, deep chains, multiple cycles |
| Performance | 5 | 1K nodes, 10K nodes, scaling tests |
| NetworkX Integration | 3 | DiGraph, MultiDiGraph, graph preservation |
| Edge Cases | 3 | Self-loops, sinks, isolated nodes |
| **Total** | **40** | **100% of acceptance criteria** |

### 4.2 Linting Results

- **ruff**: All checks passed
- **mypy**: No issues found
- **pytest**: 40/40 tests pass

### 4.3 Performance Metrics

| Metric | Requirement | Actual |
|--------|-------------|--------|
| 1,000 nodes | <100ms | ~15ms |
| 10,000 nodes | <2s | ~150ms |
| Time complexity | O(V+E) | Verified |
| Space complexity | O(V) | Verified |

---

## 5. Lessons Learned

### 5.1 Python Recursion Limits

**Issue**: Recursive DFS failed on 10,000 node chain graph
**Learning**: Always use iterative algorithms with explicit stacks for graph traversal in Python. The default recursion limit (~1000) is easily exceeded with deep graphs.

### 5.2 DFS for Cycle Detection

**Observation**: Three-color DFS (WHITE/GRAY/BLACK) elegantly identifies back edges
**Learning**: A back edge (edge to a GRAY ancestor) definitively indicates a cycle. This is simpler than maintaining explicit path tracking.

### 5.3 Topological Sort with Cycles

**Issue**: NetworkX's `topological_sort` raises exception on cyclic graphs
**Learning**: Must break cycles before topological sort. Reversing back edges creates a valid DAG while preserving layer assignment semantics.

---

## 6. Future Improvements

### 6.1 Planned Enhancements

1. **E02-F02-T02**: Crossing Minimization - Uses layer assignments to minimize edge crossings
2. **E02-F02-T03**: Coordinate Assignment - Computes final X/Y positions based on layers
3. **E02-F03**: Net Routing - Uses layer information for orthogonal routing

### 6.2 Potential Optimizations

- **Layer compaction**: Reduce empty layers when nodes can be moved closer
- **Priority-based feedback selection**: Choose feedback edges that minimize layer span
- **Incremental updates**: Update layers when graph is modified (for exploration)

---

## 7. Dependencies and Integration

### 7.1 Upstream Dependencies

| Dependency | Purpose | Status |
|------------|---------|--------|
| NetworkX | Graph data structure and algorithms | Available |
| E01-F02: Graph Construction | Provides circuit graph | Completed |

### 7.2 Downstream Dependents

| Dependent | Purpose | Status |
|-----------|---------|--------|
| E02-F02-T02: Crossing Minimization | Uses layer assignments | Planned |
| E02-F02-T03: Coordinate Assignment | Uses layer structure | Planned |
| E02-F03: Net Routing | Uses layer info for routing | Planned |

---

## 8. References

- **Spec**: [E02-F02-T01.spec.md](./E02-F02-T01.spec.md)
- **GitHub Issue**: [#70](https://github.com/ddoachi/ink/issues/70)
- **ClickUp Task**: `CU-86evzm2jd`
- **Implementation Narrative**: [E02-F02-T01-implementation-narrative.md](./E02-F02-T01-implementation-narrative.md)
