---
id: E02-F02-T01
title: Layer Assignment Algorithm
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F02
created: 2025-12-26
estimated_hours: 8
actual_hours:
effort: Medium
tags:
  - layout
  - algorithm
  - graph-analysis
clickup_task_id: ''
---

# Spec: E02-F02-T01 - Layer Assignment Algorithm

## 1. Overview

### 1.1 Problem Statement

The first phase of Sugiyama layout requires assigning each cell to a horizontal layer based on its position in the logical signal flow. Cells must be placed so that all edges flow from left (lower layer numbers) to right (higher layer numbers), with primary inputs in the leftmost layer and primary outputs accessible from the rightmost layers.

### 1.2 Goals

- Implement layer assignment using longest-path algorithm from graph sources
- Assign primary input ports and cells with no fanin to layer 0
- Assign cells to layers based on maximum distance from layer 0
- Handle cycles by identifying and temporarily reversing feedback edges
- Produce layer assignments that minimize total edge span across layers

---

## 2. Executive Summary

This task implements the layer assignment phase of the Sugiyama layout algorithm. It analyzes the circuit graph to determine the logical depth of each cell from primary inputs, assigning cells to horizontal layers that reveal left-to-right signal flow. The algorithm handles DAG layer assignment using longest-path computation and identifies feedback edges in cyclic graphs for temporary reversal.

---

## 3. Execution Flow

```
1. Initialize layer assignment data structures
   → Create layer_map: Dict[CellId, int]
   → Create reverse_edges: Set[Tuple[CellId, CellId]]

2. Detect and mark feedback edges (cycle breaking)
   → Run DFS to detect back edges
   → Mark back edges for reversal
   → If cycles detected: WARN "Circuit contains feedback loops, {count} edges reversed"

3. Assign layer 0 to source nodes
   → Find all cells with no incoming edges (after feedback removal)
   → Find all primary input ports
   → Assign layer 0 to all source nodes
   → If no sources found: ERROR "Graph has no source nodes, cannot assign layers"

4. Compute longest path for each cell
   → Use topological sort order
   → For each cell, compute: layer = max(predecessor_layers) + 1
   → Validate no negative layers: ERROR if found

5. Verify layer assignments
   → Ensure all cells assigned to a layer
   → Check no forward edges go backwards (except reversed edges)
   → If unassigned cells: ERROR "Failed to assign layers to {count} cells"

6. Return layer assignment results
   → Return: SUCCESS with LayerAssignment(layer_map, reverse_edges, layer_count)
```

---

## 4. User Stories

### Primary User Story
**As a** layout engine
**I want to** assign cells to layers based on signal flow depth
**So that** the schematic displays logical progression from inputs to outputs

### Additional Stories
- **As a** developer, **I want to** handle cyclic graphs gracefully, **So that** sequential circuits can be visualized
- **As a** user, **I want to** see inputs on the left and outputs on the right, **So that** signal flow is intuitive

---

## 5. Acceptance Scenarios

### Scenario 1: Pure Combinational Circuit
**Given** a DAG with 5 cells: IN -> A -> B -> C -> OUT
**When** layer assignment runs
**Then** layers are [IN:0, A:1, B:2, C:3, OUT:4] with no reversed edges

### Scenario 2: Multiple Input Paths
**Given** circuit with two inputs: IN1 -> A, IN2 -> B, both -> C
**When** layer assignment runs
**Then** IN1 and IN2 are layer 0, A and B are layer 1, C is layer 2

### Scenario 3: Sequential Circuit with Feedback
**Given** a circuit with flip-flop feedback: A -> B -> FF -> A
**When** layer assignment runs
**Then** one edge is marked as reversed, layers assigned without cycles, warning logged

### Scenario 4: Empty Graph
**Given** an empty circuit graph
**When** layer assignment runs
**Then** returns empty layer_map with layer_count = 0

---

## 6. Requirements

### Functional Requirements
- **FR-001**: Algorithm MUST assign all cells to a non-negative layer number
- **FR-002**: Algorithm MUST assign primary inputs to layer 0
- **FR-003**: Algorithm MUST detect and reverse feedback edges in cyclic graphs
- **FR-004**: Algorithm MUST use longest-path distance from sources for layer assignment
- **FR-005**: Algorithm MUST produce layers where forward edges only increase layer number

### Non-Functional Requirements
- **NFR-001**: Performance: Complete layer assignment for 1000 cells in <100ms
- **NFR-002**: Performance: Complete layer assignment for 10,000 cells in <2 seconds
- **NFR-003**: Memory: Use O(V + E) space where V=cells, E=edges
- **NFR-004**: Correctness: All cells reachable from inputs must be assigned valid layers

### Technical Constraints
- **TC-001**: Must work with NetworkX DiGraph structure
- **TC-002**: Must handle both combinational and sequential circuits
- **TC-003**: Must preserve original graph structure (no mutations except metadata)

---

## 7. Key Entities

### Entity: LayerAssignment
- **Description**: Result of layer assignment algorithm
- **Key Attributes**:
  - `layer_map: Dict[CellId, int]` - Cell to layer mapping
  - `reverse_edges: Set[Tuple[CellId, CellId]]` - Edges marked for reversal
  - `layer_count: int` - Total number of layers
- **Relationships**: Used by crossing minimization phase

### Entity: CellId
- **Description**: Unique identifier for circuit cells
- **Key Attributes**: String identifier
- **Relationships**: Key in layer_map, used in graph edges

---

## 8. Dependencies

### Upstream Dependencies
- [x] E01-F02: Graph construction provides NetworkX DiGraph
- [x] NetworkX: Topological sort, cycle detection algorithms

### Downstream Impact
- [ ] E02-F02-T02: Crossing minimization needs layer assignments
- [ ] E02-F02-T03: Coordinate assignment needs layer structure
- [ ] E02-F03: Net routing uses layer information for routing constraints

---

## 9. Implementation Details

### Algorithm: Longest Path Layer Assignment

```python
def assign_layers(graph: nx.DiGraph) -> LayerAssignment:
    """
    Assign cells to layers using longest-path from sources.

    Time Complexity: O(V + E)
    Space Complexity: O(V)
    """
    layer_map = {}
    reverse_edges = set()

    # Step 1: Detect cycles and mark feedback edges
    try:
        topo_order = list(nx.topological_sort(graph))
    except nx.NetworkXError:
        # Has cycles, find and reverse feedback edges
        reverse_edges = find_feedback_edges(graph)
        # Create temporary graph with reversed edges
        temp_graph = graph.copy()
        temp_graph.remove_edges_from(reverse_edges)
        temp_graph.add_edges_from([(v, u) for u, v in reverse_edges])
        topo_order = list(nx.topological_sort(temp_graph))

    # Step 2: Assign layer 0 to sources
    sources = [n for n in graph.nodes() if graph.in_degree(n) == 0]
    for source in sources:
        layer_map[source] = 0

    # Step 3: Longest path assignment
    for node in topo_order:
        if node in layer_map:
            continue
        predecessors = list(graph.predecessors(node))
        if predecessors:
            layer_map[node] = max(layer_map[p] for p in predecessors) + 1
        else:
            layer_map[node] = 0

    layer_count = max(layer_map.values()) + 1 if layer_map else 0
    return LayerAssignment(layer_map, reverse_edges, layer_count)
```

### Cycle Detection Strategy

Use DFS-based back-edge detection:
- White nodes: Unvisited
- Gray nodes: Currently in DFS stack (back edge if encountered)
- Black nodes: Fully processed

Feedback edges are those pointing from gray to gray nodes.

---

## 10. Acceptance Criteria

- [ ] All cells assigned to non-negative integer layers
- [ ] Primary inputs in layer 0
- [ ] No forward edge decreases layer number (except marked reversed edges)
- [ ] Cyclic graphs handled with feedback edge detection
- [ ] Performance: 1000 cells in <100ms, 10000 cells in <2s
- [ ] Layer span minimized (shortest possible layer count)
- [ ] Empty graphs return empty assignments without error
- [ ] Isolated components handled correctly

---

## 11. Testing Strategy

### Unit Tests
- Test pure DAG layer assignment
- Test multiple-source graphs
- Test graphs with cycles (feedback detection)
- Test empty graphs
- Test single-node graphs
- Test disconnected components

### Performance Tests
- Benchmark 1K, 10K, 100K cell graphs
- Verify O(V+E) time complexity
- Memory profiling for large graphs

### Integration Tests
- Test with real CDL-parsed circuit graphs
- Verify integration with NetworkX adapter
- Test with various netlist topologies

---

## 12. Success Criteria

### Acceptance Criteria
- [ ] Algorithm assigns valid layers to all cells
- [ ] Handles combinational and sequential circuits
- [ ] Performance targets met (<100ms for 1K cells)
- [ ] Zero critical bugs in cycle detection
- [ ] 90% test coverage

### Definition of Done
- [ ] Code implemented in `infrastructure/layout/layer_assignment.py`
- [ ] Unit tests passing with >90% coverage
- [ ] Performance tests validated
- [ ] Code reviewed and approved
- [ ] Documentation added to module docstrings

---

## 13. Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Cycle detection fails on complex graphs | Low | High | Extensive testing with sequential circuits |
| Performance degrades on large graphs | Medium | Medium | Algorithmic complexity analysis, profiling |
| Incorrect layer assignment creates crossings | Low | Medium | Validation tests, visual inspection |

---

## 14. Notes and Clarifications

### Design Decisions
- 2025-12-26: Using longest-path algorithm ensures minimal layer count
- 2025-12-26: Feedback edge reversal is temporary (metadata only), graph unchanged
- 2025-12-26: Layer 0 assignment to all sources simplifies downstream algorithms

### Open Questions
- [ ] Should we optimize layer count by compressing layers with few cells?
- [ ] How to handle very wide graphs (many cells in one layer)?

---

## 15. Artifacts

### Input Documents
- [Parent Feature Spec](../E02-F02.spec.md)
- [Architecture: Layer Architecture](../../../../docs/architecture/layer-architecture.md)

### Output Artifacts
- [ ] `layer_assignment.py` - Algorithm implementation
- [ ] `test_layer_assignment.py` - Unit tests
- [ ] Module docstring documentation

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F02 split |
