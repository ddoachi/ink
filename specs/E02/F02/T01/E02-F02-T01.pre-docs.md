# E02-F02-T01 - Layer Assignment Algorithm: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F02-T01
- **Task**: Layer Assignment Algorithm
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the first phase of the Sugiyama hierarchical layout algorithm: layer assignment. The algorithm assigns each cell in the circuit graph to a horizontal layer based on its logical depth from primary inputs, establishing the left-to-right signal flow foundation for schematic rendering.

**Core Deliverables:**
- Layer assignment algorithm using longest-path computation
- Cycle detection and feedback edge reversal
- Layer validation and verification
- Integration with NetworkX graph structure

**Success Metrics:**
- All cells assigned to valid non-negative layers
- Primary inputs placed in layer 0
- Performance: <100ms for 1000 cells, <2s for 10,000 cells
- Handles both combinational and sequential circuits correctly

### 1.2 Problem Context

The Sugiyama layout algorithm requires cells to be organized into horizontal layers that reflect signal flow direction. Without proper layer assignment:
- Edges could flow in arbitrary directions, creating visual chaos
- Signal flow from inputs to outputs would not be clear
- Subsequent phases (crossing minimization, coordinate assignment) would fail

The layer assignment phase must handle:
- DAG (Directed Acyclic Graph) structures typical in combinational logic
- Cyclic graphs due to sequential feedback paths (flip-flops, latches)
- Multiple primary input sources
- Disconnected components

---

## 2. Implementation Approach

### 2.1 Algorithm Selection: Longest Path from Sources

**Decision**: Use longest-path algorithm with topological ordering.

**Rationale:**
- Guarantees all edges flow from lower to higher layer numbers (left to right)
- Minimizes total layer count (compacts the layout horizontally)
- Well-understood algorithm with O(V+E) time complexity
- Naturally handles multiple source nodes (primary inputs)

**Algorithm Steps:**

```
1. Detect cycles in graph using DFS
2. If cycles exist:
   - Identify feedback edges (back edges in DFS)
   - Mark for temporary reversal (metadata only)
3. Compute topological ordering (with reversed edges if needed)
4. Assign layer 0 to all source nodes (no incoming edges)
5. For each node in topological order:
   - Layer = max(predecessor layers) + 1
6. Validate: all cells assigned, no negative layers
```

**Time Complexity**: O(V + E)
**Space Complexity**: O(V)

### 2.2 Cycle Handling Strategy

**Challenge**: Sequential circuits contain feedback paths (e.g., flip-flop output feeding back to input).

**Solution**: DFS-based back-edge detection with temporary reversal.

**Implementation:**
```python
def detect_feedback_edges(graph: nx.DiGraph) -> Set[Tuple[CellId, CellId]]:
    """
    Detect back edges using DFS coloring:
    - White (0): Unvisited
    - Gray (1): In current DFS path (back edge if encountered)
    - Black (2): Fully processed
    """
    color = {node: 0 for node in graph.nodes()}
    feedback_edges = set()

    def dfs(node):
        color[node] = 1  # Mark as gray (in path)
        for neighbor in graph.successors(node):
            if color[neighbor] == 1:
                # Back edge detected
                feedback_edges.add((node, neighbor))
            elif color[neighbor] == 0:
                dfs(neighbor)
        color[node] = 2  # Mark as black (processed)

    for node in graph.nodes():
        if color[node] == 0:
            dfs(node)

    return feedback_edges
```

**Marking Strategy**: Feedback edges stored in metadata, not physically reversed in graph.

### 2.3 Data Structures

**Input:**
- `graph: nx.DiGraph` - Circuit graph with cells as nodes, nets as edges

**Output:**
- `LayerAssignment` dataclass:
  ```python
  @dataclass
  class LayerAssignment:
      layer_map: Dict[CellId, int]  # Cell ID -> layer number
      reverse_edges: Set[Tuple[CellId, CellId]]  # Feedback edges
      layer_count: int  # Total number of layers
  ```

**Internal:**
- `color: Dict[CellId, int]` - DFS coloring for cycle detection
- `topo_order: List[CellId]` - Topological ordering of nodes

### 2.4 Edge Cases

| Case | Handling Strategy |
|------|------------------|
| Empty graph | Return empty layer_map, layer_count = 0 |
| Single node | Assign to layer 0 |
| Disconnected components | Treat each component separately, all sources get layer 0 |
| All nodes in cycle | Break cycle arbitrarily, warn user |
| Primary outputs | No special handling (assigned based on longest path) |

---

## 3. Key Design Decisions

### Decision 1: Longest Path vs. Shortest Path

**Choice**: Longest path from sources

**Alternatives Considered:**
- Shortest path: Would create more compact layouts but could force edges backward
- Breadth-first layering: Simpler but doesn't minimize crossings as well

**Rationale**: Longest path ensures all edges flow forward (left to right), which is critical for readable signal flow visualization.

### Decision 2: Cycle Breaking Strategy

**Choice**: DFS-based back-edge detection with metadata marking

**Alternatives Considered:**
- Greedy feedback arc set minimization (NP-hard)
- User-specified feedback edges
- Breaking at sequential element boundaries (requires cell type awareness)

**Rationale**: DFS back-edge detection is deterministic, fast O(V+E), and sufficient for MVP. Future enhancement can optimize feedback edge selection.

### Decision 3: Layer Numbering Convention

**Choice**: Layer 0 = leftmost (primary inputs), increasing rightward

**Alternatives Considered:**
- Reverse numbering (outputs on left)
- Top-down layering (vertical)

**Rationale**: Left-to-right matches standard digital circuit convention (inputs left, outputs right). Vertical layout deferred to P1.

### Decision 4: Handling Isolated Nodes

**Choice**: Assign to layer 0 if no incoming edges

**Rationale**: Isolated nodes act as pseudo-inputs. Alternative would be to warn or skip them, but placing in layer 0 is safer and simpler.

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E01-F02: Graph Construction**
- Provides `nx.DiGraph` with cells as nodes
- Node attributes: `cell: Cell` domain object
- Edge attributes: `net: Net` domain object
- **Integration Point**: Receive graph from `GraphBuilder` or application service

**NetworkX Library**
- `nx.topological_sort()` for ordering
- `nx.DiGraph.predecessors()`, `successors()` for traversal
- **Version**: NetworkX 3.0+

### 4.2 Downstream Consumers

**E02-F02-T02: Crossing Minimization**
- Consumes `layer_map: Dict[CellId, int]`
- Uses layer assignments to group cells for reordering
- **Interface**: Pass `LayerAssignment` object

**E02-F02-T03: Coordinate Assignment**
- Consumes `layer_map` to determine X coordinates
- Needs `layer_count` for spacing calculations
- **Interface**: Pass `LayerAssignment` object

**E02-F02-T04: SugiyamaLayoutEngine**
- Orchestrates layer assignment as Phase 1
- Handles error propagation
- **Interface**: Call `assign_layers(graph)` function

### 4.3 Domain Layer Integration

**Location**: `src/ink/infrastructure/layout/layer_assignment.py`

**Note**: This is infrastructure code (algorithm implementation), not domain logic. The domain layer defines the `LayoutEngine` protocol, but layer assignment is an implementation detail.

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Test Coverage Goals**: >90%

**Test Cases:**

```python
# Test 1: Simple DAG chain
def test_layer_assignment_simple_chain():
    """A -> B -> C should assign layers [0, 1, 2]"""
    graph = nx.DiGraph([("A", "B"), ("B", "C")])
    result = assign_layers(graph)
    assert result.layer_map == {"A": 0, "B": 1, "C": 2}
    assert result.layer_count == 3
    assert len(result.reverse_edges) == 0

# Test 2: Multiple inputs
def test_layer_assignment_multiple_inputs():
    """IN1 -> A, IN2 -> A should assign IN1, IN2 to layer 0"""
    graph = nx.DiGraph([("IN1", "A"), ("IN2", "A")])
    result = assign_layers(graph)
    assert result.layer_map["IN1"] == 0
    assert result.layer_map["IN2"] == 0
    assert result.layer_map["A"] == 1

# Test 3: Fanout
def test_layer_assignment_fanout():
    """A -> B, A -> C should assign B and C to same layer"""
    graph = nx.DiGraph([("A", "B"), ("A", "C")])
    result = assign_layers(graph)
    assert result.layer_map["A"] == 0
    assert result.layer_map["B"] == 1
    assert result.layer_map["C"] == 1

# Test 4: Cycle detection
def test_layer_assignment_with_cycle():
    """A -> B -> C -> A should detect and reverse one edge"""
    graph = nx.DiGraph([("A", "B"), ("B", "C"), ("C", "A")])
    result = assign_layers(graph)
    assert len(result.reverse_edges) == 1
    # All nodes should still be assigned layers
    assert len(result.layer_map) == 3
    # Verify forward flow (no edge goes backwards)
    for u, v in graph.edges():
        if (u, v) not in result.reverse_edges:
            assert result.layer_map[u] < result.layer_map[v]

# Test 5: Empty graph
def test_layer_assignment_empty_graph():
    """Empty graph should return empty assignment"""
    graph = nx.DiGraph()
    result = assign_layers(graph)
    assert result.layer_map == {}
    assert result.layer_count == 0

# Test 6: Single node
def test_layer_assignment_single_node():
    """Single node should be layer 0"""
    graph = nx.DiGraph()
    graph.add_node("A")
    result = assign_layers(graph)
    assert result.layer_map == {"A": 0}
    assert result.layer_count == 1

# Test 7: Disconnected components
def test_layer_assignment_disconnected():
    """A -> B and C -> D (separate) should both start at layer 0"""
    graph = nx.DiGraph([("A", "B"), ("C", "D")])
    result = assign_layers(graph)
    assert result.layer_map["A"] == 0
    assert result.layer_map["C"] == 0
    assert result.layer_map["B"] == 1
    assert result.layer_map["D"] == 1

# Test 8: Diamond pattern
def test_layer_assignment_diamond():
    """A -> B, A -> C, B -> D, C -> D should handle convergence"""
    graph = nx.DiGraph([("A", "B"), ("A", "C"), ("B", "D"), ("C", "D")])
    result = assign_layers(graph)
    assert result.layer_map["A"] == 0
    assert result.layer_map["B"] == 1
    assert result.layer_map["C"] == 1
    assert result.layer_map["D"] == 2
```

### 5.2 Performance Tests

```python
import pytest
import networkx as nx
from time import time

def test_layer_assignment_performance_1k_cells():
    """1000 cells should complete in <100ms"""
    graph = generate_random_dag(num_nodes=1000, avg_degree=3)
    start = time()
    result = assign_layers(graph)
    duration = time() - start
    assert duration < 0.1, f"Took {duration:.3f}s, expected <0.1s"
    assert len(result.layer_map) == 1000

def test_layer_assignment_performance_10k_cells():
    """10,000 cells should complete in <2s"""
    graph = generate_random_dag(num_nodes=10000, avg_degree=3)
    start = time()
    result = assign_layers(graph)
    duration = time() - start
    assert duration < 2.0, f"Took {duration:.3f}s, expected <2s"
    assert len(result.layer_map) == 10000
```

### 5.3 Integration Tests

```python
def test_layer_assignment_with_real_netlist():
    """Test with parsed CDL netlist"""
    # Assumes E01 parsing is complete
    from ink.infrastructure.parsing.cdl_parser import CDLParser
    parser = CDLParser()
    design = parser.parse_file("examples/adder_4bit.ckt")
    graph = build_graph_from_design(design)

    result = assign_layers(graph)

    # Verify all cells assigned
    assert len(result.layer_map) == len(graph.nodes())

    # Verify forward flow
    for u, v in graph.edges():
        if (u, v) not in result.reverse_edges:
            assert result.layer_map[u] < result.layer_map[v]
```

### 5.4 Test Data Generation

```python
def generate_random_dag(num_nodes: int, avg_degree: int) -> nx.DiGraph:
    """
    Generate random DAG for performance testing.

    Uses Erdos-Renyi model with topological constraint.
    """
    graph = nx.DiGraph()
    graph.add_nodes_from(range(num_nodes))

    # Add edges only from lower to higher numbered nodes (ensures DAG)
    prob = avg_degree / num_nodes
    for i in range(num_nodes):
        for j in range(i + 1, num_nodes):
            if random.random() < prob:
                graph.add_edge(i, j)

    return graph
```

---

## 6. Risks and Considerations

### Risk 1: Cycle Detection Performance on Dense Graphs

**Impact**: Medium
**Probability**: Low
**Concern**: DFS may be slow on graphs with high edge density

**Mitigation:**
- Profile with real netlists (typically sparse: avg degree 2-4)
- If needed, use NetworkX's optimized `simple_cycles()` instead
- Add early termination if >1000 feedback edges detected (likely error)

### Risk 2: Incorrect Feedback Edge Selection

**Impact**: High
**Probability**: Medium
**Concern**: Arbitrary feedback edge selection could break critical signal paths

**Mitigation:**
- Log all reversed edges with warning
- Future: Use domain knowledge (prefer breaking at latch boundaries)
- Future: Allow user-specified feedback edges
- Validate with sequential circuit test cases

### Risk 3: Layer Span Too Wide

**Impact**: Medium
**Probability**: Medium
**Concern**: Longest path algorithm may create unnecessarily wide layouts

**Example**: Chain of 100 cells creates 100 layers

**Mitigation:**
- Accept for MVP (correctness over compactness)
- Future: Layer compaction algorithm (Phase 4 of Sugiyama)
- Horizontal scrolling in UI handles wide layouts

### Risk 4: Memory Usage for Large Graphs

**Impact**: Low
**Probability**: Low
**Concern**: O(V) space for layer_map could be large for 100k+ cells

**Mitigation:**
- Use efficient data structures (dict is optimal)
- Profile memory usage with 100k cell test
- If needed, use numpy arrays instead of dicts

### Risk 5: Integration Errors with NetworkX

**Impact**: Medium
**Probability**: Low
**Concern**: NetworkX API changes or unexpected behavior

**Mitigation:**
- Pin NetworkX version in `pyproject.toml`
- Unit tests cover all NetworkX API usage
- Fallback: Implement custom topological sort if needed

---

## 7. Open Questions

### Q1: Should we optimize layer count by compressing empty layers?

**Context**: If a graph skips layer numbers (e.g., layers 0, 2, 5), should we renumber to 0, 1, 2?

**Recommendation**: No for MVP - adds complexity, provides minimal benefit

**Decision Needed By**: Before implementation starts

---

### Q2: How to visualize reversed feedback edges in UI?

**Context**: Downstream rendering needs to show which edges are reversed

**Options**:
- Dashed lines
- Different color
- Arrowhead at both ends

**Recommendation**: Store in metadata, let rendering phase decide

**Decision Needed By**: Before E02-F03 (Net Routing)

---

### Q3: Should we support user hints for layer assignment?

**Context**: Power users might want to manually specify certain layer assignments

**Recommendation**: Defer to P1 - not needed for MVP

**Decision Needed By**: P1 planning

---

## 8. Success Criteria

### Acceptance Criteria

- [ ] All cells in graph assigned to non-negative integer layers
- [ ] Primary inputs (nodes with no predecessors) assigned to layer 0
- [ ] All forward edges flow from lower to higher layer numbers
- [ ] Cycles detected and feedback edges identified
- [ ] Performance: <100ms for 1000 cells, <2s for 10,000 cells
- [ ] Empty graphs handled without error
- [ ] Isolated components handled correctly
- [ ] Unit test coverage >90%

### Definition of Done

- [ ] `layer_assignment.py` implemented in `infrastructure/layout/`
- [ ] `LayerAssignment` dataclass defined with proper type hints
- [ ] All unit tests passing
- [ ] Performance tests validated
- [ ] Integration test with real netlist passing
- [ ] Code reviewed and approved
- [ ] Module docstrings complete with examples

---

## 9. Implementation Checklist

### Phase 1: Core Algorithm (2 hours)
- [ ] Create `layer_assignment.py` module
- [ ] Define `LayerAssignment` dataclass
- [ ] Implement `assign_layers()` main function
- [ ] Implement topological sort wrapper
- [ ] Add basic error handling

### Phase 2: Cycle Handling (3 hours)
- [ ] Implement `detect_feedback_edges()` with DFS
- [ ] Add cycle detection tests
- [ ] Handle graphs with cycles
- [ ] Log warnings for reversed edges

### Phase 3: Validation (1 hour)
- [ ] Add layer assignment validation
- [ ] Verify all cells assigned
- [ ] Check no negative layers
- [ ] Verify forward flow property

### Phase 4: Testing (2 hours)
- [ ] Write unit tests (8+ test cases)
- [ ] Write performance tests (1k, 10k cells)
- [ ] Write integration test with real netlist
- [ ] Achieve >90% coverage

### Phase 5: Documentation (1 hour)
- [ ] Write module docstring
- [ ] Document function signatures
- [ ] Add usage examples
- [ ] Document time/space complexity

**Total Estimated Time**: 8-10 hours (matches spec estimate)

---

## 10. References

### Algorithm References
- Sugiyama et al., "Methods for Visual Understanding of Hierarchical System Structures" (1981)
- Cormen et al., "Introduction to Algorithms" - Chapter on DFS and Topological Sort

### Code References
- NetworkX Documentation: https://networkx.org/documentation/stable/reference/algorithms/dag.html
- grandalf implementation: https://github.com/bdcht/grandalf/blob/master/grandalf/layouts.py

### Internal References
- [Parent Feature Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/E02-F02.spec.md)
- [Architecture: Layer Architecture](/home/joohan/dev/project-ink/ink/docs/architecture/layer-architecture.md)
- [CLAUDE.md](/home/joohan/dev/project-ink/ink/CLAUDE.md) - Project guidelines

---

**Document Status**: Ready for Implementation
**Next Steps**: Review with team, begin Phase 1 implementation, set up test infrastructure
