# E02-F02-T03 - Coordinate Assignment Algorithm: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F02-T03
- **Task**: Coordinate Assignment Algorithm
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the third and final phase of the Sugiyama hierarchical layout algorithm: coordinate assignment. After layer assignment and crossing minimization have determined the logical structure (which layer, which order within layer), this phase translates those abstract positions into concrete X/Y pixel coordinates for rendering.

**Core Deliverables:**
- Linear coordinate assignment algorithm
- Configurable horizontal (layer) and vertical (cell) spacing
- Vertical centering alignment within layers
- Bounding box calculation for entire layout
- Integration with cell dimension data

**Success Metrics:**
- All cells assigned valid X/Y coordinates
- Performance: <50ms for 1000 cells, <500ms for 10,000 cells
- Accurate bounding box calculation (1px precision)
- Clean visual alignment with even spacing

### 1.2 Problem Context

At this stage, we have:
- Layer assignments: `{"A": 0, "B": 1, "C": 2}` (horizontal position)
- Layer ordering: `{0: ["IN1", "IN2"], 1: ["A", "B"], 2: ["OUT"]}` (vertical position)

But we need concrete pixel coordinates for the rendering engine:
- Position map: `{"IN1": (0, -50), "IN2": (0, 50), "A": (200, -50), ...}`

The coordinate assignment phase bridges this gap, applying spacing rules and alignment to produce a renderable layout.

**Key Challenges:**
- Variable cell dimensions (different widths/heights)
- Vertical centering within layers
- Configurable spacing parameters
- Bounding box calculation for pan/zoom

---

## 2. Implementation Approach

### 2.1 Algorithm Selection: Linear Coordinate Assignment

**Decision**: Use simple linear spacing with vertical centering.

**Rationale:**
- Straightforward, fast O(V) implementation
- Predictable, uniform appearance
- Easy to configure (spacing parameters)
- Sufficient for MVP (advanced layout optimization deferred to P1)

**Algorithm Overview:**

```
1. Calculate layer X coordinates:
   x[layer] = layer * layer_spacing

2. For each layer:
   a. Calculate total layer height:
      height = sum(cell_heights) + (n-1) * cell_spacing

   b. Center layer vertically:
      y_start = -height / 2

   c. Assign Y coordinates in order:
      For each cell in layer_order[layer]:
        y[cell] = y_start + cumulative_height + cell_height/2
        cumulative_height += cell_height + cell_spacing

3. Calculate bounding box:
   min_x = min(x - width/2) for all cells
   max_x = max(x + width/2) for all cells
   min_y = min(y - height/2) for all cells
   max_y = max(y + height/2) for all cells
```

**Time Complexity**: O(V) where V = number of cells
**Space Complexity**: O(V) for position map

### 2.2 Coordinate System and Conventions

**Coordinate System:**
- Origin (0, 0) at center of first layer, vertical center
- X-axis increases rightward (layer 0 → layer 1 → layer 2...)
- Y-axis increases downward (Qt convention)
- Cell positions represent cell **centers**, not top-left corners

**Spacing Parameters:**

| Parameter | Default | Description |
|-----------|---------|-------------|
| `layer_spacing` | 200.0 px | Horizontal distance between layers |
| `cell_spacing` | 100.0 px | Vertical distance between cells in same layer |
| `direction` | "LR" | Layout direction (Left-Right or Top-Bottom) |

**Example Layout:**
```
Layer 0 (x=0)         Layer 1 (x=200)       Layer 2 (x=400)

                      ┌─────┐
   ┌─────┐            │  B  │ (200, -75)
   │ IN1 │ (0, -50)   └─────┘
   └─────┘                               ┌─────┐
                      ┌─────┐            │ OUT │ (400, 0)
   ┌─────┐            │  C  │ (200, 75)  └─────┘
   │ IN2 │ (0, 50)    └─────┘
   └─────┘

Spacing:
- layer_spacing = 200px (horizontal)
- cell_spacing = 100px (vertical, between IN1 and IN2)
- Layer 1 centered vertically around y=0
```

### 2.3 Cell Dimension Integration

**Challenge**: Cells have different dimensions (width, height).

**Approach**: Accept cell dimensions as input parameter.

```python
cell_dimensions: Dict[CellId, Tuple[float, float]] = {
    "AND2_X1": (80.0, 60.0),  # width, height
    "DFFR_X1": (100.0, 80.0),
    "INV_X1": (60.0, 50.0),
    ...
}
```

**Fallback**: If dimension not available, use default (80px × 60px).

**Integration Point**: Will integrate with E02-F01 (Cell Symbol Rendering) for actual dimensions. For T03 implementation, use placeholder dimensions.

### 2.4 Data Structures

**Input:**
- `layer_map: Dict[CellId, int]` - From T01
- `layer_order: Dict[int, List[CellId]]` - From T02
- `cell_dimensions: Dict[CellId, Tuple[float, float]]` - Cell sizes
- `config: LayoutConfig` - Spacing parameters

**Output:**
- `CoordinateAssignment` dataclass:
  ```python
  @dataclass
  class CoordinateAssignment:
      position_map: Dict[CellId, Position]  # Cell -> (x, y)
      bounding_box: BoundingBox  # Layout bounds
  ```

**Value Objects:**
```python
@dataclass(frozen=True)
class Position:
    x: float
    y: float

@dataclass(frozen=True)
class BoundingBox:
    x: float      # Top-left X
    y: float      # Top-left Y
    width: float
    height: float
```

---

## 3. Key Design Decisions

### Decision 1: Linear vs. Priority-based Spacing

**Choice**: Linear spacing with uniform `cell_spacing`

**Alternatives Considered:**
- Priority-based: More space for high-fanout cells
- Minimum separation: Cells packed tightly with minimum gaps
- Force-directed: Cells positioned based on edge forces

**Rationale**: Linear spacing is simple, predictable, and sufficient for MVP. Advanced spacing can be added in P1 if needed.

### Decision 2: Vertical Alignment Strategy

**Choice**: Center alignment (layer centered around y=0)

**Alternatives Considered:**

| Strategy | Pros | Cons | Verdict |
|----------|------|------|---------|
| Top alignment | Simple calculation | Unbalanced visual weight | Rejected |
| Center alignment | Balanced appearance | Slightly more complex | **Selected** |
| Bottom alignment | Simple calculation | Unbalanced visual weight | Rejected |
| Baseline alignment | Professional look | Requires cell baseline metadata | Deferred to P1 |

**Rationale**: Center alignment provides the most balanced visual appearance, especially for layers with varying heights.

### Decision 3: Coordinate Precision

**Choice**: Floating-point coordinates (float) with 1px accuracy

**Alternatives:**
- Integer coordinates: Simpler but less flexible
- Sub-pixel precision: Unnecessary complexity

**Rationale**: Qt renders with sub-pixel precision, but 1px accuracy is sufficient for schematic rendering. Using float allows smooth zooming without rounding artifacts.

### Decision 4: Bounding Box Calculation

**Choice**: Calculate from min/max positions including cell dimensions

**Implementation:**
```python
def calculate_bounding_box(
    position_map: Dict[CellId, Position],
    cell_dimensions: Dict[CellId, Tuple[float, float]]
) -> BoundingBox:
    """Calculate tight bounding box around all cells."""
    min_x = float('inf')
    max_x = float('-inf')
    min_y = float('inf')
    max_y = float('-inf')

    for cell, pos in position_map.items():
        width, height = cell_dimensions.get(cell, (80.0, 60.0))
        # Cell center is at pos, so bounds are ±width/2, ±height/2
        min_x = min(min_x, pos.x - width / 2)
        max_x = max(max_x, pos.x + width / 2)
        min_y = min(min_y, pos.y - height / 2)
        max_y = max(max_y, pos.y + height / 2)

    return BoundingBox(
        x=min_x,
        y=min_y,
        width=max_x - min_x,
        height=max_y - min_y
    )
```

**Rationale**: Tight bounding box enables accurate fit-to-view and scroll bar sizing in UI.

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E02-F02-T01: Layer Assignment**
- Provides `layer_map: Dict[CellId, int]`
- Needed for X coordinate calculation
- **Integration Point**: Receive `LayerAssignment.layer_map`

**E02-F02-T02: Crossing Minimization**
- Provides `layer_order: Dict[int, List[CellId]]`
- Needed for Y coordinate calculation
- **Integration Point**: Receive `LayerOrder.layer_order`

**E02-F01: Cell Symbol Rendering (Future)**
- Will provide actual cell dimensions
- For now, use placeholder dimensions
- **Integration Point**: `get_cell_dimensions()` function

### 4.2 Downstream Consumers

**E02-F03: Net Routing**
- Uses `position_map` to determine pin locations
- Needs cell positions for routing endpoints
- **Interface**: Pass `CoordinateAssignment.position_map`

**E02-F02-T04: SugiyamaLayoutEngine**
- Orchestrates coordinate assignment as Phase 3
- Manages configuration
- **Interface**: Call `assign_coordinates(layer_map, layer_order, cell_dims, config)`

**Presentation Layer: SchematicCanvas**
- Uses `position_map` to render cells
- Uses `bounding_box` for view scaling
- **Interface**: Consume `CoordinateAssignment` object

### 4.3 Domain Layer Integration

**Location**: `src/ink/infrastructure/layout/coordinate_assignment.py`

**Value Objects**: `Position` and `BoundingBox` should be defined in `domain/value_objects/position.py` since they're domain concepts used across layers.

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Test Coverage Goals**: >90%

**Test Cases:**

```python
# Test 1: Single cell
def test_coordinate_assignment_single_cell():
    """Single cell should be at (0, 0)"""
    layer_map = {"A": 0}
    layer_order = {0: ["A"]}
    cell_dims = {"A": (80.0, 60.0)}
    config = LayoutConfig()

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    assert result.position_map["A"] == Position(0.0, 0.0)
    assert result.bounding_box.width == 80.0
    assert result.bounding_box.height == 60.0

# Test 2: Two layers, single cell each
def test_coordinate_assignment_two_layers():
    """Two layers should be spaced by layer_spacing"""
    layer_map = {"A": 0, "B": 1}
    layer_order = {0: ["A"], 1: ["B"]}
    cell_dims = {"A": (80.0, 60.0), "B": (80.0, 60.0)}
    config = LayoutConfig(layer_spacing=200.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    assert result.position_map["A"].x == 0.0
    assert result.position_map["B"].x == 200.0
    assert result.position_map["A"].y == 0.0  # Centered
    assert result.position_map["B"].y == 0.0  # Centered

# Test 3: Multiple cells in one layer
def test_coordinate_assignment_vertical_spacing():
    """Multiple cells in layer should have cell_spacing"""
    layer_map = {"A": 0, "B": 0, "C": 0}
    layer_order = {0: ["A", "B", "C"]}
    cell_dims = {"A": (80, 60), "B": (80, 60), "C": (80, 60)}
    config = LayoutConfig(cell_spacing=100.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    # Total height: 3*60 + 2*100 = 380
    # Centered: y_start = -190, cells at -160, 0, +160 (centered on their height)
    expected_y = [
        -190 + 30,    # A: y_start + height/2 = -160
        -190 + 60 + 100 + 30,  # B: 0
        -190 + 60 + 100 + 60 + 100 + 30  # C: +160
    ]

    assert result.position_map["A"].y == pytest.approx(expected_y[0])
    assert result.position_map["B"].y == pytest.approx(expected_y[1])
    assert result.position_map["C"].y == pytest.approx(expected_y[2])

# Test 4: Custom spacing configuration
def test_coordinate_assignment_custom_config():
    """Custom spacing should be applied"""
    layer_map = {"A": 0, "B": 1}
    layer_order = {0: ["A"], 1: ["B"]}
    cell_dims = {"A": (80, 60), "B": (80, 60)}
    config = LayoutConfig(layer_spacing=300.0, cell_spacing=150.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    assert result.position_map["A"].x == 0.0
    assert result.position_map["B"].x == 300.0  # Custom layer spacing

# Test 5: Bounding box calculation
def test_coordinate_assignment_bounding_box():
    """Bounding box should encompass all cells"""
    layer_map = {"A": 0, "B": 1}
    layer_order = {0: ["A"], 1: ["B"]}
    cell_dims = {"A": (80, 60), "B": (100, 80)}
    config = LayoutConfig(layer_spacing=200.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    # A at (0, 0) with size 80×60: bounds [-40, -30] to [40, 30]
    # B at (200, 0) with size 100×80: bounds [150, -40] to [250, 40]
    # Combined bounds: [-40, -40] to [250, 40]
    assert result.bounding_box.x == pytest.approx(-40.0)
    assert result.bounding_box.y == pytest.approx(-40.0)
    assert result.bounding_box.width == pytest.approx(290.0)  # 250 - (-40)
    assert result.bounding_box.height == pytest.approx(80.0)  # 40 - (-40)

# Test 6: Empty layer
def test_coordinate_assignment_empty_layer():
    """Empty layer should be skipped"""
    layer_map = {"A": 0, "C": 2}
    layer_order = {0: ["A"], 1: [], 2: ["C"]}  # Layer 1 empty
    cell_dims = {"A": (80, 60), "C": (80, 60)}
    config = LayoutConfig(layer_spacing=200.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    assert result.position_map["A"].x == 0.0
    assert result.position_map["C"].x == 400.0  # Still layer 2 * 200

# Test 7: Variable cell dimensions
def test_coordinate_assignment_variable_dimensions():
    """Different cell dimensions should be handled"""
    layer_map = {"A": 0, "B": 0}
    layer_order = {0: ["A", "B"]}
    cell_dims = {"A": (80, 40), "B": (80, 100)}  # Different heights
    config = LayoutConfig(cell_spacing=100.0)

    result = assign_coordinates(layer_map, layer_order, cell_dims, config)

    # Total height: 40 + 100 + 100 = 240
    # Centered: y_start = -120
    # A: -120 + 40/2 = -100
    # B: -120 + 40 + 100 + 100/2 = 70
    assert result.position_map["A"].y == pytest.approx(-100.0)
    assert result.position_map["B"].y == pytest.approx(70.0)

# Test 8: Empty graph
def test_coordinate_assignment_empty_graph():
    """Empty graph should return empty results"""
    result = assign_coordinates({}, {}, {}, LayoutConfig())

    assert result.position_map == {}
    assert result.bounding_box == BoundingBox(0, 0, 0, 0)
```

### 5.2 Performance Tests

```python
def test_coordinate_assignment_performance_1k_cells():
    """1000 cells should complete in <50ms"""
    # Create test data
    layer_map = {f"cell_{i}": i // 10 for i in range(1000)}
    layer_order = defaultdict(list)
    for cell, layer in layer_map.items():
        layer_order[layer].append(cell)
    cell_dims = {f"cell_{i}": (80, 60) for i in range(1000)}

    start = time()
    result = assign_coordinates(layer_map, dict(layer_order), cell_dims, LayoutConfig())
    duration = time() - start

    assert duration < 0.05, f"Took {duration:.3f}s, expected <0.05s"
    assert len(result.position_map) == 1000

def test_coordinate_assignment_performance_10k_cells():
    """10,000 cells should complete in <500ms"""
    layer_map = {f"cell_{i}": i // 100 for i in range(10000)}
    layer_order = defaultdict(list)
    for cell, layer in layer_map.items():
        layer_order[layer].append(cell)
    cell_dims = {f"cell_{i}": (80, 60) for i in range(10000)}

    start = time()
    result = assign_coordinates(layer_map, dict(layer_order), cell_dims, LayoutConfig())
    duration = time() - start

    assert duration < 0.5, f"Took {duration:.3f}s, expected <0.5s"
    assert len(result.position_map) == 10000
```

### 5.3 Integration Tests

```python
def test_coordinate_assignment_full_pipeline():
    """Test T01 → T02 → T03 pipeline"""
    from ink.infrastructure.layout.layer_assignment import assign_layers
    from ink.infrastructure.layout.crossing_minimization import minimize_crossings

    # Use real netlist
    graph = parse_netlist("examples/adder_4bit.ckt")

    # Phase 1: Layer assignment
    layer_result = assign_layers(graph)

    # Phase 2: Crossing minimization
    order_result = minimize_crossings(graph, layer_result.layer_map)

    # Phase 3: Coordinate assignment
    cell_dims = {cell: (80, 60) for cell in graph.nodes()}
    coord_result = assign_coordinates(
        layer_result.layer_map,
        order_result.layer_order,
        cell_dims,
        LayoutConfig()
    )

    # Verify all cells positioned
    assert len(coord_result.position_map) == len(graph.nodes())

    # Verify positions are valid
    for pos in coord_result.position_map.values():
        assert isinstance(pos, Position)
        assert pos.x >= 0  # All cells in positive X space
        assert -10000 < pos.y < 10000  # Reasonable Y bounds

    # Verify bounding box
    assert coord_result.bounding_box.width > 0
    assert coord_result.bounding_box.height > 0
```

---

## 6. Risks and Considerations

### Risk 1: Cell Overlap Due to Insufficient Spacing

**Impact**: High
**Probability**: Low
**Concern**: Cells might overlap if `cell_spacing` is too small or cell dimensions are wrong

**Mitigation:**
- Validate `cell_spacing >= max(cell_heights)` in debug mode
- Unit tests verify spacing
- Visual inspection with test netlists
- Add overlap detection in debug mode

### Risk 2: Bounding Box Calculation Errors

**Impact**: Medium
**Probability**: Low
**Concern**: Incorrect bounds could cause rendering clipping or incorrect fit-to-view

**Mitigation:**
- Comprehensive unit tests for bounding box
- Visual validation with various graph sizes
- Add assertions: `width > 0`, `height > 0`

### Risk 3: Performance with Very Wide Layers

**Impact**: Low
**Probability**: Medium
**Concern**: Layers with 1000+ cells might be slow to calculate cumulative heights

**Mitigation:**
- Algorithm is already O(V), no optimization needed
- Profile with wide-layer test case
- If needed, use numpy for vectorized cumulative sum

### Risk 4: Coordinate Precision Issues

**Impact**: Low
**Probability**: Low
**Concern**: Floating-point rounding could cause visual artifacts

**Mitigation:**
- Use float throughout (no premature rounding)
- Round only at final rendering stage (in UI layer)
- Test with extreme zoom levels

### Risk 5: Integration with Variable Cell Dimensions

**Impact**: Medium
**Probability**: Medium
**Concern**: E02-F01 may not be ready, need placeholder dimensions

**Mitigation:**
- Design API to accept dimensions as parameter
- Use default dimensions (80×60) as fallback
- Add TODO comment for E02-F01 integration
- Integration can be added later without API changes

---

## 7. Open Questions

### Q1: Should we add minimum spacing enforcement?

**Context**: Should we validate that `cell_spacing` is sufficient to prevent overlap?

**Recommendation**: Add validation in debug mode, warn but don't error in production

**Decision Needed By**: Before implementation

---

### Q2: How to handle extremely wide cells?

**Context**: If a cell width exceeds `layer_spacing`, it could overlap adjacent layers

**Options:**
- Increase `layer_spacing` dynamically
- Warn and accept overlap
- Error on invalid configuration

**Recommendation**: Accept for MVP, add dynamic spacing in P1

**Decision Needed By**: After E02-F01 provides actual dimensions

---

### Q3: Should we support top-to-bottom layout direction?

**Context**: Some users prefer vertical signal flow

**Recommendation**: Design API to support (add `direction` parameter) but only implement "LR" for MVP

**Decision Needed By**: Before API freeze

---

## 8. Success Criteria

### Acceptance Criteria

- [ ] All cells assigned valid X/Y coordinates
- [ ] Configurable `layer_spacing` and `cell_spacing` applied correctly
- [ ] Cells centered vertically within each layer
- [ ] No cell overlaps in final layout (with proper spacing)
- [ ] Bounding box accurately encompasses all cells (1px precision)
- [ ] Performance: <50ms for 1K cells, <500ms for 10K cells
- [ ] Handles empty layers gracefully
- [ ] Handles single-cell graphs correctly
- [ ] Variable cell dimensions supported
- [ ] Unit test coverage >90%

### Definition of Done

- [ ] `coordinate_assignment.py` implemented in `infrastructure/layout/`
- [ ] `Position` value object defined in `domain/value_objects/position.py`
- [ ] `BoundingBox` value object defined in `domain/value_objects/position.py`
- [ ] `CoordinateAssignment` dataclass defined
- [ ] `LayoutConfig` dataclass defined
- [ ] `assign_coordinates()` function implemented
- [ ] All unit tests passing
- [ ] Performance tests validated
- [ ] Integration test with T01+T02 passing
- [ ] Code reviewed and approved
- [ ] Module docstrings complete with usage examples

---

## 9. Implementation Checklist

### Phase 1: Data Structures (1 hour)
- [ ] Define `Position` value object in `domain/value_objects/position.py`
- [ ] Define `BoundingBox` value object
- [ ] Define `LayoutConfig` dataclass
- [ ] Define `CoordinateAssignment` dataclass
- [ ] Add type hints and immutability

### Phase 2: Layer X Coordinates (1 hour)
- [ ] Create `coordinate_assignment.py` module
- [ ] Implement layer X coordinate calculation
- [ ] Handle empty layers
- [ ] Add unit tests for X positioning

### Phase 3: Cell Y Coordinates (2 hours)
- [ ] Implement vertical centering logic
- [ ] Calculate cumulative heights
- [ ] Handle variable cell dimensions
- [ ] Add unit tests for Y positioning

### Phase 4: Bounding Box (1 hour)
- [ ] Implement `calculate_bounding_box()` function
- [ ] Handle empty graphs
- [ ] Add unit tests for bounding box

### Phase 5: Integration (1 hour)
- [ ] Integrate X and Y coordinate assignment
- [ ] Add configuration parameter handling
- [ ] Handle edge cases (empty graph, single cell)
- [ ] Add validation

### Phase 6: Testing (2 hours)
- [ ] Write unit tests (8+ test cases)
- [ ] Write performance tests (1k, 10k cells)
- [ ] Integration test with T01+T02
- [ ] Achieve >90% coverage

### Phase 7: Documentation (1 hour)
- [ ] Write module docstring
- [ ] Document function signatures
- [ ] Add usage examples
- [ ] Document coordinate system conventions

**Total Estimated Time**: 6-8 hours (matches spec estimate)

---

## 10. References

### Algorithm References
- Sugiyama et al., "Methods for Visual Understanding of Hierarchical System Structures" (1981)
- Brandes & Köpf, "Fast and Simple Horizontal Coordinate Assignment" (2001) - Advanced techniques

### Implementation References
- Qt Coordinate System: https://doc.qt.io/qt-6/coordsys.html
- grandalf coordinate assignment: https://github.com/bdcht/grandalf

### Internal References
- [Parent Feature Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/E02-F02.spec.md)
- [Layer Assignment Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T01/E02-F02-T01.spec.md)
- [Crossing Minimization Spec](/home/joohan/dev/project-ink/ink/specs/E02/F02/T02/E02-F02-T02.spec.md)
- [Architecture: DDD Architecture](/home/joohan/dev/project-ink/ink/docs/architecture/ddd-architecture.md)

---

**Document Status**: Ready for Implementation
**Next Steps**: Review with team, coordinate with E02-F01 for cell dimensions, begin implementation after T02 completion
