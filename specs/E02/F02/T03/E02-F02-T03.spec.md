---
id: E02-F02-T03
title: Coordinate Assignment Algorithm
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F02
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - layout
  - positioning
  - coordinates
clickup_task_id: ''
---

# Spec: E02-F02-T03 - Coordinate Assignment Algorithm

## 1. Overview

### 1.1 Problem Statement

After layer assignment and crossing minimization, cells have logical positions (layer, order within layer) but no concrete X/Y coordinates for rendering. The coordinate assignment phase translates the abstract layer structure into pixel coordinates, applying spacing rules and alignment to create a renderable schematic layout.

### 1.2 Goals

- Convert layer/order assignments to X/Y pixel coordinates
- Apply configurable horizontal (layer) and vertical (cell) spacing
- Align cells within layers for clean visual appearance
- Support left-to-right signal flow direction
- Calculate bounding box for the entire layout

---

## 2. Executive Summary

This task implements the coordinate assignment phase of Sugiyama layout. It takes the layer structure and cell ordering from previous phases and computes final X/Y positions for each cell, applying spacing parameters and alignment rules. The result is a complete position map ready for rendering.

---

## 3. Execution Flow

```
1. Initialize coordinate assignment context
   → Input: layer_map, layer_order, cell_dimensions
   → Input: layout_config (layer_spacing, cell_spacing)
   → Create position_map: Dict[CellId, Position]

2. Calculate layer X coordinates
   → For each layer i from 0 to N-1:
     - x_position = i * layer_spacing
     - Store layer_x_positions[i] = x_position

3. Calculate cell Y coordinates for each layer
   → For each layer i:
     a. Get ordered cells: layer_order[i]
     b. Calculate total layer height: sum(cell_heights) + (n-1) * cell_spacing
     c. Center layer vertically around y=0
     d. Assign Y position to each cell in order:
        - y_offset = -total_height/2 + cumulative_height
        - position_map[cell] = Position(layer_x_positions[i], y_offset)

4. Apply cell dimension offsets
   → For each cell, adjust position based on symbol anchor point
   → If anchor is CENTER: no adjustment
   → If anchor is TOP_LEFT: adjust by (width/2, height/2)
   → Update position_map with adjusted positions

5. Calculate layout bounding box
   → min_x = min(p.x - cell_width/2 for all cells)
   → max_x = max(p.x + cell_width/2 for all cells)
   → min_y = min(p.y - cell_height/2 for all cells)
   → max_y = max(p.y + cell_height/2 for all cells)
   → bounding_box = BoundingBox(min_x, min_y, max_x - min_x, max_y - min_y)

6. Validate coordinates
   → Ensure all cells have positions assigned
   → Check no positions are negative (if absolute positioning)
   → If validation fails: ERROR "Invalid coordinates generated"

7. Return coordinate assignment results
   → Return: SUCCESS with CoordinateAssignment(position_map, bounding_box)
```

---

## 4. User Stories

### Primary User Story
**As a** layout engine
**I want to** convert logical layer/order into pixel coordinates
**So that** cells can be rendered on the schematic canvas

### Additional Stories
- **As a** user, **I want to** see evenly spaced cells, **So that** the schematic is visually clean
- **As a** developer, **I want to** configure spacing parameters, **So that** layout density is adjustable

---

## 5. Acceptance Scenarios

### Scenario 1: Simple Two-Layer Layout
**Given** layer 0 has [A, B] and layer 1 has [C] with spacing 200px horizontal, 100px vertical
**When** coordinate assignment runs
**Then** A at (0, -50), B at (0, 50), C at (200, 0)

### Scenario 2: Multi-Layer with Varying Cell Heights
**Given** 3 layers with cells of different heights
**When** coordinate assignment runs
**Then** cells centered vertically in each layer, proper spacing maintained

### Scenario 3: Empty Layer
**Given** layer 2 has no cells
**When** coordinate assignment runs
**Then** no coordinates assigned for layer 2, no error occurs

### Scenario 4: Single Cell Graph
**Given** one cell in layer 0
**When** coordinate assignment runs
**Then** cell positioned at (0, 0), bounding box calculated correctly

---

## 6. Requirements

### Functional Requirements
- **FR-001**: Algorithm MUST assign X/Y coordinates to all cells
- **FR-002**: Algorithm MUST use configurable layer spacing (horizontal)
- **FR-003**: Algorithm MUST use configurable cell spacing (vertical)
- **FR-004**: Algorithm MUST center cells vertically within each layer
- **FR-005**: Algorithm MUST calculate accurate bounding box for layout
- **FR-006**: Algorithm MUST support cell dimension awareness (width/height)

### Non-Functional Requirements
- **NFR-001**: Performance: Complete coordinate assignment for 1000 cells in <50ms
- **NFR-002**: Performance: Complete coordinate assignment for 10,000 cells in <500ms
- **NFR-003**: Accuracy: Coordinates accurate to 1px precision
- **NFR-004**: Memory: Use O(V) space where V=cells

### Technical Constraints
- **TC-001**: Must work with layer_map from E02-F02-T01
- **TC-002**: Must work with layer_order from E02-F02-T02
- **TC-003**: Must support future top-to-bottom layout direction
- **TC-004**: Must integrate with cell symbol dimensions from E02-F01

---

## 7. Key Entities

### Entity: Position
- **Description**: 2D coordinate in pixel space
- **Key Attributes**:
  - `x: float` - Horizontal position
  - `y: float` - Vertical position
- **Relationships**: Assigned to each cell in position_map

### Entity: BoundingBox
- **Description**: Rectangular bounds of entire layout
- **Key Attributes**:
  - `x: float` - Top-left X coordinate
  - `y: float` - Top-left Y coordinate
  - `width: float` - Bounding box width
  - `height: float` - Bounding box height
- **Relationships**: Calculated from all cell positions

### Entity: CoordinateAssignment
- **Description**: Result of coordinate assignment algorithm
- **Key Attributes**:
  - `position_map: Dict[CellId, Position]` - Cell to position mapping
  - `bounding_box: BoundingBox` - Layout bounds
- **Relationships**: Final output of layout engine

### Entity: LayoutConfig
- **Description**: Configuration for coordinate assignment
- **Key Attributes**:
  - `layer_spacing: float` - Horizontal spacing between layers (default: 200px)
  - `cell_spacing: float` - Vertical spacing between cells (default: 100px)
  - `direction: str` - Layout direction ("LR" or "TB")
- **Relationships**: Input parameter to algorithm

---

## 8. Dependencies

### Upstream Dependencies
- [x] E02-F02-T01: Layer assignment provides layer_map
- [x] E02-F02-T02: Crossing minimization provides layer_order
- [x] E02-F01: Cell symbol rendering provides cell dimensions

### Downstream Impact
- [ ] E02-F03: Net routing uses cell positions for edge routing
- [ ] E03: Expansion updates use coordinate assignment for incremental layout
- [ ] Presentation layer: SchematicCanvas uses positions for rendering

---

## 9. Implementation Details

### Algorithm: Linear Coordinate Assignment

```python
@dataclass(frozen=True)
class Position:
    x: float
    y: float


@dataclass(frozen=True)
class BoundingBox:
    x: float
    y: float
    width: float
    height: float


@dataclass
class LayoutConfig:
    layer_spacing: float = 200.0
    cell_spacing: float = 100.0
    direction: str = "LR"  # Left-to-right


@dataclass
class CoordinateAssignment:
    position_map: Dict[CellId, Position]
    bounding_box: BoundingBox


def assign_coordinates(
    layer_map: Dict[CellId, int],
    layer_order: Dict[int, List[CellId]],
    cell_dimensions: Dict[CellId, Tuple[float, float]],
    config: LayoutConfig
) -> CoordinateAssignment:
    """
    Assign X/Y coordinates to cells based on layer structure.

    Time Complexity: O(V) where V=cells
    Space Complexity: O(V)
    """
    position_map = {}
    num_layers = max(layer_map.values()) + 1

    # Step 1: Calculate layer X positions
    layer_x_positions = {
        i: i * config.layer_spacing for i in range(num_layers)
    }

    # Step 2: Assign coordinates to each cell
    for layer_idx, cells in layer_order.items():
        if not cells:
            continue

        x_pos = layer_x_positions[layer_idx]

        # Calculate total layer height
        total_height = sum(
            cell_dimensions.get(cell, (0, 0))[1] for cell in cells
        )
        total_spacing = (len(cells) - 1) * config.cell_spacing
        total_layer_height = total_height + total_spacing

        # Start from top (negative y)
        y_offset = -total_layer_height / 2

        # Assign Y positions
        for cell in cells:
            cell_width, cell_height = cell_dimensions.get(cell, (0, 0))

            # Cell center position
            cell_center_y = y_offset + cell_height / 2
            position_map[cell] = Position(x_pos, cell_center_y)

            # Move to next cell position
            y_offset += cell_height + config.cell_spacing

    # Step 3: Calculate bounding box
    if position_map:
        positions_with_dims = [
            (
                pos.x - cell_dimensions.get(cell, (0, 0))[0] / 2,
                pos.y - cell_dimensions.get(cell, (0, 0))[1] / 2,
                pos.x + cell_dimensions.get(cell, (0, 0))[0] / 2,
                pos.y + cell_dimensions.get(cell, (0, 0))[1] / 2,
            )
            for cell, pos in position_map.items()
        ]

        min_x = min(p[0] for p in positions_with_dims)
        min_y = min(p[1] for p in positions_with_dims)
        max_x = max(p[2] for p in positions_with_dims)
        max_y = max(p[3] for p in positions_with_dims)

        bounding_box = BoundingBox(
            x=min_x,
            y=min_y,
            width=max_x - min_x,
            height=max_y - min_y
        )
    else:
        bounding_box = BoundingBox(0, 0, 0, 0)

    return CoordinateAssignment(position_map, bounding_box)
```

### Alignment Strategies

**Current: Vertical Center Alignment**
- Cells in each layer centered around y=0
- Symmetric distribution above/below horizontal axis

**Future Options:**
- Top alignment: All cells start at same y
- Bottom alignment: All cells end at same y
- Weighted alignment: Based on connectivity importance

### Spacing Calculations

**Layer Spacing (Horizontal):**
- Default: 200px between layers
- Ensures adequate space for net routing
- Adjustable based on cell width and edge density

**Cell Spacing (Vertical):**
- Default: 100px between cells in same layer
- Prevents cell overlap
- Adjustable based on pin count and routing complexity

---

## 10. Acceptance Criteria

- [ ] All cells assigned valid X/Y coordinates
- [ ] Configurable layer and cell spacing applied correctly
- [ ] Cells centered vertically within each layer
- [ ] No cell overlaps in final layout
- [ ] Bounding box accurately encompasses all cells
- [ ] Performance: <50ms for 1K cells, <500ms for 10K cells
- [ ] Handles empty layers gracefully
- [ ] Handles single-cell graphs correctly

---

## 11. Testing Strategy

### Unit Tests
- Test single-cell coordinate assignment
- Test multi-layer coordinate assignment
- Test empty layer handling
- Test bounding box calculation
- Test custom spacing configurations
- Test cell dimension integration

### Performance Tests
- Benchmark 1K, 10K, 100K cell graphs
- Verify O(V) time complexity
- Memory profiling for large graphs

### Integration Tests
- Test with layer_map and layer_order from T01/T02
- Test with real cell dimensions from E02-F01
- Visual validation of coordinate accuracy

### Visual Tests
- Render small test circuits
- Verify spacing visually
- Check alignment and centering

---

## 12. Success Criteria

### Acceptance Criteria
- [ ] Accurate coordinate assignment for all cells
- [ ] Configurable spacing parameters working
- [ ] Performance targets met (<50ms for 1K cells)
- [ ] Zero coordinate calculation errors
- [ ] 90% test coverage

### Definition of Done
- [ ] Code implemented in `infrastructure/layout/coordinate_assignment.py`
- [ ] Unit tests passing with >90% coverage
- [ ] Performance tests validated
- [ ] Integration with T01/T02 verified
- [ ] Code reviewed and approved

---

## 13. Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Cell overlaps due to dimension errors | Low | Medium | Validation tests, visual inspection |
| Bounding box calculation errors | Low | Low | Comprehensive unit tests |
| Performance issues with large layers | Low | Medium | Algorithmic complexity verification |

---

## 14. Notes and Clarifications

### Design Decisions
- 2025-12-26: Center alignment chosen for balanced visual appearance
- 2025-12-26: Layer spacing default (200px) accommodates typical cell widths + routing
- 2025-12-26: Cell spacing default (100px) prevents pin overlap while staying compact

### Future Enhancements
- Support for top-to-bottom layout direction
- Dynamic spacing based on cell connectivity
- Alignment options (top/center/bottom)
- Margin/padding configuration

### Open Questions
- [ ] Should we add minimum spacing enforcement based on pin positions?
- [ ] How to handle extremely wide cells that exceed layer spacing?

---

## 15. Artifacts

### Input Documents
- [Parent Feature Spec](../E02-F02.spec.md)
- [Layer Assignment Spec](../T01/E02-F02-T01.spec.md)
- [Crossing Minimization Spec](../T02/E02-F02-T02.spec.md)

### Output Artifacts
- [ ] `coordinate_assignment.py` - Algorithm implementation
- [ ] `test_coordinate_assignment.py` - Unit tests
- [ ] Module docstring documentation

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F02 split |
