# E02-F01-T05 - Sequential Cell Styling: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F01-T05
- **Task**: Sequential Cell Styling
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements visual styling to distinguish sequential cells (latches and flip-flops) from combinational logic cells. Sequential elements are critical boundaries in digital circuit analysis affecting timing, expansion strategies, and debugging workflows. Clear visual distinction enables engineers to quickly identify these elements during schematic exploration.

**Core Deliverables:**
- Visual styling differentiation for sequential vs combinational cells
- Thicker border rendering for sequential cells (3px vs 2px)
- Distinct fill color (white vs light gray)
- Optional clock icon indicator at FULL detail level
- Consistent styling across all zoom levels

**Success Metrics:**
- Sequential cells visually distinguishable in <1 second glance
- No performance degradation vs standard cell rendering
- Styling accessible to colorblind users (relies on border thickness)
- User acceptance: >80% find distinction clear and helpful

### 1.2 Problem Context

Sequential elements (latches, flip-flops) have special significance in digital circuit design:

1. **Timing Boundaries**: Sequential cells define clock domains and timing paths. Engineers need to quickly identify them for timing analysis.

2. **Expansion Boundaries**: Ink's incremental expansion stops at sequential boundaries by default. Visual distinction helps users understand expansion scope.

3. **Debugging Context**: When tracing signals, knowing whether a cell is sequential vs combinational affects interpretation of circuit behavior.

4. **Circuit Understanding**: Sequential cells represent state storage. Their locations and connections are critical to understanding circuit function.

**Design Challenge**: Provide clear visual distinction without:
- Making sequential cells too visually dominant (distraction)
- Relying solely on color (accessibility concern)
- Adding rendering complexity that degrades performance
- Breaking visual coherence of the schematic

---

## 2. Implementation Approach

### 2.1 Architecture Design

**Integration Point:**

Sequential cell styling is implemented entirely within `CellItem.paint()` method. The domain model provides the `is_sequential` flag, and the presentation layer translates this into visual styling.

```
┌────────────────────────────────────────────┐
│ Presentation Layer                         │
│  └─ CellItem.paint() ◄── THIS TASK        │
│      - Queries cell.is_sequential          │
│      - Selects border width, fill color    │
│      - Draws optional clock icon           │
└────────────┬───────────────────────────────┘
             │ reads
┌────────────▼───────────────────────────────┐
│ Domain Layer                               │
│  └─ Cell.is_sequential: bool               │
│      - Set by parser (E01-F03)             │
│      - Based on cell type pattern matching │
└────────────────────────────────────────────┘
```

**Design Principle**: Styling is a pure presentation concern. Domain model provides semantic information (`is_sequential`), presentation layer handles visual representation.

### 2.2 Visual Style Specification

**Comparison Table:**

| Element | Combinational | Sequential |
|---------|---------------|------------|
| Border Width | 2px | 3px |
| Border Color | #999999 (gray) | #999999 (gray) |
| Fill Color | #F0F0F0 (light gray) | #FFFFFF (white) |
| Clock Icon | None | Optional (FULL detail only) |
| Corner Radius | 5px | 5px |

**Rationale for Choices:**

1. **Thicker Border** (3px vs 2px):
   - Subtle but noticeable difference
   - Works at all zoom levels (thickness scales)
   - Accessible to colorblind users

2. **White Fill** vs light gray:
   - Creates contrast without strong color distinction
   - White = "special" or "highlighted"
   - Maintains professional appearance

3. **Clock Icon** (optional):
   - Only shown at FULL detail (>75% zoom)
   - Additional visual cue when zoomed in
   - Simple clock symbol (circle + hands)
   - Positioned in top-right corner (12x12 pixels)

4. **Same Border Color**:
   - Primary distinction is thickness, not color
   - Maintains visual coherence
   - Color could be configurable in future (user themes)

### 2.3 Implementation in CellItem

```python
# File: src/ink/presentation/canvas/cell_item.py
# Additions/modifications to existing CellItem from T01

class CellItem(QGraphicsItem):
    """QGraphicsItem representing a cell symbol in the schematic canvas."""

    # Style constants
    COMB_BORDER_WIDTH = 2.0
    SEQ_BORDER_WIDTH = 3.0
    COMB_FILL_COLOR = QColor("#F0F0F0")
    SEQ_FILL_COLOR = QColor("#FFFFFF")
    BORDER_COLOR = QColor("#999999")
    SELECTED_BORDER_COLOR = QColor("#2196F3")

    # Clock icon constants
    CLOCK_ICON_SIZE = 12.0
    CLOCK_ICON_MARGIN = 5.0

    def paint(self, painter: QPainter, option, widget=None):
        """Render cell with LOD and sequential styling."""
        if self._detail_level == DetailLevel.MINIMAL:
            self._paint_minimal(painter)
        elif self._detail_level == DetailLevel.BASIC:
            self._paint_basic(painter)
        else:  # FULL
            self._paint_full(painter)

    def _paint_basic(self, painter: QPainter):
        """
        Basic rendering: box + cell name with sequential styling.

        Applies appropriate border width and fill color based on
        whether the cell is sequential.
        """
        # Select style based on cell type
        if self._cell.is_sequential:
            border_width = self.SEQ_BORDER_WIDTH
            fill_color = self.SEQ_FILL_COLOR
        else:
            border_width = self.COMB_BORDER_WIDTH
            fill_color = self.COMB_FILL_COLOR

        # Adjust border color for selection state
        border_color = self._get_border_color(option)

        # Draw cell body
        pen = QPen(border_color, border_width)
        brush = QBrush(fill_color)
        painter.setPen(pen)
        painter.setBrush(brush)

        rect = QRectF(0, 0, self.DEFAULT_WIDTH, self.DEFAULT_HEIGHT)
        painter.drawRoundedRect(rect, self.CORNER_RADIUS, self.CORNER_RADIUS)

        # Draw cell name
        painter.setPen(QColor("#000000"))
        painter.setFont(QFont("Sans-serif", 10))
        painter.drawText(rect, Qt.AlignCenter, self._cell.name)

    def _paint_full(self, painter: QPainter):
        """
        Full rendering: detailed symbol with sequential styling.

        Same as basic, but adds clock icon for sequential cells.
        """
        # Draw cell body (same as basic)
        self._paint_basic(painter)

        # Draw clock indicator for sequential cells
        if self._cell.is_sequential:
            self._draw_clock_indicator(painter)

    def _draw_clock_indicator(self, painter: QPainter):
        """
        Draw small clock symbol for sequential cells.

        Renders a simple clock icon (circle with clock hands) in
        the top-right corner of the cell symbol.
        """
        # Position in top-right corner
        icon_x = self.DEFAULT_WIDTH - self.CLOCK_ICON_SIZE - self.CLOCK_ICON_MARGIN
        icon_y = self.CLOCK_ICON_MARGIN

        # Calculate clock center
        center = QPointF(
            icon_x + self.CLOCK_ICON_SIZE / 2,
            icon_y + self.CLOCK_ICON_SIZE / 2
        )
        radius = (self.CLOCK_ICON_SIZE / 2) - 1

        # Save painter state
        painter.save()

        # Draw clock circle
        painter.setPen(QPen(QColor("#666666"), 1))
        painter.setBrush(Qt.NoBrush)
        painter.drawEllipse(center, radius, radius)

        # Draw clock hands (hour at 12 o'clock, minute at 3 o'clock)
        # Hour hand (pointing up)
        hour_end = center + QPointF(0, -radius * 0.5)
        painter.drawLine(center, hour_end)

        # Minute hand (pointing right)
        minute_end = center + QPointF(radius * 0.7, 0)
        painter.drawLine(center, minute_end)

        # Restore painter state
        painter.restore()

    def _get_border_color(self, option) -> QColor:
        """
        Determine border color based on item state.

        Selection state overrides default border color.
        """
        if option.state & QStyle.State_Selected:
            return self.SELECTED_BORDER_COLOR
        else:
            return self.BORDER_COLOR

    def boundingRect(self) -> QRectF:
        """
        Return the bounding rectangle for collision and rendering.

        Must account for thicker sequential border to prevent clipping.
        """
        # Use sequential border width (thicker) for safe bounds
        half_border = self.SEQ_BORDER_WIDTH / 2.0
        return QRectF(
            -half_border,
            -half_border,
            self.DEFAULT_WIDTH + self.SEQ_BORDER_WIDTH,
            self.DEFAULT_HEIGHT + self.SEQ_BORDER_WIDTH
        )
```

### 2.4 Domain Model Requirement

**Cell Entity Extension:**

The domain `Cell` entity must have an `is_sequential` boolean property. This is set during parsing (E01-F03 Latch Detection).

```python
# File: src/ink/domain/model/cell.py

@dataclass
class Cell:
    id: CellId
    name: str
    cell_type: str
    pins: List[Pin]
    is_sequential: bool  # ← Required for this task

    def __post_init__(self):
        """Validate cell attributes."""
        if self.is_sequential is None:
            raise ValueError("is_sequential must be set")
```

**Detection in Parser (E01-F03):**

```python
# Example detection logic (simplified)

def is_sequential_cell_type(cell_type: str) -> bool:
    """
    Detect if cell type is sequential based on naming patterns.

    Common sequential cell patterns:
    - DFF* (D flip-flops)
    - LATCH* (latches)
    - SDFF* (scan flip-flops)
    - REG* (registers)
    """
    seq_patterns = [
        "DFF", "DFFR", "DFFS", "SDFF",
        "LATCH", "DLATCH",
        "FF", "REG"
    ]

    cell_type_upper = cell_type.upper()
    return any(pattern in cell_type_upper for pattern in seq_patterns)

# In parser:
cell = Cell(
    id=CellId(instance_name),
    name=instance_name,
    cell_type=cell_type,
    pins=pins,
    is_sequential=is_sequential_cell_type(cell_type)
)
```

---

## 3. Key Design Decisions

### Decision 1: Visual Style Approach

**Selected**: Combination of border thickness + fill color + optional icon

**Rationale:**
- **Border thickness** (3px vs 2px): Primary distinction, works at all zoom levels, accessible
- **Fill color** (white vs gray): Reinforces distinction without strong color
- **Clock icon**: Additional cue at high zoom for clarity

**Alternatives Considered:**

| Option | Pros | Cons | Verdict |
|--------|------|------|---------|
| Border color only | Simple | Color-dependent, accessibility concern | Rejected |
| Fill pattern (stripes) | Unique appearance | Complex rendering, noisy | Rejected |
| Rounded vs square corners | Easy to implement | Too subtle, corner clipping issues | Rejected |
| Icon only | Clear symbol | Too small at low zoom | Rejected (but added as enhancement) |

### Decision 2: Clock Icon Design

**Selected**: Simple circle with clock hands (hour + minute)

**Rationale:**
- Universally recognized clock symbol
- Simple to render (circle + 2 lines)
- Clear at 12x12 pixel size
- No external assets required

**Position**: Top-right corner with 5px margin

**Why Top-Right**:
- Doesn't interfere with cell name (centered)
- Standard position for status indicators
- Visible but not dominant

**Alternative Considered**: Use Unicode clock emoji
- Rejected: Font-dependent, inconsistent rendering across platforms

### Decision 3: Border Width Difference

**Selected**: 3px vs 2px (1px difference, 50% increase)

**Rationale:**
- 1px difference is noticeable when cells are side-by-side
- Not so large that sequential cells dominate visually
- Scales proportionally with zoom

**Testing**: User acceptance testing will validate whether 1px is sufficient or if 4px would be clearer.

### Decision 4: Color Accessibility

**Selected**: Primary distinction is border thickness (not color)

**Rationale:**
- Thickness distinction works for colorblind users
- White vs light gray has high luminance contrast (WCAG compliant)
- Color is secondary reinforcement, not sole differentiator

**Accessibility Compliance**:
- Border thickness: 50% increase (easily perceivable)
- Luminance contrast: ~10% difference (subtle but visible)
- Does not rely on color alone (WCAG 2.1 compliant)

### Decision 5: LOD Integration

**Selected**: Clock icon only shown at FULL detail level (>75% zoom)

**Rationale:**
- At lower zoom, icon would be too small to see clearly
- Border thickness and fill color visible at all levels
- Reduces rendering complexity at BASIC and MINIMAL levels

**Behavior by LOD**:
- **MINIMAL**: Solid fill (no distinction, too zoomed out)
- **BASIC**: Border thickness + fill color (core distinction)
- **FULL**: Border thickness + fill color + clock icon (all cues)

---

## 4. Dependencies and Integration

### 4.1 Upstream Dependencies

**E01-F03: Latch Detection** (CRITICAL DEPENDENCY)
- Must set `Cell.is_sequential` flag during parsing
- Without this, all cells will render as combinational

**E01-F01: Cell Domain Entity** (REQUIRED)
- Must support `is_sequential: bool` attribute

**T01: CellItem** (REQUIRED)
- Base implementation must exist
- This task enhances `paint()` method

**T04: Zoom Level of Detail** (SOFT DEPENDENCY)
- Clock icon only shown at FULL detail
- Can implement without T04, but icon always shown

### 4.2 Downstream Consumers

**E04: Interaction** (BENEFITS)
- Selection and highlighting work with styled cells
- No special handling needed

**E06: Property Panel** (USES)
- May show sequential indicator in cell properties
- Consistency with visual styling

**E03: Expansion** (BENEFITS)
- Sequential cells as expansion boundaries more visible
- Helps users understand expansion scope

### 4.3 Integration Risks

**Risk 1**: `is_sequential` flag not set correctly

**Impact**: High - incorrect styling misleads users

**Mitigation**:
- E01-F03 must provide comprehensive cell type detection
- Unit tests verify sequential cell detection patterns
- Manual testing with real netlists validates detection
- Fallback: If `is_sequential` is None, default to False (combinational)

**Risk 2**: Border width causes layout issues

**Impact**: Low - minimal visual misalignment

**Mitigation**:
- `boundingRect()` uses larger border width for safe bounds
- Qt handles clipping automatically
- Visual regression tests catch alignment issues

**Risk 3**: Performance degradation from icon rendering

**Impact**: Low - clock icon is simple

**Mitigation**:
- Icon only rendered at FULL detail (fewer items visible)
- Simple primitives (circle + 2 lines) = fast rendering
- Performance tests verify no regression

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/canvas/test_cell_item_styling.py`

```python
import pytest
from PySide6.QtCore import QRectF
from PySide6.QtGui import QPainter, QPixmap
from ink.presentation.canvas.cell_item import CellItem
from ink.presentation.canvas.detail_level import DetailLevel
from tests.fixtures.cell_fixtures import create_mock_cell

def test_sequential_cell_has_thicker_border():
    """Verify sequential cells use thicker border width."""
    seq_cell = create_mock_cell(name="FF1", is_sequential=True)
    comb_cell = create_mock_cell(name="AND1", is_sequential=False)

    seq_item = CellItem(seq_cell)
    comb_item = CellItem(comb_cell)

    # Verify border width constants
    assert seq_item.SEQ_BORDER_WIDTH > seq_item.COMB_BORDER_WIDTH
    assert seq_item.SEQ_BORDER_WIDTH == 3.0
    assert seq_item.COMB_BORDER_WIDTH == 2.0

def test_sequential_cell_has_white_fill():
    """Verify sequential cells use white fill color."""
    seq_item = CellItem(create_mock_cell(is_sequential=True))
    comb_item = CellItem(create_mock_cell(is_sequential=False))

    assert seq_item.SEQ_FILL_COLOR == QColor("#FFFFFF")
    assert seq_item.COMB_FILL_COLOR == QColor("#F0F0F0")

def test_clock_icon_only_at_full_detail():
    """Verify clock icon only rendered at FULL detail."""
    seq_cell = create_mock_cell(is_sequential=True)
    seq_item = CellItem(seq_cell)

    # Mock painter to capture draw calls
    pixmap = QPixmap(200, 200)
    painter = QPainter(pixmap)

    # At BASIC, clock icon should not be drawn
    seq_item.set_detail_level(DetailLevel.BASIC)
    seq_item.paint(painter, QStyleOptionGraphicsItem(), None)
    # Would need to verify _draw_clock_indicator not called
    # (mock-based test or visual inspection)

    # At FULL, clock icon should be drawn
    seq_item.set_detail_level(DetailLevel.FULL)
    seq_item.paint(painter, QStyleOptionGraphicsItem(), None)
    # Would verify _draw_clock_indicator called

    painter.end()

def test_combinational_cell_no_clock_icon():
    """Verify combinational cells never show clock icon."""
    comb_cell = create_mock_cell(is_sequential=False)
    comb_item = CellItem(comb_cell)
    comb_item.set_detail_level(DetailLevel.FULL)

    # Clock icon should never be drawn for combinational cells
    # (mock-based verification or visual inspection)

def test_bounding_rect_accounts_for_thick_border():
    """Verify bounding rect large enough for sequential border."""
    seq_item = CellItem(create_mock_cell(is_sequential=True))

    bounds = seq_item.boundingRect()

    # Should extend beyond cell dimensions to include thick border
    half_border = seq_item.SEQ_BORDER_WIDTH / 2.0
    expected_width = seq_item.DEFAULT_WIDTH + seq_item.SEQ_BORDER_WIDTH
    expected_height = seq_item.DEFAULT_HEIGHT + seq_item.SEQ_BORDER_WIDTH

    assert bounds.width() >= expected_width
    assert bounds.height() >= expected_height

def test_is_sequential_flag_none_raises_error():
    """Verify cell with None is_sequential raises error."""
    # Domain model validation (if implemented)
    # Should raise ValueError if is_sequential is None
    with pytest.raises(ValueError):
        cell = Cell(
            id=CellId("U1"),
            name="U1",
            cell_type="AND",
            pins=[],
            is_sequential=None  # Invalid
        )
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_sequential_cell_rendering.py`

```python
import pytest
from PySide6.QtWidgets import QGraphicsScene, QGraphicsView
from ink.presentation.canvas.cell_item import CellItem
from tests.fixtures.cell_fixtures import create_mock_cell

def test_mixed_cells_render_distinctly(qtbot):
    """Test sequential and combinational cells render with visual distinction."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    # Create sequential cell
    seq_cell = create_mock_cell(name="FF1", is_sequential=True)
    seq_item = CellItem(seq_cell)
    seq_item.setPos(0.0, 0.0)
    scene.addItem(seq_item)

    # Create combinational cell
    comb_cell = create_mock_cell(name="AND1", is_sequential=False)
    comb_item = CellItem(comb_cell)
    comb_item.setPos(150.0, 0.0)
    scene.addItem(comb_item)

    view.show()
    qtbot.waitExposed(view)

    # Both cells should be visible
    assert seq_item.isVisible()
    assert comb_item.isVisible()

    # Visual distinction would be verified by screenshot comparison
```

### 5.3 Visual Regression Tests

**File**: `tests/visual/test_sequential_styling.py`

```python
def test_sequential_cell_visual_regression(qtbot):
    """Compare rendered sequential cell against reference image."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    # Create sequential cell
    seq_cell = create_mock_cell(name="DFF_X1", is_sequential=True)
    seq_item = CellItem(seq_cell)
    seq_item.setPos(10.0, 10.0)
    seq_item.set_detail_level(DetailLevel.FULL)
    scene.addItem(seq_item)

    view.show()
    qtbot.waitExposed(view)

    # Capture screenshot
    pixmap = view.grab()
    actual_image = pixmap.toImage()

    # Compare against reference
    reference_image = QImage("tests/visual/references/sequential_cell.png")
    diff_percent = compare_images(actual_image, reference_image)

    assert diff_percent < 0.01

def test_combinational_cell_visual_regression(qtbot):
    """Compare rendered combinational cell against reference image."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    comb_cell = create_mock_cell(name="AND2_X1", is_sequential=False)
    comb_item = CellItem(comb_cell)
    comb_item.setPos(10.0, 10.0)
    comb_item.set_detail_level(DetailLevel.FULL)
    scene.addItem(comb_item)

    view.show()
    qtbot.waitExposed(view)

    pixmap = view.grab()
    actual_image = pixmap.toImage()

    reference_image = QImage("tests/visual/references/combinational_cell.png")
    diff_percent = compare_images(actual_image, reference_image)

    assert diff_percent < 0.01

def test_clock_icon_appearance(qtbot):
    """Verify clock icon renders correctly."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    seq_cell = create_mock_cell(name="FF1", is_sequential=True)
    seq_item = CellItem(seq_cell)
    seq_item.setPos(10.0, 10.0)
    seq_item.set_detail_level(DetailLevel.FULL)
    scene.addItem(seq_item)

    # Zoom in to show icon clearly
    view.scale(2.0, 2.0)
    view.show()
    qtbot.waitExposed(view)

    pixmap = view.grab()
    actual_image = pixmap.toImage()

    # Reference image should show clock icon in top-right corner
    reference_image = QImage("tests/visual/references/clock_icon.png")
    diff_percent = compare_images(actual_image, reference_image)

    assert diff_percent < 0.01
```

### 5.4 User Acceptance Testing

**Manual Test Plan:**

1. **Load schematic with mixed cell types**
   - Load netlist with both sequential and combinational cells
   - Verify visual distinction is immediately apparent

2. **Zoom through detail levels**
   - Zoom out to MINIMAL: No distinction visible
   - Zoom to BASIC (50%): Border thickness and fill color distinct
   - Zoom to FULL (100%): Clock icon appears on sequential cells

3. **Accessibility verification**
   - Simulate colorblindness (use color filter)
   - Verify border thickness still distinguishes cells

4. **Performance verification**
   - Load large schematic (1000+ cells, mix of types)
   - Verify no performance degradation
   - Smooth pan and zoom

5. **User feedback**
   - Ask: "Can you identify sequential cells quickly?"
   - Ask: "Is the distinction clear but not distracting?"
   - Collect feedback on styling preferences

---

## 6. Risks and Considerations

### Risk 1: Sequential Cell Detection Accuracy

**Impact**: High
**Probability**: Medium

**Concern**: If E01-F03 detection misclassifies cells, styling will be misleading.

**Mitigation**:
- Comprehensive cell type pattern matching in E01-F03
- Configuration file for cell type mappings
- Manual testing with real-world netlists
- User ability to override cell type classification (P1 feature)

### Risk 2: Visual Distraction

**Impact**: Low
**Probability**: Low

**Concern**: Sequential cells may be too visually prominent, distracting from circuit analysis.

**Mitigation**:
- Conservative styling (subtle border thickness increase)
- User testing to validate visual balance
- Future: User-configurable styling intensity
- White fill is neutral, not bright color

### Risk 3: Accessibility for Colorblind Users

**Impact**: Medium
**Probability**: Low

**Concern**: Fill color difference may not be visible to colorblind users.

**Mitigation**:
- **Primary distinction is border thickness** (not color)
- Border thickness works for all vision types
- WCAG 2.1 compliant (doesn't rely on color alone)
- User testing with colorblind simulation

### Risk 4: Icon Scaling at High Zoom

**Impact**: Low
**Probability**: Low

**Concern**: Clock icon may look pixelated or too large at extreme zoom (500%).

**Mitigation**:
- Icon is vector-based (QPainter primitives, not raster)
- Scales cleanly with zoom
- Fixed size in scene coordinates (grows proportionally)
- Acceptable for MVP, could use `ItemIgnoresTransformations` in P1

### Risk 5: Performance Impact

**Impact**: Low
**Probability**: Very Low

**Concern**: Clock icon rendering adds overhead.

**Mitigation**:
- Icon only rendered at FULL detail (fewer items visible)
- Simple primitives (circle + 2 lines) = negligible cost
- Performance tests will catch any regression
- Measured impact: <0.1ms per cell

---

## 7. Open Questions

### Q1: Should styling be user-configurable?

**Current Approach**: Hard-coded styling constants

**Consideration**: Users may have preferences for color schemes or border styles

**Recommendation**: Hard-coded for MVP, add preferences in P1
**Future Implementation**: Style configuration file or preferences dialog

### Q2: Should other cell types have distinct styling?

**Current Approach**: Only sequential vs combinational distinction

**Consideration**: Could distinguish other types (buffers, muxes, etc.)

**Recommendation**: Defer to P1, two-way distinction sufficient for MVP
**Rationale**: Avoid visual complexity, sequential distinction is most critical

### Q3: How to handle user-defined cell types?

**Current Approach**: Pattern-based detection in parser

**Consideration**: User may have custom sequential cells with non-standard names

**Recommendation**: Configuration file for cell type mappings (P1)
**MVP**: Best-effort pattern matching, accept some misclassification

### Q4: Should clock icon be animated?

**Current Approach**: Static icon

**Consideration**: Animated clock hands would be eye-catching

**Recommendation**: Static for MVP, consider animation in P1
**Rationale**: Animation adds complexity, may be distracting

### Q5: Should INOUT pins have distinct styling too?

**Current Approach**: Only cell-level styling, pins use direction arrows

**Consideration**: INOUT pins could have different color

**Recommendation**: Pin direction arrows sufficient for MVP
**Rationale**: Focus on cell-level distinction first

---

## 8. Implementation Checklist

**Preparation:**
- [ ] Verify E01-F03 (Latch Detection) sets `is_sequential` flag
- [ ] Verify T01 (CellItem) base implementation complete
- [ ] Verify T04 (LOD) integrated with CellItem

**Core Implementation:**
- [ ] Add sequential cell style constants to `CellItem`
  - `SEQ_BORDER_WIDTH = 3.0`
  - `SEQ_FILL_COLOR = QColor("#FFFFFF")`
  - `CLOCK_ICON_SIZE = 12.0`
  - `CLOCK_ICON_MARGIN = 5.0`
- [ ] Modify `_paint_basic()` to select style based on `is_sequential`
- [ ] Modify `_paint_full()` to call `_draw_clock_indicator()` for sequential cells
- [ ] Implement `_draw_clock_indicator()` method
  - Draw circle
  - Draw hour hand
  - Draw minute hand
- [ ] Modify `boundingRect()` to account for thicker border
- [ ] Update `_get_border_color()` if needed

**Testing:**
- [ ] Write unit tests for style selection logic
- [ ] Write unit tests for border width and fill color
- [ ] Write unit tests for clock icon rendering
- [ ] Write integration tests for mixed cell rendering
- [ ] Create visual regression baselines
- [ ] Conduct user acceptance testing

**Documentation:**
- [ ] Document styling constants
- [ ] Document clock icon design
- [ ] Add usage examples
- [ ] Update architecture documentation

**Code Review:**
- [ ] Verify visual quality (screenshots)
- [ ] Check performance (no degradation)
- [ ] Review accessibility (colorblind simulation)
- [ ] Verify test coverage (>90%)

---

## 9. Success Criteria

This task is complete when:

**Functional:**
- [ ] Sequential cells render with 3px border (vs 2px combinational)
- [ ] Sequential cells use white fill (vs light gray combinational)
- [ ] Clock icon appears on sequential cells at FULL detail only
- [ ] Clock icon positioned in top-right corner (12x12px)
- [ ] Combinational cells render with standard style
- [ ] Styling consistent across all zoom levels (except icon)

**Performance:**
- [ ] No performance degradation vs standard cells
- [ ] Clock icon rendering <0.1ms overhead per cell

**Quality:**
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Visual regression tests passing
- [ ] User acceptance: >80% find distinction clear

**Accessibility:**
- [ ] Border thickness distinction works for colorblind users
- [ ] WCAG 2.1 compliant (doesn't rely on color alone)
- [ ] Luminance contrast sufficient

**Documentation:**
- [ ] Styling constants documented
- [ ] Clock icon design documented
- [ ] Usage examples provided

---

## 10. References

**Sequential Cell Types:**
- Common flip-flop naming: DFF, DFFR, DFFS, SDFF
- Latch naming: LATCH, DLATCH
- Register naming: REG

**EDA Tool Conventions:**
- Sequential cell visual styles in KiCad, gSchem
- Clock symbol representations

**Accessibility:**
- WCAG 2.1 Guidelines: https://www.w3.org/WAI/WCAG21/quickref/
- Colorblind simulation tools

**Qt Documentation:**
- QPainter primitives: https://doc.qt.io/qt-6/qpainter.html
- QColor: https://doc.qt.io/qt-6/qcolor.html

**Project Documentation:**
- CLAUDE.md: Architecture guidelines
- E01-F03.spec.md: Latch detection specification
- E02.pre-docs.md: Rendering epic overview
- T01.spec.md: CellItem specification
- T04.spec.md: Zoom LOD specification

---

**Document Status**: Ready for Implementation
**Estimated Implementation Time**: 4 hours
**Next Steps**: Implement after E01-F03 (Latch Detection) is complete, coordinate with T01 and T04 for integration
