# Spec: E02-F01-T05 - Sequential Cell Styling

## Metadata
- **ID**: E02-F01-T05
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E02-F01](../E02-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Small
- **Tags**: [styling, graphics, presentation-layer]

---

## 1. Overview

### 1.1 Problem Statement

Sequential elements (latches and flip-flops) are critical boundaries in digital circuits that affect timing analysis, expansion strategies, and debugging workflows. They must be visually distinguishable from combinational logic cells to enable quick identification during schematic exploration.

### 1.2 Goals

- Implement visual styling to distinguish sequential cells
- Apply consistent style across all sequential cell types
- Make distinction clear but not distracting
- Support potential future styling customization
- Integrate seamlessly with existing cell rendering

---

## 2. Technical Requirements

### 2.1 Style Specification

**Sequential Cell Visual Markers**:

1. **Border Style**:
   - Width: 3px (vs 2px for combinational)
   - Color: Darker shade or accent color
   - Optional: Double-line border effect

2. **Fill Color**:
   - White or very light fill (#FFFFFF)
   - Combinational: Light gray (#F0F0F0)
   - Creates clear contrast

3. **Optional Indicator**:
   - Small clock symbol (â°) in corner
   - Positioned: Top-right or bottom-right corner
   - Size: 12x12 pixels
   - Only shown at FULL detail level

4. **Color Scheme Options**:

   **Option A: Border emphasis**
   - Sequential: 3px blue border (#2196F3), white fill
   - Combinational: 2px gray border (#999999), light gray fill

   **Option B: Subtle distinction**
   - Sequential: 3px black border, white fill
   - Combinational: 2px black border, light gray fill

   **Option C: Fill pattern**
   - Sequential: White fill with subtle diagonal lines
   - Combinational: Solid light gray fill

### 2.2 Implementation Location

**File**: `src/ink/presentation/canvas/cell_item.py`

Add styling logic to existing `CellItem.paint()` method:

```python
class CellItem(QGraphicsItem):
    # Style constants
    COMB_BORDER_WIDTH = 2.0
    SEQ_BORDER_WIDTH = 3.0
    COMB_FILL_COLOR = QColor("#F0F0F0")
    SEQ_FILL_COLOR = QColor("#FFFFFF")
    COMB_BORDER_COLOR = QColor("#999999")
    SEQ_BORDER_COLOR = QColor("#2196F3")

    CLOCK_ICON_SIZE = 12.0

    def paint(self, painter: QPainter, option, widget=None):
        """Render cell with appropriate styling."""
        cell = self._cell

        # Select style based on cell type
        if cell.is_sequential:
            border_width = self.SEQ_BORDER_WIDTH
            fill_color = self.SEQ_FILL_COLOR
            border_color = self.SEQ_BORDER_COLOR
        else:
            border_width = self.COMB_BORDER_WIDTH
            fill_color = self.COMB_FILL_COLOR
            border_color = self.COMB_BORDER_COLOR

        # Draw cell body
        pen = QPen(border_color, border_width)
        brush = QBrush(fill_color)
        painter.setPen(pen)
        painter.setBrush(brush)
        painter.drawRoundedRect(
            self.boundingRect(),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )

        # Draw cell name
        self._draw_cell_name(painter)

        # Draw clock indicator for sequential cells (FULL detail only)
        if cell.is_sequential and self._detail_level == DetailLevel.FULL:
            self._draw_clock_indicator(painter)
```

### 2.3 Clock Indicator Icon

```python
def _draw_clock_indicator(self, painter: QPainter):
    """Draw small clock symbol for sequential cells."""
    # Position in top-right corner
    rect = self.boundingRect()
    icon_x = rect.right() - self.CLOCK_ICON_SIZE - 5
    icon_y = rect.top() + 5

    # Simple clock icon: circle with clock hands
    center = QPointF(icon_x + self.CLOCK_ICON_SIZE/2,
                     icon_y + self.CLOCK_ICON_SIZE/2)
    radius = self.CLOCK_ICON_SIZE / 2 - 1

    # Draw clock circle
    painter.setPen(QPen(Qt.black, 1))
    painter.setBrush(Qt.NoBrush)
    painter.drawEllipse(center, radius, radius)

    # Draw clock hands (simplified)
    painter.drawLine(center, center + QPointF(0, -radius * 0.6))  # Hour hand
    painter.drawLine(center, center + QPointF(radius * 0.4, 0))   # Minute hand
```

### 2.4 Style Configuration

**Future Enhancement**: Support user-configurable styles

```python
@dataclass
class CellStyle:
    """Configuration for cell visual styling."""
    border_width: float
    border_color: QColor
    fill_color: QColor
    show_clock_icon: bool = True

class StyleManager:
    """Manage cell styling configuration."""

    def __init__(self):
        self._sequential_style = CellStyle(...)
        self._combinational_style = CellStyle(...)

    def get_style(self, cell: Cell) -> CellStyle:
        """Return appropriate style for cell."""
        return (self._sequential_style if cell.is_sequential
                else self._combinational_style)
```

### 2.5 Domain Model Integration

**Requirement**: `Cell` domain entity must have `is_sequential` property

```python
# In domain/model/cell.py
@dataclass
class Cell:
    id: CellId
    name: str
    cell_type: str
    pins: List[Pin]
    is_sequential: bool  # Must be set during parsing/construction
```

**Detection Strategy** (from E01-F03 Latch Detection):
- Pattern matching on cell type name (e.g., "DFF", "LATCH", "FF")
- Configuration file mapping cell types to categories
- Parser annotation during CDL parsing

---

## 3. Dependencies

- **Upstream**:
  - E01-F01: `Cell` entity with `is_sequential` property
  - E01-F03: Latch detection sets `is_sequential` flag
  - T01: `CellItem` base rendering implementation

- **Downstream**:
  - E04: Selection and highlighting respect styling
  - E06: Property panel shows sequential indicator

---

## 4. Acceptance Criteria

- [ ] Sequential cells render with thicker border (3px vs 2px)
- [ ] Sequential cells use distinct fill color (white vs light gray)
- [ ] Sequential cells show clock icon at FULL detail level
- [ ] Clock icon positioned in top-right corner
- [ ] Combinational cells render with standard style
- [ ] Style difference is visually clear but not distracting
- [ ] Styling consistent across all zoom levels (except icon)
- [ ] Unit tests verify style selection logic
- [ ] Integration test shows mixed sequential/combinational cells
- [ ] Visual regression test captures styled output

---

## 5. Implementation Notes

### 5.1 Example Sequential Cell Types

Common sequential cell naming patterns:
- Flip-flops: `DFF*`, `DFFR*`, `DFFS*`, `SDFF*`
- Latches: `LATCH*`, `DL*`, `DLATCH*`
- Registers: `REG*`

Detection in parser:
```python
def is_sequential_cell(cell_type: str) -> bool:
    """Detect if cell type is sequential."""
    seq_patterns = ["DFF", "LATCH", "FF", "REG", "DL"]
    return any(pattern in cell_type.upper() for pattern in seq_patterns)
```

### 5.2 Testing Approach

**Unit Tests**:
- Verify style selection for sequential vs combinational
- Test clock icon drawing at different detail levels
- Verify border width and color application

**Integration Tests**:
- Render scene with mixed cell types
- Verify visual distinction is clear
- Test at different zoom levels

**Visual Tests**:
- Capture reference images of styled cells
- Compare against regression baseline
- Verify consistency across platforms

### 5.3 Style Refinement

Initial MVP will use **Option B** (subtle distinction):
- Sequential: 3px black border, white fill, clock icon
- Combinational: 2px black border, light gray fill

Future iterations can add:
- User-configurable color schemes
- Theme support (light/dark mode)
- Custom cell type styling rules
- Border patterns (dashed, dotted)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F01 split |
