# E02-F01-T02 - Pin Graphics Item: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F01-T02
- **Task**: Pin Graphics Item
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the visual representation of pins (connection points) on cell symbols. Pins are critical UI elements that connect cells to nets, display signal direction, and provide visual feedback for circuit topology. The `PinItem` class must support zoom-based level of detail, accurate connection point calculation for net routing, and clear visual communication of pin direction.

**Core Deliverables:**
- `PinItem` class as a custom `QGraphicsItem` subclass
- Small circular pin indicators on cell edges
- Pin name labels adjacent to indicators
- Direction arrows (input/output/inout)
- Connection point calculation for net routing
- Zoom-based level of detail support (MINIMAL/BASIC/FULL)

**Success Metrics:**
- Render 5000+ pins without frame drops (<16ms frame time)
- Connection point accuracy within 1 pixel
- Pin visibility transitions smoothly with zoom
- Clear direction indication at >75% zoom

### 1.2 Problem Context

Pins serve multiple critical functions in the schematic viewer:

1. **Visual Communication**: Pins must clearly indicate signal direction (input/output/inout) and connection points for nets.

2. **Routing Integration**: The net router (E02-F03) requires precise connection point coordinates to draw nets correctly. Any mismatch will result in nets not connecting to pins visually.

3. **Zoom Adaptability**: At different zoom levels, pins must show appropriate detail:
   - Far zoom: Hidden (too small to see)
   - Medium zoom: Dots only (visual indicators)
   - Close zoom: Full details (names, arrows)

4. **Parent-Child Relationship**: Pins are children of cell items, inheriting coordinate transformations. Position calculations must account for this parent-child relationship.

5. **Performance at Scale**: A cell may have 10-20 pins, and a schematic may have 1000 cells = 10,000+ pin items. Rendering must be highly optimized.

---

## 2. Implementation Approach

### 2.1 Architecture Design

**Parent-Child Graphics Item Hierarchy:**

```
QGraphicsScene
  └─ CellItem (parent)
       ├─ PinItem (child) - positioned relative to parent
       ├─ PinItem (child)
       └─ PinItem (child)
```

**Coordinate System:**
- PinItems positioned relative to parent CellItem (0,0) = cell top-left
- Connection points calculated in scene coordinates for net routing
- Pin position determined by SymbolLayoutCalculator (T03)

**Layer Positioning:**

```
┌────────────────────────────────────────────┐
│ Presentation Layer                         │
│  ├─ CellItem (QGraphicsItem)               │
│  ├─ PinItem (QGraphicsItem) ◄── THIS TASK │
│  └─ DetailLevel (enum, from T04)           │
└────────────┬───────────────────────────────┘
             │ accepts, never modifies
┌────────────▼───────────────────────────────┐
│ Domain Layer                               │
│  ├─ Pin (entity)                           │
│  └─ PinDirection (value object)            │
└────────────────────────────────────────────┘
```

### 2.2 Class Structure

```python
# File: src/ink/presentation/canvas/pin_item.py

from enum import Enum
from PySide6.QtWidgets import QGraphicsItem
from PySide6.QtCore import QPointF, QRectF, Qt
from PySide6.QtGui import QPainter, QPen, QBrush, QColor, QPolygonF, QFont
from ink.domain.model.pin import Pin
from ink.domain.value_objects.pin_direction import PinDirection

class DetailLevel(Enum):
    """Level of detail for rendering (will be moved to detail_level.py in T04)."""
    MINIMAL = 0   # <25% zoom: Hidden
    BASIC = 1     # 25-75% zoom: Dot only
    FULL = 2      # >75% zoom: Dot + name + arrow

class PinItem(QGraphicsItem):
    """
    QGraphicsItem representing a pin on a cell symbol.

    Responsibilities:
    - Render pin indicator (circle) on cell edge
    - Display pin name label at FULL detail level
    - Show direction arrow (input/output/inout) at FULL detail level
    - Provide connection point for net routing
    - Adapt rendering to zoom level
    """

    # Visual constants
    PIN_RADIUS = 3.0
    PIN_COLOR = QColor("#333333")
    ARROW_SIZE = 8.0
    LABEL_OFFSET = 5.0
    LABEL_FONT_SIZE = 8

    def __init__(self, pin: Pin, parent_cell_item: QGraphicsItem):
        """
        Initialize pin graphics item.

        Args:
            pin: Domain pin entity (read-only reference)
            parent_cell_item: Parent CellItem for coordinate inheritance
        """
        super().__init__(parent_cell_item)  # Set parent for hierarchy
        self._pin = pin
        self._detail_level = DetailLevel.FULL  # Default, updated by T04

        # Pin position will be set by SymbolLayoutCalculator (T03)
        # via setPos() after construction

    def boundingRect(self) -> QRectF:
        """
        Return bounding rectangle including label and arrow.

        Must account for:
        - Pin circle radius
        - Direction arrow (if FULL detail)
        - Text label (if FULL detail)
        """
        if self._detail_level == DetailLevel.MINIMAL:
            return QRectF()  # Hidden, no bounds

        # Base bounds: pin circle
        bounds = QRectF(
            -self.PIN_RADIUS,
            -self.PIN_RADIUS,
            self.PIN_RADIUS * 2,
            self.PIN_RADIUS * 2
        )

        if self._detail_level == DetailLevel.FULL:
            # Expand to include arrow and label
            # Arrow extends 8px in direction
            # Label extends based on text width
            arrow_extent = self.ARROW_SIZE + 2
            label_extent = self._estimate_label_width() + self.LABEL_OFFSET

            # Expand bounds based on pin direction
            if self._pin.direction == PinDirection.INPUT:
                # Arrow points right (into cell), label on left
                bounds.adjust(-label_extent, 0, arrow_extent, 0)
            elif self._pin.direction == PinDirection.OUTPUT:
                # Arrow points left (out of cell), label on right
                bounds.adjust(-arrow_extent, 0, label_extent, 0)
            else:  # INOUT
                # Bidirectional, expand both sides
                bounds.adjust(-arrow_extent, 0, arrow_extent, 0)

        return bounds

    def paint(self, painter: QPainter, option, widget=None):
        """
        Render pin with appropriate detail level.

        Rendering by detail level:
        - MINIMAL: Nothing (hidden)
        - BASIC: Pin circle only
        - FULL: Pin circle + name label + direction arrow
        """
        if self._detail_level == DetailLevel.MINIMAL:
            return  # Don't render

        # Draw pin circle (BASIC and FULL)
        painter.setPen(QPen(self.PIN_COLOR, 1))
        painter.setBrush(QBrush(self.PIN_COLOR))
        painter.drawEllipse(QPointF(0, 0), self.PIN_RADIUS, self.PIN_RADIUS)

        if self._detail_level == DetailLevel.FULL:
            # Draw pin name label
            self._draw_label(painter)

            # Draw direction arrow
            self._draw_direction_arrow(painter)

    def _draw_label(self, painter: QPainter):
        """Draw pin name label adjacent to pin."""
        painter.setPen(QColor("#000000"))
        painter.setFont(QFont("Sans-serif", self.LABEL_FONT_SIZE))

        # Position label based on pin direction
        if self._pin.direction == PinDirection.INPUT:
            # Label on left (outside cell)
            label_pos = QPointF(-self.LABEL_OFFSET - self._estimate_label_width(), -4)
            painter.drawText(label_pos, self._pin.name)
        elif self._pin.direction == PinDirection.OUTPUT:
            # Label on right (outside cell)
            label_pos = QPointF(self.LABEL_OFFSET, -4)
            painter.drawText(label_pos, self._pin.name)
        else:  # INOUT
            # Label above pin
            label_pos = QPointF(-self._estimate_label_width() / 2, -self.LABEL_OFFSET - 5)
            painter.drawText(label_pos, self._pin.name)

    def _draw_direction_arrow(self, painter: QPainter):
        """Draw direction arrow based on pin type."""
        painter.setPen(QPen(self.PIN_COLOR, 1))
        painter.setBrush(QBrush(self.PIN_COLOR))

        if self._pin.direction == PinDirection.INPUT:
            self._draw_input_arrow(painter)
        elif self._pin.direction == PinDirection.OUTPUT:
            self._draw_output_arrow(painter)
        else:  # INOUT
            self._draw_bidirectional_arrow(painter)

    def _draw_input_arrow(self, painter: QPainter):
        """Draw arrow pointing into cell (right direction)."""
        # Arrow points from left to right (→)
        arrow = QPolygonF([
            QPointF(self.PIN_RADIUS + 2, 0),           # Arrow base
            QPointF(self.PIN_RADIUS + 2 + self.ARROW_SIZE, 0),  # Arrow tip
            QPointF(self.PIN_RADIUS + 2 + self.ARROW_SIZE - 3, -3),  # Upper barb
            QPointF(self.PIN_RADIUS + 2 + self.ARROW_SIZE, 0),  # Back to tip
            QPointF(self.PIN_RADIUS + 2 + self.ARROW_SIZE - 3, 3),   # Lower barb
        ])
        painter.drawPolyline(arrow)

    def _draw_output_arrow(self, painter: QPainter):
        """Draw arrow pointing out of cell (left direction)."""
        # Arrow points from right to left (←)
        arrow = QPolygonF([
            QPointF(-self.PIN_RADIUS - 2, 0),           # Arrow base
            QPointF(-self.PIN_RADIUS - 2 - self.ARROW_SIZE, 0),  # Arrow tip
            QPointF(-self.PIN_RADIUS - 2 - self.ARROW_SIZE + 3, -3),  # Upper barb
            QPointF(-self.PIN_RADIUS - 2 - self.ARROW_SIZE, 0),  # Back to tip
            QPointF(-self.PIN_RADIUS - 2 - self.ARROW_SIZE + 3, 3),   # Lower barb
        ])
        painter.drawPolyline(arrow)

    def _draw_bidirectional_arrow(self, painter: QPainter):
        """Draw bidirectional arrow for INOUT pins (↔)."""
        # Left arrow
        self._draw_output_arrow(painter)
        # Right arrow
        self._draw_input_arrow(painter)

    def _estimate_label_width(self) -> float:
        """Estimate label width for bounding rect calculation."""
        # Rough estimate: 6 pixels per character
        return len(self._pin.name) * 6

    def get_connection_point(self) -> QPointF:
        """
        Return the scene coordinate for net attachment.

        Critical for net routing - must be accurate to scene coordinates.
        """
        # Pin center in item coordinates
        item_pos = QPointF(0, 0)

        # Convert to scene coordinates (accounts for parent cell position)
        scene_pos = self.mapToScene(item_pos)

        return scene_pos

    def set_detail_level(self, level: DetailLevel):
        """
        Set the level of detail based on zoom.

        Called by SchematicCanvas when zoom changes (T04).
        """
        if self._detail_level != level:
            self._detail_level = level
            self.setVisible(level != DetailLevel.MINIMAL)
            self.update()  # Trigger repaint

    def get_pin(self) -> Pin:
        """Return the associated domain pin entity."""
        return self._pin
```

### 2.3 Integration Points

**With CellItem (T01):**
```python
# Pins are children of cells
cell_item = CellItem(cell)
for pin in cell.pins:
    pin_item = PinItem(pin, parent_cell_item=cell_item)
    # Position set by SymbolLayoutCalculator (T03)
    pin_item.setPos(calculated_x, calculated_y)
```

**With SymbolLayoutCalculator (T03):**
```python
# T03 calculates pin positions
calculator = SymbolLayoutCalculator()
layouts = calculator.calculate_pin_layouts(cell)

for pin_id, layout in layouts.items():
    pin_item = PinItem(cell.get_pin(pin_id), cell_item)
    pin_item.setPos(layout.position)  # Relative to cell
```

**With Net Router (E02-F03):**
```python
# Router uses connection points to draw nets
start_point = start_pin_item.get_connection_point()  # Scene coords
end_point = end_pin_item.get_connection_point()      # Scene coords
net_path = router.route(start_point, end_point)
```

**With Zoom LOD (T04):**
```python
# Canvas updates detail level on zoom
for item in scene.items():
    if isinstance(item, PinItem):
        item.set_detail_level(DetailLevel.from_zoom(current_zoom))
```

---

## 3. Key Design Decisions

### Decision 1: Pin Positioning Strategy

**Selected**: Pins positioned by external SymbolLayoutCalculator (T03), not calculated within PinItem.

**Rationale:**
- Separation of concerns: PinItem handles rendering, Calculator handles layout
- Allows different layout strategies without modifying PinItem
- Calculator has full view of all pins on a cell for optimal distribution
- Position can be set via `setPos()` after construction

**Alternative Considered**: PinItem auto-positions itself based on direction
- Rejected: Would duplicate layout logic, hard to maintain consistency

### Decision 2: Connection Point Calculation

**Selected**: Connection point is the center of the pin circle in scene coordinates.

**Rationale:**
- Simple and intuitive
- Matches visual appearance (nets connect to center of circle)
- Scene coordinates required by net router for global routing
- `mapToScene()` handles all coordinate transformations automatically

**Implementation Detail**: Use Qt's `mapToScene()` to account for parent cell position and any future transformations.

### Decision 3: Detail Level Management

**Selected**: Three explicit levels (MINIMAL/BASIC/FULL) with hard thresholds.

**Rationale:**
- Clear, predictable behavior
- Easy to implement and test
- Matches T04 zoom LOD design
- Allows future enhancement to smooth transitions

**Detail Level Behaviors:**
- MINIMAL (<25% zoom): `setVisible(False)`, don't render
- BASIC (25-75% zoom): Render circle only, skip label and arrow
- FULL (>75% zoom): Render circle, label, and arrow

### Decision 4: Label Positioning

**Selected**: Labels positioned outside cell boundary based on pin direction.

**Rationale:**
- INPUT pins: Label on left (outside cell) to avoid cell name overlap
- OUTPUT pins: Label on right (outside cell) for readability
- INOUT pins: Label above pin to avoid ambiguity

**Trade-off**: Increases bounding rect size, but improves readability.

### Decision 5: Arrow Style

**Selected**: Simple line-based arrows (not filled triangles).

**Rationale:**
- Faster to render (fewer primitives)
- Clear at all zoom levels
- Consistent with common EDA tool conventions
- Easy to distinguish from other graphics

**Future Enhancement**: Option for filled arrows if user feedback requests it.

---

## 4. Dependencies and Integration

### 4.1 Upstream Dependencies

**E01-F01: Pin Domain Entity** (REQUIRED)
```python
# Must exist with this interface:
@dataclass
class Pin:
    id: PinId
    name: str
    direction: PinDirection
    cell_id: CellId
```

**E01-F01: PinDirection Value Object** (REQUIRED)
```python
class PinDirection(Enum):
    INPUT = "input"
    OUTPUT = "output"
    INOUT = "inout"
```

**T01: CellItem** (REQUIRED)
- PinItem needs CellItem as parent for coordinate hierarchy
- Must be implemented before PinItem

**T03: SymbolLayoutCalculator** (SOFT DEPENDENCY)
- Provides pin positions, but PinItem can be tested with manual positions
- Can implement PinItem first, integrate with T03 later

**PySide6** (REQUIRED)
- QGraphicsItem framework
- QPainter for rendering

### 4.2 Downstream Consumers

**E02-F03: Net Router** (CRITICAL DEPENDENCY)
- Requires `get_connection_point()` to return accurate scene coordinates
- Any error in connection point calculation will break net routing visually

**T04: Zoom Level of Detail** (ENHANCES)
- Will call `set_detail_level()` to update rendering based on zoom
- PinItem must function independently first

**E04: Selection and Interaction** (USES)
- May allow pin selection for highlighting connected nets
- May show pin properties in property panel

### 4.3 Integration Risks

**Risk 1**: Connection point coordinate mismatch with net router

**Impact**: High - nets won't connect to pins visually

**Mitigation**:
- Integration tests verify connection points in scene coordinates
- Debug visualization shows pin positions and connection points
- Unit tests verify `mapToScene()` transformation
- Coordinate system clearly documented

**Risk 2**: Parent-child coordinate confusion

**Impact**: Medium - pins positioned incorrectly relative to cells

**Mitigation**:
- Document coordinate system (item vs scene coordinates)
- Unit tests verify relative positioning
- Visual tests show pins on cell edges

**Risk 3**: Detail level transitions cause flickering

**Impact**: Low - aesthetic issue

**Mitigation**:
- T04 will handle smooth LOD transitions
- Threshold tuning based on user feedback
- Cache expensive operations (text layout)

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/canvas/test_pin_item.py`

```python
import pytest
from PySide6.QtCore import QPointF
from ink.presentation.canvas.pin_item import PinItem, DetailLevel
from ink.presentation.canvas.cell_item import CellItem
from ink.domain.value_objects.pin_direction import PinDirection
from tests.fixtures.pin_fixtures import create_mock_pin
from tests.fixtures.cell_fixtures import create_mock_cell

def test_pin_item_construction():
    """Verify pin item constructs with domain pin."""
    pin = create_mock_pin(name="A", direction=PinDirection.INPUT)
    cell_item = CellItem(create_mock_cell())

    pin_item = PinItem(pin, cell_item)

    assert pin_item.get_pin() is pin
    assert pin_item.parentItem() is cell_item

def test_connection_point_scene_coordinates():
    """Verify connection point returns scene coordinates."""
    pin = create_mock_pin()
    cell = create_mock_cell()
    cell_item = CellItem(cell)
    cell_item.setPos(100.0, 200.0)  # Cell at (100, 200)

    pin_item = PinItem(pin, cell_item)
    pin_item.setPos(10.0, 20.0)  # Pin at (10, 20) relative to cell

    connection_point = pin_item.get_connection_point()

    # Should be (110, 220) in scene coordinates
    assert connection_point.x() == pytest.approx(110.0)
    assert connection_point.y() == pytest.approx(220.0)

def test_detail_level_minimal_hides_pin():
    """Verify MINIMAL detail level hides pin."""
    pin = create_mock_pin()
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    pin_item.set_detail_level(DetailLevel.MINIMAL)

    assert not pin_item.isVisible()

def test_detail_level_basic_shows_dot_only():
    """Verify BASIC detail level renders dot without label."""
    # This test would need to mock QPainter to verify rendering calls
    # Alternatively, check that bounding rect is small (no label extent)
    pin = create_mock_pin(name="LONG_PIN_NAME")
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    pin_item.set_detail_level(DetailLevel.BASIC)
    bounds = pin_item.boundingRect()

    # Should be small (just pin circle)
    assert bounds.width() < 10  # PIN_RADIUS * 2 = 6, plus margin

def test_detail_level_full_includes_label():
    """Verify FULL detail level has larger bounding rect for label."""
    pin = create_mock_pin(name="LONG_PIN_NAME")
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    pin_item.set_detail_level(DetailLevel.FULL)
    bounds = pin_item.boundingRect()

    # Should be larger to include label
    assert bounds.width() > 50  # Approximate label width

def test_input_pin_arrow_direction():
    """Verify input pins render arrow pointing right."""
    # Would require QPainter mock to verify arrow geometry
    # Simplified: verify pin direction is correctly stored
    pin = create_mock_pin(direction=PinDirection.INPUT)
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    assert pin_item.get_pin().direction == PinDirection.INPUT

def test_output_pin_arrow_direction():
    """Verify output pins render arrow pointing left."""
    pin = create_mock_pin(direction=PinDirection.OUTPUT)
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    assert pin_item.get_pin().direction == PinDirection.OUTPUT

def test_inout_pin_bidirectional():
    """Verify inout pins have bidirectional indicator."""
    pin = create_mock_pin(direction=PinDirection.INOUT)
    cell_item = CellItem(create_mock_cell())
    pin_item = PinItem(pin, cell_item)

    assert pin_item.get_pin().direction == PinDirection.INOUT
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_pin_rendering.py`

```python
import pytest
from PySide6.QtWidgets import QGraphicsScene
from ink.presentation.canvas.pin_item import PinItem, DetailLevel
from ink.presentation.canvas.cell_item import CellItem
from tests.fixtures.cell_fixtures import create_cell_with_pins

def test_pins_render_on_cell(qtbot):
    """Test pins render correctly as children of cell."""
    scene = QGraphicsScene()
    cell = create_cell_with_pins(input_count=3, output_count=2)
    cell_item = CellItem(cell)
    cell_item.setPos(100.0, 100.0)
    scene.addItem(cell_item)

    # Add pins as children
    for i, pin in enumerate(cell.pins):
        pin_item = PinItem(pin, cell_item)
        pin_item.setPos(0.0, i * 20.0)  # Manual positioning for test

    # Verify all pins added
    pin_items = [item for item in scene.items() if isinstance(item, PinItem)]
    assert len(pin_items) == 5

def test_connection_points_accuracy(qtbot):
    """Test connection points are accurate for routing."""
    scene = QGraphicsScene()
    cell = create_cell_with_pins(input_count=1)
    cell_item = CellItem(cell)
    cell_item.setPos(100.0, 200.0)
    scene.addItem(cell_item)

    pin_item = PinItem(cell.pins[0], cell_item)
    pin_item.setPos(10.0, 20.0)

    connection_point = pin_item.get_connection_point()

    # Should be cell position + pin position
    assert connection_point.x() == pytest.approx(110.0, abs=1.0)
    assert connection_point.y() == pytest.approx(220.0, abs=1.0)

def test_detail_level_switching(qtbot):
    """Test detail level switches update rendering."""
    scene = QGraphicsScene()
    cell = create_cell_with_pins(input_count=1)
    cell_item = CellItem(cell)
    scene.addItem(cell_item)

    pin_item = PinItem(cell.pins[0], cell_item)

    # Test visibility at each level
    pin_item.set_detail_level(DetailLevel.MINIMAL)
    assert not pin_item.isVisible()

    pin_item.set_detail_level(DetailLevel.BASIC)
    assert pin_item.isVisible()

    pin_item.set_detail_level(DetailLevel.FULL)
    assert pin_item.isVisible()
```

### 5.3 Visual Regression Tests

**File**: `tests/visual/test_pin_appearance.py`

```python
def test_pin_visual_regression(qtbot):
    """Compare rendered pin against reference image."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    cell = create_cell_with_pins(input_count=2, output_count=1)
    cell_item = CellItem(cell)
    cell_item.setPos(10.0, 10.0)
    scene.addItem(cell_item)

    # Add pins with explicit positions
    input_pins = [p for p in cell.pins if p.direction == PinDirection.INPUT]
    for i, pin in enumerate(input_pins):
        pin_item = PinItem(pin, cell_item)
        pin_item.setPos(0.0, 20.0 + i * 30.0)
        pin_item.set_detail_level(DetailLevel.FULL)

    view.show()
    qtbot.waitExposed(view)

    # Capture and compare
    pixmap = view.grab()
    actual_image = pixmap.toImage()
    reference_image = QImage("tests/visual/references/pins_full_detail.png")

    diff_percent = compare_images(actual_image, reference_image)
    assert diff_percent < 0.01
```

### 5.4 Performance Tests

**File**: `tests/performance/test_pin_rendering_performance.py`

```python
@pytest.mark.benchmark
def test_pin_item_creation_performance(benchmark):
    """Benchmark pin item instantiation."""
    pin = create_mock_pin()
    cell_item = CellItem(create_mock_cell())

    result = benchmark(PinItem, pin, cell_item)

    # Should create 10,000 items per second
    assert benchmark.stats['ops'] > 10000

@pytest.mark.benchmark
def test_many_pins_rendering(benchmark, qtbot):
    """Benchmark rendering 5000 pins."""
    scene = QGraphicsScene()

    # Create 500 cells with 10 pins each = 5000 pins
    for i in range(500):
        cell = create_cell_with_pins(input_count=5, output_count=5)
        cell_item = CellItem(cell)
        cell_item.setPos(i * 150.0, 0.0)
        scene.addItem(cell_item)

        for j, pin in enumerate(cell.pins):
            pin_item = PinItem(pin, cell_item)
            pin_item.setPos(0.0, j * 8.0)

    view = QGraphicsView(scene)
    qtbot.addWidget(view)
    view.show()

    def repaint():
        scene.update()
        QApplication.processEvents()

    result = benchmark(repaint)

    # Should maintain <16ms for 60fps
    assert benchmark.stats['mean'] < 0.016
```

---

## 6. Risks and Considerations

### Risk 1: Coordinate Transformation Complexity

**Impact**: High
**Probability**: Medium

**Concern**: Converting between item coordinates and scene coordinates for connection points may introduce bugs.

**Mitigation**:
- Use Qt's built-in `mapToScene()` instead of manual calculation
- Comprehensive unit tests for coordinate transformation
- Debug visualization showing connection points
- Document coordinate system clearly

### Risk 2: Performance with Many Pins

**Impact**: Medium
**Probability**: Low

**Concern**: Rendering 10,000+ pins may degrade performance.

**Mitigation**:
- MINIMAL detail level hides pins completely at low zoom
- Qt's scene graph culling handles off-screen items
- Performance tests enforce <16ms frame time
- Benchmark with realistic pin counts (5000+)

### Risk 3: Text Label Overlap

**Impact**: Low
**Probability**: Medium

**Concern**: Pin labels may overlap with cell names or other pin labels at high pin density.

**Mitigation**:
- T03 (SymbolLayoutCalculator) will space pins to avoid overlap
- Font size can be reduced if needed
- Future: Smart label placement algorithm
- Accept some overlap for MVP, refine in P1

### Risk 4: Arrow Visibility at Low Zoom

**Impact**: Low
**Probability**: Medium

**Concern**: Arrows may be too small to see at medium zoom (BASIC level).

**Mitigation**:
- Arrows only shown at FULL detail (>75% zoom)
- Pin circle visible at BASIC level provides sufficient indicator
- User can zoom in for details
- Arrow size tunable based on feedback

### Risk 5: Direction Ambiguity for INOUT Pins

**Impact**: Low
**Probability**: Low

**Concern**: Bidirectional arrows may be confusing.

**Mitigation**:
- Use clear bidirectional arrow symbol (↔)
- Pin name typically indicates INOUT nature (e.g., "DATA")
- Future: Different color for INOUT pins
- User testing will validate clarity

---

## 7. Open Questions

### Q1: Should pins be selectable independently?

**Current Approach**: Pins inherit parent cell selection

**Consideration**: Allowing pin selection could enable:
- Highlighting connected nets
- Showing pin-specific properties
- Starting manual routing from a pin

**Recommendation**: Defer to E04 (Interaction)
**Rationale**: MVP focuses on rendering, interaction is separate epic

### Q2: How to handle very long pin names?

**Options**:
- Option A: Elide with ellipsis ("VERY_LONG...")
- Option B: Reduce font size dynamically
- Option C: Rotate text vertically
- Option D: Show on hover/tooltip only

**Recommendation**: Option A (elide) for MVP
**Implementation**: Use `QFontMetrics.elidedText()` with maximum width

### Q3: Should arrow style be configurable?

**Current Approach**: Fixed line-based arrows

**Consideration**: User preferences may vary (filled vs outline arrows)

**Recommendation**: Fixed style for MVP, add configuration in P1
**Rationale**: Minimize complexity, gather user feedback first

### Q4: How to handle power/ground pins?

**Current Approach**: Treat same as INPUT/OUTPUT pins

**Consideration**: Power pins often implicit, may clutter view

**Recommendation**: Render normally for MVP, add filtering in P1
**Future**: Option to hide power/ground pins

### Q5: Should pin indicators scale with zoom?

**Current Approach**: Fixed size (3px radius) in scene coordinates

**Consideration**: At very high zoom, pins may appear too small

**Recommendation**: Fixed size for MVP, evaluate based on testing
**Alternative**: Use `ItemIgnoresTransformations` flag to fix size in screen pixels (from T04)

---

## 8. Implementation Checklist

**Preparation:**
- [ ] Verify E01-F01 (Pin domain entity) is complete
- [ ] Verify T01 (CellItem) is complete
- [ ] Review Qt parent-child item hierarchy
- [ ] Review coordinate transformation APIs (`mapToScene`, `mapToParent`)

**Core Implementation:**
- [ ] Create `src/ink/presentation/canvas/pin_item.py`
- [ ] Implement `PinItem.__init__()` with parent cell item
- [ ] Implement `boundingRect()` for each detail level
- [ ] Implement `paint()` with detail level switching
- [ ] Implement pin circle rendering
- [ ] Implement pin label rendering (FULL detail)
- [ ] Implement direction arrows (input/output/inout)
- [ ] Implement `get_connection_point()` with scene coordinate mapping
- [ ] Implement `set_detail_level()` method
- [ ] Add `get_pin()` accessor

**Testing:**
- [ ] Write unit tests for connection point calculation
- [ ] Write unit tests for detail level switching
- [ ] Write unit tests for parent-child hierarchy
- [ ] Write integration test for pins on cell
- [ ] Write performance test for 5000 pins
- [ ] Create visual regression baseline images
- [ ] Manual testing: verify arrows for each direction

**Documentation:**
- [ ] Add docstrings to all public methods
- [ ] Document coordinate system (item vs scene)
- [ ] Add usage examples in module docstring
- [ ] Update architecture documentation

**Code Review:**
- [ ] Verify coordinate transformation correctness
- [ ] Check performance characteristics
- [ ] Review arrow rendering quality
- [ ] Verify test coverage (>90%)

---

## 9. Success Criteria

This task is complete when:

**Functional:**
- [ ] `PinItem` class renders pins as circles on cell edges
- [ ] Pin names displayed at FULL detail level
- [ ] Direction arrows shown correctly (input/output/inout)
- [ ] Connection point calculation returns accurate scene coordinates
- [ ] Detail level transitions work (MINIMAL/BASIC/FULL)
- [ ] Pins hidden at MINIMAL level
- [ ] Pins show dots only at BASIC level
- [ ] Pins show full details at FULL level

**Performance:**
- [ ] Render 5000 pins at 60fps (<16ms frame time)
- [ ] Pin item creation <0.1ms per item
- [ ] Connection point calculation <0.01ms per call

**Quality:**
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Visual regression tests passing
- [ ] Code coverage >90%
- [ ] Coordinate transformations verified

**Documentation:**
- [ ] All public APIs documented
- [ ] Coordinate system documented
- [ ] Usage examples provided

---

## 10. References

**Qt Documentation:**
- QGraphicsItem Parent-Child Hierarchy: https://doc.qt.io/qt-6/qgraphicsitem.html#parent-child-relationship
- Coordinate Systems: https://doc.qt.io/qt-6/qgraphicsitem.html#coordinate-systems
- `mapToScene()`: https://doc.qt.io/qt-6/qgraphicsitem.html#mapToScene
- QPainter: https://doc.qt.io/qt-6/qpainter.html

**Project Documentation:**
- CLAUDE.md: Architecture and layer rules
- E02.pre-docs.md: Overall rendering epic design
- T01.spec.md: CellItem specification
- T03.spec.md: SymbolLayoutCalculator specification

**EDA Tool References:**
- Pin rendering conventions in KiCad, gSchem
- Direction arrow styles in schematic viewers

---

**Document Status**: Ready for Implementation
**Estimated Implementation Time**: 6 hours
**Next Steps**: Begin implementation after T01 completion, coordinate with T03 for pin positioning
