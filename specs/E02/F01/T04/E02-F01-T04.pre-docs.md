# E02-F01-T04 - Zoom Level of Detail: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F01-T04
- **Task**: Zoom Level of Detail
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements a zoom-based level of detail (LOD) system that adapts schematic rendering quality to the current zoom level. As users zoom in and out, the system automatically adjusts what details are shown to maintain visual clarity and rendering performance. This is a critical optimization for handling large schematics with thousands of cells.

**Core Deliverables:**
- `DetailLevel` enumeration with three levels (MINIMAL, BASIC, FULL)
- Zoom detection and level assignment in `SchematicCanvas`
- LOD integration into `CellItem` and `PinItem` paint methods
- Smooth transitions between detail levels
- Performance optimization for 1000+ cell schematics

**Success Metrics:**
- Maintain 60fps (< 16ms frame time) at all zoom levels
- Smooth LOD transitions without visual artifacts
- Correct detail level selection based on zoom thresholds
- Performance improvement: 3x faster rendering at MINIMAL vs FULL

### 1.2 Problem Context

Without level of detail optimization, large schematics suffer from performance degradation:

1. **Rendering Overhead**: At low zoom (viewing entire schematic), rendering pin names, arrows, and detailed symbols wastes GPU cycles on sub-pixel details invisible to the user.

2. **Visual Clutter**: At very low zoom, attempting to render all details creates visual noise rather than clarity.

3. **Frame Rate Degradation**: Large schematics (1000+ cells = 10,000+ pins) can drop below 60fps during pan/zoom operations.

4. **Memory Pressure**: Caching full-detail renderings of all items consumes excessive memory.

**Solution**: Implement a three-tier LOD system that progressively reduces detail as zoom level decreases:

```
FULL (>75% zoom):     All details (pin names, arrows, cell decorations)
BASIC (25-75% zoom):  Essential details (cell names, pin dots)
MINIMAL (<25% zoom):  Minimal details (cell boxes only)
```

---

## 2. Implementation Approach

### 2.1 Architecture Design

**Component Interaction:**

```
┌────────────────────────────────────────────┐
│ SchematicCanvas (QGraphicsView)            │
│  - Tracks current zoom factor              │
│  - Detects zoom changes                    │
│  - Broadcasts detail level updates         │
└────────────┬───────────────────────────────┘
             │ updates on zoom change
             ▼
┌────────────────────────────────────────────┐
│ DetailLevel (Enum)                         │
│  - MINIMAL, BASIC, FULL                    │
│  - from_zoom(factor) → DetailLevel         │
└────────────┬───────────────────────────────┘
             │ consumed by
   ┌─────────┴─────────┐
   ▼                   ▼
┌─────────┐       ┌─────────┐
│CellItem │       │PinItem  │
│paint()  │       │paint()  │
└─────────┘       └─────────┘
```

**Design Principle**: Zoom detection is centralized in SchematicCanvas. Graphics items (CellItem, PinItem) are stateless renderers that adapt to the detail level provided to them.

### 2.2 DetailLevel Enumeration

```python
# File: src/ink/presentation/canvas/detail_level.py

from enum import Enum

class DetailLevel(Enum):
    """
    Level of detail for schematic rendering based on zoom.

    The LOD system optimizes rendering performance and visual clarity
    by showing progressively less detail as the user zooms out.

    Zoom thresholds:
    - MINIMAL: zoom < 0.25 (< 25%)
    - BASIC:   0.25 <= zoom < 0.75 (25-75%)
    - FULL:    zoom >= 0.75 (>= 75%)
    """

    MINIMAL = 0   # <25% zoom: Minimal detail
    BASIC = 1     # 25-75% zoom: Medium detail
    FULL = 2      # >75% zoom: Full detail

    @classmethod
    def from_zoom(cls, zoom_factor: float) -> 'DetailLevel':
        """
        Determine detail level from zoom factor.

        Args:
            zoom_factor: Current zoom (1.0 = 100%, 0.5 = 50%, 2.0 = 200%)

        Returns:
            Appropriate detail level for the zoom factor

        Examples:
            >>> DetailLevel.from_zoom(0.1)
            DetailLevel.MINIMAL
            >>> DetailLevel.from_zoom(0.5)
            DetailLevel.BASIC
            >>> DetailLevel.from_zoom(1.5)
            DetailLevel.FULL
        """
        if zoom_factor < 0.25:
            return cls.MINIMAL
        elif zoom_factor < 0.75:
            return cls.BASIC
        else:
            return cls.FULL
```

### 2.3 SchematicCanvas Integration

```python
# File: src/ink/presentation/canvas/schematic_canvas.py

from PySide6.QtWidgets import QGraphicsView, QGraphicsScene
from PySide6.QtCore import Qt
from PySide6.QtGui import QWheelEvent
from ink.presentation.canvas.detail_level import DetailLevel
from ink.presentation.canvas.cell_item import CellItem
from ink.presentation.canvas.pin_item import PinItem

class SchematicCanvas(QGraphicsView):
    """
    Main schematic viewing canvas with zoom LOD support.

    Responsibilities:
    - Manage view transformations (zoom, pan)
    - Track current zoom factor
    - Detect detail level changes
    - Update graphics items when detail level changes
    """

    # Zoom limits
    MIN_ZOOM = 0.1   # 10% - Far out view
    MAX_ZOOM = 5.0   # 500% - Close inspection

    # Zoom step for wheel/button operations
    ZOOM_STEP = 1.25

    def __init__(self, parent=None):
        super().__init__(parent)
        self._current_zoom = 1.0
        self._current_detail_level = DetailLevel.FULL

        # Configure view
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        self.setRenderHint(QPainter.Antialiasing)
        self.setViewportUpdateMode(QGraphicsView.SmartViewportUpdate)

    def zoom_in(self):
        """Zoom in by one step."""
        self._apply_zoom(self._current_zoom * self.ZOOM_STEP)

    def zoom_out(self):
        """Zoom out by one step."""
        self._apply_zoom(self._current_zoom / self.ZOOM_STEP)

    def set_zoom(self, zoom_factor: float):
        """
        Set zoom to specific factor.

        Args:
            zoom_factor: Target zoom (1.0 = 100%)
        """
        self._apply_zoom(zoom_factor)

    def wheelEvent(self, event: QWheelEvent):
        """
        Handle mouse wheel for zooming centered on cursor.

        Args:
            event: Wheel event from Qt
        """
        # Determine zoom direction
        if event.angleDelta().y() > 0:
            zoom_factor = self._current_zoom * self.ZOOM_STEP
        else:
            zoom_factor = self._current_zoom / self.ZOOM_STEP

        # Apply zoom centered on cursor
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self._apply_zoom(zoom_factor)

        event.accept()

    def _apply_zoom(self, new_zoom: float):
        """
        Apply zoom transform and update detail level if needed.

        Args:
            new_zoom: Requested zoom factor
        """
        # Clamp to valid range
        new_zoom = self._clamp_zoom(new_zoom)

        if new_zoom == self._current_zoom:
            return  # No change

        # Apply view transform
        self.resetTransform()
        self.scale(new_zoom, new_zoom)
        self._current_zoom = new_zoom

        # Check if detail level changed
        new_level = DetailLevel.from_zoom(new_zoom)
        if new_level != self._current_detail_level:
            self._current_detail_level = new_level
            self._update_item_detail_levels()

    def _clamp_zoom(self, zoom: float) -> float:
        """Clamp zoom to valid range [MIN_ZOOM, MAX_ZOOM]."""
        return max(self.MIN_ZOOM, min(self.MAX_ZOOM, zoom))

    def _update_item_detail_levels(self):
        """
        Update all graphics items with new detail level.

        This is called when detail level changes due to zoom.
        Broadcasts the new level to all LOD-aware items.
        """
        if not self.scene():
            return

        # Update all items in scene
        for item in self.scene().items():
            if isinstance(item, PinItem):
                item.set_detail_level(self._current_detail_level)
            elif isinstance(item, CellItem):
                item.set_detail_level(self._current_detail_level)

        # Trigger scene repaint
        self.scene().update()

    def get_current_zoom(self) -> float:
        """Return current zoom factor."""
        return self._current_zoom

    def get_current_detail_level(self) -> DetailLevel:
        """Return current detail level."""
        return self._current_detail_level
```

### 2.4 CellItem LOD Integration

```python
# Addition to CellItem from T01

class CellItem(QGraphicsItem):
    def __init__(self, cell: Cell, parent=None):
        super().__init__(parent)
        self._cell = cell
        self._detail_level = DetailLevel.FULL  # Default

        # ... existing initialization ...

    def set_detail_level(self, level: DetailLevel):
        """
        Update rendering detail level.

        Args:
            level: New detail level
        """
        if self._detail_level != level:
            self._detail_level = level
            self.update()  # Trigger repaint

    def paint(self, painter: QPainter, option, widget=None):
        """Render cell with LOD awareness."""
        if self._detail_level == DetailLevel.MINIMAL:
            self._paint_minimal(painter)
        elif self._detail_level == DetailLevel.BASIC:
            self._paint_basic(painter)
        else:  # FULL
            self._paint_full(painter)

    def _paint_minimal(self, painter: QPainter):
        """
        Minimal rendering: bounding box only.

        At very low zoom, show just a filled rectangle to indicate
        cell presence without any text or decorations.
        """
        # Simple filled box
        painter.fillRect(
            QRectF(0, 0, self.DEFAULT_WIDTH, self.DEFAULT_HEIGHT),
            QBrush(QColor("#E0E0E0"))
        )

    def _paint_basic(self, painter: QPainter):
        """
        Basic rendering: box + cell name.

        At medium zoom, show cell box with name but no pin details.
        """
        # Select style based on cell type
        if self._cell.is_sequential:
            border_width = self.SEQUENTIAL_BORDER_WIDTH
            fill_color = self.SEQUENTIAL_FILL_COLOR
        else:
            border_width = self.BORDER_WIDTH
            fill_color = self.FILL_COLOR

        # Draw cell body
        pen = QPen(self.BORDER_COLOR, border_width)
        brush = QBrush(fill_color)
        painter.setPen(pen)
        painter.setBrush(brush)

        rect = QRectF(0, 0, self.DEFAULT_WIDTH, self.DEFAULT_HEIGHT)
        painter.drawRoundedRect(rect, self.CORNER_RADIUS, self.CORNER_RADIUS)

        # Draw cell name
        painter.setPen(QColor("#000000"))
        painter.setFont(QFont("Sans-serif", 10))
        painter.drawText(rect, Qt.AlignCenter, self._cell.name)

    def _paint_full(self, painter: QPainter):
        """
        Full rendering: detailed symbol with all decorations.

        At high zoom, show complete cell symbol with borders,
        fill colors, and name.
        """
        # Same as _paint_basic for cells (pins add the detail)
        # Future: Could add additional decorations here
        self._paint_basic(painter)
```

### 2.5 PinItem LOD Integration

```python
# Addition to PinItem from T02

class PinItem(QGraphicsItem):
    def __init__(self, pin: Pin, parent_cell_item: QGraphicsItem):
        super().__init__(parent_cell_item)
        self._pin = pin
        self._detail_level = DetailLevel.FULL  # Default

        # ... existing initialization ...

    def set_detail_level(self, level: DetailLevel):
        """
        Update rendering detail level.

        Args:
            level: New detail level
        """
        if self._detail_level != level:
            self._detail_level = level
            # Hide completely at MINIMAL
            self.setVisible(level != DetailLevel.MINIMAL)
            self.update()  # Trigger repaint

    def paint(self, painter: QPainter, option, widget=None):
        """Render pin with appropriate detail level."""
        if self._detail_level == DetailLevel.MINIMAL:
            return  # Hidden, don't render

        # Draw pin circle (BASIC and FULL)
        painter.setPen(QPen(self.PIN_COLOR, 1))
        painter.setBrush(QBrush(self.PIN_COLOR))
        painter.drawEllipse(QPointF(0, 0), self.PIN_RADIUS, self.PIN_RADIUS)

        if self._detail_level == DetailLevel.FULL:
            # Draw pin name label
            self._draw_label(painter)

            # Draw direction arrow
            self._draw_direction_arrow(painter)

    def boundingRect(self) -> QRectF:
        """Return bounding rectangle accounting for detail level."""
        if self._detail_level == DetailLevel.MINIMAL:
            return QRectF()  # Hidden, no bounds

        # Base bounds: pin circle
        bounds = QRectF(
            -self.PIN_RADIUS,
            -self.PIN_RADIUS,
            self.PIN_RADIUS * 2,
            self.PIN_RADIUS * 2
        )

        if self._detail_level == DetailLevel.FULL:
            # Expand to include arrow and label
            # ... (existing logic from T02)
            pass

        return bounds
```

---

## 3. Key Design Decisions

### Decision 1: Three-Level LOD System

**Selected**: MINIMAL, BASIC, FULL with hard thresholds

**Rationale:**
- Simple to implement and reason about
- Clear threshold values (25%, 75%)
- Discrete levels easier to test than continuous LOD
- Matches common EDA tool patterns

**Alternatives Considered:**
- **Continuous LOD**: Gradual transitions with interpolated alpha
  - Rejected: Complex implementation, minimal benefit
- **Two-Level LOD**: Just BASIC and FULL
  - Rejected: Doesn't address extreme zoom-out performance
- **Five-Level LOD**: More granular levels
  - Rejected: Diminishing returns, added complexity

### Decision 2: Threshold Values

**Selected**: MINIMAL <25%, BASIC 25-75%, FULL >=75%

**Rationale:**
- 25% threshold: Below this, pin details are sub-pixel and invisible
- 75% threshold: Above this, pins are large enough for text to be readable
- Thresholds based on typical schematic viewing patterns

**Tunable**: Thresholds can be adjusted based on user testing feedback.

### Decision 3: Centralized vs Distributed LOD

**Selected**: Centralized in SchematicCanvas, broadcast to items

**Rationale:**
- Single source of truth for current zoom level
- Items remain stateless (don't track zoom themselves)
- Easier to add new item types (just implement `set_detail_level()`)
- Consistent LOD across all items

**Alternative Considered**: Items query view transform directly
- Rejected: Couples items to view, harder to test

### Decision 4: LOD Update Strategy

**Selected**: Update all items when detail level changes (threshold crossing)

**Rationale:**
- Detail level changes infrequently (only when crossing thresholds)
- Batch update more efficient than per-frame checks
- Items can cache rendering based on stable detail level

**Performance**: Crossing threshold triggers one batch update, then items use cached detail level until next crossing.

### Decision 5: Pin Visibility at MINIMAL

**Selected**: Pins completely hidden (`setVisible(False)`)

**Rationale:**
- At <25% zoom, pins are too small to see (<1 pixel)
- Hiding completely allows Qt to skip rendering and bounds checks
- Performance improvement: ~30% faster rendering at MINIMAL

**Alternative Considered**: Render pin dots
- Rejected: Sub-pixel rendering has no visual benefit

---

## 4. Dependencies and Integration

### 4.1 Upstream Dependencies

**T01: CellItem** (REQUIRED)
- Must add `set_detail_level()` method
- Must split `paint()` into `_paint_minimal/basic/full()`

**T02: PinItem** (REQUIRED)
- Must add `set_detail_level()` method
- Must adjust `boundingRect()` based on detail level

**PySide6 QGraphicsView** (REQUIRED)
- View transformation system
- Wheel event handling

### 4.2 Downstream Consumers

**E02-F05: Pan/Zoom Controls** (INTEGRATES)
- Provides zoom in/out/fit commands
- Uses `SchematicCanvas.set_zoom()` method

**E04: Interaction** (USES)
- Selection and interaction work at all LOD levels
- May need to account for simplified rendering

**E03: Expansion** (BENEFITS)
- New cells added respect current detail level
- Performance maintained during expansion

### 4.3 Integration Risks

**Risk 1**: LOD transitions cause visual "popping"

**Impact**: Low - aesthetic issue
**Probability**: High - hard thresholds cause instant changes

**Mitigation**:
- Threshold values chosen to minimize visibility of changes
- Future: Add smooth transitions with opacity fade
- User testing will validate acceptability

**Risk 2**: Items not updated when detail level changes

**Impact**: Medium - stale rendering
**Probability**: Low - centralized update ensures consistency

**Mitigation**:
- Comprehensive testing of update propagation
- Add debug visualization showing current detail level
- Log warnings if items miss updates

**Risk 3**: Performance degradation during LOD updates

**Impact**: Low - brief stutter during transition
**Probability**: Low - updates are infrequent

**Mitigation**:
- Batch updates efficiently (single scene pass)
- Items cache detail level (no per-frame checks)
- Performance tests verify <5ms update time

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/canvas/test_detail_level.py`

```python
import pytest
from ink.presentation.canvas.detail_level import DetailLevel

def test_detail_level_from_zoom_minimal():
    """Verify MINIMAL level for low zoom."""
    assert DetailLevel.from_zoom(0.1) == DetailLevel.MINIMAL
    assert DetailLevel.from_zoom(0.24) == DetailLevel.MINIMAL

def test_detail_level_from_zoom_basic():
    """Verify BASIC level for medium zoom."""
    assert DetailLevel.from_zoom(0.25) == DetailLevel.BASIC
    assert DetailLevel.from_zoom(0.5) == DetailLevel.BASIC
    assert DetailLevel.from_zoom(0.74) == DetailLevel.BASIC

def test_detail_level_from_zoom_full():
    """Verify FULL level for high zoom."""
    assert DetailLevel.from_zoom(0.75) == DetailLevel.FULL
    assert DetailLevel.from_zoom(1.0) == DetailLevel.FULL
    assert DetailLevel.from_zoom(5.0) == DetailLevel.FULL

def test_threshold_boundaries():
    """Verify threshold boundary conditions."""
    # Just below threshold should be MINIMAL
    assert DetailLevel.from_zoom(0.24999) == DetailLevel.MINIMAL

    # At threshold should be BASIC
    assert DetailLevel.from_zoom(0.25) == DetailLevel.BASIC

    # Just below next threshold
    assert DetailLevel.from_zoom(0.74999) == DetailLevel.BASIC

    # At next threshold should be FULL
    assert DetailLevel.from_zoom(0.75) == DetailLevel.FULL
```

**File**: `tests/unit/presentation/canvas/test_schematic_canvas_lod.py`

```python
def test_canvas_initial_zoom():
    """Verify canvas starts at 100% zoom."""
    canvas = SchematicCanvas()
    assert canvas.get_current_zoom() == 1.0
    assert canvas.get_current_detail_level() == DetailLevel.FULL

def test_zoom_in():
    """Verify zoom in increases zoom factor."""
    canvas = SchematicCanvas()
    initial_zoom = canvas.get_current_zoom()

    canvas.zoom_in()

    assert canvas.get_current_zoom() > initial_zoom

def test_zoom_out():
    """Verify zoom out decreases zoom factor."""
    canvas = SchematicCanvas()
    initial_zoom = canvas.get_current_zoom()

    canvas.zoom_out()

    assert canvas.get_current_zoom() < initial_zoom

def test_zoom_clamping_minimum():
    """Verify zoom clamped at minimum."""
    canvas = SchematicCanvas()

    # Zoom out many times
    for _ in range(20):
        canvas.zoom_out()

    assert canvas.get_current_zoom() == canvas.MIN_ZOOM

def test_zoom_clamping_maximum():
    """Verify zoom clamped at maximum."""
    canvas = SchematicCanvas()

    # Zoom in many times
    for _ in range(20):
        canvas.zoom_in()

    assert canvas.get_current_zoom() == canvas.MAX_ZOOM

def test_detail_level_changes_with_zoom():
    """Verify detail level updates when crossing thresholds."""
    canvas = SchematicCanvas()

    # Start at FULL
    assert canvas.get_current_detail_level() == DetailLevel.FULL

    # Zoom out to BASIC range
    canvas.set_zoom(0.5)
    assert canvas.get_current_detail_level() == DetailLevel.BASIC

    # Zoom out to MINIMAL range
    canvas.set_zoom(0.2)
    assert canvas.get_current_detail_level() == DetailLevel.MINIMAL

    # Zoom back to FULL
    canvas.set_zoom(1.0)
    assert canvas.get_current_detail_level() == DetailLevel.FULL
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_lod_integration.py`

```python
def test_cell_item_lod_updates(qtbot):
    """Test CellItem updates when detail level changes."""
    scene = QGraphicsScene()
    canvas = SchematicCanvas()
    canvas.setScene(scene)

    cell = create_mock_cell()
    cell_item = CellItem(cell)
    scene.addItem(cell_item)

    # Start at FULL
    assert cell_item._detail_level == DetailLevel.FULL

    # Zoom out to BASIC
    canvas.set_zoom(0.5)

    # CellItem should be updated
    assert cell_item._detail_level == DetailLevel.BASIC

def test_pin_item_visibility_lod(qtbot):
    """Test PinItem visibility changes with LOD."""
    scene = QGraphicsScene()
    canvas = SchematicCanvas()
    canvas.setScene(scene)

    cell = create_cell_with_pins(input_count=1)
    cell_item = CellItem(cell)
    scene.addItem(cell_item)

    pin_item = PinItem(cell.pins[0], cell_item)

    # At FULL, pin should be visible
    canvas.set_zoom(1.0)
    assert pin_item.isVisible()

    # At BASIC, pin should be visible (dot only)
    canvas.set_zoom(0.5)
    assert pin_item.isVisible()

    # At MINIMAL, pin should be hidden
    canvas.set_zoom(0.2)
    assert not pin_item.isVisible()

def test_lod_performance_improvement(qtbot, benchmark):
    """Verify performance improvement at MINIMAL vs FULL."""
    scene = QGraphicsScene()
    canvas = SchematicCanvas()
    canvas.setScene(scene)

    # Create 1000 cells
    for i in range(1000):
        cell = create_cell_with_pins(input_count=5, output_count=3)
        cell_item = CellItem(cell)
        cell_item.setPos(i * 150.0, 0.0)
        scene.addItem(cell_item)

        for pin in cell.pins:
            pin_item = PinItem(pin, cell_item)

    canvas.show()
    qtbot.waitExposed(canvas)

    # Benchmark FULL detail
    canvas.set_zoom(1.0)
    full_time = benchmark_repaint(scene)

    # Benchmark MINIMAL detail
    canvas.set_zoom(0.1)
    minimal_time = benchmark_repaint(scene)

    # MINIMAL should be significantly faster
    assert minimal_time < full_time * 0.5  # At least 2x faster
```

### 5.3 Visual Tests

**File**: `tests/visual/test_lod_appearance.py`

```python
def test_lod_visual_regression(qtbot):
    """Capture screenshots at each LOD level for regression testing."""
    scene = QGraphicsScene()
    canvas = SchematicCanvas()
    canvas.setScene(scene)

    # Create test scene
    cell = create_cell_with_pins(input_count=3, output_count=2)
    cell_item = CellItem(cell)
    cell_item.setPos(50.0, 50.0)
    scene.addItem(cell_item)

    for pin in cell.pins:
        pin_item = PinItem(pin, cell_item)
        # Position pins (simplified for test)

    canvas.show()
    qtbot.waitExposed(canvas)

    # Capture at MINIMAL
    canvas.set_zoom(0.1)
    minimal_image = canvas.grab().toImage()

    # Capture at BASIC
    canvas.set_zoom(0.5)
    basic_image = canvas.grab().toImage()

    # Capture at FULL
    canvas.set_zoom(1.0)
    full_image = canvas.grab().toImage()

    # Compare against references
    assert compare_images(minimal_image, load_reference("lod_minimal.png")) < 0.01
    assert compare_images(basic_image, load_reference("lod_basic.png")) < 0.01
    assert compare_images(full_image, load_reference("lod_full.png")) < 0.01
```

### 5.4 Performance Tests

**File**: `tests/performance/test_lod_performance.py`

```python
@pytest.mark.benchmark
def test_lod_update_performance(benchmark, qtbot):
    """Benchmark detail level update propagation."""
    scene = QGraphicsScene()
    canvas = SchematicCanvas()
    canvas.setScene(scene)

    # Create 1000 cells with pins
    for i in range(1000):
        cell = create_cell_with_pins(input_count=5, output_count=3)
        cell_item = CellItem(cell)
        scene.addItem(cell_item)

        for pin in cell.pins:
            pin_item = PinItem(pin, cell_item)

    def update_detail_level():
        canvas.set_zoom(0.5)  # Trigger LOD update

    result = benchmark(update_detail_level)

    # Should complete in <5ms
    assert benchmark.stats['mean'] < 0.005

@pytest.mark.benchmark
def test_frame_time_at_minimal(benchmark, qtbot):
    """Verify <16ms frame time at MINIMAL detail."""
    scene, canvas = create_large_scene(cell_count=1000)

    canvas.set_zoom(0.1)  # MINIMAL
    canvas.show()
    qtbot.waitExposed(canvas)

    def repaint():
        scene.update()
        QApplication.processEvents()

    result = benchmark(repaint)

    assert benchmark.stats['mean'] < 0.016  # 60fps
```

---

## 6. Risks and Considerations

### Risk 1: Visual "Popping" at Thresholds

**Impact**: Low
**Probability**: High

**Concern**: Hard thresholds cause instant visibility changes that may be distracting.

**Mitigation**:
- Threshold values chosen to minimize perceived changes
- Changes occur during zoom (user's attention on movement)
- Future: Fade transitions with opacity interpolation
- User testing will validate acceptability

### Risk 2: Threshold Sensitivity

**Impact**: Low
**Probability**: Medium

**Concern**: Users may frequently cross thresholds during typical zoom operations.

**Mitigation**:
- Threshold values chosen based on typical zoom patterns
- Hysteresis could be added (different thresholds for zoom in/out)
- Tunable thresholds for different user preferences
- Analytics to track threshold crossing frequency

### Risk 3: Detail Level State Synchronization

**Impact**: Medium
**Probability**: Low

**Concern**: Items may have stale detail levels if update propagation fails.

**Mitigation**:
- Centralized update in `_update_item_detail_levels()` ensures consistency
- Items cache detail level, no reliance on external state
- Unit tests verify update propagation
- Debug mode to visualize current detail level

### Risk 4: Performance During Update

**Impact**: Low
**Probability**: Low

**Concern**: Updating 10,000 items when detail level changes may cause frame drop.

**Mitigation**:
- Updates only occur when crossing thresholds (infrequent)
- Single scene traversal for batch update
- Items use efficient `update()` call (invalidates cache)
- Performance tests enforce <5ms update time

### Risk 5: Bounding Rect Changes

**Impact**: Low
**Probability**: Low

**Concern**: Changing detail level changes bounding rects, may affect scene bounds.

**Mitigation**:
- Qt handles bounding rect changes automatically
- Scene bounds recalculated as needed
- PinItems use `setVisible(False)` at MINIMAL (Qt handles bounds)

---

## 7. Open Questions

### Q1: Should thresholds be user-configurable?

**Current Approach**: Hard-coded thresholds (25%, 75%)

**Consideration**: Power users may want to customize when details appear

**Recommendation**: Hard-coded for MVP, add preferences in P1
**Rationale**: Simplify initial implementation, gather usage data first

### Q2: Should LOD apply to nets?

**Current Approach**: Only cells and pins have LOD

**Consideration**: Nets could be simplified at low zoom (fewer segments)

**Recommendation**: Defer to E02-F03 (Net Routing)
**Rationale**: Net simplification is separate concern

### Q3: Should there be a "force full detail" mode?

**Current Approach**: Detail level strictly follows zoom

**Consideration**: Debug mode or user preference for always-full-detail

**Recommendation**: Add debug flag for MVP, user preference in P1
**Implementation**: `SchematicCanvas._force_full_detail = True`

### Q4: How to handle LOD during animations?

**Current Approach**: No animations in MVP

**Consideration**: Future expansion animations may need LOD coordination

**Recommendation**: Defer to E03 (Expansion)
**Rationale**: Animations not in MVP scope

### Q5: Should text size be fixed at high zoom?

**Current Approach**: Text scales with view transform

**Consideration**: At very high zoom (500%), text becomes huge

**Recommendation**: Accept scaling for MVP, consider `ItemIgnoresTransformations` in P1
**Rationale**: Extreme zoom is edge case, adds complexity

---

## 8. Implementation Checklist

**Preparation:**
- [ ] Verify T01 (CellItem) and T02 (PinItem) are complete
- [ ] Review Qt view transformation system
- [ ] Review QGraphicsItem paint and update mechanisms

**Core Implementation:**
- [ ] Create `src/ink/presentation/canvas/detail_level.py`
- [ ] Implement `DetailLevel` enum with MINIMAL/BASIC/FULL
- [ ] Implement `DetailLevel.from_zoom()` class method
- [ ] Modify `SchematicCanvas` to track current zoom
- [ ] Implement `SchematicCanvas.zoom_in/out/set_zoom()`
- [ ] Implement `SchematicCanvas.wheelEvent()` for mouse wheel zoom
- [ ] Implement `SchematicCanvas._update_item_detail_levels()`
- [ ] Add `CellItem.set_detail_level()` method
- [ ] Refactor `CellItem.paint()` into `_paint_minimal/basic/full()`
- [ ] Add `PinItem.set_detail_level()` method
- [ ] Modify `PinItem.paint()` to respect detail level
- [ ] Update `PinItem.boundingRect()` for detail level

**Testing:**
- [ ] Write unit tests for `DetailLevel.from_zoom()`
- [ ] Write unit tests for threshold boundaries
- [ ] Write unit tests for zoom clamping
- [ ] Write unit tests for detail level change detection
- [ ] Write integration tests for item updates
- [ ] Write performance tests for update propagation
- [ ] Write performance tests for rendering at each level
- [ ] Create visual regression baselines for each level

**Documentation:**
- [ ] Document LOD system in module docstrings
- [ ] Document threshold values and rationale
- [ ] Add usage examples
- [ ] Update architecture documentation

**Code Review:**
- [ ] Verify threshold values produce good visual results
- [ ] Check performance characteristics
- [ ] Review update propagation logic
- [ ] Verify test coverage (>90%)

---

## 9. Success Criteria

This task is complete when:

**Functional:**
- [ ] `DetailLevel` enum implemented with three levels
- [ ] `SchematicCanvas` tracks current zoom factor
- [ ] Zoom in/out methods update detail level correctly
- [ ] Mouse wheel zoom centers on cursor
- [ ] Cell items render simplified at MINIMAL level
- [ ] Pin items hidden at MINIMAL level
- [ ] Pin items show dots only at BASIC level
- [ ] Full pin details shown at FULL level (>75% zoom)
- [ ] Detail level transitions occur when crossing thresholds

**Performance:**
- [ ] Maintain 60fps (<16ms frame time) with 1000 cells at all levels
- [ ] MINIMAL level 2x+ faster than FULL level
- [ ] Detail level update completes in <5ms
- [ ] No frame drops during zoom operations

**Quality:**
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Visual regression tests passing
- [ ] Performance benchmarks passing
- [ ] Code coverage >90%

**User Experience:**
- [ ] LOD transitions not distracting
- [ ] Correct details visible at each zoom level
- [ ] Smooth zoom operations

---

## 10. References

**Level of Detail Techniques:**
- Real-time rendering LOD strategies
- Qt Graphics View performance optimization
- EDA tool rendering best practices

**Qt Documentation:**
- QGraphicsView: https://doc.qt.io/qt-6/qgraphicsview.html
- View transformations: https://doc.qt.io/qt-6/qgraphicsview.html#transformations
- QStyleOptionGraphicsItem LOD: https://doc.qt.io/qt-6/qstyleoptiongraphicsitem.html

**Project Documentation:**
- CLAUDE.md: Architecture guidelines
- E02.pre-docs.md: Rendering epic overview
- T01.spec.md: CellItem specification
- T02.spec.md: PinItem specification

**Performance References:**
- Qt Graphics View scalability limits
- Rendering optimization techniques

---

**Document Status**: Ready for Implementation
**Estimated Implementation Time**: 5 hours
**Next Steps**: Implement after T01 and T02 are complete, integrate LOD into existing graphics items
