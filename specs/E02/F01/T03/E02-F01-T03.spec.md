---
id: E02-F01-T03
title: Symbol Layout Calculator
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F01
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - layout
  - algorithm
  - presentation-layer
clickup_task_id: ''
---

# Spec: E02-F01-T03 - Symbol Layout Calculator

## 1. Overview

### 1.1 Problem Statement

Pins need to be positioned on cell symbol edges in an organized, readable manner. The layout must handle varying numbers of pins, distribute them evenly along edges, and calculate exact positions for both pin graphics and connection points.

### 1.2 Goals

- Calculate pin positions on cell edges based on direction
- Evenly distribute multiple pins along each edge
- Handle edge cases (1 pin, many pins, unequal input/output counts)
- Provide position data for both pin graphics and net routing
- Support configurable cell dimensions and spacing

---

## 2. Technical Requirements

### 2.1 Class Definition

**Location**: `src/ink/presentation/canvas/symbol_layout_calculator.py`

```python
from dataclasses import dataclass
from typing import List, Dict
from PySide6.QtCore import QPointF, QRectF
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.value_objects.pin_direction import PinDirection

@dataclass(frozen=True)
class PinLayout:
    """Position information for a single pin."""
    pin_id: str
    position: QPointF  # Relative to cell origin
    connection_point: QPointF  # Scene coordinate for routing
    side: str  # "left", "right", "top", "bottom"

class SymbolLayoutCalculator:
    """Calculate pin positions on cell symbol edges."""

    # Configuration
    DEFAULT_CELL_WIDTH = 120.0
    DEFAULT_CELL_HEIGHT = 80.0
    MIN_PIN_SPACING = 15.0  # Minimum vertical spacing between pins
    PIN_MARGIN = 10.0  # Top/bottom margin on edges

    def __init__(
        self,
        cell_width: float = DEFAULT_CELL_WIDTH,
        cell_height: float = DEFAULT_CELL_HEIGHT
    ):
        """Initialize calculator with cell dimensions."""

    def calculate_pin_layouts(self, cell: Cell) -> Dict[str, PinLayout]:
        """
        Calculate positions for all pins on a cell.

        Args:
            cell: Domain cell entity with pins

        Returns:
            Dictionary mapping pin_id to PinLayout
        """

    def _distribute_pins_on_edge(
        self,
        pins: List[Pin],
        edge_side: str,
        cell_rect: QRectF
    ) -> List[PinLayout]:
        """Evenly distribute pins along an edge."""

    def _calculate_pin_position(
        self,
        edge_side: str,
        index: int,
        total_pins: int,
        cell_rect: QRectF
    ) -> QPointF:
        """Calculate position for a single pin on an edge."""

    def adjust_cell_height_for_pins(
        self,
        input_count: int,
        output_count: int
    ) -> float:
        """Calculate required cell height based on pin counts."""
```

### 2.2 Layout Algorithm

**Pin Distribution Strategy**:

1. **Separate pins by direction**:
   - INPUT → Left edge
   - OUTPUT → Right edge
   - INOUT → Right edge (configurable)

2. **Calculate edge length**:
   - Available height = cell_height - (2 × PIN_MARGIN)
   - Example: 80px cell → 60px available (10px margin top/bottom)

3. **Distribute pins evenly**:
   - Single pin: Center of available space
   - Multiple pins: Evenly spaced with minimum spacing
   - Formula: `spacing = available_height / (pin_count + 1)`

4. **Position calculation**:
   ```
   For left edge (INPUT):
   x = 0
   y = PIN_MARGIN + (index + 1) × spacing

   For right edge (OUTPUT):
   x = cell_width
   y = PIN_MARGIN + (index + 1) × spacing
   ```

5. **Height adjustment**:
   - If pins exceed available space, increase cell height
   - New height = (pin_count × MIN_PIN_SPACING) + (2 × PIN_MARGIN)

### 2.3 Edge Cases

**Single Pin**:
- Position at vertical center of edge
- y = cell_height / 2

**Many Pins** (>6 per edge):
- Maintain MIN_PIN_SPACING (15px)
- Increase cell height if needed
- Consider compression strategy if space limited

**Unequal Counts**:
- Left edge has 3 inputs, right has 1 output
- Each edge distributes independently
- Cell height determined by maximum pin count

**INOUT Pins**:
- Default: Place on right edge with outputs
- Optional: Split between left and right edges
- Configuration option for placement strategy

### 2.4 Return Data Structure

```python
{
    "U1/A": PinLayout(
        pin_id="U1/A",
        position=QPointF(0.0, 25.0),
        connection_point=QPointF(100.0, 225.0),  # Scene coords
        side="left"
    ),
    "U1/Y": PinLayout(
        pin_id="U1/Y",
        position=QPointF(120.0, 40.0),
        connection_point=QPointF(220.0, 240.0),
        side="right"
    )
}
```

---

## 3. Dependencies

- **Upstream**:
  - E01-F01: `Cell` and `Pin` domain entities
  - `PinDirection` value object

- **Downstream**:
  - T01: `CellItem` uses calculated dimensions
  - T02: `PinItem` uses calculated positions
  - E02-F03: Net router uses connection points

---

## 4. Acceptance Criteria

- [ ] `SymbolLayoutCalculator` class implemented
- [ ] Calculates positions for all pins on a cell
- [ ] Input pins positioned on left edge
- [ ] Output pins positioned on right edge
- [ ] Pins evenly distributed with minimum spacing
- [ ] Single pin positioned at center of edge
- [ ] Cell height adjusts for many pins (>6)
- [ ] Returns `PinLayout` with relative and scene coordinates
- [ ] Handles INOUT pins correctly
- [ ] Unit tests verify distribution algorithm
- [ ] Edge case tests (1 pin, 10 pins, unequal counts)

---

## 5. Implementation Notes

### 5.1 Example Usage

```python
calculator = SymbolLayoutCalculator(
    cell_width=120.0,
    cell_height=80.0
)

# Calculate layouts for a cell with 3 inputs, 1 output
layouts = calculator.calculate_pin_layouts(cell)

# Use in CellItem to position PinItems
for pin_id, layout in layouts.items():
    pin_item = PinItem(cell.get_pin(pin_id), cell_item)
    pin_item.setPos(layout.position)
```

### 5.2 Pin Distribution Math

```python
def _distribute_pins_on_edge(pins, edge_height, margin):
    available_height = edge_height - (2 * margin)
    count = len(pins)

    if count == 1:
        return [margin + available_height / 2]

    spacing = available_height / (count + 1)
    positions = []

    for i in range(count):
        y = margin + (i + 1) * spacing
        positions.append(y)

    return positions
```

### 5.3 Testing Approach

**Unit Tests**:
- Test single pin positioning (centered)
- Test multiple pin distribution (evenly spaced)
- Test height adjustment for many pins
- Verify edge selection (INPUT→left, OUTPUT→right)

**Edge Case Tests**:
- 1 input, 1 output (minimal)
- 10 inputs, 10 outputs (many pins)
- 5 inputs, 1 output (unequal)
- INOUT pin placement

**Integration Tests**:
- Use calculated layouts to position pin graphics
- Verify visual appearance in test scene

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F01 split |
