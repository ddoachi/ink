# E02-F01-T03: Symbol Layout Calculator - Post-Implementation Documentation

## 1. Implementation Summary

**Spec**: [E02-F01-T03](./E02-F01-T03.spec.md)
**Status**: Completed
**Implementation Date**: 2025-12-28
**TDD Approach**: Red-Green-Refactor

### What Was Built

`SymbolLayoutCalculator` - A presentation layer utility that calculates pin positions on cell symbol edges for schematic rendering. The calculator determines where each pin should be placed based on its direction (INPUT on left, OUTPUT/INOUT on right) and evenly distributes multiple pins along each edge.

### Key Components

| Component | Location | Purpose |
|-----------|----------|---------|
| `PinLayout` | `symbol_layout_calculator.py:55` | Immutable value object holding pin position data |
| `SymbolLayoutCalculator` | `symbol_layout_calculator.py:106` | Main calculator class with distribution logic |
| Unit Tests | `test_symbol_layout_calculator.py` | 37 comprehensive test cases |

---

## 2. Design Decisions

### 2.1 Architecture Decision: Value Object Pattern for PinLayout

**Decision**: Use frozen dataclass for `PinLayout`

**Rationale**:
- Pin positions are calculated once and used by multiple consumers (PinItem, net router)
- Immutability ensures thread safety and enables caching
- Frozen dataclass provides equals/hash automatically

**Trade-offs**:
- (+) Safe sharing between components
- (+) Clear data contract
- (-) Cannot modify positions post-calculation (requires recalculation)

### 2.2 Algorithm Decision: Even Distribution Formula

**Decision**: Use the formula `y = margin + (index + 1) * spacing` where `spacing = available / (count + 1)`

**Rationale**:
- Creates equal gaps between pins AND between pins and margins
- Handles edge cases (1 pin = centered) elegantly
- Matches industry standard schematic editors

**Visualization**:
```
Cell height = 80px, margin = 10px, 3 pins:
available = 80 - 20 = 60px
spacing = 60 / 4 = 15px

 ┌─────────┐
 │  10px   │ ← margin
 ├─────────┤
 │  • A    │ y = 10 + 15 = 25px
 │  15px   │
 ├─────────┤
 │  • B    │ y = 10 + 30 = 40px
 │  15px   │
 ├─────────┤
 │  • C    │ y = 10 + 45 = 55px
 │  15px   │
 ├─────────┤
 │  10px   │ ← margin
 └─────────┘
```

### 2.3 API Decision: Design Dependency Injection

**Decision**: Pass `Design` aggregate to `calculate_pin_layouts()` instead of storing it

**Rationale**:
- Calculator is stateless and reusable
- Avoids circular dependencies between presentation and domain
- Enables testing with mock designs

**Usage Pattern**:
```python
calculator = SymbolLayoutCalculator()
layouts = calculator.calculate_pin_layouts(cell, design, scene_pos)
```

---

## 3. Algorithm Deep Dive

### Pin Distribution Algorithm

```python
def calculate_y_position(index: int, total: int, height: float, margin: float) -> float:
    """Calculate y position for a pin on an edge.

    Args:
        index: Zero-based index of the pin (0 = first pin)
        total: Total number of pins on this edge
        height: Total cell height in pixels
        margin: Top/bottom margin in pixels

    Returns:
        Y coordinate in cell-local coordinates
    """
    if total == 1:
        # Single pin: center vertically
        return height / 2

    # Multiple pins: even distribution
    available = height - 2 * margin
    spacing = available / (total + 1)
    return margin + (index + 1) * spacing
```

### Edge Cases Handled

| Scenario | Behavior |
|----------|----------|
| No pins | Returns empty dict |
| 1 pin per edge | Centered at height/2 |
| Many pins (>6) | Height auto-adjusted via `adjust_cell_height_for_pins()` |
| Unequal counts | Each edge distributes independently |
| Missing pin in Design | Silently skipped (graceful degradation) |

---

## 4. Test Coverage

### Test Categories

| Category | Tests | Coverage |
|----------|-------|----------|
| PinLayout value object | 4 | Immutability, field storage, valid sides |
| Calculator creation | 6 | Defaults, constants, custom dimensions |
| Pin layout calculation | 3 | Return type, all pins included |
| Direction placement | 5 | INPUT→left, OUTPUT→right, INOUT→right |
| Pin distribution | 4 | Single pin, two pins, many pins, even spacing |
| Edge cases | 2 | Unequal counts, no pins |
| Height adjustment | 3 | Default, increased, max count logic |
| Connection points | 2 | Scene offset, default position |
| Custom dimensions | 2 | Width, height effects |
| Private methods | 4 | Distribution, position calculation |
| Integration | 2 | Qt compatibility, bounds checking |

**Total**: 37 tests, 100% pass rate

---

## 5. Integration Points

### Upstream Dependencies

| Dependency | Used For |
|------------|----------|
| `Cell` entity | Get pin_ids for layout calculation |
| `Design` aggregate | Look up Pin entities by ID |
| `PinDirection` enum | Determine edge placement |
| `Pin` entity | Access direction for sorting |

### Downstream Consumers

| Consumer | Usage |
|----------|-------|
| `CellItem` | Get cell dimensions for sizing |
| `PinItem` (future) | Use `PinLayout.position` for placement |
| Net router (future) | Use `PinLayout.connection_point` for routing |

---

## 6. Performance Characteristics

### Time Complexity

| Operation | Complexity | Notes |
|-----------|------------|-------|
| `calculate_pin_layouts()` | O(n) | Linear in number of pins |
| `_distribute_pins_on_edge()` | O(n) | Linear per edge |
| `_calculate_pin_position()` | O(1) | Simple arithmetic |
| `adjust_cell_height_for_pins()` | O(1) | Max comparison |

### Space Complexity

- O(n) for result dictionary where n = number of pins
- No caching (stateless calculator)

---

## 7. Lessons Learned

### What Worked Well

1. **TDD Approach**: Writing tests first clarified the API design before implementation
2. **Value Object Pattern**: `PinLayout` frozen dataclass eliminated mutability bugs
3. **Separation of Concerns**: Calculator is pure logic, no Qt dependencies except types

### What Could Be Improved

1. **Top/Bottom Edge Support**: Current implementation only handles left/right edges. Spec mentions "top", "bottom" in `side` field but no logic exists.
2. **INOUT Placement Strategy**: All INOUT pins go to right edge. Could add configuration for split placement.

### Future Enhancements

1. Consider caching layouts if same cell is rendered multiple times
2. Add top/bottom edge support for special pin types (power, ground)
3. Add pin sorting options (by name, by net importance)

---

## 8. Quick Reference

### Usage Example

```python
from ink.presentation.canvas.symbol_layout_calculator import (
    SymbolLayoutCalculator,
    PinLayout,
)

# Create calculator with default dimensions
calculator = SymbolLayoutCalculator()

# Or with custom dimensions
calculator = SymbolLayoutCalculator(cell_width=150.0, cell_height=100.0)

# Calculate layouts for a cell
layouts = calculator.calculate_pin_layouts(
    cell=cell,
    design=design,
    cell_scene_pos=QPointF(100.0, 200.0),  # Optional
)

# Use layouts to position pin graphics
for pin_id, layout in layouts.items():
    print(f"{pin_id}: {layout.side} edge at {layout.position}")
    # layout.position - relative to cell origin
    # layout.connection_point - absolute scene coordinates
```

### Configuration Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `DEFAULT_CELL_WIDTH` | 120.0 | Standard cell width |
| `DEFAULT_CELL_HEIGHT` | 80.0 | Standard cell height |
| `MIN_PIN_SPACING` | 15.0 | Minimum gap between pins |
| `PIN_MARGIN` | 10.0 | Top/bottom edge margin |

---

## Related Documentation

- [Spec E02-F01-T03](./E02-F01-T03.spec.md) - Original requirements
- [E02-F01-T01 CellItem](../T01/E02-F01-T01.spec.md) - Cell graphics that use layouts
- [E02-F01-T02 PinItem](../T02/E02-F01-T02.spec.md) - Pin graphics (future)
