# E02-F01-T03 - Symbol Layout Calculator: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F01-T03
- **Task**: Symbol Layout Calculator
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the algorithm for calculating pin positions on cell symbol edges. The `SymbolLayoutCalculator` determines where each pin should be placed based on its direction (input/output/inout), distributes multiple pins evenly along edges, and handles edge cases like cells with many pins or unequal input/output counts.

**Core Deliverables:**
- `SymbolLayoutCalculator` class for pin position calculation
- Pin distribution algorithm for even spacing on edges
- Edge assignment based on pin direction (INPUT→left, OUTPUT→right)
- Cell height adjustment for cells with many pins
- `PinLayout` data structure for position information

**Success Metrics:**
- Accurate pin positioning (no overlaps)
- Even pin distribution (visually balanced)
- Handles cells with 1-20 pins per edge
- Cell height adapts to pin count while maintaining spacing

### 1.2 Problem Context

Pin positioning is a critical layout problem that affects schematic readability:

1. **Readability**: Pins must be evenly distributed and clearly separated to avoid visual clutter.

2. **Convention Compliance**: EDA tool conventions dictate that inputs appear on the left, outputs on the right. This matches left-to-right signal flow.

3. **Scalability**: Cells can have varying pin counts (2-pin NAND gate vs. 32-pin register). The algorithm must handle both extremes gracefully.

4. **Net Routing Integration**: Pin positions directly impact net routing quality. Poorly positioned pins lead to crossing nets and poor routing.

5. **Dynamic Cell Sizing**: Cells with many pins need taller symbols to maintain readable spacing.

**Key Challenge**: Balance mathematical precision (evenly spaced pins) with aesthetic quality (visually pleasing layout).

---

## 2. Implementation Approach

### 2.1 Architecture Design

**Layer Positioning:**

The SymbolLayoutCalculator is a pure presentation layer utility. It bridges domain model (Cell, Pin entities) with graphics rendering (CellItem, PinItem).

```
┌────────────────────────────────────────────┐
│ Presentation Layer                         │
│  ├─ CellItem, PinItem (graphics)           │
│  ├─ SymbolLayoutCalculator ◄── THIS TASK  │
│  └─ SchematicCanvas (view)                 │
└────────────┬───────────────────────────────┘
             │ reads, never modifies
┌────────────▼───────────────────────────────┐
│ Domain Layer                               │
│  ├─ Cell (entity)                          │
│  ├─ Pin (entity)                           │
│  └─ PinDirection (value object)            │
└────────────────────────────────────────────┘
```

**Design Principle**: Calculator is a stateless utility - same input always produces same output. All state lives in domain model.

### 2.2 Data Structures

```python
# File: src/ink/presentation/canvas/symbol_layout_calculator.py

from dataclasses import dataclass
from typing import List, Dict
from PySide6.QtCore import QPointF, QRectF
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.value_objects.pin_direction import PinDirection

@dataclass(frozen=True)
class PinLayout:
    """
    Position information for a single pin.

    Attributes:
        pin_id: Unique identifier for the pin
        position: QPointF relative to cell origin (top-left)
        connection_point: QPointF in scene coordinates (for routing)
        side: Edge where pin is positioned ("left", "right", "top", "bottom")
    """
    pin_id: str
    position: QPointF  # Relative to cell (0, 0)
    connection_point: QPointF  # Scene coordinates (cell_pos + position)
    side: str  # "left", "right", "top", "bottom"
```

### 2.3 Core Algorithm

**Pin Distribution Strategy:**

```
1. Separate pins by direction:
   INPUT  → Left edge
   OUTPUT → Right edge
   INOUT  → Right edge (configurable)

2. Calculate available edge space:
   available_height = cell_height - (2 × PIN_MARGIN)

3. Distribute pins evenly:
   if pin_count == 1:
       position = center of edge
   else:
       spacing = available_height / (pin_count + 1)
       positions = [margin + (i + 1) × spacing for i in range(pin_count)]

4. Check for overcrowding:
   if spacing < MIN_PIN_SPACING:
       increase cell_height to maintain MIN_PIN_SPACING

5. Calculate positions:
   Left edge:  (x=0, y=calculated_y)
   Right edge: (x=cell_width, y=calculated_y)
```

**Mathematical Formulation:**

For `n` pins on an edge of height `h` with margins `m`:

```
Available space: A = h - 2m
Spacing: s = A / (n + 1)

Pin i position: y_i = m + (i + 1) × s, where i ∈ [0, n-1]

Constraint: s ≥ MIN_SPACING
If violated: h' = (n × MIN_SPACING) + 2m
```

**Example Calculation:**

```
Cell: height=80, margin=10
Pins: 3 inputs

Available: 80 - 20 = 60
Spacing: 60 / (3 + 1) = 15

Positions:
  Pin 0: y = 10 + 1×15 = 25
  Pin 1: y = 10 + 2×15 = 40
  Pin 2: y = 10 + 3×15 = 55
```

### 2.4 Class Implementation

```python
class SymbolLayoutCalculator:
    """
    Calculate pin positions on cell symbol edges.

    This calculator implements an even distribution algorithm that:
    - Places INPUT pins on left edge
    - Places OUTPUT pins on right edge
    - Distributes pins evenly with configurable spacing
    - Adjusts cell height dynamically for many pins
    """

    # Configuration constants
    DEFAULT_CELL_WIDTH = 120.0
    DEFAULT_CELL_HEIGHT = 80.0
    MIN_PIN_SPACING = 15.0  # Minimum vertical spacing between pins
    PIN_MARGIN = 10.0  # Top/bottom margin on edges

    def __init__(
        self,
        cell_width: float = DEFAULT_CELL_WIDTH,
        cell_height: float = DEFAULT_CELL_HEIGHT
    ):
        """
        Initialize calculator with cell dimensions.

        Args:
            cell_width: Width of cell symbol in pixels
            cell_height: Base height of cell symbol in pixels
        """
        self._cell_width = cell_width
        self._cell_height = cell_height

    def calculate_pin_layouts(
        self,
        cell: Cell,
        cell_position: QPointF = QPointF(0, 0)
    ) -> Dict[str, PinLayout]:
        """
        Calculate positions for all pins on a cell.

        Args:
            cell: Domain cell entity with pins
            cell_position: Cell position in scene coordinates (for connection points)

        Returns:
            Dictionary mapping pin_id to PinLayout
        """
        # Separate pins by direction
        input_pins = [p for p in cell.pins if p.direction == PinDirection.INPUT]
        output_pins = [p for p in cell.pins if p.direction == PinDirection.OUTPUT]
        inout_pins = [p for p in cell.pins if p.direction == PinDirection.INOUT]

        # Assign INOUT pins to right edge (with outputs)
        output_pins.extend(inout_pins)

        # Calculate required cell height
        required_height = self._calculate_required_height(
            len(input_pins),
            len(output_pins)
        )

        # Create cell rectangle
        cell_rect = QRectF(0, 0, self._cell_width, required_height)

        # Calculate layouts for each edge
        layouts = {}

        # Left edge (inputs)
        left_layouts = self._distribute_pins_on_edge(
            input_pins,
            "left",
            cell_rect,
            cell_position
        )
        layouts.update({layout.pin_id: layout for layout in left_layouts})

        # Right edge (outputs + inouts)
        right_layouts = self._distribute_pins_on_edge(
            output_pins,
            "right",
            cell_rect,
            cell_position
        )
        layouts.update({layout.pin_id: layout for layout in right_layouts})

        return layouts

    def _distribute_pins_on_edge(
        self,
        pins: List[Pin],
        edge_side: str,
        cell_rect: QRectF,
        cell_position: QPointF
    ) -> List[PinLayout]:
        """
        Evenly distribute pins along an edge.

        Args:
            pins: List of pins to distribute
            edge_side: "left" or "right"
            cell_rect: Cell bounding rectangle
            cell_position: Cell position in scene for connection points

        Returns:
            List of PinLayout objects
        """
        if not pins:
            return []

        layouts = []
        count = len(pins)

        # Calculate Y positions (vertical distribution)
        y_positions = self._calculate_edge_positions(
            count,
            cell_rect.height()
        )

        # Calculate X position based on edge
        if edge_side == "left":
            x = 0.0
        elif edge_side == "right":
            x = cell_rect.width()
        else:
            raise ValueError(f"Unknown edge side: {edge_side}")

        # Create layouts
        for i, pin in enumerate(pins):
            position = QPointF(x, y_positions[i])
            connection_point = QPointF(
                cell_position.x() + x,
                cell_position.y() + y_positions[i]
            )

            layout = PinLayout(
                pin_id=str(pin.id),
                position=position,
                connection_point=connection_point,
                side=edge_side
            )
            layouts.append(layout)

        return layouts

    def _calculate_edge_positions(
        self,
        pin_count: int,
        edge_height: float
    ) -> List[float]:
        """
        Calculate Y positions for pins on an edge.

        Args:
            pin_count: Number of pins to position
            edge_height: Height of the edge

        Returns:
            List of Y positions
        """
        if pin_count == 0:
            return []

        available_height = edge_height - (2 * self.PIN_MARGIN)

        if pin_count == 1:
            # Single pin: center on edge
            return [edge_height / 2.0]

        # Multiple pins: evenly spaced
        spacing = available_height / (pin_count + 1)
        positions = []

        for i in range(pin_count):
            y = self.PIN_MARGIN + (i + 1) * spacing
            positions.append(y)

        return positions

    def _calculate_required_height(
        self,
        input_count: int,
        output_count: int
    ) -> float:
        """
        Calculate required cell height based on pin counts.

        Args:
            input_count: Number of input pins
            output_count: Number of output pins

        Returns:
            Required cell height in pixels
        """
        max_pins_per_edge = max(input_count, output_count)

        if max_pins_per_edge == 0:
            return self._cell_height

        # Calculate required height for minimum spacing
        required_height = (
            (max_pins_per_edge * self.MIN_PIN_SPACING) +
            (2 * self.PIN_MARGIN)
        )

        # Use default height if sufficient, otherwise increase
        return max(self._cell_height, required_height)

    def adjust_cell_height_for_pins(
        self,
        input_count: int,
        output_count: int
    ) -> float:
        """
        Public method to query required cell height.

        Useful for CellItem to adjust its bounding rect.

        Args:
            input_count: Number of input pins
            output_count: Number of output pins

        Returns:
            Required cell height in pixels
        """
        return self._calculate_required_height(input_count, output_count)
```

### 2.5 Integration Example

```python
# Usage in SchematicCanvas or CellItem creation

calculator = SymbolLayoutCalculator(
    cell_width=120.0,
    cell_height=80.0
)

# Calculate layouts for a cell
cell_position = QPointF(100.0, 200.0)
layouts = calculator.calculate_pin_layouts(cell, cell_position)

# Create CellItem
cell_item = CellItem(cell)
cell_item.setPos(cell_position)

# Adjust cell height if needed
required_height = calculator.adjust_cell_height_for_pins(
    len(cell.get_inputs()),
    len(cell.get_outputs())
)
# Note: CellItem would need to support dynamic height

# Create PinItems with calculated positions
for pin in cell.pins:
    layout = layouts[str(pin.id)]
    pin_item = PinItem(pin, cell_item)
    pin_item.setPos(layout.position)  # Relative to cell
```

---

## 3. Key Design Decisions

### Decision 1: Edge Assignment Strategy

**Selected**: INPUT→left, OUTPUT→right, INOUT→right (with outputs)

**Rationale:**
- Matches EDA tool conventions (left-to-right signal flow)
- Clear visual separation of inputs and outputs
- INOUT pins grouped with outputs (typically data buses)

**Alternative Considered**: INOUT pins split between left and right
- Rejected: Adds complexity, unclear benefit

**Configurable Option (Future)**: Allow INOUT edge to be configurable per-cell-type.

### Decision 2: Pin Distribution Algorithm

**Selected**: Even spacing with (n+1) dividers

**Rationale:**
- Mathematically balanced (equal spacing above, between, and below pins)
- Produces aesthetically pleasing results
- Standard algorithm used in EDA tools

**Formula**: `spacing = available_height / (pin_count + 1)`

**Alternative Considered**: Equal spacing with pins at boundaries
- Formula: `spacing = available_height / (pin_count - 1)`
- Rejected: Pins too close to top/bottom edges

### Decision 3: Cell Height Adjustment

**Selected**: Dynamically increase cell height to maintain MIN_PIN_SPACING

**Rationale:**
- Prevents pin overlap and visual clutter
- Maintains readability for cells with many pins
- Simple algorithm (linear scaling)

**Constraint**: `spacing ≥ MIN_PIN_SPACING (15px)`

**Trade-off**: Cells with many pins become tall, may affect layout aesthetics.

**Future Enhancement**: Compress spacing gradually rather than hard cutoff.

### Decision 4: Single Pin Positioning

**Selected**: Position single pin at vertical center of edge

**Rationale:**
- Aesthetically balanced
- Matches user expectation for single I/O cells
- Simplifies routing (centered connection points)

**Implementation**: Special case in `_calculate_edge_positions()`

### Decision 5: Connection Point Calculation

**Selected**: Calculator computes both relative and scene coordinates

**Rationale:**
- PinItem needs relative position for `setPos()`
- Net router needs scene coordinates for global routing
- Computing both at once ensures consistency

**Data Structure**: `PinLayout` contains both `position` and `connection_point`

---

## 4. Dependencies and Integration

### 4.1 Upstream Dependencies

**E01-F01: Cell and Pin Domain Entities** (REQUIRED)
```python
# Must exist with this interface:
@dataclass
class Cell:
    id: CellId
    name: str
    pins: List[Pin]

@dataclass
class Pin:
    id: PinId
    name: str
    direction: PinDirection
    cell_id: CellId

class PinDirection(Enum):
    INPUT = "input"
    OUTPUT = "output"
    INOUT = "inout"
```

**PySide6** (REQUIRED)
- QPointF, QRectF for coordinate calculations

### 4.2 Downstream Consumers

**T01: CellItem** (USES)
- May query `adjust_cell_height_for_pins()` to resize bounding rect
- Not strictly required - CellItem can use fixed height for MVP

**T02: PinItem** (CRITICAL DEPENDENCY)
- Requires `calculate_pin_layouts()` to position pins
- Without calculator, pins would need manual positioning

**E02-F03: Net Router** (USES)
- Uses `connection_point` from `PinLayout` for routing
- Connection point accuracy critical for visual quality

### 4.3 Integration Risks

**Risk 1**: CellItem and Calculator produce inconsistent dimensions

**Impact**: Medium - pins may appear outside cell boundary

**Mitigation**:
- CellItem should query calculator for required height
- Integration tests verify pins within cell bounds
- Document cell dimension calculation clearly

**Risk 2**: Connection point mismatch with PinItem

**Impact**: High - nets won't connect to pins visually

**Mitigation**:
- Calculator and PinItem both use same coordinate system
- Unit tests verify connection point equals pin scene position
- Integration tests validate net attachment

**Risk 3**: Rounding errors in position calculation

**Impact**: Low - minor visual misalignment

**Mitigation**:
- Use float precision throughout
- Accept sub-pixel positioning (Qt handles this)
- Visual regression tests catch alignment issues

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/canvas/test_symbol_layout_calculator.py`

```python
import pytest
from PySide6.QtCore import QPointF
from ink.presentation.canvas.symbol_layout_calculator import (
    SymbolLayoutCalculator, PinLayout
)
from ink.domain.value_objects.pin_direction import PinDirection
from tests.fixtures.cell_fixtures import create_cell_with_pins

def test_single_pin_centered():
    """Verify single pin positioned at center of edge."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=1, output_count=0)

    layouts = calculator.calculate_pin_layouts(cell)

    input_layout = layouts[str(cell.pins[0].id)]
    assert input_layout.position.x() == 0.0  # Left edge
    assert input_layout.position.y() == 40.0  # Center of 80px height

def test_multiple_pins_evenly_spaced():
    """Verify multiple pins evenly distributed."""
    calculator = SymbolLayoutCalculator(cell_height=80.0)
    cell = create_cell_with_pins(input_count=3, output_count=0)

    layouts = calculator.calculate_pin_layouts(cell)

    # Extract Y positions
    y_positions = sorted([
        layouts[str(pin.id)].position.y()
        for pin in cell.pins
    ])

    # Check spacing
    # Available: 80 - 20 = 60, spacing = 60/4 = 15
    expected_positions = [25.0, 40.0, 55.0]
    assert y_positions == pytest.approx(expected_positions)

def test_input_pins_on_left_edge():
    """Verify input pins positioned on left edge (x=0)."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=2, output_count=0)

    layouts = calculator.calculate_pin_layouts(cell)

    for pin in cell.pins:
        layout = layouts[str(pin.id)]
        assert layout.position.x() == 0.0
        assert layout.side == "left"

def test_output_pins_on_right_edge():
    """Verify output pins positioned on right edge (x=width)."""
    calculator = SymbolLayoutCalculator(cell_width=120.0)
    cell = create_cell_with_pins(input_count=0, output_count=2)

    layouts = calculator.calculate_pin_layouts(cell)

    for pin in cell.pins:
        layout = layouts[str(pin.id)]
        assert layout.position.x() == 120.0
        assert layout.side == "right"

def test_unequal_input_output_counts():
    """Verify cells with unequal pin counts distribute correctly."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=5, output_count=1)

    layouts = calculator.calculate_pin_layouts(cell)

    # All pins should have valid positions
    assert len(layouts) == 6

    # Output pin should be centered (single pin)
    output_pins = [p for p in cell.pins if p.direction == PinDirection.OUTPUT]
    output_layout = layouts[str(output_pins[0].id)]
    assert output_layout.position.y() == pytest.approx(40.0)

def test_height_adjustment_for_many_pins():
    """Verify cell height increases for many pins."""
    calculator = SymbolLayoutCalculator()

    # 10 pins with MIN_SPACING=15, margin=10
    # Required: (10 * 15) + 20 = 170
    required_height = calculator.adjust_cell_height_for_pins(
        input_count=10,
        output_count=0
    )

    assert required_height >= 170.0

def test_connection_point_scene_coordinates():
    """Verify connection points in scene coordinates."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=1, output_count=0)
    cell_position = QPointF(100.0, 200.0)

    layouts = calculator.calculate_pin_layouts(cell, cell_position)

    layout = layouts[str(cell.pins[0].id)]

    # Connection point should be cell_position + pin_position
    expected_connection = QPointF(
        cell_position.x() + layout.position.x(),
        cell_position.y() + layout.position.y()
    )

    assert layout.connection_point.x() == pytest.approx(expected_connection.x())
    assert layout.connection_point.y() == pytest.approx(expected_connection.y())

def test_inout_pins_on_right_edge():
    """Verify INOUT pins placed on right edge with outputs."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=0, output_count=1, inout_count=1)

    layouts = calculator.calculate_pin_layouts(cell)

    # Both pins should be on right edge
    for pin in cell.pins:
        layout = layouts[str(pin.id)]
        assert layout.side == "right"

def test_empty_cell_no_pins():
    """Verify calculator handles cells with no pins."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=0, output_count=0)

    layouts = calculator.calculate_pin_layouts(cell)

    assert len(layouts) == 0

def test_minimum_spacing_maintained():
    """Verify minimum spacing constraint enforced."""
    calculator = SymbolLayoutCalculator()

    # Many pins should trigger height adjustment
    required_height = calculator.adjust_cell_height_for_pins(
        input_count=20,
        output_count=0
    )

    # Calculate actual spacing
    # spacing = (height - 2*margin) / (pins + 1)
    spacing = (required_height - 2 * calculator.PIN_MARGIN) / 21

    assert spacing >= calculator.MIN_PIN_SPACING
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_pin_layout_integration.py`

```python
import pytest
from PySide6.QtCore import QPointF
from PySide6.QtWidgets import QGraphicsScene
from ink.presentation.canvas.cell_item import CellItem
from ink.presentation.canvas.pin_item import PinItem
from ink.presentation.canvas.symbol_layout_calculator import SymbolLayoutCalculator
from tests.fixtures.cell_fixtures import create_cell_with_pins

def test_pin_layout_with_cell_item(qtbot):
    """Test pin layout integrates correctly with CellItem."""
    scene = QGraphicsScene()
    calculator = SymbolLayoutCalculator()

    cell = create_cell_with_pins(input_count=3, output_count=2)
    cell_position = QPointF(100.0, 200.0)

    # Calculate layouts
    layouts = calculator.calculate_pin_layouts(cell, cell_position)

    # Create cell item
    cell_item = CellItem(cell)
    cell_item.setPos(cell_position)
    scene.addItem(cell_item)

    # Create pin items with calculated positions
    for pin in cell.pins:
        layout = layouts[str(pin.id)]
        pin_item = PinItem(pin, cell_item)
        pin_item.setPos(layout.position)

        # Verify connection point matches
        connection_point = pin_item.get_connection_point()
        assert connection_point.x() == pytest.approx(layout.connection_point.x())
        assert connection_point.y() == pytest.approx(layout.connection_point.y())

def test_pins_within_cell_bounds(qtbot):
    """Test pins positioned within cell bounding rect."""
    scene = QGraphicsScene()
    calculator = SymbolLayoutCalculator()

    cell = create_cell_with_pins(input_count=5, output_count=5)
    cell_position = QPointF(0.0, 0.0)

    layouts = calculator.calculate_pin_layouts(cell, cell_position)

    cell_item = CellItem(cell)
    cell_item.setPos(cell_position)
    scene.addItem(cell_item)

    cell_bounds = cell_item.boundingRect()

    # All pin positions should be within cell height
    for layout in layouts.values():
        assert 0 <= layout.position.y() <= cell_bounds.height()
```

### 5.3 Edge Case Tests

**File**: `tests/unit/presentation/canvas/test_layout_edge_cases.py`

```python
def test_extreme_pin_count():
    """Test layout with extreme pin counts."""
    calculator = SymbolLayoutCalculator()

    # 50 pins per edge
    required_height = calculator.adjust_cell_height_for_pins(
        input_count=50,
        output_count=50
    )

    # Should scale linearly
    assert required_height >= 50 * calculator.MIN_PIN_SPACING

def test_zero_height_cell():
    """Test calculator handles invalid cell height gracefully."""
    # This should raise or clamp to minimum
    # Implementation-dependent behavior

def test_layout_deterministic():
    """Verify same inputs produce same outputs (no randomness)."""
    calculator = SymbolLayoutCalculator()
    cell = create_cell_with_pins(input_count=5, output_count=3)

    layouts1 = calculator.calculate_pin_layouts(cell)
    layouts2 = calculator.calculate_pin_layouts(cell)

    # Should be identical
    for pin_id in layouts1.keys():
        assert layouts1[pin_id] == layouts2[pin_id]
```

---

## 6. Risks and Considerations

### Risk 1: Visual Aesthetics vs Mathematical Precision

**Impact**: Medium
**Probability**: Medium

**Concern**: Mathematically even spacing may not always look visually balanced, especially with unequal input/output counts.

**Mitigation**:
- Start with mathematical approach for MVP
- Collect user feedback on visual quality
- Future: Add aesthetic adjustments (e.g., weighted spacing)
- Visual regression tests capture layout quality

### Risk 2: Cell Height Explosion

**Impact**: Low
**Probability**: Low

**Concern**: Cells with very many pins (50+) may become excessively tall, dominating the schematic.

**Mitigation**:
- Most gate-level cells have <10 pins
- Acceptable for MVP to have tall cells for edge cases
- Future: Multi-column pin layout for very wide cells
- Future: Compression strategy (reduce spacing gradually)

### Risk 3: INOUT Pin Ambiguity

**Impact**: Low
**Probability**: Low

**Concern**: Placing INOUT pins on right edge with outputs may be confusing.

**Mitigation**:
- T02 provides bidirectional arrow visual cue
- Matches common EDA tool convention (data buses on right)
- Future: Configurable INOUT edge assignment per cell type

### Risk 4: Coordinate System Confusion

**Impact**: Medium
**Probability**: Low

**Concern**: Relative vs scene coordinates may cause integration bugs.

**Mitigation**:
- `PinLayout` explicitly provides both coordinates
- Clear documentation of coordinate systems
- Integration tests verify coordinate consistency
- Use descriptive variable names (`relative_pos`, `scene_pos`)

### Risk 5: Performance with Many Cells

**Impact**: Low
**Probability**: Very Low

**Concern**: Calculating layouts for 1000 cells may be slow.

**Mitigation**:
- Algorithm is O(n) per cell (linear in pin count)
- No complex computation (just arithmetic)
- Calculations done once during cell creation
- Benchmark confirms <1ms per cell

---

## 7. Open Questions

### Q1: Should cell width be adjustable based on cell name length?

**Current Approach**: Fixed width (120px)

**Consideration**: Long cell names may overflow cell boundary

**Recommendation**: Fixed width for MVP, elide cell name if too long
**Future**: Dynamic width based on text metrics

### Q2: Should top/bottom edges be used for pins?

**Current Approach**: Only left/right edges used

**Consideration**: Some cell types (muxes, decoders) may benefit from top/bottom pins

**Recommendation**: Defer to P1, left/right sufficient for gate-level netlists
**Future**: Support 4-sided pin placement with configuration

### Q3: How to handle power/ground pins?

**Current Approach**: Treated as INPUT pins (on left edge)

**Consideration**: Power pins often implicit, may clutter layout

**Recommendation**: Position normally for MVP
**Future**: Option to hide or position differently (top/bottom edges)

### Q4: Should pin order match netlist order or be sorted?

**Current Approach**: Implicitly matches iteration order from `cell.pins`

**Consideration**: Sorting pins alphabetically may improve consistency

**Recommendation**: Use domain model order for MVP
**Future**: Configurable sort (alphabetical, netlist order, LSB-first for buses)

### Q5: Should spacing be configurable per cell type?

**Current Approach**: Global MIN_PIN_SPACING constant

**Consideration**: Some cell types (muxes) may need tighter spacing

**Recommendation**: Global constant for MVP
**Future**: Cell-type-specific spacing configuration

---

## 8. Implementation Checklist

**Preparation:**
- [ ] Verify E01-F01 (Cell, Pin entities) is complete
- [ ] Review PySide6 QPointF and QRectF APIs
- [ ] Understand coordinate systems (item vs scene)

**Core Implementation:**
- [ ] Create `src/ink/presentation/canvas/symbol_layout_calculator.py`
- [ ] Implement `PinLayout` dataclass
- [ ] Implement `SymbolLayoutCalculator.__init__()`
- [ ] Implement `calculate_pin_layouts()` main method
- [ ] Implement `_distribute_pins_on_edge()` distribution algorithm
- [ ] Implement `_calculate_edge_positions()` position calculation
- [ ] Implement `_calculate_required_height()` height adjustment
- [ ] Implement `adjust_cell_height_for_pins()` public method
- [ ] Handle single pin special case (centered)
- [ ] Handle empty cell (no pins)

**Testing:**
- [ ] Write unit tests for single pin positioning
- [ ] Write unit tests for multiple pin distribution
- [ ] Write unit tests for edge assignment (left/right)
- [ ] Write unit tests for height adjustment
- [ ] Write unit tests for connection point calculation
- [ ] Write unit tests for INOUT pin handling
- [ ] Write integration tests with CellItem and PinItem
- [ ] Write edge case tests (extreme pin counts)
- [ ] Verify deterministic behavior (same input → same output)

**Documentation:**
- [ ] Add docstrings to all public methods
- [ ] Document distribution algorithm clearly
- [ ] Add usage examples in module docstring
- [ ] Document coordinate system conventions

**Code Review:**
- [ ] Verify algorithm correctness (manual calculation check)
- [ ] Check edge case handling
- [ ] Review code clarity and maintainability
- [ ] Verify test coverage (>90%)

---

## 9. Success Criteria

This task is complete when:

**Functional:**
- [ ] `SymbolLayoutCalculator` calculates positions for all pins
- [ ] Input pins positioned on left edge
- [ ] Output pins positioned on right edge
- [ ] Pins evenly distributed with minimum spacing
- [ ] Single pin positioned at center of edge
- [ ] Cell height adjusts for many pins (>6 per edge)
- [ ] Returns `PinLayout` with both relative and scene coordinates
- [ ] Handles INOUT pins (placed on right edge)

**Performance:**
- [ ] Layout calculation <1ms per cell
- [ ] Handles cells with 50+ pins without issues

**Quality:**
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Edge case tests passing
- [ ] Code coverage >90%
- [ ] Algorithm verified with manual calculations

**Documentation:**
- [ ] All public APIs documented
- [ ] Distribution algorithm documented
- [ ] Coordinate systems documented
- [ ] Usage examples provided

---

## 10. References

**Mathematical References:**
- Even spacing algorithm: Standard layout technique
- Margin and padding conventions: EDA tool best practices

**Qt Documentation:**
- QPointF: https://doc.qt.io/qt-6/qpointf.html
- QRectF: https://doc.qt.io/qt-6/qrectf.html

**Project Documentation:**
- CLAUDE.md: Architecture guidelines
- E02.pre-docs.md: Overall rendering epic
- T01.spec.md: CellItem specification
- T02.spec.md: PinItem specification

**EDA Tool References:**
- KiCad symbol layout conventions
- gSchem pin positioning

---

**Document Status**: Ready for Implementation
**Estimated Implementation Time**: 6 hours
**Next Steps**: Implement after T01 and T02 foundation is in place, integrate with PinItem positioning
