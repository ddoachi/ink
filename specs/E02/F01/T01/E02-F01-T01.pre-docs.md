# E02-F01-T01 - Cell Graphics Item: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F01-T01
- **Task**: Cell Graphics Item
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the fundamental QGraphicsItem subclass for rendering cell symbols in the schematic canvas. The `CellItem` class serves as the visual representation of gate-level instances (AND gates, flip-flops, latches, etc.) and must integrate seamlessly with Qt's Graphics View Framework while maintaining clean separation from the domain layer.

**Core Deliverables:**
- `CellItem` class as a custom `QGraphicsItem` subclass
- Rectangular cell symbol rendering with rounded corners
- Centered cell name label display
- Visual distinction for sequential cells (latches/FFs)
- Selection and hover state support
- Efficient bounding rect and paint implementations

**Success Metrics:**
- Render 1000+ cells without frame drops (<16ms frame time)
- Selection response time <50ms
- Memory usage <1KB per cell item
- Visual clarity at all zoom levels

### 1.2 Problem Context

The schematic viewer requires a visual representation layer that bridges the domain model (Cell entities) with Qt's rendering system. This layer must:

1. **Maintain Architectural Boundaries**: The presentation layer must not leak into the domain layer. `CellItem` should accept domain entities but never modify them.

2. **Support Interactive Features**: The graphics item must handle selection, hover states, and future drag-and-drop operations while maintaining visual feedback.

3. **Enable Performance at Scale**: With potential schematic sizes of 1000+ cells, rendering must be highly optimized using Qt's built-in mechanisms (caching, LOD, culling).

4. **Prepare for Future Features**: The design must accommodate upcoming features like expansion/collapse animations, highlighting, and property inspection.

---

## 2. Implementation Approach

### 2.1 Architecture Design

**Layer Positioning:**

```
┌────────────────────────────────────────────┐
│ Presentation Layer (PySide6)               │
│  ├─ SchematicCanvas (QGraphicsView)        │
│  ├─ CellItem (QGraphicsItem) ◄── THIS TASK│
│  └─ PinItem (QGraphicsItem)                │
└────────────┬───────────────────────────────┘
             │ accepts, never modifies
┌────────────▼───────────────────────────────┐
│ Domain Layer                               │
│  └─ Cell (entity)                          │
└────────────────────────────────────────────┘
```

**Key Design Principle**: `CellItem` holds a reference to the domain `Cell` entity for read-only queries but never modifies it. All visual state (selection, position) lives in the QGraphicsItem.

### 2.2 Class Structure

```python
# File: src/ink/presentation/canvas/cell_item.py

from PySide6.QtWidgets import QGraphicsItem
from PySide6.QtCore import QRectF, Qt
from PySide6.QtGui import QPainter, QPen, QBrush, QColor, QFont
from ink.domain.model.cell import Cell

class CellItem(QGraphicsItem):
    """
    QGraphicsItem representing a cell symbol in the schematic canvas.

    Responsibilities:
    - Render cell as rectangular symbol with rounded corners
    - Display cell name centered within symbol
    - Provide visual distinction for sequential cells
    - Handle selection and hover states
    - Calculate accurate bounding rectangles for collision detection
    """

    # Visual constants
    DEFAULT_WIDTH = 120.0
    DEFAULT_HEIGHT = 80.0
    CORNER_RADIUS = 5.0
    BORDER_WIDTH = 2.0
    SEQUENTIAL_BORDER_WIDTH = 3.0

    # Colors
    FILL_COLOR = QColor("#F0F0F0")
    SEQUENTIAL_FILL_COLOR = QColor("#FFFFFF")
    BORDER_COLOR = QColor("#999999")
    SELECTED_BORDER_COLOR = QColor("#2196F3")
    HOVER_BORDER_COLOR = QColor("#666666")

    def __init__(self, cell: Cell, parent=None):
        """
        Initialize cell graphics item.

        Args:
            cell: Domain cell entity (read-only reference)
            parent: Optional parent QGraphicsItem
        """
        super().__init__(parent)
        self._cell = cell
        self._detail_level = None  # Set by T04

        # Configure item flags for interaction
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemUsesExtendedStyleOption, True)
        self.setCacheMode(QGraphicsItem.DeviceCoordinateCache)

    def boundingRect(self) -> QRectF:
        """
        Return the bounding rectangle for collision and rendering.

        Must account for border width to prevent clipping.
        """
        half_border = self.SEQUENTIAL_BORDER_WIDTH / 2.0
        return QRectF(
            -half_border,
            -half_border,
            self.DEFAULT_WIDTH + self.SEQUENTIAL_BORDER_WIDTH,
            self.DEFAULT_HEIGHT + self.SEQUENTIAL_BORDER_WIDTH
        )

    def paint(self, painter: QPainter, option, widget=None):
        """
        Render the cell symbol.

        Rendering order:
        1. Fill background
        2. Draw border (thickness varies by cell type)
        3. Draw cell name (centered)
        """
        # Select style based on cell type
        if self._cell.is_sequential:
            border_width = self.SEQUENTIAL_BORDER_WIDTH
            fill_color = self.SEQUENTIAL_FILL_COLOR
        else:
            border_width = self.BORDER_WIDTH
            fill_color = self.FILL_COLOR

        # Adjust border color for selection/hover states
        border_color = self._get_border_color(option)

        # Draw cell body
        pen = QPen(border_color, border_width)
        brush = QBrush(fill_color)
        painter.setPen(pen)
        painter.setBrush(brush)

        rect = QRectF(0, 0, self.DEFAULT_WIDTH, self.DEFAULT_HEIGHT)
        painter.drawRoundedRect(rect, self.CORNER_RADIUS, self.CORNER_RADIUS)

        # Draw cell name centered
        painter.setPen(QColor("#000000"))
        painter.setFont(QFont("Sans-serif", 10))
        painter.drawText(rect, Qt.AlignCenter, self._cell.name)

    def _get_border_color(self, option) -> QColor:
        """Determine border color based on item state."""
        if option.state & QStyle.State_Selected:
            return self.SELECTED_BORDER_COLOR
        elif option.state & QStyle.State_MouseOver:
            return self.HOVER_BORDER_COLOR
        else:
            return self.BORDER_COLOR

    def set_position(self, x: float, y: float):
        """Set the cell position in scene coordinates."""
        self.setPos(x, y)

    def get_cell(self) -> Cell:
        """Return the associated domain cell entity."""
        return self._cell

    def shape(self) -> QPainterPath:
        """
        Override shape for accurate selection detection.

        Default uses bounding rect, which is sufficient for rectangles.
        Override if we add more complex shapes in the future.
        """
        path = QPainterPath()
        path.addRoundedRect(
            QRectF(0, 0, self.DEFAULT_WIDTH, self.DEFAULT_HEIGHT),
            self.CORNER_RADIUS,
            self.CORNER_RADIUS
        )
        return path
```

### 2.3 Integration Points

**With SchematicCanvas:**
```python
# In SchematicCanvas (future implementation)
cell_item = CellItem(cell)
cell_item.set_position(100.0, 200.0)
scene.addItem(cell_item)
```

**With Domain Layer:**
```python
# CellItem queries domain entity for display data
cell_name = cell_item.get_cell().name
is_sequential = cell_item.get_cell().is_sequential
```

**With PinItem (T02):**
```python
# PinItems will be children of CellItem
for pin in cell.pins:
    pin_item = PinItem(pin, parent_cell_item=cell_item)
    # Pin positions calculated by T03
```

---

## 3. Key Design Decisions

### Decision 1: Visual Style for Sequential Cells

**Options Considered:**
- **Option A**: Different border color (e.g., blue)
- **Option B**: Different fill color + thicker border
- **Option C**: Icon overlay (clock symbol)

**Selected**: Option B (different fill + thicker border)

**Rationale:**
- Clear visual distinction without being distracting
- Works well at all zoom levels (color + thickness both scale)
- Thicker border (3px vs 2px) provides subtle but noticeable difference
- White fill vs light gray creates contrast
- Defers icon overlay to T05 for additional enhancement

**Trade-offs:**
- Requires `is_sequential` flag in domain `Cell` entity (depends on E01-F03)
- May need color adjustment based on user feedback

### Decision 2: Coordinate System

**Selected**: Cell origin at top-left (0, 0) with width/height extending right/down

**Rationale:**
- Consistent with Qt's standard coordinate system
- Simplifies pin positioning calculations (T03)
- Aligns with schematic layout convention (left-to-right signal flow)

**Alternative Considered**: Center-based origin
- Rejected: Complicates pin position math, no significant benefit

### Decision 3: Caching Strategy

**Selected**: Use `DeviceCoordinateCache` for cell items

**Rationale:**
- Cells are mostly static after layout
- Device coordinate caching survives view transforms (zoom/pan)
- Automatically invalidated on selection state changes
- Minimal memory overhead (<50KB per 100 cells cached)

**Deferred**: Item coordinate caching (would not survive zoom)

### Decision 4: Text Rendering

**Selected**: Direct text rendering with `drawText()` for MVP

**Rationale:**
- Simple implementation
- Sufficient performance for 1000 cells
- Text automatically scales with zoom

**Future Enhancement**: Use `QStaticText` if profiling shows text rendering is a bottleneck (likely in T04 when LOD is implemented)

---

## 4. Dependencies and Integration

### 4.1 Upstream Dependencies

**E01-F01: Cell Domain Entity** (REQUIRED)
```python
# Must exist with this interface:
@dataclass
class Cell:
    id: CellId
    name: str
    cell_type: str
    pins: List[Pin]
    is_sequential: bool
```

**Status**: E01-F01 must be complete before this task begins.

**E01-F03: Latch Detection** (REQUIRED)
- Needed to set `is_sequential` flag during parsing
- Without this, all cells will render as combinational

**PySide6** (REQUIRED)
- QGraphicsItem framework
- QPainter rendering APIs

### 4.2 Downstream Consumers

**T02: PinItem** (BLOCKS)
- PinItems will be children of CellItem
- Requires `CellItem` to exist as parent container
- Requires bounding rect to calculate pin edge positions

**T04: Zoom Level of Detail** (ENHANCES)
- Will add `set_detail_level()` method to CellItem
- Will modify `paint()` to conditionally render based on zoom
- CellItem must be functional independently first

**E04: Selection and Interaction** (USES)
- Will rely on `ItemIsSelectable` flag
- Will use selection state for property panel updates

**E03: Expansion** (USES)
- Will add/remove CellItems dynamically during expansion
- Requires `CellItem` to be lightweight and fast to construct

### 4.3 Integration Risks

**Risk 1**: Domain `Cell` entity missing `is_sequential` attribute

**Mitigation**:
- Coordinate with E01-F03 implementer
- Fallback: Assume all cells combinational if attribute missing
- Unit tests mock Cell with `is_sequential` property

**Risk 2**: Coordinate mismatch between layout engine and graphics items

**Mitigation**:
- Clearly document coordinate system in this pre-docs
- Integration tests verify positions match expected layout
- Provide debug mode to visualize bounding rects

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/canvas/test_cell_item.py`

```python
import pytest
from PySide6.QtCore import QRectF
from ink.presentation.canvas.cell_item import CellItem
from ink.domain.model.cell import Cell
from tests.fixtures.cell_fixtures import create_mock_cell

def test_cell_item_bounding_rect():
    """Verify bounding rect includes border padding."""
    cell = create_mock_cell(name="U1", is_sequential=False)
    item = CellItem(cell)

    rect = item.boundingRect()

    # Should extend beyond cell dimensions to include border
    assert rect.width() > CellItem.DEFAULT_WIDTH
    assert rect.height() > CellItem.DEFAULT_HEIGHT

def test_sequential_cell_styling():
    """Verify sequential cells have thicker border."""
    seq_cell = create_mock_cell(name="FF1", is_sequential=True)
    comb_cell = create_mock_cell(name="AND1", is_sequential=False)

    seq_item = CellItem(seq_cell)
    comb_item = CellItem(comb_cell)

    # Test will verify border width in paint method
    # (Requires QPainter mock to intercept setPen calls)
    # Implementation detail: check via internal state or mock painter

def test_cell_item_position():
    """Verify set_position updates scene coordinates."""
    cell = create_mock_cell()
    item = CellItem(cell)

    item.set_position(100.0, 200.0)

    assert item.pos().x() == 100.0
    assert item.pos().y() == 200.0

def test_cell_item_selectable():
    """Verify item is selectable by default."""
    cell = create_mock_cell()
    item = CellItem(cell)

    assert item.flags() & QGraphicsItem.ItemIsSelectable

def test_get_cell_returns_domain_entity():
    """Verify get_cell returns original domain entity."""
    cell = create_mock_cell(name="TEST_CELL")
    item = CellItem(cell)

    retrieved_cell = item.get_cell()

    assert retrieved_cell is cell
    assert retrieved_cell.name == "TEST_CELL"
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_cell_rendering.py`

```python
import pytest
from PySide6.QtWidgets import QGraphicsScene, QGraphicsView
from ink.presentation.canvas.cell_item import CellItem
from tests.fixtures.cell_fixtures import create_mock_cell

@pytest.fixture
def graphics_scene():
    """Create a QGraphicsScene for testing."""
    return QGraphicsScene()

def test_cell_renders_in_scene(qtbot, graphics_scene):
    """Test cell item renders correctly in QGraphicsScene."""
    cell = create_mock_cell(name="U1")
    item = CellItem(cell)
    item.set_position(50.0, 50.0)

    graphics_scene.addItem(item)

    # Verify item is in scene
    assert item in graphics_scene.items()
    assert graphics_scene.itemsBoundingRect().contains(item.boundingRect())

def test_multiple_cells_render(qtbot, graphics_scene):
    """Test rendering 100 cells for performance validation."""
    for i in range(100):
        cell = create_mock_cell(name=f"U{i}")
        item = CellItem(cell)
        item.set_position(i * 150.0, 0.0)
        graphics_scene.addItem(item)

    # Verify all items added
    assert len(graphics_scene.items()) == 100

def test_cell_selection_interaction(qtbot, graphics_scene):
    """Test cell selection state changes."""
    cell = create_mock_cell()
    item = CellItem(cell)
    graphics_scene.addItem(item)

    # Simulate selection
    item.setSelected(True)

    assert item.isSelected()
    # Visual verification: border should change color (manual inspection)
```

### 5.3 Visual Regression Tests

**File**: `tests/visual/test_cell_appearance.py`

```python
def test_cell_visual_regression(qtbot):
    """Compare rendered cell against reference image."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    cell = create_mock_cell(name="VISUAL_TEST")
    item = CellItem(cell)
    item.set_position(10.0, 10.0)
    scene.addItem(item)

    view.show()
    qtbot.waitExposed(view)

    # Capture screenshot
    pixmap = view.grab()
    actual_image = pixmap.toImage()

    # Compare against reference
    reference_image = QImage("tests/visual/references/cell_basic.png")
    diff_percent = compare_images(actual_image, reference_image)

    assert diff_percent < 0.01  # <1% pixel difference
```

### 5.4 Performance Tests

**File**: `tests/performance/test_cell_rendering_performance.py`

```python
@pytest.mark.benchmark
def test_cell_item_creation_performance(benchmark):
    """Benchmark cell item instantiation."""
    cell = create_mock_cell()

    result = benchmark(CellItem, cell)

    # Should create 10,000 items per second
    assert benchmark.stats['ops'] > 10000

@pytest.mark.benchmark
def test_cell_paint_performance(benchmark, qtbot):
    """Benchmark paint method execution."""
    cell = create_mock_cell()
    item = CellItem(cell)

    scene = QGraphicsScene()
    scene.addItem(item)
    view = QGraphicsView(scene)
    qtbot.addWidget(view)
    view.show()

    def repaint():
        scene.update()
        QApplication.processEvents()

    result = benchmark(repaint)

    # Should maintain <16ms for 60fps
    assert benchmark.stats['mean'] < 0.016
```

---

## 6. Risks and Considerations

### Risk 1: Qt Graphics Framework Learning Curve

**Impact**: Medium
**Probability**: Medium

**Concern**: Team may be unfamiliar with QGraphicsItem API, paint methods, and coordinate systems.

**Mitigation**:
- Provide code examples (see this pre-docs)
- Reference Qt documentation: https://doc.qt.io/qt-6/qgraphicsitem.html
- Start with simple implementation, iterate based on testing
- Pair programming for initial implementation

### Risk 2: Performance with Many Items

**Impact**: High
**Probability**: Low

**Concern**: Rendering 1000+ cells may degrade performance despite caching.

**Mitigation**:
- Enable `DeviceCoordinateCache` from the start
- Performance tests enforce <16ms frame time
- Profile early with realistic cell counts
- T04 (LOD) will further optimize by reducing detail at low zoom
- Qt's BSP tree scene indexing handles culling automatically

### Risk 3: Text Rendering at Extreme Zooms

**Impact**: Low
**Probability**: Medium

**Concern**: Cell names may become unreadable at very low zoom or too large at high zoom.

**Mitigation**:
- T04 will implement LOD to hide text at <25% zoom
- Font size can be adjusted based on user feedback
- Consider eliding long cell names with ellipsis (...)
- `ItemIgnoresTransformations` flag can fix text size (deferred to T04)

### Risk 4: Color Accessibility

**Impact**: Low
**Probability**: Low

**Concern**: Sequential cell color distinction may not be accessible to colorblind users.

**Mitigation**:
- Primary distinction is border thickness (3px vs 2px), not just color
- Future: T05 adds clock icon for additional visual cue
- Future P1: User-configurable color themes
- Conduct accessibility review during manual testing

### Risk 5: Domain Entity Coupling

**Impact**: Medium
**Probability**: Low

**Concern**: `CellItem` may become tightly coupled to domain `Cell` structure, making changes difficult.

**Mitigation**:
- Minimize domain entity queries (only name, is_sequential)
- Keep domain entity as read-only reference
- If domain model changes, only `CellItem.__init__` and `paint()` affected
- Unit tests use mock cells to detect coupling issues

---

## 7. Open Questions

### Q1: Should cell dimensions be configurable or fixed?

**Current Approach**: Fixed at 120x80 pixels (class constants)

**Future Consideration**: T03 (Symbol Layout Calculator) may need to adjust height based on pin count. Should dimensions be:
- Option A: Fixed (current)
- Option B: Passed to constructor
- Option C: Calculated dynamically in `boundingRect()`

**Decision Needed By**: Before implementing T03
**Recommendation**: Start with fixed, adjust in T03 if needed

### Q2: How should very long cell names be handled?

**Options**:
- Option A: Elide with ellipsis ("VERY_LO...")
- Option B: Reduce font size dynamically
- Option C: Wrap text to multiple lines
- Option D: Clip text at boundaries

**Recommendation**: Option A (elide) for MVP
**Implementation**: Use `QFontMetrics.elidedText()` in paint method

### Q3: Should cell items be draggable in MVP?

**Current Approach**: No drag support (layout is automatic)

**Consideration**: Future manual layout override may need drag support.

**Decision**: Defer drag support to E04 (Interaction) or P1 feature
**Rationale**: Automatic layout is MVP requirement, manual override is not

### Q4: How to handle cell selection in multi-select scenarios?

**Current Approach**: Standard Qt selection (Ctrl+Click for multi-select)

**Question**: Should multi-selected cells have different visual appearance?

**Recommendation**: Use Qt's default multi-select behavior for MVP
**Future**: E04 may add custom selection highlighting

---

## 8. Implementation Checklist

**Preparation:**
- [ ] Verify E01-F01 (Cell domain entity) is complete
- [ ] Verify E01-F03 (Latch detection) provides `is_sequential` flag
- [ ] Set up PySide6 development environment
- [ ] Review Qt Graphics View Framework documentation

**Core Implementation:**
- [ ] Create `src/ink/presentation/canvas/cell_item.py`
- [ ] Implement `CellItem.__init__()` with domain entity reference
- [ ] Implement `boundingRect()` with border padding
- [ ] Implement `paint()` with basic rectangle rendering
- [ ] Add cell name text rendering (centered)
- [ ] Implement sequential cell styling (thicker border, different fill)
- [ ] Add `set_position()` convenience method
- [ ] Add `get_cell()` accessor
- [ ] Configure item flags (selectable, caching)

**Testing:**
- [ ] Write unit tests for bounding rect calculation
- [ ] Write unit tests for position setting
- [ ] Write unit tests for domain entity access
- [ ] Write integration test for scene rendering
- [ ] Write performance test for 1000 cells
- [ ] Create visual regression baseline images
- [ ] Manual testing: verify selection and hover states

**Documentation:**
- [ ] Add docstrings to all public methods
- [ ] Document coordinate system convention
- [ ] Add usage examples in module docstring
- [ ] Update architecture documentation with CellItem integration

**Code Review:**
- [ ] Verify architectural layer separation (no domain modification)
- [ ] Check performance characteristics (profiling results)
- [ ] Review code style (PEP 8, type hints)
- [ ] Verify test coverage (>90%)

---

## 9. Success Criteria

This task is complete when:

**Functional:**
- [ ] `CellItem` class renders cells as rounded rectangles
- [ ] Cell name displayed centered within symbol
- [ ] Sequential cells have distinct visual styling (thicker border)
- [ ] Selection state shows blue border
- [ ] Hover state shows darker border
- [ ] Position can be set via `set_position()`

**Performance:**
- [ ] Render 1000 cells at 60fps (<16ms frame time)
- [ ] Cell item creation <0.1ms per item
- [ ] Memory usage <1KB per cell item

**Quality:**
- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] Visual regression tests passing
- [ ] Code coverage >90%
- [ ] No architectural violations (layer separation maintained)

**Documentation:**
- [ ] All public APIs documented
- [ ] Usage examples provided
- [ ] Coordinate system documented

---

## 10. References

**Qt Documentation:**
- QGraphicsItem: https://doc.qt.io/qt-6/qgraphicsitem.html
- QGraphicsScene: https://doc.qt.io/qt-6/qgraphicsscene.html
- Graphics View Framework: https://doc.qt.io/qt-6/graphicsview.html
- QPainter: https://doc.qt.io/qt-6/qpainter.html

**Project Documentation:**
- CLAUDE.md: Architecture and layer rules
- E02.pre-docs.md: Overall rendering epic design
- E01-F01.spec.md: Cell domain entity specification

**Code Examples:**
- Qt Circuit Example: Built-in Qt demo showing QGraphicsItem usage
- EDA tool references: KiCad, gSchem

---

**Document Status**: Ready for Implementation
**Estimated Implementation Time**: 8 hours
**Next Steps**: Begin implementation after E01-F01 completion, coordinate with T02 implementer on parent-child relationship
