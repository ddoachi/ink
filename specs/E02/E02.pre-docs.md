# E02 - Schematic Rendering: Pre-Implementation Planning

## Document Information
- **Epic ID**: E02
- **Epic**: Schematic Rendering
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Epic Summary

E02 implements the visual rendering subsystem for Ink's incremental schematic viewer. This epic transforms the graph-based circuit model (from E01) into interactive visual schematics with automatic layout, orthogonal net routing, and adaptive level-of-detail rendering.

**Core Deliverables:**
- Cell symbol rendering with pin visualization
- Sugiyama hierarchical layout algorithm for automatic positioning
- Orthogonal (right-angle) net routing with minimal crossings
- Zoom-based level of detail (LOD) system for performance
- Pan/zoom navigation controls

**Success Metrics:**
- Render 1000+ cells without UI lag (<16ms frame time)
- Achieve 60fps during pan/zoom operations
- Maintain <5% visible net crossings after layout
- Support zoom range from 10% to 500%

### 1.2 Context and Dependencies

**Upstream Dependencies:**
- E01 Data Model: Provides `Cell`, `Pin`, `Port`, `Net` domain models and graph structure via NetworkX

**Downstream Consumers:**
- E03 Expansion: Relies on rendering pipeline to visualize newly expanded subgraphs
- E04 Interaction: Requires rendered graphics items for selection and manipulation

**External Dependencies:**
- PySide6 (Qt6): Graphics View Framework (`QGraphicsScene`, `QGraphicsView`)
- NetworkX: Graph traversal for layout algorithm
- Optional: grandalf library for Sugiyama implementation

---

## 2. Architecture Decisions

### 2.1 Rendering Architecture: Qt Graphics Framework

**Decision**: Use PySide6's `QGraphicsScene` / `QGraphicsView` architecture rather than custom OpenGL or canvas-based rendering.

**Rationale:**
- Built-in scene graph management and object picking
- Native pan/zoom support via view transformations
- Hardware-accelerated rendering through Qt's raster engine
- Well-established LOD patterns via `QGraphicsItem.itemChange()`
- Reduced implementation complexity for MVP

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| Qt Graphics View | Built-in scene management, object picking | Performance ceiling for 10k+ objects | **Selected** - Sufficient for MVP |
| Custom OpenGL | Maximum performance, full control | Complex state management, longer dev time | Rejected - Premature optimization |
| Web Canvas (Qt WebEngine) | Cross-platform HTML5 | Embedding overhead, IPC complexity | Rejected - Unnecessary layer |

### 2.2 Layout Algorithm: Sugiyama Hierarchical Layout

**Decision**: Implement Sugiyama algorithm using grandalf library for MVP, with custom NetworkX implementation as fallback.

**Rationale:**
- Sugiyama produces clear left-to-right signal flow (inputs → outputs)
- Hierarchical layer assignment matches circuit logic depth semantics
- Proven algorithm with existing implementations
- grandalf provides production-ready Python implementation

**Key Algorithm Phases:**

```
1. Cycle Removal:    Handle feedback paths (rare in gate-level netlists)
2. Layer Assignment: BFS-based topological ordering by logic depth
3. Crossing Reduction: Median heuristic for layer reordering
4. Coordinate Assignment: Priority layout with minimum separation
5. Edge Routing:     Channel-based orthogonal routing
```

**Alternatives Considered:**

| Algorithm | Pros | Cons | Verdict |
|-----------|------|------|---------|
| Sugiyama | Clear hierarchy, left-right flow | O(n²) crossing reduction | **Selected** |
| Force-directed | Organic appearance, simple | No clear signal flow, oscillation | Rejected |
| Dot (Graphviz) | Industry standard | External process dependency | Deferred - P1 option |

### 2.3 Net Routing: Simplified Orthogonal Routing

**Decision**: Implement simplified channel routing with A* pathfinding for MVP, deferring advanced techniques.

**MVP Approach:**
- Assign vertical routing channels between cell layers
- Route each net independently using A* with Manhattan distance heuristic
- Mark junction points for multi-fanout nets
- Accept moderate crossing count (<5%) for MVP

**Deferred to P1:**
- Bus routing optimization (parallel nets)
- Global routing with rip-up and reroute
- Congestion-aware channel assignment

**Rationale:**
- Simplified approach reduces implementation risk
- Gate-level netlists have lower fanout complexity than RTL
- Users can tolerate some crossings if signal flow is clear
- Performance-critical path is layout, not routing

### 2.4 Level of Detail: Zoom-Based LOD

**Decision**: Implement three LOD levels with hard thresholds based on view scale factor.

**LOD Levels:**

| Zoom Range | Cell Rendering | Pin Rendering | Net Rendering |
|------------|----------------|---------------|---------------|
| <25% | Solid box (bounding rect) | Hidden | Single line (no junctions) |
| 25-75% | Box + cell name | Small circles | Full with junctions |
| >75% | Full symbol + name | Names + direction arrows | Full with labels |

**Implementation Strategy:**
- Override `QGraphicsItem.paint()` to check current view scale
- Swap rendering primitives based on thresholds
- Cache expensive text layout objects (QStaticText)
- Use `QGraphicsItem::ItemIgnoresTransformations` for labels at high zoom

**Alternatives Considered:**
- Continuous LOD with gradual transitions (rejected - complex interpolation logic)
- Distance-based LOD from camera (rejected - zoom is more predictable)
- Item-level caching with QPixmapCache (deferred - premature optimization)

### 2.5 Coordinate System and Scaling

**Decision**: Use schematic-space coordinates internally, apply view transform for screen rendering.

**Coordinate Convention:**
- Origin (0,0) at top-left of schematic bounds
- X-axis increases rightward (signal flow direction)
- Y-axis increases downward (standard Qt convention)
- One unit = one grid spacing (e.g., 10 schematic units = 1mm at 1:1 zoom)

**Grid System:**
- Base grid: 10 units (cell alignment)
- Pin grid: 5 units (finer granularity for pins)
- Routing grid: 1 unit (finest granularity for net paths)

**Rationale:**
- Separating schematic and view coordinates simplifies layout logic
- Grid alignment produces cleaner visual appearance
- Standard Qt coordinate system reduces mental overhead

---

## 3. Implementation Strategy

### 3.1 Phased Approach

**Phase 1: Foundational Rendering (E02-F01)**
- Implement basic `CellSymbol` and `PinGraphic` classes
- Render cells as simple rectangles with labels
- Display pins as small circles on cell boundaries
- No layout - use manual test positions
- **Milestone**: Display 10 cells with pins in fixed positions

**Phase 2: Layout Engine (E02-F02)**
- Integrate grandalf for Sugiyama layout
- Implement graph → layout coordinate mapping
- Add layer assignment and crossing reduction
- Calculate cell positions automatically
- **Milestone**: Auto-layout 100+ cells with readable signal flow

**Phase 3: Net Routing (E02-F03)**
- Implement channel-based routing strategy
- Add A* pathfinding for individual nets
- Render orthogonal polylines with junction dots
- Handle multi-fanout nets
- **Milestone**: Route 200+ nets with <10% crossings

**Phase 4: Level of Detail (E02-F04)**
- Implement zoom threshold detection in paint methods
- Add simplified rendering for low zoom levels
- Cache expensive graphics objects (text, paths)
- Optimize scene culling
- **Milestone**: Smooth rendering at all zoom levels 10%-500%

**Phase 5: Pan/Zoom Controls (E02-F05)**
- Implement mouse wheel zoom centered on cursor
- Add click-drag panning
- Implement fit-to-view command
- Add zoom percentage indicator
- **Milestone**: Responsive navigation with <16ms frame time

### 3.2 Module Structure

```
src/ink/
├── ui/
│   └── canvas/
│       ├── __init__.py
│       ├── schematic_scene.py      # QGraphicsScene subclass
│       ├── schematic_view.py       # QGraphicsView with pan/zoom
│       ├── items/
│       │   ├── __init__.py
│       │   ├── cell_item.py        # QGraphicsItem for cells
│       │   ├── pin_item.py         # QGraphicsItem for pins
│       │   └── net_item.py         # QGraphicsItem for nets
│       └── rendering/
│           ├── __init__.py
│           ├── lod.py              # Level of detail utilities
│           └── styles.py           # Visual styling constants
└── core/
    ├── layout/
    │   ├── __init__.py
    │   ├── sugiyama.py             # Sugiyama layout wrapper
    │   ├── layer_assignment.py     # Topological layer assignment
    │   └── coordinate_assignment.py # Final position calculation
    └── routing/
        ├── __init__.py
        ├── router.py               # Main routing coordinator
        ├── channel.py              # Channel-based routing
        └── pathfinding.py          # A* for individual nets
```

### 3.3 Key Interfaces

**Layout Engine Interface:**

```python
class LayoutEngine(Protocol):
    def compute_layout(
        self,
        graph: nx.DiGraph,
        config: LayoutConfig
    ) -> Dict[str, Position]:
        """
        Compute positions for all nodes in graph.

        Args:
            graph: NetworkX graph with Cell/Port nodes
            config: Layout configuration (spacing, direction, etc.)

        Returns:
            Mapping from node ID to (x, y) position
        """
        ...
```

**Router Interface:**

```python
class NetRouter(Protocol):
    def route_nets(
        self,
        graph: nx.DiGraph,
        positions: Dict[str, Position],
        config: RoutingConfig
    ) -> Dict[str, List[Point]]:
        """
        Compute routing paths for all nets.

        Args:
            graph: NetworkX graph with net edges
            positions: Cell/port positions from layout
            config: Routing configuration

        Returns:
            Mapping from net name to polyline points
        """
        ...
```

**Graphics Item Interface:**

```python
class CellItem(QGraphicsItem):
    def __init__(self, cell: Cell, position: Position):
        """Create graphics item for a cell."""
        ...

    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget):
        """Render cell with LOD awareness."""
        scale = option.levelOfDetailFromTransform(painter.worldTransform())
        if scale < 0.25:
            self._paint_simple_box(painter)
        elif scale < 0.75:
            self._paint_box_with_name(painter)
        else:
            self._paint_full_detail(painter)
```

---

## 4. Technical Deep Dive

### 4.1 Sugiyama Layout Implementation

**Layer Assignment Algorithm:**

```python
def assign_layers(graph: nx.DiGraph) -> Dict[str, int]:
    """
    Assign cells to horizontal layers via topological sort.

    Layer 0: Primary inputs (ports with no fanin)
    Layer N: Longest path from any primary input
    """
    layers = {}

    # Topological sort with depth tracking
    for node in nx.topological_sort(graph):
        if graph.in_degree(node) == 0:
            layers[node] = 0  # Primary input
        else:
            max_pred_layer = max(layers[pred] for pred in graph.predecessors(node))
            layers[node] = max_pred_layer + 1

    return layers
```

**Crossing Reduction (Median Heuristic):**

```python
def reduce_crossings(layers: List[List[str]], graph: nx.DiGraph, iterations: int = 10):
    """
    Reorder nodes within each layer to minimize edge crossings.
    Uses median heuristic with bidirectional sweeps.
    """
    for _ in range(iterations):
        # Forward sweep: order by median of predecessors
        for i in range(1, len(layers)):
            layers[i] = _order_by_median(layers[i], graph, direction='in')

        # Backward sweep: order by median of successors
        for i in range(len(layers) - 2, -1, -1):
            layers[i] = _order_by_median(layers[i], graph, direction='out')
```

**Coordinate Assignment:**

```python
def assign_coordinates(
    layers: Dict[str, int],
    layer_spacing: float = 200.0,
    node_spacing: float = 100.0
) -> Dict[str, Position]:
    """
    Convert layer assignments to (x, y) coordinates.

    X: layer * layer_spacing
    Y: node_index_in_layer * node_spacing (centered vertically)
    """
    positions = {}
    nodes_per_layer = defaultdict(list)

    for node, layer in layers.items():
        nodes_per_layer[layer].append(node)

    for layer, nodes in nodes_per_layer.items():
        x = layer * layer_spacing
        total_height = len(nodes) * node_spacing
        y_offset = -total_height / 2  # Center vertically

        for i, node in enumerate(nodes):
            y = y_offset + i * node_spacing
            positions[node] = Position(x, y)

    return positions
```

### 4.2 Orthogonal Net Routing

**Channel Routing Strategy:**

```
Layer 0    Channel 0    Layer 1    Channel 1    Layer 2
  |            |           |            |           |
  [ Cell A ]   |||||||    [ Cell B ]   |||||||    [ Cell C ]
  |            |||||||     |            |||||||     |
                ^^^
            Routing channels for vertical wire segments
```

**A* Pathfinding for Individual Net:**

```python
def route_net_astar(
    start_pin: Point,
    end_pins: List[Point],
    obstacles: Set[Point],
    grid: RoutingGrid
) -> List[Point]:
    """
    Route net from start_pin to all end_pins using A*.

    Manhattan distance heuristic with orthogonal constraint:
    - Each step moves one grid unit in cardinal direction
    - Obstacle avoidance via closed set
    - Minimize total wire length + bend penalty
    """
    def heuristic(point: Point, target: Point) -> float:
        return abs(point.x - target.x) + abs(point.y - target.y)

    def get_neighbors(point: Point) -> List[Point]:
        return [
            Point(point.x + grid.spacing, point.y),  # Right
            Point(point.x - grid.spacing, point.y),  # Left
            Point(point.x, point.y + grid.spacing),  # Down
            Point(point.x, point.y - grid.spacing),  # Up
        ]

    # Standard A* implementation with orthogonal constraint
    # Returns list of waypoints forming orthogonal polyline
    ...
```

**Junction Detection:**

```python
def add_junction_dots(net_paths: List[List[Point]]) -> List[Point]:
    """
    Detect junction points where net branches.

    Junction occurs when:
    - 3+ path segments share a common point
    - Point is not a pin connection point
    """
    point_usage = Counter()
    for path in net_paths:
        for point in path:
            point_usage[point] += 1

    junctions = [pt for pt, count in point_usage.items() if count >= 3]
    return junctions
```

### 4.3 Level of Detail Rendering

**Scale Detection:**

```python
class CellItem(QGraphicsItem):
    def paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget):
        # Get current view scale from transform
        scale = option.levelOfDetailFromTransform(painter.worldTransform())

        # Three LOD levels
        if scale < 0.25:
            self._paint_lod_low(painter)
        elif scale < 0.75:
            self._paint_lod_medium(painter)
        else:
            self._paint_lod_high(painter)
```

**LOD Rendering Methods:**

```python
def _paint_lod_low(self, painter: QPainter):
    """Minimal rendering: solid box only."""
    painter.fillRect(self.boundingRect(), QBrush(QColor(200, 200, 200)))

def _paint_lod_medium(self, painter: QPainter):
    """Medium rendering: box + cell name."""
    painter.fillRect(self.boundingRect(), QBrush(QColor(220, 220, 220)))
    painter.drawRect(self.boundingRect())

    # Draw cell name (cached for performance)
    if not self._cached_name_text:
        self._cached_name_text = QStaticText(self.cell.name)
    painter.drawStaticText(QPointF(5, 5), self._cached_name_text)

def _paint_lod_high(self, painter: QPainter):
    """Full rendering: detailed symbol + pins."""
    # Draw cell box with border
    painter.fillRect(self.boundingRect(), QBrush(QColor(240, 240, 240)))
    painter.setPen(QPen(QColor(0, 0, 0), 2))
    painter.drawRect(self.boundingRect())

    # Draw cell name
    painter.drawStaticText(QPointF(5, 5), self._cached_name_text)

    # Draw all pins with names and direction arrows
    for pin_item in self.pin_items:
        pin_item.paint(painter, ...)
```

### 4.4 Pan and Zoom Controls

**Mouse Wheel Zoom:**

```python
class SchematicView(QGraphicsView):
    def wheelEvent(self, event: QWheelEvent):
        """Zoom centered on cursor position."""
        # Zoom factor per wheel step
        zoom_factor = 1.15 if event.angleDelta().y() > 0 else 1 / 1.15

        # Clamp to allowed range [0.1, 5.0]
        new_scale = self.transform().m11() * zoom_factor
        if 0.1 <= new_scale <= 5.0:
            # Zoom centered on mouse cursor
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
            self.scale(zoom_factor, zoom_factor)

            # Trigger LOD updates
            self.scene().update()
```

**Click-Drag Panning:**

```python
class SchematicView(QGraphicsView):
    def __init__(self):
        super().__init__()
        self.setDragMode(QGraphicsView.ScrollHandDrag)
        # Qt handles panning automatically with ScrollHandDrag mode
```

**Fit to View:**

```python
def fit_to_view(self):
    """Scale view to show all scene contents."""
    self.fitInView(self.scene().itemsBoundingRect(), Qt.KeepAspectRatio)
```

### 4.5 Performance Optimizations

**Scene Culling:**
- Qt automatically culls items outside viewport via BSP tree indexing
- For large scenes (>5k items), consider explicit `QGraphicsItem.setFlag(ItemHasNoContents)` for container items

**Cached Rendering:**
```python
class CellItem(QGraphicsItem):
    def __init__(self, cell: Cell):
        super().__init__()
        self.setFlag(QGraphicsItem.ItemUsesExtendedStyleOption)  # Enable LOD
        self.setCacheMode(QGraphicsItem.DeviceCoordinateCache)  # Cache at screen resolution
```

**Static Text Caching:**
```python
# Use QStaticText for frequently redrawn labels
self._name_text = QStaticText(self.cell.name)
self._name_text.prepare()  # Pre-layout text
```

**Deferred Updates:**
```python
# Batch scene updates during expansion
scene.setUpdatesEnabled(False)
# ... add many items ...
scene.setUpdatesEnabled(True)
scene.update()
```

---

## 5. Risk Analysis

### 5.1 Performance Risks

**Risk R01: Layout performance degradation with large graphs (>1000 cells)**

- **Impact**: High - Directly affects user experience
- **Probability**: High - Sugiyama is O(n²) in crossing reduction phase
- **Symptoms**: Multi-second layout computation, UI freezing
- **Mitigation**:
  - Implement incremental layout (only re-layout affected subgraph)
  - Profile and optimize hot paths (crossing reduction iterations)
  - Add progress indicator for layouts >500ms
  - Fallback to simpler layout algorithm for very large graphs
  - Consider running layout in background thread with cancellation

**Risk R02: Qt rendering bottleneck at high item count (>5000 items)**

- **Impact**: Medium - Affects zoomed-out views and large expansions
- **Probability**: Medium - Qt Graphics View has known scalability limits
- **Symptoms**: Slow panning, janky zoom, high CPU during repaints
- **Mitigation**:
  - Aggressive LOD with item hiding at low zoom
  - Enable device coordinate caching for static items
  - Use `QGraphicsItemGroup` to reduce item count
  - Profile with Qt's built-in performance tools
  - Deferred optimization: OpenGL scene rendering (QPainter → QOpenGLWidget)

### 5.2 Algorithm Risks

**Risk R03: Routing produces excessive crossings or long wire lengths**

- **Impact**: Medium - Reduces schematic readability
- **Probability**: Medium - Simplified routing may not handle complex topologies
- **Symptoms**: >10% net crossings, spaghetti routing, overlapping wires
- **Mitigation**:
  - Tune A* cost function (wire length vs. bend penalty)
  - Implement simple crossing avoidance (track used routing channels)
  - Manual routing override for critical nets (P1 feature)
  - Accept some crossings with visual disambiguation (arc jumps)

**Risk R04: Sugiyama fails on cyclic graphs (feedback paths)**

- **Impact**: Low - Gate-level netlists rarely have combinational cycles
- **Probability**: Low - Most cycles involve sequential elements (latches)
- **Symptoms**: Layout algorithm crashes or produces degenerate layout
- **Mitigation**:
  - Detect cycles via NetworkX and reverse feedback edges
  - Mark reversed edges visually (dashed line with arrowhead)
  - Log warning when cycles detected
  - Future: Break cycles at latch boundaries

### 5.3 Integration Risks

**Risk R05: Coordinate mismatch between layout and rendering**

- **Impact**: High - Produces incorrect visuals
- **Probability**: Low - Well-defined coordinate system reduces risk
- **Symptoms**: Nets not connecting to pins, misaligned cells
- **Mitigation**:
  - Unit tests for coordinate transformations
  - Visual regression tests with known-good reference images
  - Debug overlay showing layout grid and pin connection points

**Risk R06: LOD transitions cause visual artifacts**

- **Impact**: Low - Aesthetic issue, doesn't block functionality
- **Probability**: Medium - Hard thresholds can cause "popping"
- **Symptoms**: Items suddenly appearing/disappearing during zoom
- **Mitigation**:
  - Smooth threshold ranges (e.g., fade opacity near boundaries)
  - Tune thresholds via user testing
  - Accept crisp transitions for MVP, enhance in P1

### 5.4 External Dependency Risks

**Risk R07: grandalf library lacks features or has bugs**

- **Impact**: Medium - Delays layout implementation
- **Probability**: Low - Mature library, widely used
- **Symptoms**: Incorrect layouts, crashes on certain graph structures
- **Mitigation**:
  - Prototype with grandalf early (Phase 2, Week 1)
  - Maintain custom NetworkX fallback implementation
  - Contribute fixes upstream if needed
  - Alternative: Use pygraphviz with Dot algorithm

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Layout Engine Tests:**
```python
# tests/core/layout/test_layer_assignment.py
def test_layer_assignment_simple_chain():
    """Test layer assignment on linear chain A → B → C."""
    graph = nx.DiGraph([("A", "B"), ("B", "C")])
    layers = assign_layers(graph)
    assert layers == {"A": 0, "B": 1, "C": 2}

def test_layer_assignment_fanout():
    """Test layer assignment with fanout A → B, A → C."""
    graph = nx.DiGraph([("A", "B"), ("A", "C")])
    layers = assign_layers(graph)
    assert layers["A"] == 0
    assert layers["B"] == layers["C"] == 1

def test_crossing_reduction():
    """Test crossing reduction reduces crossings."""
    # Create graph with known crossing count
    initial_crossings = count_crossings(layers)
    reduce_crossings(layers, graph, iterations=5)
    final_crossings = count_crossings(layers)
    assert final_crossings <= initial_crossings
```

**Routing Tests:**
```python
# tests/core/routing/test_pathfinding.py
def test_astar_simple_path():
    """Test A* finds simple orthogonal path."""
    start = Point(0, 0)
    end = Point(100, 100)
    path = route_net_astar(start, [end], obstacles=set(), grid=RoutingGrid(10))

    # Verify orthogonality
    for i in range(len(path) - 1):
        p1, p2 = path[i], path[i+1]
        assert p1.x == p2.x or p1.y == p2.y  # Horizontal or vertical

    # Verify endpoints
    assert path[0] == start
    assert path[-1] == end

def test_astar_obstacle_avoidance():
    """Test A* routes around obstacles."""
    start = Point(0, 0)
    end = Point(100, 0)
    obstacles = {Point(50, 0)}  # Block direct path
    path = route_net_astar(start, [end], obstacles, RoutingGrid(10))

    # Verify path avoids obstacle
    assert Point(50, 0) not in path
```

**Rendering Tests:**
```python
# tests/ui/canvas/test_lod.py
def test_lod_switching():
    """Test LOD switches at correct thresholds."""
    cell_item = CellItem(cell=mock_cell)

    # Mock painter with different scales
    for scale, expected_lod in [(0.2, LOD.LOW), (0.5, LOD.MEDIUM), (1.0, LOD.HIGH)]:
        option = QStyleOptionGraphicsItem()
        option.levelOfDetailFromTransform = lambda t: scale

        with patch.object(cell_item, '_paint_lod_low') as low, \
             patch.object(cell_item, '_paint_lod_medium') as med, \
             patch.object(cell_item, '_paint_lod_high') as high:

            cell_item.paint(mock_painter, option, None)

            if expected_lod == LOD.LOW:
                low.assert_called_once()
            elif expected_lod == LOD.MEDIUM:
                med.assert_called_once()
            else:
                high.assert_called_once()
```

### 6.2 Integration Tests

**End-to-End Rendering Pipeline:**
```python
# tests/integration/test_rendering_pipeline.py
def test_render_simple_netlist(qtbot):
    """Test full pipeline: graph → layout → render."""
    # Load sample netlist
    graph = parse_netlist("examples/simple_and.ckt")

    # Compute layout
    layout_engine = SugiyamaLayout()
    positions = layout_engine.compute_layout(graph, LayoutConfig())

    # Route nets
    router = OrthogonalRouter()
    paths = router.route_nets(graph, positions, RoutingConfig())

    # Create scene and view
    scene = SchematicScene()
    view = SchematicView(scene)

    # Populate scene with items
    for node, pos in positions.items():
        cell = graph.nodes[node]['cell']
        item = CellItem(cell, pos)
        scene.addItem(item)

    for net_name, path in paths.items():
        item = NetItem(net_name, path)
        scene.addItem(item)

    # Show view and verify rendering
    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    # Check item count
    assert len(scene.items()) > 0

    # Check view is not empty
    assert not view.sceneRect().isEmpty()
```

### 6.3 Performance Tests

**Layout Scalability:**
```python
# tests/performance/test_layout_performance.py
@pytest.mark.benchmark
def test_layout_1000_cells(benchmark):
    """Benchmark layout computation for 1000 cells."""
    graph = generate_random_dag(num_nodes=1000, avg_degree=3)
    layout_engine = SugiyamaLayout()

    result = benchmark(layout_engine.compute_layout, graph, LayoutConfig())

    # Assert completes within 500ms
    assert benchmark.stats['mean'] < 0.5

@pytest.mark.benchmark
def test_routing_1000_nets(benchmark):
    """Benchmark routing for 1000 nets."""
    graph = generate_random_dag(num_nodes=500, avg_degree=4)
    positions = compute_mock_positions(graph)
    router = OrthogonalRouter()

    result = benchmark(router.route_nets, graph, positions, RoutingConfig())

    # Assert completes within 1 second
    assert benchmark.stats['mean'] < 1.0
```

**Rendering Performance:**
```python
@pytest.mark.benchmark
def test_paint_performance(benchmark, qtbot):
    """Benchmark paint performance for 1000 items."""
    scene = SchematicScene()
    for i in range(1000):
        cell = create_mock_cell(f"cell_{i}")
        item = CellItem(cell, Position(i * 100, 0))
        scene.addItem(item)

    view = SchematicView(scene)
    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    # Benchmark full scene repaint
    def repaint():
        scene.update()
        QApplication.processEvents()

    result = benchmark(repaint)

    # Assert <16ms for 60fps
    assert benchmark.stats['mean'] < 0.016
```

### 6.4 Visual Regression Tests

**Screenshot Comparison:**
```python
# tests/visual/test_rendering_regression.py
def test_visual_regression_simple_and(qtbot):
    """Compare rendering against reference screenshot."""
    scene, view = render_netlist("examples/simple_and.ckt")
    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    # Capture screenshot
    pixmap = view.grab()
    actual_image = pixmap.toImage()

    # Load reference image
    reference_image = QImage("tests/visual/references/simple_and.png")

    # Compare images (allow 1% pixel difference for anti-aliasing)
    diff_percent = compare_images(actual_image, reference_image)
    assert diff_percent < 0.01
```

### 6.5 Test Data

**Sample Netlists:**
- `examples/simple_and.ckt`: 2-input AND gate (minimal test case)
- `examples/adder_4bit.ckt`: 4-bit ripple-carry adder (~50 cells)
- `examples/counter_8bit.ckt`: 8-bit counter with latches (~200 cells)
- `examples/alu.ckt`: Simple ALU (~500 cells, multiple fanout)
- `examples/large_random.ckt`: Randomly generated 1000-cell netlist (stress test)

**Expected Layouts:**
- Reference screenshots for each example
- JSON files with expected layer assignments
- JSON files with expected crossing counts

---

## 7. Definition of Done

### 7.1 Epic-Level Completion Criteria

**E02 is complete when ALL of the following are true:**

**Functional Requirements:**
- [ ] Cells render as symbols with name labels and pin positions
- [ ] Input pins consistently appear on left, outputs on right
- [ ] Sequential cells (latches) have distinct visual styling
- [ ] Sugiyama layout produces left-to-right signal flow
- [ ] Cells automatically positioned with minimal edge crossings
- [ ] All nets routed as orthogonal polylines (only horizontal/vertical segments)
- [ ] Multi-fanout nets display junction dots at branch points
- [ ] Three LOD levels implemented with correct zoom thresholds
- [ ] Mouse wheel zooms smoothly centered on cursor
- [ ] Click-drag pans the view
- [ ] Fit-to-view command shows all visible content
- [ ] Zoom range supports 10% to 500%

**Performance Requirements:**
- [ ] Render 1000 cells without frame drops (<16ms frame time)
- [ ] Layout computation completes within 500ms for 1000 cells
- [ ] Routing computation completes within 1s for 1000 nets
- [ ] Pan/zoom operations maintain 60fps
- [ ] LOD transitions occur smoothly without visual artifacts

**Quality Requirements:**
- [ ] Net crossing percentage <5% for typical gate-level netlists
- [ ] All unit tests passing (>90% code coverage for core algorithms)
- [ ] Integration tests passing for sample netlists
- [ ] Performance benchmarks passing
- [ ] Visual regression tests passing
- [ ] No memory leaks during pan/zoom operations (verified with profiler)

**Documentation Requirements:**
- [ ] API documentation for all public classes and methods
- [ ] Architecture diagram showing rendering pipeline
- [ ] Developer guide for adding new symbol types
- [ ] Performance tuning guide

### 7.2 Feature-Level Completion Criteria

**E02-F01: Cell Symbol Rendering**
- [ ] `CellItem` class implemented
- [ ] `PinItem` class implemented
- [ ] Renders cells with bounding boxes
- [ ] Displays cell names
- [ ] Positions pins on cell boundaries
- [ ] Shows pin names and directions
- [ ] Unit tests for rendering primitives

**E02-F02: Sugiyama Layout Engine**
- [ ] Layer assignment algorithm implemented
- [ ] Crossing reduction implemented (median heuristic)
- [ ] Coordinate assignment implemented
- [ ] Integration with grandalf library
- [ ] Fallback to custom NetworkX implementation
- [ ] Unit tests for each layout phase
- [ ] Handles cyclic graphs gracefully

**E02-F03: Orthogonal Net Routing**
- [ ] Channel routing strategy implemented
- [ ] A* pathfinding for individual nets
- [ ] Junction dot detection
- [ ] Renders nets as `QGraphicsPathItem` polylines
- [ ] Unit tests for routing algorithms
- [ ] Visual distinction for net crossings (optional: arc jumps)

**E02-F04: Zoom Level of Detail**
- [ ] LOD threshold detection in `paint()` methods
- [ ] Simplified rendering for low zoom (<25%)
- [ ] Medium rendering (25-75%)
- [ ] Full detail rendering (>75%)
- [ ] Text caching with `QStaticText`
- [ ] Performance tests verify <16ms paint time

**E02-F05: Pan/Zoom Controls**
- [ ] Mouse wheel zoom implemented
- [ ] Zoom range clamped to 10%-500%
- [ ] Click-drag panning enabled
- [ ] Fit-to-view command implemented
- [ ] Zoom percentage displayed in UI
- [ ] Keyboard shortcuts for zoom in/out/fit

### 7.3 Acceptance Testing

**Manual Acceptance Test Procedure:**

1. **Launch Application**
   - Start Ink with `uv run python -m ink`
   - Load `examples/adder_4bit.ckt`

2. **Verify Layout**
   - Schematic displays automatically
   - Signal flow is left-to-right
   - Cells aligned in clear layers
   - Minimal overlapping or crossing nets

3. **Verify Rendering**
   - Cell names are readable
   - Pins visible on cell boundaries
   - Input pins on left, outputs on right
   - Nets connect correctly to pins
   - Junction dots visible where nets branch

4. **Verify Zoom LOD**
   - Zoom out to 10%: cells appear as simple boxes
   - Zoom to 50%: cell names visible
   - Zoom to 100%: full detail with pin names
   - Transitions smooth without flickering

5. **Verify Navigation**
   - Mouse wheel zooms centered on cursor
   - Click-drag pans the view smoothly
   - Fit-to-view command shows all cells

6. **Performance Verification**
   - Load `examples/large_random.ckt` (1000 cells)
   - Layout completes within 1 second
   - Pan and zoom remain responsive
   - No visible lag or stuttering

**Sign-off Required:**
- [ ] Product Owner approves visual quality
- [ ] Tech Lead approves architecture and code quality
- [ ] QA verifies all acceptance criteria on target platform (Linux)

---

## 8. Open Questions and Decisions Needed

### 8.1 Library Selection

**Q1**: Use grandalf vs. custom Sugiyama implementation?

- **Recommendation**: Start with grandalf for MVP, maintain custom implementation as fallback
- **Rationale**: Grandalf is battle-tested and reduces implementation risk
- **Decision Needed By**: End of Phase 1 (before starting Phase 2)
- **Owner**: Tech Lead

**Q2**: Should we support alternative layout algorithms (force-directed, Dot)?

- **Recommendation**: No for MVP, add as P1 feature with user preference
- **Rationale**: Sugiyama is sufficient for gate-level netlists
- **Decision Needed By**: P1 planning

### 8.2 Visual Design

**Q3**: What visual style for sequential cells (latches)?

- **Options**:
  - Option A: Rounded corners
  - Option B: Different fill color (e.g., light blue)
  - Option C: Icon overlay (clock symbol)
- **Recommendation**: Option B (fill color) - simplest to implement
- **Decision Needed By**: Phase 1 (before implementing `CellItem`)
- **Owner**: Product Owner + Designer

**Q4**: How to visually distinguish net crossings?

- **Options**:
  - Option A: Simple overlap (accept ambiguity)
  - Option B: Arc jump at crossings
  - Option C: Small gap in lower-priority net
- **Recommendation**: Option A for MVP, Option B for P1
- **Decision Needed By**: Phase 3 (routing implementation)

### 8.3 Performance Targets

**Q5**: What is the target maximum netlist size for E02?

- **Current Target**: 1000 cells (based on acceptance criteria)
- **Question**: Should we design for 10k cells from the start?
- **Recommendation**: Design for 1k, profile and optimize for 10k in P1
- **Rationale**: Premature optimization risk, most user workflows <1k cells
- **Decision Needed By**: Before Phase 2

### 8.4 Integration with Future Features

**Q6**: Should rendering pipeline support incremental updates for expansion (E03)?

- **Recommendation**: Yes - design scene management to support adding/removing items
- **Implementation**: Use `QGraphicsScene.addItem()` / `removeItem()` for dynamic updates
- **Decision Needed By**: Before Phase 1 architecture finalization

**Q7**: Should we implement undo/redo for view state (zoom/pan)?

- **Recommendation**: No for E02, add in E04 (Interaction)
- **Rationale**: E02 focuses on rendering, not user interaction state management
- **Decision Needed By**: E04 planning

---

## 9. Success Metrics and KPIs

### 9.1 Performance KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Layout Time (1000 cells) | <500ms | Benchmark suite |
| Routing Time (1000 nets) | <1s | Benchmark suite |
| Frame Time (pan/zoom) | <16ms | Qt profiler |
| Memory Usage (1000 cells) | <100MB | Memory profiler |
| Net Crossing Rate | <5% | Automated analysis of routing output |

### 9.2 Quality KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Unit Test Coverage | >90% | pytest-cov |
| Integration Test Pass Rate | 100% | CI/CD pipeline |
| Visual Regression Test Pass Rate | 100% | Image comparison |
| Code Review Approval | 2+ approvers | GitHub PR reviews |

### 9.3 User Experience KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Layout Readability Score | >8/10 | User acceptance testing |
| Zoom Smoothness Score | >8/10 | User acceptance testing |
| First-Time User Success | >90% can navigate within 2min | Usability testing |

---

## 10. Timeline Estimate

### 10.1 Development Phases

| Phase | Duration | Dependencies | Deliverables |
|-------|----------|--------------|--------------|
| Phase 1: Foundational Rendering | 1 week | E01 complete | `CellItem`, `PinItem`, basic rendering |
| Phase 2: Layout Engine | 2 weeks | Phase 1 | Sugiyama layout integration |
| Phase 3: Net Routing | 1.5 weeks | Phase 2 | Orthogonal routing |
| Phase 4: Level of Detail | 1 week | Phase 3 | LOD system |
| Phase 5: Pan/Zoom Controls | 0.5 weeks | Phase 4 | Navigation controls |
| **Total Development** | **6 weeks** | | |
| Testing & Polish | 1 week | All phases | Bug fixes, performance tuning |
| **Total E02 Duration** | **7 weeks** | | |

### 10.2 Milestone Schedule

| Milestone | Target Date | Success Criteria |
|-----------|-------------|------------------|
| M1: Render 10 static cells | Week 1 | Cell symbols visible with pins |
| M2: Auto-layout 100 cells | Week 3 | Sugiyama layout working |
| M3: Route 200 nets | Week 4.5 | Orthogonal routing functional |
| M4: LOD implementation | Week 5.5 | Three LOD levels working |
| M5: E02 Complete | Week 7 | All acceptance criteria met |

---

## 11. References and Resources

### 11.1 Technical References

**Graph Layout Algorithms:**
- Sugiyama et al., "Methods for Visual Understanding of Hierarchical System Structures" (1981)
- Gansner et al., "A Technique for Drawing Directed Graphs" (DOT algorithm, 1993)
- grandalf Documentation: https://github.com/bdcht/grandalf

**Routing Algorithms:**
- Hightower, "A Solution to Line-Routing Problems on the Continuous Plane" (1969)
- Mikami-Tabuchi, "A Computer Program for Optimal Routing of Printed Circuit Connectors" (1968)

**Qt Graphics Framework:**
- Qt Graphics View Framework: https://doc.qt.io/qt-6/graphicsview.html
- Qt Performance Tuning: https://doc.qt.io/qt-6/qtquick-performance.html

### 11.2 Code Examples

**Reference Implementations:**
- EDA schematic viewers: KiCad (C++), gSchem (C)
- Graph visualization: yEd (Java), Gephi (Java)
- Qt schematic examples: Qt Circuit Example (built-in Qt demo)

### 11.3 Design Tools

**Prototyping:**
- Figma/Sketch for UI mockups
- Graphviz for layout algorithm prototyping
- Qt Designer for widget layout

### 11.4 Internal Documentation

- `/home/joohan/dev/project-ink/ink/docs/prd.md` - Product Requirements Document
- `/home/joohan/dev/project-ink/ink/specs/E01/E01.spec.md` - Data Model spec (dependency)
- `/home/joohan/dev/project-ink/ink/CLAUDE.md` - Project guidelines

---

## Appendices

### Appendix A: Coordinate System Diagram

```
Schematic Space (logical coordinates)
┌─────────────────────────────────────┐
│ (0, 0)                              │
│   ┌──────┐     ┌──────┐     ┌─────┐│
│   │Cell A│────▶│Cell B│────▶│Port │││  Layer 0   Layer 1   Layer 2
│   └──────┘     └──────┘     └─────┘││
│      ▲            │                 │
│      │            ▼                 │
│   ┌──────┐     ┌──────┐            │
│   │Port 1│     │Cell C│            │
│   └──────┘     └──────┘            │
│                                     │
│                   (x_max, y_max)    │
└─────────────────────────────────────┘
         │
         │ View Transform
         ▼
Screen Space (pixel coordinates)
```

### Appendix B: Rendering Pipeline Flowchart

```
┌─────────────────────────────────────────────────────┐
│ E01 Data Model (NetworkX Graph)                     │
│  - Nodes: Cell, Port                                │
│  - Edges: Net                                       │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ E02-F02: Layout Engine                              │
│  - Sugiyama Algorithm                               │
│  - Output: Dict[node_id, Position]                  │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ E02-F03: Net Router                                 │
│  - Channel Routing + A*                             │
│  - Output: Dict[net_name, List[Point]]              │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ E02-F01: Graphics Item Creation                     │
│  - CellItem(position)                               │
│  - NetItem(path)                                    │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ QGraphicsScene.addItem(...)                         │
│  - Scene Graph Management                           │
│  - BSP Tree Indexing                                │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ E02-F05: SchematicView (QGraphicsView)              │
│  - View Transform (zoom/pan)                        │
│  - Event Handling                                   │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ E02-F04: CellItem.paint() with LOD                  │
│  - Scale detection                                  │
│  - Conditional rendering                            │
└────────────────┬────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────┐
│ Screen Output (QPainter → Display)                  │
└─────────────────────────────────────────────────────┘
```

### Appendix C: Glossary

- **Sugiyama Layout**: Hierarchical graph layout algorithm that produces layered drawings with minimized edge crossings
- **Orthogonal Routing**: Net routing style where all wire segments are horizontal or vertical (Manhattan geometry)
- **Level of Detail (LOD)**: Rendering technique that adjusts detail based on zoom level to improve performance
- **Graphics Scene**: Qt's scene graph container for managing 2D graphics items
- **Graphics View**: Qt's viewport widget for displaying and interacting with a graphics scene
- **Junction Dot**: Visual marker at branch points where a net splits into multiple paths
- **Layer**: In Sugiyama layout, a horizontal or vertical rank of nodes at the same logic depth
- **Crossing Reduction**: Algorithm phase that reorders nodes within layers to minimize edge crossings
- **Channel Routing**: Routing technique that assigns nets to vertical channels between layers of cells

---

**Document Status**: Ready for Implementation
**Next Steps**: Review with team, schedule Phase 1 kickoff, create E02-F01 detailed spec
