# E02-F04-T02 - Cell LOD Rendering: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F04-T02
- **Task**: Cell LOD Rendering
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements multi-level rendering for cell graphics items that adapts detail based on LOD level from the LODManager. Cell rendering complexity is a primary performance bottleneck in large schematics - rendering full cell symbols with text labels for hundreds of visible cells can exceed the 16ms frame budget. By implementing LOD-aware rendering, we can maintain 60fps even with 500+ cells visible.

**Core Deliverables:**
- `CellGraphicsItem` class extending `QGraphicsRectItem`
- Three rendering modes: LOW (bounding box), MEDIUM (box + name), HIGH (full detail)
- LOD level subscription and dynamic rendering updates
- Child item management for pins (visibility control)
- Performance-optimized paint methods
- Qt device coordinate caching for performance

**Success Metrics:**
- 500 cells render at LOW LOD in <5ms (100 fps capable)
- 200 cells render at MEDIUM LOD in <10ms (100 fps capable)
- 50 cells render at HIGH LOD in <10ms (100 fps capable)
- LOD transitions for 200 cells complete in <16ms (60 fps maintained)
- No visual artifacts during LOD transitions

### 1.2 Context and Dependencies

**Upstream Dependencies:**
- Task E02-F04-T01: `LODManager` and `LODLevel` definitions
- E02-F01: Base cell rendering concepts (not yet implemented)
- E02-F02: Layout engine provides cell position and size (not yet implemented)
- Domain model: `Cell` entity with name, position, size

**Downstream Consumers:**
- Task E02-F04-T03: Pin graphics items added as children, visibility controlled by LOD
- E04-F01: Selection highlighting must work at all LOD levels
- E03 Expansion: New cells added with appropriate LOD level

**External Dependencies:**
- PySide6: `QGraphicsRectItem`, `QGraphicsTextItem`, `QPainter`, `QBrush`, `QPen`
- Domain: `ink.domain.model.cell.Cell` entity

---

## 2. Architecture Decisions

### 2.1 Base Class Selection: QGraphicsRectItem

**Decision**: Extend `QGraphicsRectItem` as the base class for `CellGraphicsItem`.

**Rationale:**
- Provides built-in rectangular bounding box rendering (core cell representation)
- Efficient primitive for simple filled rectangles at LOW LOD
- Supports child items naturally (pins attached to cell)
- Qt optimizes `QGraphicsRectItem` rendering path
- Simpler than `QGraphicsItem` (fewer methods to override)

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| QGraphicsRectItem | Built-in rectangle rendering, child support | Limited to rectangular shapes | **Selected** |
| QGraphicsItem | Maximum flexibility | Must implement boundingRect, paint from scratch | Rejected - unnecessary complexity |
| QGraphicsPathItem | Support complex shapes | Overhead for simple rectangles | Rejected - premature generalization |
| QGraphicsPixmapItem | Fast raster rendering | Static, no dynamic LOD | Rejected - doesn't fit use case |

### 2.2 LOD Rendering Strategy: Visibility vs. Conditional Painting

**Decision**: Use child item visibility control for MEDIUM/HIGH LOD, with custom paint override for LOW LOD optimization.

**Hybrid Approach:**
- **LOW LOD**: Override `paint()` to draw simple filled rectangle (fast path)
- **MEDIUM/HIGH LOD**: Use default Qt rendering + child item visibility toggling

**Rationale:**
- Visibility control is simpler than destroying/recreating child items
- Qt efficiently handles invisible items (skips rendering, keeps scene graph)
- Custom paint for LOW LOD avoids Qt text rendering overhead
- Preserves state (selection, hover) across LOD transitions

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| Visibility control | Simple, preserves state | All items always in scene graph | **Selected** for children |
| Destroy/recreate | Minimal memory | Complex state management | Rejected |
| Conditional paint() | Full control | Complex paint logic | **Selected** for LOW LOD only |
| Multiple QGraphicsItemGroups | Clean separation | Memory overhead | Rejected |

### 2.3 Visual Distinction per LOD Level: Color Coding

**Decision**: Use different background colors for each LOD level in MVP for visual debugging, make configurable in P1.

**Color Scheme:**
- LOW: Gray (180, 180, 180) - Minimal visual detail
- MEDIUM: Light blue (200, 220, 240) - Overview mode
- HIGH: Lighter blue (220, 240, 255) - Full detail mode

**Rationale:**
- MVP: Visual confirmation that LOD system is working
- Debugging: Quickly identify which LOD level is active
- P1: Remove color differences or make configurable via theme
- Minimal implementation cost (simple brush assignment)

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| Different colors | Easy debugging | Not production-ready | **Selected** for MVP |
| Same color all LODs | Production-ready | Harder to debug LOD issues | Deferred to P1 |
| User-configurable theme | Maximum flexibility | Implementation complexity | Deferred to P1 |

### 2.4 Child Item Management: Pin Visibility

**Decision**: Pins are added as child items via `add_pin_item()`, visibility controlled by LOD level.

**Pin Visibility Rules:**
- LOW LOD: All pins hidden
- MEDIUM LOD: All pins hidden (too cluttered)
- HIGH LOD: All pins visible

**Justification:**
- Pins consume significant rendering time (text labels, direction arrows)
- At LOW/MEDIUM zoom, pins are too small to see clearly anyway
- Hiding pins provides major performance improvement
- T03 will implement pin LOD (small dots at MEDIUM)

**Implementation Pattern:**
```python
def set_lod_level(self, lod_level: LODLevel):
    if lod_level == LODLevel.HIGH:
        for pin in self._pin_items:
            pin.setVisible(True)
    else:
        for pin in self._pin_items:
            pin.setVisible(False)
```

### 2.5 Performance Optimization: Device Coordinate Caching

**Decision**: Enable `DeviceCoordinateCache` on cell items for faster redraws during panning.

**Qt Cache Mode:**
```python
self.setCacheMode(QGraphicsItem.DeviceCoordinateCache)
```

**Rationale:**
- Caches rendered item in screen pixel coordinates
- Significantly faster redraws when panning (no re-rendering)
- Trade-off: Cache invalidated on zoom (but LOD change triggers redraw anyway)
- Qt recommendation for static items that pan frequently

**Cache Invalidation:**
- Zoom operations: Cache invalidated automatically
- LOD changes: Trigger redraw via `self.update()`
- Geometry changes: Rare after layout stabilization

**Alternatives Considered:**

| Cache Mode | Pros | Cons | Verdict |
|------------|------|------|---------|
| DeviceCoordinateCache | Fast panning | Invalidated on zoom | **Selected** |
| ItemCoordinateCache | Preserves across zoom | Slower than device cache | Rejected |
| NoCache | No invalidation overhead | Slow panning | Rejected |

---

## 3. Implementation Strategy

### 3.1 Module Structure

**File Location:**
```
src/ink/presentation/canvas/
├── cell_item.py          # CellGraphicsItem implementation
├── lod_level.py          # LODLevel enum (from T01)
└── schematic_canvas.py   # Canvas integration
```

**Class Hierarchy:**
```
QGraphicsRectItem (Qt)
    └── CellGraphicsItem
            ├── _name_label: QGraphicsTextItem (child)
            └── _pin_items: List[QGraphicsItem] (children from T03)
```

### 3.2 Implementation Phases

**Phase 1: Basic Cell Item Structure (2 hours)**
- Define `CellGraphicsItem` class extending `QGraphicsRectItem`
- Implement `__init__()` with cell parameter and geometry setup
- Add `_setup_geometry()` for bounding box initialization
- Add `_setup_children()` for name label creation
- Write unit tests for initialization

**Phase 2: LOD Rendering Implementation (3 hours)**
- Implement `set_lod_level()` method with three branches
- Implement `_render_low_detail()` - solid box only
- Implement `_render_medium_detail()` - box + name
- Implement `_render_high_detail()` - full detail
- Override `paint()` for LOW LOD fast path
- Write unit tests for each rendering mode

**Phase 3: Child Item Management (1 hour)**
- Implement `add_pin_item()` for pin registration
- Update LOD rendering to control pin visibility
- Write unit tests for child item visibility

**Phase 4: Canvas Integration (1 hour)**
- Modify `SchematicCanvas.add_cell_item()` to track cells
- Connect LOD manager to cell item updates
- Implement `_on_lod_changed()` to update all cells

**Phase 5: Testing and Optimization (1 hour)**
- Performance benchmarks for 500 cells at each LOD
- Visual regression tests
- Optimization profiling and tuning

**Total Estimated Time**: 8 hours (aligns with spec estimate)

### 3.3 Key Algorithms

**Geometry Setup from Domain Model:**

```python
def _setup_geometry(self):
    """
    Initialize bounding box from cell's layout position and size.

    Assumes:
    - Cell.position is a Position value object with x, y attributes
    - Cell.size is a Size value object with width, height attributes
    - Coordinates are in schematic space (grid aligned)
    """
    x, y = self._cell.position.x, self._cell.position.y
    width, height = self._cell.size.width, self._cell.size.height

    # Set rectangle geometry
    self.setRect(QRectF(x, y, width, height))

    # Set border and initial fill
    self.setPen(QPen(self.BORDER_COLOR, self.BORDER_WIDTH))
    self.setBrush(QBrush(self.BBOX_COLOR_HIGH))
```

**Name Label Centering:**

```python
def _setup_children(self):
    """
    Create child graphics items (name label, pins added later).

    Name label is centered within cell bounding box.
    """
    # Create name label as child item
    self._name_label = QGraphicsTextItem(self._cell.name, self)
    self._name_label.setDefaultTextColor(Qt.black)

    # Calculate center position
    rect = self.rect()
    label_rect = self._name_label.boundingRect()

    x_offset = rect.center().x() - label_rect.width() / 2
    y_offset = rect.center().y() - label_rect.height() / 2

    # Position label relative to cell
    self._name_label.setPos(x_offset, y_offset)
```

**LOD Rendering Decision Tree:**

```python
def set_lod_level(self, lod_level: LODLevel) -> None:
    """
    Update rendering based on LOD level.

    Algorithm:
    1. Early exit if LOD hasn't changed
    2. Branch based on target LOD level
    3. Update visual properties (brush, child visibility)
    4. Trigger redraw
    """
    if lod_level == self._current_lod:
        return  # No change, skip update

    self._current_lod = lod_level

    # Branch to appropriate rendering method
    if lod_level == LODLevel.LOW:
        self._render_low_detail()
    elif lod_level == LODLevel.MEDIUM:
        self._render_medium_detail()
    else:  # HIGH
        self._render_high_detail()

    # Force redraw with new LOD
    self.update()
```

**Custom Paint for LOW LOD Optimization:**

```python
def paint(self, painter: QPainter, option, widget=None):
    """
    Override paint for LOW LOD optimization.

    LOW LOD Fast Path:
    - Skip Qt's default rendering
    - Draw simple filled rectangle directly
    - Avoid text rendering overhead

    MEDIUM/HIGH LOD:
    - Use Qt's default QGraphicsRectItem rendering
    - Child items (name label, pins) rendered automatically
    """
    if self._current_lod == LODLevel.LOW:
        # Fast path: minimal rendering
        painter.setPen(self.pen())
        painter.setBrush(self.brush())
        painter.drawRect(self.rect())
    else:
        # Default Qt rendering for detail levels
        super().paint(painter, option, widget)
```

### 3.4 Integration Points

**Canvas Integration:**

```python
# In SchematicCanvas
class SchematicCanvas(QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._lod_manager = LODManager()
        self._cell_items: List[CellGraphicsItem] = []

        # Register LOD change callback
        self._lod_manager.add_listener(self._on_lod_changed)

    def add_cell_item(self, cell_item: CellGraphicsItem) -> None:
        """
        Add cell to scene and register for LOD updates.

        Steps:
        1. Add to Qt scene graph
        2. Track in internal list
        3. Set initial LOD level
        """
        self.scene().addItem(cell_item)
        self._cell_items.append(cell_item)

        # Sync with current LOD level
        cell_item.set_lod_level(self._lod_manager.current_level)

    def _on_lod_changed(self, new_level: LODLevel) -> None:
        """
        Update all cell items when LOD changes.

        Performance: O(n) where n = number of cells
        Target: <16ms for 200 cells
        """
        for cell_item in self._cell_items:
            cell_item.set_lod_level(new_level)
```

**Pin Integration (T03 dependency):**

```python
# In CellGraphicsItem
def add_pin_item(self, pin_item: QGraphicsItem) -> None:
    """
    Add pin as child item (called by pin rendering system).

    Pin visibility controlled by current LOD:
    - LOW/MEDIUM: Hidden
    - HIGH: Visible
    """
    self._pin_items.append(pin_item)
    pin_item.setParentItem(self)  # Attach to cell

    # Set initial visibility based on current LOD
    if self._current_lod != LODLevel.HIGH:
        pin_item.setVisible(False)
```

---

## 4. Technical Deep Dive

### 4.1 Qt Graphics Item Coordinate Systems

**Coordinate Spaces:**

```
1. Schematic Space (domain model):
   - Cell.position: (100.0, 200.0) in schematic units
   - Cell.size: (80.0, 60.0)

2. Item Coordinates (QGraphicsItem):
   - Item's local coordinate system
   - Origin at top-left of bounding rect
   - rect(): QRectF(0, 0, 80, 60)

3. Scene Coordinates (QGraphicsScene):
   - Global schematic space
   - Item position: setPos(100, 200)
   - Combined: item local + item position

4. View Coordinates (screen pixels):
   - After view transform (zoom/pan)
   - QGraphicsView.mapToScene() / mapFromScene()
```

**Cell Item Positioning:**
```python
# Domain model provides absolute schematic position
cell.position = Position(x=100, y=200)
cell.size = Size(width=80, height=60)

# Option A: Set item position, use relative rect
cell_item.setPos(100, 200)
cell_item.setRect(QRectF(0, 0, 80, 60))

# Option B: Use absolute rect, position = (0, 0) [SELECTED]
cell_item.setPos(0, 0)
cell_item.setRect(QRectF(100, 200, 80, 60))
```

**Decision**: Use Option B (absolute rect) for simplicity and alignment with layout engine output.

### 4.2 Performance Analysis: Rendering Complexity

**Rendering Operations per Cell:**

| LOD Level | Operations | Qt API Calls | Estimated Time |
|-----------|-----------|--------------|----------------|
| LOW | 1 filled rectangle | `drawRect()` | ~0.01ms |
| MEDIUM | 1 rectangle + 1 text | `drawRect()` + text layout | ~0.05ms |
| HIGH | 1 rect + 1 text + N pins | Base + pin rendering | ~0.2ms (N=10) |

**Performance Targets Validation:**

500 cells at LOW LOD:
- 500 × 0.01ms = 5ms ✓ (within target)

200 cells at MEDIUM LOD:
- 200 × 0.05ms = 10ms ✓ (within target)

50 cells at HIGH LOD:
- 50 × 0.2ms = 10ms ✓ (within target)

**Bottleneck Analysis:**
- Text rendering is 5x slower than rectangles
- Pin rendering (from T03) will dominate HIGH LOD time
- Qt's text layout is expensive (glyph shaping, anti-aliasing)

**Optimization Opportunities:**
- Cache `QStaticText` for cell names (pre-layout text)
- Use `QGraphicsSimpleTextItem` instead of `QGraphicsTextItem` (no rich text overhead)
- Batch scene updates: `scene.setUpdatesEnabled(False)` during mass LOD changes

### 4.3 Qt Caching Mechanisms

**Device Coordinate Cache:**

```python
# Enable caching
self.setCacheMode(QGraphicsItem.DeviceCoordinateCache)
```

**How it works:**
1. First paint: Qt renders item, caches result in device pixels
2. Subsequent paints (pan): Qt blits cached pixmap (very fast)
3. Transform change (zoom): Cache invalidated, re-render
4. Item update: Cache invalidated, re-render

**Cache Memory Cost:**
- Cache size = bounding_rect_width × bounding_rect_height × 4 bytes (RGBA)
- Example: 100×80 cell = 32KB per cell
- 500 cells = 16MB total cache (acceptable)

**Trade-offs:**
- Pros: 10-100x faster panning (no re-rendering)
- Cons: Memory overhead, invalidation on zoom
- Verdict: Worth it for schematic viewers (frequent panning)

### 4.4 LOD Transition Performance

**Transition Sequence:**

```
1. User zooms (wheel event)
2. SchematicCanvas.wheelEvent()
   - Apply zoom transform: ~0.1ms
   - Update LODManager: ~0.01ms
3. LODManager detects transition
   - Calculate new LOD: <0.01ms
   - Notify listeners: ~10ms (200 cells × 0.05ms)
4. Each CellGraphicsItem.set_lod_level()
   - Update brush: ~0.001ms
   - Toggle child visibility: ~0.01ms
   - Queue update: ~0.001ms
5. Qt scene update
   - Repaint visible items: ~10ms (depends on LOD)

Total: ~20ms (marginally over 16ms budget)
```

**Optimization Strategies:**
- Batch updates: Disable scene updates, update all cells, re-enable
- Cull off-screen items: Only update visible cells
- Defer transitions: Wait for zoom to stabilize (debounce)
- Progressive update: Update visible items first, background items later

**Target with Optimization:**
- Batch updates: 10-15ms total (within budget)

---

## 5. Risk Analysis

### 5.1 Performance Risks

**Risk R01: LOD transitions exceed 16ms frame budget with 200+ cells**

- **Impact**: High - Causes visible lag during zoom
- **Probability**: Medium - Expected 200 × 0.05ms = 10ms, close to budget
- **Symptoms**: Stuttering during zoom, delayed LOD transitions
- **Mitigation**:
  - Implement batched scene updates (`setUpdatesEnabled(False/True)`)
  - Profile actual transition times with 500 cell test scene
  - Optimize `set_lod_level()` - avoid redundant operations
  - Consider progressive updates (visible items first)
  - Fallback: Reduce hysteresis buffer to prevent rapid transitions

**Risk R02: Text rendering overhead at MEDIUM LOD still too slow**

- **Impact**: Medium - Limits max cell count at MEDIUM LOD
- **Probability**: Low - Qt's text rendering is well-optimized
- **Symptoms**: Frame drops when 200+ cells visible at MEDIUM LOD
- **Mitigation**:
  - Use `QGraphicsSimpleTextItem` instead of `QGraphicsTextItem`
  - Cache cell name text with `QStaticText`
  - Profile text rendering with 500 cell test
  - Consider custom text rendering (QPainter.drawText with cached layout)

**Risk R03: Cache memory overhead exceeds acceptable limits**

- **Impact**: Low - Memory is cheap on desktop Linux
- **Probability**: Low - 16MB for 500 cells is acceptable
- **Symptoms**: High memory usage (>100MB for 1000 cells)
- **Mitigation**:
  - Profile memory usage with tracemalloc
  - Disable caching for off-screen items
  - Use `ItemCoordinateCache` for very large scenes (>1000 cells)
  - Make caching mode configurable

### 5.2 Visual Quality Risks

**Risk R04: Visual artifacts during LOD transitions**

- **Impact**: Medium - Affects user experience
- **Probability**: Low - Qt handles visibility changes cleanly
- **Symptoms**: Flickering, items appearing/disappearing abruptly
- **Mitigation**:
  - Test LOD transitions at various zoom speeds
  - Ensure `update()` called after LOD changes
  - Verify child item visibility synchronized with parent LOD
  - Consider fade animations in P1 (opacity interpolation)

**Risk R05: Cell name label not readable at MEDIUM LOD**

- **Impact**: Medium - Reduces usefulness of MEDIUM LOD
- **Probability**: Low - MEDIUM LOD is 25-75% zoom, text should be readable
- **Symptoms**: User feedback that names are too small
- **Mitigation**:
  - Test readability at 25%, 50%, 75% zoom
  - Adjust font size per LOD level if needed
  - Use `QGraphicsItem.ItemIgnoresTransformations` flag for labels (P1)

### 5.3 Integration Risks

**Risk R06: Pin items from T03 not integrating cleanly**

- **Impact**: High - Blocks T03 implementation
- **Probability**: Low - Well-defined `add_pin_item()` interface
- **Symptoms**: Pin visibility not controlled by cell LOD
- **Mitigation**:
  - Define clear interface contract for `add_pin_item()`
  - Write integration test stub for pin management
  - Coordinate with T03 implementer on API

**Risk R07: Domain model (Cell entity) not providing required attributes**

- **Impact**: High - Cannot render cells
- **Probability**: Medium - E01 data model not yet implemented
- **Symptoms**: Missing `position`, `size`, `name` attributes
- **Mitigation**:
  - Mock `Cell` entity for unit tests
  - Coordinate with E01 implementer on required attributes
  - Document requirements: `Cell.name: str`, `Cell.position: Position`, `Cell.size: Size`

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test Coverage Targets:**
- `CellGraphicsItem`: 85%+ coverage
- LOD rendering methods: 100% coverage
- Geometry setup: 100% coverage

**Test Cases:**

```python
# tests/unit/presentation/canvas/test_cell_item_lod.py
from unittest.mock import Mock
import pytest
from PySide6.QtCore import QRectF
from ink.presentation.canvas.cell_item import CellGraphicsItem
from ink.presentation.canvas.lod_level import LODLevel

@pytest.fixture
def mock_cell():
    """Mock Cell domain entity."""
    cell = Mock()
    cell.name = "AND2_X1"
    cell.position = Mock(x=100.0, y=200.0)
    cell.size = Mock(width=80.0, height=60.0)
    return cell

def test_cell_item_initialization(mock_cell):
    """Test cell item creates with correct geometry."""
    item = CellGraphicsItem(mock_cell)

    # Verify bounding rect
    assert item.rect() == QRectF(100.0, 200.0, 80.0, 60.0)

    # Verify name label created
    assert item._name_label is not None
    assert item._name_label.toPlainText() == "AND2_X1"

    # Verify initial LOD
    assert item.current_lod == LODLevel.HIGH

def test_set_lod_level_low(mock_cell):
    """Test LOW LOD rendering."""
    item = CellGraphicsItem(mock_cell)
    item.set_lod_level(LODLevel.LOW)

    # Verify brush color changed
    assert item.brush().color() == CellGraphicsItem.BBOX_COLOR_LOW

    # Verify name label hidden
    assert not item._name_label.isVisible()

    # Verify LOD tracked
    assert item.current_lod == LODLevel.LOW

def test_set_lod_level_medium(mock_cell):
    """Test MEDIUM LOD rendering."""
    item = CellGraphicsItem(mock_cell)
    item.set_lod_level(LODLevel.MEDIUM)

    # Verify brush color
    assert item.brush().color() == CellGraphicsItem.BBOX_COLOR_MEDIUM

    # Verify name label visible
    assert item._name_label.isVisible()

def test_set_lod_level_high(mock_cell):
    """Test HIGH LOD rendering."""
    item = CellGraphicsItem(mock_cell)
    item.set_lod_level(LODLevel.HIGH)

    # Verify brush color
    assert item.brush().color() == CellGraphicsItem.BBOX_COLOR_HIGH

    # Verify name label visible
    assert item._name_label.isVisible()

def test_set_lod_level_no_change(mock_cell):
    """Test LOD setter early exits if no change."""
    item = CellGraphicsItem(mock_cell)
    initial_lod = item.current_lod

    # Mock update to detect if called
    item.update = Mock()

    # Set to same LOD
    item.set_lod_level(initial_lod)

    # Verify update not called (early exit)
    item.update.assert_not_called()

def test_add_pin_item(mock_cell, qtbot):
    """Test adding pin items and LOD visibility control."""
    from PySide6.QtWidgets import QGraphicsEllipseItem

    item = CellGraphicsItem(mock_cell)
    pin = QGraphicsEllipseItem()  # Dummy pin item

    # Add pin at HIGH LOD
    item.set_lod_level(LODLevel.HIGH)
    item.add_pin_item(pin)

    # Verify pin is child
    assert pin.parentItem() == item
    assert pin in item._pin_items

    # Verify pin visible at HIGH
    assert pin.isVisible()

    # Switch to LOW LOD
    item.set_lod_level(LODLevel.LOW)

    # Verify pin hidden
    assert not pin.isVisible()

def test_name_label_centering(mock_cell):
    """Test name label positioned at center of cell."""
    item = CellGraphicsItem(mock_cell)

    # Get positions
    cell_center = item.rect().center()
    label_rect = item._name_label.boundingRect()
    label_center_x = item._name_label.pos().x() + label_rect.width() / 2
    label_center_y = item._name_label.pos().y() + label_rect.height() / 2

    # Verify centered (within 1 pixel tolerance)
    assert abs(label_center_x - cell_center.x()) < 1.0
    assert abs(label_center_y - cell_center.y()) < 1.0
```

### 6.2 Visual Tests

**Screenshot Regression Tests:**

```python
# tests/visual/test_cell_rendering_lod.py
def test_visual_cell_low_lod(qtbot, tmp_path):
    """Capture cell rendering at LOW LOD."""
    from PySide6.QtWidgets import QGraphicsScene, QGraphicsView

    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    cell = create_mock_cell("TEST_CELL")
    item = CellGraphicsItem(cell)
    item.set_lod_level(LODLevel.LOW)
    scene.addItem(item)

    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    # Capture screenshot
    pixmap = view.grab()
    screenshot_path = tmp_path / "cell_low_lod.png"
    pixmap.save(str(screenshot_path))

    # Compare with reference (manual inspection for MVP)
    assert screenshot_path.exists()
```

### 6.3 Integration Tests

**Canvas Integration:**

```python
# tests/integration/presentation/test_cell_lod_integration.py
def test_cell_lod_updates_with_canvas(qtbot):
    """Test cells update LOD when canvas zoom changes."""
    from ink.presentation.canvas.schematic_canvas import SchematicCanvas

    canvas = SchematicCanvas()
    qtbot.addWidget(canvas)

    # Add multiple cells
    cells = [create_mock_cell(f"CELL_{i}") for i in range(10)]
    cell_items = [CellGraphicsItem(cell) for cell in cells]

    for item in cell_items:
        canvas.add_cell_item(item)

    # Verify initial LOD
    assert all(item.current_lod == LODLevel.HIGH for item in cell_items)

    # Simulate zoom out to trigger LOW LOD
    canvas._lod_manager.update_zoom(0.1)

    # Verify all cells updated
    assert all(item.current_lod == LODLevel.LOW for item in cell_items)
```

### 6.4 Performance Tests

**Rendering Benchmarks:**

```python
# tests/performance/test_cell_lod_benchmark.py
import pytest
from PySide6.QtWidgets import QGraphicsScene, QGraphicsView, QApplication

@pytest.mark.benchmark
def test_render_500_cells_low_lod(benchmark, qtbot):
    """Benchmark rendering 500 cells at LOW LOD."""
    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    # Create 500 cells in grid layout
    cells = []
    for i in range(500):
        cell = create_mock_cell(f"CELL_{i}")
        cell.position.x = (i % 25) * 100
        cell.position.y = (i // 25) * 100

        item = CellGraphicsItem(cell)
        item.set_lod_level(LODLevel.LOW)
        scene.addItem(item)
        cells.append(item)

    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    def render():
        scene.update()
        QApplication.processEvents()

    result = benchmark(render)

    # Assert <5ms for 500 cells
    assert result < 0.005

@pytest.mark.benchmark
def test_lod_transition_200_cells(benchmark, qtbot):
    """Benchmark LOD transition for 200 cells."""
    scene = QGraphicsScene()

    cells = []
    for i in range(200):
        cell = create_mock_cell(f"CELL_{i}")
        item = CellGraphicsItem(cell)
        item.set_lod_level(LODLevel.HIGH)
        scene.addItem(item)
        cells.append(item)

    def transition():
        # Toggle LOD
        new_lod = LODLevel.LOW if cells[0].current_lod == LODLevel.HIGH else LODLevel.HIGH
        for item in cells:
            item.set_lod_level(new_lod)

    result = benchmark(transition)

    # Assert <16ms for 60fps
    assert result < 0.016
```

---

## 7. Definition of Done

### 7.1 Functional Completeness

- [ ] `CellGraphicsItem` class implemented extending `QGraphicsRectItem`
- [ ] Cell renders as bounding box only at LOD LOW
- [ ] Cell renders box + name label at LOD MEDIUM
- [ ] Cell renders full detail at LOD HIGH
- [ ] `set_lod_level()` updates rendering immediately
- [ ] Name label centered in bounding box
- [ ] `add_pin_item()` attaches pins as child items
- [ ] Pin visibility controlled by LOD level
- [ ] Different background colors per LOD level
- [ ] Border visible at all LOD levels

### 7.2 Performance Completeness

- [ ] 500 cells render at LOW LOD in <5ms
- [ ] 200 cells render at MEDIUM LOD in <10ms
- [ ] 50 cells render at HIGH LOD in <10ms
- [ ] LOD transition for 200 cells completes in <16ms
- [ ] No memory leaks when switching LOD levels repeatedly
- [ ] Device coordinate caching enabled

### 7.3 Testing Completeness

- [ ] Unit tests for initialization and geometry setup
- [ ] Unit tests for all three LOD rendering modes
- [ ] Unit tests for `set_lod_level()` state changes
- [ ] Unit tests for child item visibility
- [ ] Unit tests for `add_pin_item()` integration
- [ ] Visual regression tests for each LOD level
- [ ] Integration test: LOD manager triggers cell updates
- [ ] Performance benchmark: 500 cells at LOW LOD <5ms
- [ ] Performance benchmark: LOD transition <16ms
- [ ] Code coverage: 85%+ on `CellGraphicsItem`

### 7.4 Code Quality

- [ ] All methods have type hints
- [ ] All public methods documented with docstrings
- [ ] No PEP 8 violations (ruff check passes)
- [ ] No type errors (mypy passes)
- [ ] Code reviewed and approved
- [ ] No visual artifacts during LOD transitions (manual verification)

---

## 8. Open Questions and Decisions Needed

### 8.1 Text Rendering Optimization

**Q1**: Should we use `QGraphicsSimpleTextItem` or `QGraphicsTextItem` for name labels?

- **Options**:
  - Option A: `QGraphicsTextItem` (current spec) - Rich text support
  - Option B: `QGraphicsSimpleTextItem` - Faster, plain text only
  - Option C: `QStaticText` with custom painting - Maximum performance
- **Recommendation**: Start with Option A, switch to B if performance tests show slowness
- **Decision Needed By**: Phase 2 implementation
- **Testing**: Benchmark text rendering with 500 cells

### 8.2 Cell Symbol Shapes

**Q2**: Should cells support non-rectangular shapes (rounded corners, custom symbols)?

- **Context**: Spec shows simple rectangles, but some cell types may need distinction
- **Options**:
  - Option A: Rectangles only (MVP)
  - Option B: Rounded corners for sequential cells (latches)
  - Option C: Custom `QPainterPath` per cell type
- **Recommendation**: Option A for MVP, Option B for P1
- **Decision Needed By**: Before Phase 1
- **Coordination**: Align with E02-F01 cell symbol rendering spec

### 8.3 LOD Color Coding in Production

**Q3**: Should different LOD colors be removed before release?

- **Context**: Color coding useful for debugging, but may not be desirable in production
- **Options**:
  - Option A: Remove color differences, use single theme color
  - Option B: Make configurable via user preference
  - Option C: Keep for MVP, remove in P1
- **Recommendation**: Option C - keep for MVP debugging, make configurable in P1
- **Decision Needed By**: P1 planning

---

## 9. Success Metrics and Validation

### 9.1 Performance KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| 500 cells LOW LOD render time | <5ms | Performance benchmark |
| 200 cells MEDIUM LOD render time | <10ms | Performance benchmark |
| 50 cells HIGH LOD render time | <10ms | Performance benchmark |
| LOD transition time (200 cells) | <16ms | Performance benchmark |
| Memory overhead per cell | <50KB | Memory profiler |

### 9.2 Quality KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Unit Test Coverage | 85%+ | pytest-cov |
| Integration Test Pass Rate | 100% | CI/CD |
| Visual Regression Pass Rate | 100% | Manual verification |
| Code Review Approval | Required | GitHub PR |

### 9.3 User Experience KPIs

| Metric | Target | Validation Method |
|--------|--------|------------------|
| No visual artifacts | 0 occurrences | Manual testing |
| Name label readability | Readable at 50% zoom | User testing |
| Smooth LOD transitions | Subjective "smooth" | Manual testing |

---

## 10. Timeline and Milestones

### 10.1 Implementation Schedule

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| Phase 1: Basic Structure | 2 hours | Class skeleton, initialization |
| Phase 2: LOD Rendering | 3 hours | Three rendering modes |
| Phase 3: Child Management | 1 hour | Pin item integration |
| Phase 4: Canvas Integration | 1 hour | LOD manager connection |
| Phase 5: Testing | 1 hour | Unit and performance tests |
| **Total** | **8 hours** | Fully tested CellGraphicsItem |

### 10.2 Milestones

| Milestone | Success Criteria |
|-----------|-----------------|
| M1: Basic Cell Rendering | Cell renders at all three LOD levels |
| M2: Performance Validated | Benchmarks pass for 500 cells |
| M3: Integration Complete | Works with LODManager and canvas |
| M4: Testing Complete | All tests passing, 85%+ coverage |

---

## 11. References and Resources

### 11.1 Technical References

**Qt Graphics Framework:**
- Qt Documentation: `QGraphicsRectItem`, `QGraphicsTextItem`
- Qt Performance: Device coordinate caching
- Qt Examples: Diagram Scene example (cell-like items)

**Rendering Optimization:**
- Qt Graphics View Performance Tuning
- Level of Detail patterns in CAD software

### 11.2 Internal Documentation

- `/home/joohan/dev/project-ink/ink/specs/E02/F04/T01/E02-F04-T01.spec.md` - LODManager spec
- `/home/joohan/dev/project-ink/ink/specs/E02/F04/E02-F04.spec.md` - Parent feature spec
- `/home/joohan/dev/project-ink/ink/CLAUDE.md` - Architecture guidelines

---

**Document Status**: Ready for Implementation
**Next Steps**: Begin Phase 1 after T01 completion, coordinate with E01 for Cell entity API
