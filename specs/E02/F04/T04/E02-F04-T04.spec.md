# Spec: E02-F04-T04 - Net LOD Rendering

## Metadata
- **ID**: E02-F04-T04
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E02-F04](../E02-F04.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Small
- **Tags**: [lod, rendering, net-graphics]

---

## 1. Overview

### 1.1 Problem Statement

Net routing graphics need to simplify at low zoom levels to reduce visual clutter and improve rendering performance. At low LOD, nets should render as simple straight lines between cells. At medium and high LOD, full orthogonal routing with junction dots should be shown.

### 1.2 Goals

- Implement two-tier LOD rendering for net graphics (simplified/full)
- Reduce net routing complexity at low zoom
- Maintain connection visibility across all LOD levels
- Improve rendering performance for large netlists
- Integrate with LOD scene manager from T02

---

## 2. Technical Requirements

### 2.1 Net Item LOD Levels

| LOD Level | Net Rendering | Visible Elements |
|-----------|---------------|------------------|
| **LOW** (<25% zoom) | Single straight line | Direct line between connected pins |
| **MEDIUM** (25-75% zoom) | Full orthogonal routing | All route segments, junction dots |
| **HIGH** (>75% zoom) | Full orthogonal routing | All route segments, junction dots, net name labels |

### 2.2 Net Item Structure with LOD

```python
from PySide6.QtWidgets import QGraphicsItem, QGraphicsPathItem, QGraphicsLineItem
from PySide6.QtGui import QPainterPath, QPen, QColor
from PySide6.QtCore import QPointF, QLineF

class NetItem(QGraphicsPathItem):
    """Net graphics item with two-tier LOD support."""

    def __init__(self, net, route_points: list[QPointF], lod_scene_manager: LODSceneManager):
        """
        Initialize net item.

        Args:
            net: Domain net entity
            route_points: Full orthogonal route path
            lod_scene_manager: LOD manager for registration
        """
        super().__init__()
        self._net = net
        self._route_points = route_points
        self._current_lod = LODLevel.HIGH
        self._lod_scene_manager = lod_scene_manager

        # Create both simplified and full paths
        self._simplified_path = self._create_simplified_path()
        self._full_path = self._create_full_path()

        # Create detail items
        self._create_detail_items()

        # Set initial path (full)
        self.setPath(self._full_path)

        # Register for LOD updates
        lod_scene_manager.register_item(self)

    def _create_simplified_path(self) -> QPainterPath:
        """Create simplified straight-line path between endpoints."""
        if len(self._route_points) < 2:
            return QPainterPath()

        path = QPainterPath()
        path.moveTo(self._route_points[0])
        path.lineTo(self._route_points[-1])  # Direct line to end
        return path

    def _create_full_path(self) -> QPainterPath:
        """Create full orthogonal routing path."""
        if len(self._route_points) < 2:
            return QPainterPath()

        path = QPainterPath()
        path.moveTo(self._route_points[0])
        for point in self._route_points[1:]:
            path.lineTo(point)
        return path

    def _create_detail_items(self):
        """Create junction dots and net name labels."""
        # Junction dots at route points (visible: MEDIUM, HIGH)
        self._junction_dots = QGraphicsItemGroup(self)
        for point in self._get_junction_points():
            dot = QGraphicsEllipseItem(-2, -2, 4, 4, self._junction_dots)
            dot.setBrush(QBrush(QColor(0, 0, 0)))
            dot.setPos(point)

        # Net name label (visible: HIGH only)
        self._name_label = QGraphicsTextItem(self._net.name, self)
        self._name_label.setPos(self._get_label_position())
        self._name_label.setDefaultTextColor(QColor(0, 100, 0))

    def _get_junction_points(self) -> list[QPointF]:
        """Get points where three or more segments meet."""
        # Identify T-junctions and crossings in route
        junctions = []
        # Implementation: detect points with >2 connected segments
        return junctions

    def _get_label_position(self) -> QPointF:
        """Calculate position for net name label."""
        # Place label at midpoint of longest segment
        if len(self._route_points) < 2:
            return QPointF(0, 0)

        # Find longest segment
        max_length = 0
        mid_point = self._route_points[0]
        for i in range(len(self._route_points) - 1):
            p1 = self._route_points[i]
            p2 = self._route_points[i + 1]
            length = QLineF(p1, p2).length()
            if length > max_length:
                max_length = length
                mid_point = QPointF((p1.x() + p2.x()) / 2, (p1.y() + p2.y()) / 2)

        return mid_point

    def update_lod(self, lod_level: LODLevel) -> None:
        """
        Update net rendering based on LOD level.

        Args:
            lod_level: New level of detail
        """
        if self._current_lod == lod_level:
            return

        self._current_lod = lod_level

        if lod_level == LODLevel.LOW:
            # Simplified straight-line routing
            self.setPath(self._simplified_path)
            self._junction_dots.setVisible(False)
            self._name_label.setVisible(False)

            # Thin pen for performance
            self.setPen(QPen(QColor(50, 50, 50), 1))

        elif lod_level == LODLevel.MEDIUM:
            # Full orthogonal routing with junctions
            self.setPath(self._full_path)
            self._junction_dots.setVisible(True)
            self._name_label.setVisible(False)

            # Standard pen
            self.setPen(QPen(QColor(0, 0, 0), 2))

        else:  # LODLevel.HIGH
            # Full routing with labels
            self.setPath(self._full_path)
            self._junction_dots.setVisible(True)
            self._name_label.setVisible(True)

            # High-quality pen
            self.setPen(QPen(QColor(0, 0, 0), 2))

        # Trigger redraw
        self.update()

    def get_detail_items(self) -> dict[str, QGraphicsItem]:
        """Get dictionary of detail items for LOD management."""
        return {
            'junction_dots': self._junction_dots,
            'name_label': self._name_label
        }
```

### 2.3 Visual Design Specifications

**LOD Level: LOW**
```
Cell A ────────────────────── Cell B
       (single straight line)
```

**LOD Level: MEDIUM**
```
Cell A ─────┬──────────┐
            │          │
            ●          │  (junction dot)
                       │
                  Cell B
```

**LOD Level: HIGH**
```
Cell A ─────┬──────────┐
            │  net_123 │  (net name label)
            ●          │  (junction dot)
                       │
                  Cell B
```

### 2.4 Performance Optimization

**Rendering Metrics:**
- LOW LOD: 1 line per net (~5 draw calls)
- MEDIUM LOD: N segments + M junctions (~N+M draw calls)
- HIGH LOD: N segments + M junctions + 1 label (~N+M+3 draw calls)

**Optimization Strategies:**
1. **Pre-computed paths**: Both simplified and full paths created once at construction
2. **Path switching**: LOD change just swaps QPainterPath, no recalculation
3. **Thin pens at LOW**: Reduces antialiasing overhead
4. **Junction culling**: Only show junctions where 3+ segments meet
5. **Label positioning**: Calculated once, cached for reuse

### 2.5 Simplified Path Algorithm

```python
def _create_simplified_path(self) -> QPainterPath:
    """
    Create simplified straight-line path.

    Strategy:
    - Find source pin (first connected pin)
    - Find sink pins (all other connected pins)
    - Draw direct line from source to first sink
    - For multi-fanout nets, draw lines to centroid of sinks
    """
    if not self._route_points:
        return QPainterPath()

    path = QPainterPath()
    start = self._route_points[0]
    end = self._route_points[-1]

    # For simple point-to-point nets
    if len(self._net.connected_pins) == 2:
        path.moveTo(start)
        path.lineTo(end)
        return path

    # For multi-fanout nets, draw to centroid
    centroid = self._calculate_centroid()
    path.moveTo(start)
    path.lineTo(centroid)

    return path

def _calculate_centroid(self) -> QPointF:
    """Calculate centroid of all route points."""
    x_sum = sum(p.x() for p in self._route_points)
    y_sum = sum(p.y() for p in self._route_points)
    count = len(self._route_points)
    return QPointF(x_sum / count, y_sum / count)
```

### 2.6 File Locations

- **Module**: `src/ink/presentation/canvas/net_item.py`
- **Tests**: `tests/unit/presentation/canvas/test_net_item_lod.py`

---

## 3. Acceptance Criteria

- [ ] `NetItem` implements `LODAware` protocol
- [ ] LOW LOD shows simplified straight-line routing
- [ ] MEDIUM LOD shows full orthogonal routing with junction dots
- [ ] HIGH LOD adds net name labels
- [ ] Simplified path correctly connects endpoints
- [ ] Full path follows all route points
- [ ] Junction dots placed at multi-segment intersections
- [ ] Net name labels positioned at longest segment midpoint
- [ ] LOD transitions update path and visibility correctly
- [ ] No visual glitches during path switching
- [ ] Performance: 3x faster rendering at LOW vs HIGH LOD
- [ ] Selection/highlighting works at all LOD levels
- [ ] Unit tests cover all LOD levels
- [ ] Integration tests with LOD scene manager

---

## 4. Testing Strategy

### 4.1 Unit Tests

```python
def test_net_item_low_lod():
    """Test net rendering at LOW LOD."""
    route_points = [QPointF(0, 0), QPointF(50, 50), QPointF(100, 50), QPointF(100, 100)]
    net = MockNet(name="net_123")

    item = NetItem(net, route_points, scene_manager)
    item.update_lod(LODLevel.LOW)

    # Should use simplified path
    assert item.path() == item._simplified_path
    assert not item._junction_dots.isVisible()
    assert not item._name_label.isVisible()

def test_net_item_medium_lod():
    """Test net rendering at MEDIUM LOD."""
    item = NetItem(MockNet(), route_points, scene_manager)
    item.update_lod(LODLevel.MEDIUM)

    # Should use full path with junctions
    assert item.path() == item._full_path
    assert item._junction_dots.isVisible()
    assert not item._name_label.isVisible()

def test_net_item_high_lod():
    """Test net rendering at HIGH LOD."""
    item = NetItem(MockNet(), route_points, scene_manager)
    item.update_lod(LODLevel.HIGH)

    # All details visible
    assert item.path() == item._full_path
    assert item._junction_dots.isVisible()
    assert item._name_label.isVisible()

def test_simplified_path_point_to_point():
    """Test simplified path for two-pin net."""
    route_points = [QPointF(0, 0), QPointF(50, 50), QPointF(100, 100)]
    net = MockNet(connected_pins=[pin1, pin2])

    item = NetItem(net, route_points, scene_manager)
    simplified = item._simplified_path

    # Should be direct line from start to end
    assert simplified.elementAt(0).x == 0
    assert simplified.elementAt(0).y == 0
    assert simplified.elementAt(1).x == 100
    assert simplified.elementAt(1).y == 100

def test_junction_detection():
    """Test junction dots placed at correct points."""
    # Create route with T-junction
    route_points = [
        QPointF(0, 0),
        QPointF(50, 0),   # Junction point
        QPointF(50, 50),
        QPointF(50, 100)
    ]

    item = NetItem(MockNet(), route_points, scene_manager)
    junctions = item._get_junction_points()

    # Should detect junction at (50, 0)
    assert QPointF(50, 0) in junctions

def test_path_switching_performance():
    """Test LOD transition performance."""
    import time

    # Create complex net with many route points
    route_points = [QPointF(i * 10, i * 10) for i in range(100)]
    item = NetItem(MockNet(), route_points, scene_manager)

    start = time.perf_counter()
    item.update_lod(LODLevel.LOW)
    low_time = time.perf_counter() - start

    assert low_time < 0.001  # Path switch should be instant
```

### 4.2 Visual Tests

```python
def test_net_visual_appearance(qtbot):
    """Test visual appearance at each LOD level."""
    view = QGraphicsView()
    scene = QGraphicsScene()
    view.setScene(scene)

    lod_manager = LODManager()
    scene_manager = LODSceneManager(scene, lod_manager)

    # Create test net with complex routing
    route_points = create_complex_route()
    net = create_test_net()
    item = NetItem(net, route_points, scene_manager)
    scene.addItem(item)

    view.show()
    qtbot.addWidget(view)

    # Cycle through LOD levels
    for lod in [LODLevel.LOW, LODLevel.MEDIUM, LODLevel.HIGH]:
        item.update_lod(lod)
        qtbot.wait(1000)  # Pause for inspection
```

---

## 5. Dependencies

- **Upstream**:
  - E02-F04-T01 (LOD Manager provides LOD levels)
  - E02-F04-T02 (LOD Scene Manager handles registration)
  - E02-F03 (Net routing provides route points)
- **Downstream**:
  - E04 (Selection system must work with LOD items)

---

## 6. Implementation Notes

### 6.1 Design Decisions

1. **Two-tier LOD for nets**: Simplified (LOW) vs Full (MEDIUM/HIGH)
2. **Pre-computed paths**: Both paths created at construction for instant switching
3. **Junction dots only at intersections**: Reduces visual clutter
4. **Net labels at HIGH only**: Names not needed for topology understanding

### 6.2 Simplified Routing Rationale

- **Straight lines preserve topology**: Connections still visible
- **Reduced segment count**: Dramatically improves rendering performance
- **Maintains connectivity information**: Essential for circuit understanding
- **Avoids over-simplification**: Don't hide nets entirely

### 6.3 Future Enhancements

- **Bus routing**: Special rendering for multi-bit buses
- **Signal flow animation**: Animate signal propagation at HIGH LOD
- **Net coloring**: Color-code nets by type (clock, reset, data)
- **Smart label placement**: Avoid overlap with cells and other nets
- **Curved nets**: Bezier curves for more aesthetic routing at HIGH LOD
- **Net bundling**: Group parallel nets at LOW LOD

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task spec creation |
