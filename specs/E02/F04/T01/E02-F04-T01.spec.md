---
id: E02-F04-T01
title: LOD Manager and State Management
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F04
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - presentation
  - state-management
  - performance
clickup_task_id: ''
---

# Spec: E02-F04-T01 - LOD Manager and State Management

## 1. Overview

### 1.1 Problem Statement
Implement a centralized LOD (Level of Detail) management system that monitors zoom level changes and determines the appropriate detail level for rendering. The manager must provide threshold-based LOD level detection, manage LOD state transitions, and notify graphics items when LOD levels change.

### 1.2 Goals
- Create `LODManager` class to calculate LOD levels based on zoom factor
- Define LOD level thresholds (LOW <25%, MEDIUM 25-75%, HIGH >75%)
- Integrate with Qt `QGraphicsView` zoom change signals
- Provide event notification system for LOD changes
- Implement hysteresis to prevent flickering at threshold boundaries
- Ensure LOD transitions complete in <16ms for smooth 60fps rendering

---

## 2. Technical Requirements

### 2.1 LOD Level Enumeration

**Location**: `src/ink/presentation/canvas/lod_level.py`

```python
from enum import Enum


class LODLevel(Enum):
    """Level of detail for schematic rendering based on zoom factor"""
    LOW = 0      # <25% zoom: Minimal detail (bounding boxes only)
    MEDIUM = 1   # 25-75% zoom: Moderate detail (names, pin indicators)
    HIGH = 2     # >75% zoom: Full detail (all text, pins, routing)

    @property
    def threshold_min(self) -> float:
        """Minimum zoom factor for this LOD level"""
        if self == LODLevel.LOW:
            return 0.0
        elif self == LODLevel.MEDIUM:
            return 0.25
        else:  # HIGH
            return 0.75

    @property
    def threshold_max(self) -> float:
        """Maximum zoom factor for this LOD level"""
        if self == LODLevel.LOW:
            return 0.25
        elif self == LODLevel.MEDIUM:
            return 0.75
        else:  # HIGH
            return float('inf')
```

### 2.2 LOD Manager Implementation

**Location**: `src/ink/presentation/canvas/lod_manager.py`

```python
from typing import Optional, Callable
from dataclasses import dataclass
import logging

from .lod_level import LODLevel


@dataclass
class LODState:
    """Current state of the LOD system"""
    current_level: LODLevel
    zoom_factor: float
    transition_count: int = 0  # For debugging/metrics


class LODManager:
    """
    Manages Level of Detail state based on zoom factor.

    Responsibilities:
    - Calculate LOD level from zoom factor
    - Track current LOD state
    - Notify listeners on LOD changes
    - Implement hysteresis to prevent flickering
    """

    # Hysteresis buffer: 2% zone to prevent rapid switching
    HYSTERESIS_BUFFER = 0.02

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self._state = LODState(
            current_level=LODLevel.HIGH,
            zoom_factor=1.0
        )
        self._listeners: list[Callable[[LODLevel], None]] = []

    @property
    def current_level(self) -> LODLevel:
        """Get current LOD level"""
        return self._state.current_level

    @property
    def zoom_factor(self) -> float:
        """Get current zoom factor"""
        return self._state.zoom_factor

    def add_listener(self, callback: Callable[[LODLevel], None]) -> None:
        """
        Register a callback to be notified on LOD changes.

        Args:
            callback: Function called with new LODLevel when it changes
        """
        if callback not in self._listeners:
            self._listeners.append(callback)
            self.logger.debug(f"Added LOD listener: {callback.__name__}")

    def remove_listener(self, callback: Callable[[LODLevel], None]) -> None:
        """Unregister a LOD change callback"""
        if callback in self._listeners:
            self._listeners.remove(callback)
            self.logger.debug(f"Removed LOD listener: {callback.__name__}")

    def update_zoom(self, zoom_factor: float) -> Optional[LODLevel]:
        """
        Update zoom factor and recalculate LOD level.

        Args:
            zoom_factor: Current zoom factor (1.0 = 100%)

        Returns:
            New LOD level if it changed, None otherwise
        """
        self._state.zoom_factor = zoom_factor
        new_level = self._calculate_lod_level(zoom_factor)

        if new_level != self._state.current_level:
            old_level = self._state.current_level
            self._state.current_level = new_level
            self._state.transition_count += 1

            self.logger.info(
                f"LOD transition: {old_level.name} -> {new_level.name} "
                f"at zoom {zoom_factor:.2%}"
            )

            # Notify all listeners
            self._notify_listeners(new_level)
            return new_level

        return None

    def _calculate_lod_level(self, zoom_factor: float) -> LODLevel:
        """
        Determine LOD level based on zoom factor with hysteresis.

        Hysteresis prevents rapid switching at threshold boundaries:
        - Upward transition: threshold + buffer
        - Downward transition: threshold - buffer

        Args:
            zoom_factor: Current zoom factor

        Returns:
            Appropriate LOD level for this zoom factor
        """
        current = self._state.current_level

        # Upward transitions (increasing detail)
        if current == LODLevel.LOW and zoom_factor >= 0.25 + self.HYSTERESIS_BUFFER:
            return LODLevel.MEDIUM
        if current == LODLevel.MEDIUM and zoom_factor >= 0.75 + self.HYSTERESIS_BUFFER:
            return LODLevel.HIGH

        # Downward transitions (decreasing detail)
        if current == LODLevel.HIGH and zoom_factor < 0.75 - self.HYSTERESIS_BUFFER:
            return LODLevel.MEDIUM
        if current == LODLevel.MEDIUM and zoom_factor < 0.25 - self.HYSTERESIS_BUFFER:
            return LODLevel.LOW

        # Hard thresholds for initial state or large jumps
        if zoom_factor < 0.25:
            return LODLevel.LOW
        elif zoom_factor < 0.75:
            return LODLevel.MEDIUM
        else:
            return LODLevel.HIGH

    def _notify_listeners(self, new_level: LODLevel) -> None:
        """Notify all registered listeners of LOD change"""
        for callback in self._listeners:
            try:
                callback(new_level)
            except Exception as e:
                self.logger.error(
                    f"Error in LOD listener {callback.__name__}: {e}",
                    exc_info=True
                )

    def reset(self) -> None:
        """Reset LOD state to default (HIGH at 100% zoom)"""
        self._state = LODState(
            current_level=LODLevel.HIGH,
            zoom_factor=1.0
        )
        self.logger.debug("LOD state reset")

    def get_state_summary(self) -> dict:
        """Get current state for debugging/telemetry"""
        return {
            'current_level': self._state.current_level.name,
            'zoom_factor': self._state.zoom_factor,
            'transition_count': self._state.transition_count,
            'listener_count': len(self._listeners)
        }
```

### 2.3 Integration with QGraphicsView

**Location**: `src/ink/presentation/canvas/schematic_canvas.py` (modifications)

```python
from PySide6.QtWidgets import QGraphicsView
from PySide6.QtCore import Signal

from .lod_manager import LODManager, LODLevel


class SchematicCanvas(QGraphicsView):
    """Schematic rendering canvas with LOD support"""

    # Signal emitted when LOD level changes
    lod_changed = Signal(LODLevel)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._lod_manager = LODManager()

        # Connect LOD manager to signal
        self._lod_manager.add_listener(self._on_lod_changed)

    def wheelEvent(self, event):
        """Handle mouse wheel zoom and update LOD"""
        # Existing zoom logic...
        zoom_factor = 1.1 if event.angleDelta().y() > 0 else 0.9
        self.scale(zoom_factor, zoom_factor)

        # Update LOD based on new zoom level
        current_transform = self.transform()
        zoom_level = current_transform.m11()  # Get horizontal scale factor
        self._lod_manager.update_zoom(zoom_level)

    def _on_lod_changed(self, new_level: LODLevel):
        """Handle LOD level change"""
        self.lod_changed.emit(new_level)
        # Trigger scene update to re-render with new detail level
        self.scene().update()

    @property
    def lod_manager(self) -> LODManager:
        """Access to LOD manager for graphics items"""
        return self._lod_manager
```

### 2.4 Performance Requirements

- **LOD calculation**: <1ms per zoom event
- **Listener notification**: <15ms total (allow 1ms per listener x 15 max)
- **Hysteresis check**: No flickering when slowly crossing thresholds
- **Memory overhead**: <100 bytes for LODManager state

---

## 3. Dependencies

### 3.1 Upstream
- PySide6 `QGraphicsView` for zoom event handling
- Qt transform matrix for zoom factor extraction

### 3.2 Downstream
- Task E02-F04-T02: Cell graphics items subscribe to LOD changes
- Task E02-F04-T03: Pin/Net graphics items subscribe to LOD changes

### 3.3 External Dependencies
- Python standard library: `dataclasses`, `logging`, `enum`, `typing`
- PySide6 (Qt6 bindings)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `LODLevel` enum defines three levels (LOW, MEDIUM, HIGH)
- [ ] `LODManager` calculates correct LOD level for zoom factors
- [ ] LOD level transitions at correct thresholds (25%, 75%)
- [ ] Hysteresis buffer prevents flickering (Â±2% zones)
- [ ] Listener registration/unregistration works correctly
- [ ] All listeners notified on LOD change
- [ ] Integration with `QGraphicsView` zoom events

### 4.2 Edge Cases
- [ ] Handle zoom factor = 0.0 (return LOW)
- [ ] Handle zoom factor > 5.0 (return HIGH)
- [ ] Handle rapid zoom changes (multiple transitions)
- [ ] Handle listener exceptions without crashing
- [ ] Handle duplicate listener registration (ignored)

### 4.3 Performance
- [ ] LOD calculation completes in <1ms
- [ ] 10 listener notifications complete in <15ms
- [ ] Hysteresis prevents >1 transition per 0.04 zoom range
- [ ] No memory leaks in listener list management

### 4.4 Testing
- [ ] Unit tests for `_calculate_lod_level()` at all thresholds
- [ ] Unit tests for hysteresis behavior (up/down transitions)
- [ ] Unit tests for listener notification
- [ ] Unit tests for error handling in listener callbacks
- [ ] Integration test with Qt `QGraphicsView` zoom simulation
- [ ] Performance test: 1000 zoom updates in <1 second
- [ ] 90%+ code coverage on LODManager

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why hysteresis?**
- Prevents visual flickering when zoom level hovers near threshold
- 2% buffer provides smooth user experience without lag
- Common pattern in zoom/LOD systems

**Why listener pattern instead of Qt signals?**
- LODManager is pure Python (no QObject overhead)
- Flexible: supports both Qt and non-Qt listeners
- Simpler testing (no Qt event loop required)

**Why three LOD levels instead of continuous?**
- Clear thresholds simplify rendering logic
- Easy to understand and debug
- Sufficient granularity for MVP
- Can extend to 5 levels in P1 if needed

**Why track transition count?**
- Debugging: detect excessive transitions (performance issue)
- Telemetry: understand user zoom behavior
- Testing: verify hysteresis is working

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/presentation/canvas/test_lod_manager.py`):
- Test LOD calculation at exact thresholds
- Test hysteresis up/down transitions
- Test listener registration and notification
- Mock zoom events to verify state changes

**Integration Tests** (`tests/integration/presentation/test_lod_integration.py`):
- Create real `QGraphicsView` and simulate zoom
- Verify LOD changes propagate to scene items
- Test performance with multiple listeners

### 5.3 Future Enhancements (P1)
- Configurable thresholds per user preference
- Smooth interpolation between LOD levels
- Per-item LOD override (e.g., always show selected item at HIGH)
- LOD metrics dashboard for performance analysis

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F04 split |
