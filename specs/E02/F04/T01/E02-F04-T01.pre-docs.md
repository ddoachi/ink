# E02-F04-T01 - LOD Manager and State Management: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F04-T01
- **Task**: LOD Manager and State Management
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements the foundational Level of Detail (LOD) management system for the schematic canvas. The LODManager acts as a centralized coordinator that monitors zoom level changes and determines the appropriate detail level for rendering graphics items. This is a critical performance optimization that enables smooth rendering of large schematics by adaptively showing/hiding details based on the current zoom level.

**Core Deliverables:**
- `LODLevel` enumeration defining three detail levels (LOW, MEDIUM, HIGH)
- `LODManager` class for zoom monitoring and LOD calculation
- `LODState` dataclass for tracking current state
- Listener notification system for LOD changes
- Hysteresis implementation to prevent flickering
- Integration with Qt `QGraphicsView` zoom events

**Success Metrics:**
- LOD calculation completes in <1ms per zoom event
- Listener notification completes in <15ms total
- No visual flickering when crossing LOD thresholds
- Memory overhead <100 bytes for manager state

### 1.2 Context and Dependencies

**Upstream Dependencies:**
- PySide6 `QGraphicsView` for zoom event handling
- Qt transform matrix API for zoom factor extraction

**Downstream Consumers:**
- Task E02-F04-T02: Cell graphics items subscribe to LOD changes
- Task E02-F04-T03: Pin and net graphics items subscribe to LOD changes
- SchematicCanvas requires LODManager integration for zoom handling

**External Dependencies:**
- Python standard library: `dataclasses`, `logging`, `enum`, `typing`
- PySide6 Qt6 bindings

---

## 2. Architecture Decisions

### 2.1 LOD Level Design: Three Discrete Levels

**Decision**: Use three discrete LOD levels (LOW, MEDIUM, HIGH) with hard thresholds at 25% and 75% zoom.

**Rationale:**
- Discrete levels simplify rendering logic (clear branching in paint methods)
- Three levels provide sufficient granularity for schematic visualization
- Hard thresholds are predictable and easy to debug
- Aligns with Qt's `QStyleOptionGraphicsItem.levelOfDetail` patterns
- Can extend to 5 levels in P1 if needed without architectural changes

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| Three discrete levels | Simple branching, clear semantics | Less smooth than continuous | **Selected** |
| Continuous LOD (0.0-1.0) | Smooth interpolation possible | Complex rendering logic, harder to test | Rejected - unnecessary complexity |
| Five levels | Finer granularity | Increased complexity, more test cases | Deferred to P1 |
| Per-item LOD levels | Maximum flexibility | Inconsistent visuals, management overhead | Rejected - MVP doesn't need it |

### 2.2 Threshold Values: 25% and 75% Zoom

**Decision**: Use 25% and 75% zoom factors as LOD transition thresholds.

**Rationale:**
- 25% threshold: Below this, text becomes unreadable anyway
- 75% threshold: Above this, pins and routing details are clearly visible
- Empirically validated in similar schematic viewers (KiCad, gSchem)
- Provides good balance between performance and visual clarity

**Threshold Mapping:**
- LOW (<25%): Minimal rendering for performance
- MEDIUM (25-75%): Overview mode with cell names
- HIGH (>75%): Full detail for analysis

### 2.3 Hysteresis Implementation: ±2% Buffer Zones

**Decision**: Implement hysteresis with a 2% buffer zone around each threshold to prevent rapid LOD switching.

**Rationale:**
- Prevents "flickering" when zoom level hovers near threshold (e.g., 24.9% ↔ 25.1%)
- 2% buffer provides smooth user experience without introducing noticeable lag
- Common pattern in zoom-based LOD systems (games, CAD tools)
- Minimal complexity: simple conditional logic in `_calculate_lod_level()`

**Hysteresis Behavior:**
```
Upward transition (increasing detail):
  LOW → MEDIUM: zoom >= 25% + 2% = 27%
  MEDIUM → HIGH: zoom >= 75% + 2% = 77%

Downward transition (decreasing detail):
  HIGH → MEDIUM: zoom < 75% - 2% = 73%
  MEDIUM → LOW: zoom < 25% - 2% = 23%
```

**Edge Cases Handled:**
- Large zoom jumps (e.g., fit-to-view) use hard thresholds
- Initial state defaults to HIGH at 100% zoom
- Extreme zooms (<0% or >500%) clamp to valid ranges

### 2.4 Listener Pattern vs. Qt Signals

**Decision**: Use pure Python callback listener pattern instead of Qt signals for LOD notifications.

**Rationale:**
- LODManager is pure Python (no `QObject` inheritance required)
- Avoids Qt signal/slot overhead and boilerplate
- Flexible: supports both Qt and non-Qt listeners
- Simpler testing: no Qt event loop required for unit tests
- SchematicCanvas can still emit Qt signals based on listener callbacks

**Listener Registration:**
- `add_listener(callback: Callable[[LODLevel], None])`: Register callback
- `remove_listener(callback)`: Unregister callback
- `_notify_listeners(new_level)`: Invoke all registered callbacks

**Error Handling:**
- Listener exceptions caught and logged, don't crash manager
- Failed listeners don't prevent other listeners from executing

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| Pure Python callbacks | Simple, testable, no Qt dependency | Manual registration management | **Selected** |
| Qt signals/slots | Native Qt integration | Requires QObject, harder to unit test | Rejected |
| Observer pattern with ABC | Formal interface | Boilerplate overhead | Rejected - YAGNI |

### 2.5 State Tracking: Transition Count and Telemetry

**Decision**: Track transition count in `LODState` for debugging and telemetry.

**Rationale:**
- Debugging: Detect excessive transitions (indicates hysteresis not working)
- Telemetry: Understand user zoom behavior patterns
- Testing: Verify hysteresis prevents rapid switching
- Minimal overhead: single integer increment per transition

**State Information Tracked:**
- `current_level`: Current LOD level
- `zoom_factor`: Current zoom factor (0.0-5.0 range)
- `transition_count`: Total number of LOD changes since initialization

---

## 3. Implementation Strategy

### 3.1 Module Structure

**File Organization:**
```
src/ink/presentation/canvas/
├── lod_level.py           # LODLevel enum with threshold properties
├── lod_manager.py         # LODManager and LODState classes
└── schematic_canvas.py    # Integration with QGraphicsView
```

**Justification:**
- Separate module for `LODLevel` allows independent import by graphics items
- `LODManager` is self-contained with minimal dependencies
- Clean separation of concerns (state management vs. rendering)

### 3.2 Implementation Phases

**Phase 1: Core LOD Enumeration (2 hours)**
- Implement `LODLevel` enum with three values
- Add `threshold_min` and `threshold_max` properties
- Write unit tests for threshold ranges

**Phase 2: LODManager Implementation (3 hours)**
- Implement `LODManager` class with state management
- Add `update_zoom()` method with hysteresis logic
- Implement `_calculate_lod_level()` with all edge cases
- Add listener registration and notification
- Write unit tests for state transitions

**Phase 3: Qt Integration (1 hour)**
- Modify `SchematicCanvas.wheelEvent()` to call `update_zoom()`
- Add `_on_lod_changed()` callback to emit Qt signal
- Connect LOD manager to scene update

**Phase 4: Testing and Validation (1 hour)**
- Integration tests with Qt `QGraphicsView` simulation
- Performance benchmarks for 1000 zoom events
- Manual testing with real zoom interactions

**Total Estimated Time**: 6-7 hours (aligns with 6-hour estimate in spec)

### 3.3 Key Algorithms

**LOD Calculation with Hysteresis:**

```python
def _calculate_lod_level(self, zoom_factor: float) -> LODLevel:
    """
    Calculate LOD level with hysteresis to prevent flickering.

    Algorithm:
    1. Check upward transitions (increasing detail) with positive buffer
    2. Check downward transitions (decreasing detail) with negative buffer
    3. Fall through to hard thresholds for large jumps or initial state
    """
    current = self._state.current_level

    # Upward transitions: threshold + buffer
    if current == LODLevel.LOW and zoom_factor >= 0.25 + HYSTERESIS_BUFFER:
        return LODLevel.MEDIUM
    if current == LODLevel.MEDIUM and zoom_factor >= 0.75 + HYSTERESIS_BUFFER:
        return LODLevel.HIGH

    # Downward transitions: threshold - buffer
    if current == LODLevel.HIGH and zoom_factor < 0.75 - HYSTERESIS_BUFFER:
        return LODLevel.MEDIUM
    if current == LODLevel.MEDIUM and zoom_factor < 0.25 - HYSTERESIS_BUFFER:
        return LODLevel.LOW

    # Hard thresholds (initial state or large jumps)
    if zoom_factor < 0.25:
        return LODLevel.LOW
    elif zoom_factor < 0.75:
        return LODLevel.MEDIUM
    else:
        return LODLevel.HIGH
```

**Listener Notification with Error Handling:**

```python
def _notify_listeners(self, new_level: LODLevel) -> None:
    """
    Notify all registered listeners of LOD change.

    Error Handling:
    - Catch exceptions from individual listeners
    - Log errors but continue notifying other listeners
    - Don't let listener errors crash the manager
    """
    for callback in self._listeners:
        try:
            callback(new_level)
        except Exception as e:
            self.logger.error(
                f"Error in LOD listener {callback.__name__}: {e}",
                exc_info=True
            )
```

### 3.4 Integration Points

**Qt QGraphicsView Integration:**

```python
class SchematicCanvas(QGraphicsView):
    # Signal emitted when LOD level changes (for Qt components)
    lod_changed = Signal(LODLevel)

    def __init__(self, parent=None):
        super().__init__(parent)
        self._lod_manager = LODManager()
        self._lod_manager.add_listener(self._on_lod_changed)

    def wheelEvent(self, event):
        # Perform zoom transformation
        zoom_factor = 1.1 if event.angleDelta().y() > 0 else 0.9
        self.scale(zoom_factor, zoom_factor)

        # Extract current zoom level from transform
        current_transform = self.transform()
        zoom_level = current_transform.m11()  # Horizontal scale factor

        # Update LOD manager
        self._lod_manager.update_zoom(zoom_level)

    def _on_lod_changed(self, new_level: LODLevel):
        # Emit Qt signal for Qt-based listeners
        self.lod_changed.emit(new_level)

        # Trigger scene redraw
        self.scene().update()
```

**Graphics Item Subscription:**

```python
# In CellGraphicsItem (from T02)
def __init__(self, cell: Cell, canvas: SchematicCanvas):
    super().__init__()
    self._cell = cell

    # Subscribe to LOD changes via canvas
    canvas.lod_changed.connect(self.set_lod_level)
```

---

## 4. Technical Deep Dive

### 4.1 Zoom Factor Extraction from Qt Transform

**Qt Transform Matrix:**

Qt's `QGraphicsView` uses a `QTransform` matrix for view transformations:

```
| m11  m12  m13 |   | sx   0   0 |
| m21  m22  m23 | = |  0  sy   0 |  (for pure scale/translate)
| m31  m32  m33 |   | tx  ty   1 |

Where:
- m11 (sx): horizontal scale factor (zoom level)
- m22 (sy): vertical scale factor (should equal m11 for uniform zoom)
- m31 (tx), m32 (ty): translation offsets
```

**Zoom Factor Extraction:**

```python
# Get current transform from view
transform = self.transform()

# Extract horizontal scale factor (zoom level)
zoom_factor = transform.m11()

# Sanity check: verify uniform scaling
assert abs(transform.m11() - transform.m22()) < 1e-6
```

**Coordinate System:**
- `zoom_factor = 1.0`: 100% zoom (1:1 schematic to screen)
- `zoom_factor = 0.5`: 50% zoom (zoomed out)
- `zoom_factor = 2.0`: 200% zoom (zoomed in)

### 4.2 Hysteresis State Machine

**State Diagram:**

```
                    zoom >= 27%
    ┌─────┐     ─────────────────►    ┌────────┐
    │ LOW │                            │ MEDIUM │
    └─────┘     ◄─────────────────     └────────┘
                    zoom < 23%              │
                                            │ zoom >= 77%
                                            ▼
                                       ┌──────┐
                                       │ HIGH │
                                       └──────┘
                                            │
                                            │ zoom < 73%
                                            ▼
                                       ┌────────┐
                                       │ MEDIUM │
                                       └────────┘
```

**Key Invariants:**
- Only one LOD level active at any time
- Transitions only occur when crossing buffer zones
- No oscillation within buffer zones (23-27% and 73-77%)

### 4.3 Performance Considerations

**LOD Calculation Complexity:**
- Time complexity: O(1) - constant time regardless of item count
- Space complexity: O(1) - fixed state size
- No allocations during calculation (all branching logic)

**Listener Notification Complexity:**
- Time complexity: O(n) where n = number of listeners
- Expected n < 15 for MVP (cell items, pin items, net items)
- Target: <1ms per listener × 15 = <15ms total

**Memory Overhead:**
```
LODManager size:
  - logger reference: 8 bytes
  - _state (LODState): 24 bytes (int + float + int + padding)
  - _listeners (list): 8 bytes + 8n bytes (n listener references)

Total: ~40 bytes + 8n bytes
For n=15: ~160 bytes (well under 100 byte target is 64 bytes base)
```

**Optimization Opportunities:**
- Use `__slots__` on `LODState` to reduce memory (24 → 16 bytes)
- Cache listener count to avoid `len()` calls
- Early exit from `update_zoom()` if zoom hasn't changed significantly

### 4.4 Edge Cases and Error Handling

**Edge Case Matrix:**

| Scenario | Input | Expected Behavior |
|----------|-------|-------------------|
| Extreme zoom out | zoom_factor = 0.01 | Return LODLevel.LOW |
| Extreme zoom in | zoom_factor = 10.0 | Return LODLevel.HIGH |
| Negative zoom | zoom_factor = -0.5 | Clamp to 0.0, return LODLevel.LOW |
| Threshold boundary | zoom_factor = 0.25 exactly | Return current level (hysteresis) |
| Rapid zoom changes | Multiple `update_zoom()` calls | Transitions counted correctly |
| Listener throws exception | Callback raises RuntimeError | Log error, continue to next listener |
| Duplicate listener | Same callback added twice | Only notify once (duplicate prevention) |

**Error Handling Strategy:**
- Invalid zoom factors: Clamp to valid range [0.0, 5.0]
- Listener exceptions: Catch, log, continue
- State corruption: Reset to default via `reset()` method
- Thread safety: Not required for MVP (Qt runs on main thread)

---

## 5. Risk Analysis

### 5.1 Performance Risks

**Risk R01: Listener notification overhead exceeds 16ms frame budget**

- **Impact**: Medium - Causes frame drops during zoom
- **Probability**: Low - Expected 10-15 listeners × <1ms each
- **Mitigation**:
  - Profile listener execution times during integration testing
  - Set hard limit of 15 listeners with validation
  - Optimize slow listeners (e.g., cache expensive calculations)
  - Fallback: Throttle `update_zoom()` calls to max 60Hz

**Risk R02: Hysteresis buffer too small causes flickering**

- **Impact**: Low - Aesthetic issue, doesn't block functionality
- **Probability**: Medium - 2% buffer may not be enough for all zoom patterns
- **Symptoms**: Items flicker on/off when zooming slowly near thresholds
- **Mitigation**:
  - Make `HYSTERESIS_BUFFER` configurable (class constant)
  - Add user preference for buffer size in P1
  - Test with various zoom speeds and adjust empirically
  - Recommended buffer range: 1-5%

### 5.2 Integration Risks

**Risk R03: Qt transform extraction fails on non-uniform scaling**

- **Impact**: High - Incorrect LOD levels shown
- **Probability**: Low - User zoom is always uniform
- **Symptoms**: LOD level doesn't match visual zoom
- **Mitigation**:
  - Add assertion to verify `m11 == m22` (uniform scaling)
  - Log warning if non-uniform scaling detected
  - Use average of `m11` and `m22` as fallback

**Risk R04: Listener registration leaks causing memory growth**

- **Impact**: Medium - Accumulates over long sessions
- **Probability**: Medium - Items added but not removed
- **Symptoms**: Listener list grows unbounded, slow notifications
- **Mitigation**:
  - Document listener lifecycle (add on create, remove on destroy)
  - Add `remove_listener()` calls in item destructors
  - Add max listener count warning (log if >100)
  - Use weak references in P1 (automatic cleanup)

### 5.3 Testing Risks

**Risk R05: Qt event loop required for integration tests complicates CI**

- **Impact**: Low - Slower tests, potential CI flakiness
- **Probability**: High - Qt requires QApplication instance
- **Mitigation**:
  - Use `pytest-qt` plugin for test fixtures
  - Separate unit tests (pure Python, no Qt) from integration tests
  - Mock Qt components in unit tests where possible
  - Run integration tests with Xvfb on Linux CI

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test Coverage Targets:**
- `LODLevel`: 100% coverage (simple enum)
- `LODManager`: 95%+ coverage
- `_calculate_lod_level()`: 100% coverage (critical path)

**Test Cases:**

```python
# tests/unit/presentation/canvas/test_lod_level.py
def test_lod_level_threshold_min():
    assert LODLevel.LOW.threshold_min == 0.0
    assert LODLevel.MEDIUM.threshold_min == 0.25
    assert LODLevel.HIGH.threshold_min == 0.75

def test_lod_level_threshold_max():
    assert LODLevel.LOW.threshold_max == 0.25
    assert LODLevel.MEDIUM.threshold_max == 0.75
    assert LODLevel.HIGH.threshold_max == float('inf')
```

```python
# tests/unit/presentation/canvas/test_lod_manager.py
def test_lod_manager_initial_state():
    manager = LODManager()
    assert manager.current_level == LODLevel.HIGH
    assert manager.zoom_factor == 1.0

def test_lod_transition_low_to_medium():
    manager = LODManager()
    manager._state.current_level = LODLevel.LOW

    # Should NOT transition at 25% (hysteresis)
    result = manager.update_zoom(0.25)
    assert result is None
    assert manager.current_level == LODLevel.LOW

    # Should transition at 27% (25% + 2% buffer)
    result = manager.update_zoom(0.27)
    assert result == LODLevel.MEDIUM
    assert manager.current_level == LODLevel.MEDIUM

def test_hysteresis_prevents_flickering():
    manager = LODManager()
    manager._state.current_level = LODLevel.MEDIUM

    # Oscillate around 75% threshold
    for zoom in [0.74, 0.76, 0.74, 0.76]:
        manager.update_zoom(zoom)

    # Should remain MEDIUM (not oscillate to HIGH)
    assert manager.current_level == LODLevel.MEDIUM

def test_listener_notification():
    manager = LODManager()
    notifications = []

    def callback(level: LODLevel):
        notifications.append(level)

    manager.add_listener(callback)
    manager.update_zoom(0.1)  # Trigger LOW transition

    assert len(notifications) == 1
    assert notifications[0] == LODLevel.LOW

def test_listener_exception_handling():
    manager = LODManager()

    def bad_callback(level: LODLevel):
        raise RuntimeError("Listener error")

    def good_callback(level: LODLevel):
        pass  # Should still be called

    manager.add_listener(bad_callback)
    manager.add_listener(good_callback)

    # Should not raise exception
    manager.update_zoom(0.1)

def test_extreme_zoom_values():
    manager = LODManager()

    # Extreme zoom out
    result = manager.update_zoom(0.001)
    assert manager.current_level == LODLevel.LOW

    # Extreme zoom in
    result = manager.update_zoom(10.0)
    assert manager.current_level == LODLevel.HIGH

def test_transition_count_tracking():
    manager = LODManager()
    initial_count = manager._state.transition_count

    manager.update_zoom(0.1)  # HIGH → LOW
    assert manager._state.transition_count == initial_count + 1

    manager.update_zoom(1.0)  # LOW → HIGH
    assert manager._state.transition_count == initial_count + 2
```

### 6.2 Integration Tests

**Test Cases:**

```python
# tests/integration/presentation/test_lod_integration.py
def test_lod_manager_with_qgraphicsview(qtbot):
    """Test LOD manager integration with real Qt view."""
    from PySide6.QtWidgets import QGraphicsView, QGraphicsScene

    scene = QGraphicsScene()
    view = QGraphicsView(scene)
    lod_manager = LODManager()

    # Simulate zoom via transform
    view.scale(0.5, 0.5)  # 50% zoom

    # Extract zoom and update manager
    zoom_factor = view.transform().m11()
    lod_manager.update_zoom(zoom_factor)

    assert lod_manager.current_level == LODLevel.MEDIUM

def test_lod_integration_with_scene_update(qtbot):
    """Test that LOD changes trigger scene updates."""
    from PySide6.QtWidgets import QGraphicsScene
    from unittest.mock import Mock

    scene = QGraphicsScene()
    update_spy = Mock()
    scene.update = update_spy

    # SchematicCanvas integration (simplified)
    lod_manager = LODManager()

    def on_lod_changed(level: LODLevel):
        scene.update()

    lod_manager.add_listener(on_lod_changed)
    lod_manager.update_zoom(0.1)  # Trigger transition

    update_spy.assert_called_once()
```

### 6.3 Performance Tests

**Benchmarks:**

```python
# tests/performance/test_lod_performance.py
import pytest

@pytest.mark.benchmark
def test_lod_calculation_performance(benchmark):
    """LOD calculation should complete in <1ms."""
    manager = LODManager()

    def calculate():
        manager.update_zoom(0.5)

    result = benchmark(calculate)
    assert result < 0.001  # <1ms

@pytest.mark.benchmark
def test_listener_notification_performance(benchmark):
    """Notify 15 listeners in <15ms."""
    manager = LODManager()

    # Register 15 dummy listeners
    for i in range(15):
        manager.add_listener(lambda level: None)

    def notify():
        manager.update_zoom(0.1 if manager.current_level == LODLevel.HIGH else 1.0)

    result = benchmark(notify)
    assert result < 0.015  # <15ms

def test_no_memory_leaks():
    """Verify no memory leaks after 1000 transitions."""
    import tracemalloc

    tracemalloc.start()
    manager = LODManager()

    # Perform 1000 transitions
    for i in range(1000):
        manager.update_zoom(0.1 if i % 2 == 0 else 1.0)

    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    # Should not grow significantly (allow <10KB growth)
    assert current < 10000
```

---

## 7. Definition of Done

### 7.1 Functional Completeness

- [ ] `LODLevel` enum implemented with three levels (LOW, MEDIUM, HIGH)
- [ ] `LODLevel.threshold_min` and `threshold_max` properties implemented
- [ ] `LODState` dataclass tracks current level, zoom factor, transition count
- [ ] `LODManager` class implemented with state management
- [ ] `update_zoom()` method calculates LOD level with hysteresis
- [ ] `_calculate_lod_level()` handles all edge cases (extreme zoom, boundaries)
- [ ] Listener registration via `add_listener()` and `remove_listener()`
- [ ] `_notify_listeners()` invokes all callbacks with error handling
- [ ] Integration with `SchematicCanvas.wheelEvent()`
- [ ] Qt `lod_changed` signal emitted on transitions

### 7.2 Testing Completeness

- [ ] Unit tests for `LODLevel` threshold properties (100% coverage)
- [ ] Unit tests for LOD calculation at all thresholds
- [ ] Unit tests for hysteresis behavior (up/down transitions)
- [ ] Unit tests for listener notification
- [ ] Unit tests for error handling in listener callbacks
- [ ] Unit tests for extreme zoom values (0.0, 10.0)
- [ ] Integration test with Qt `QGraphicsView` zoom simulation
- [ ] Performance benchmark: 1000 zoom updates in <1 second
- [ ] Performance benchmark: 15 listener notifications in <15ms
- [ ] Memory leak test: No growth after 1000 transitions
- [ ] Code coverage: 90%+ on `LODManager`

### 7.3 Code Quality

- [ ] All functions have type hints
- [ ] All public methods documented with docstrings
- [ ] Logging added at INFO level for transitions
- [ ] Logging added at DEBUG level for listener registration
- [ ] No PEP 8 violations (ruff check passes)
- [ ] No type errors (mypy passes)
- [ ] Code reviewed and approved
- [ ] No TODO comments in production code

### 7.4 Integration Readiness

- [ ] `LODManager` exposed via `SchematicCanvas.lod_manager` property
- [ ] Qt signal `SchematicCanvas.lod_changed` emits on transitions
- [ ] Downstream tasks (T02, T03) can subscribe to LOD changes
- [ ] Scene update triggered on LOD transitions
- [ ] Documentation added for listener usage pattern

---

## 8. Open Questions and Decisions Needed

### 8.1 Hysteresis Buffer Size

**Q1**: Is 2% hysteresis buffer sufficient to prevent flickering?

- **Options**:
  - Option A: 2% buffer (current spec)
  - Option B: 5% buffer (more conservative)
  - Option C: Configurable buffer via constant
- **Recommendation**: Start with 2%, make it a class constant for easy tuning
- **Decision Needed By**: Before Phase 2 implementation
- **Owner**: Developer implementing T01

**Testing Plan**: Manually zoom slowly near 25% and 75% thresholds, observe for flickering

### 8.2 Listener Count Limit

**Q2**: Should we enforce a maximum listener count?

- **Concern**: Unbounded listener list could grow if items not cleaned up
- **Options**:
  - Option A: No limit (trust cleanup)
  - Option B: Log warning at 100 listeners
  - Option C: Hard limit at 1000 listeners
- **Recommendation**: Option B - log warning as defensive measure
- **Decision Needed By**: Before Phase 2 implementation

### 8.3 Thread Safety

**Q3**: Does LODManager need to be thread-safe?

- **Context**: Qt runs on main thread, zoom events always on main thread
- **Options**:
  - Option A: No thread safety (current design)
  - Option B: Add mutex for listener list
- **Recommendation**: Option A - not needed for MVP, can add in P1 if needed
- **Decision Needed By**: Before implementation

---

## 9. Success Metrics and Validation

### 9.1 Performance KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| LOD Calculation Time | <1ms | Performance benchmark |
| Listener Notification (15 listeners) | <15ms | Performance benchmark |
| Memory Overhead | <100 bytes base | tracemalloc |
| Transition Count Accuracy | 100% | Unit tests |

### 9.2 Quality KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Unit Test Coverage | 90%+ | pytest-cov |
| Integration Test Pass Rate | 100% | CI/CD |
| Edge Case Coverage | 100% | Test case review |
| Code Review Approval | Required | GitHub PR |

### 9.3 User Experience KPIs

| Metric | Target | Validation Method |
|--------|--------|------------------|
| No Visual Flickering | 0 occurrences | Manual testing at thresholds |
| Smooth Transitions | Subjective "smooth" | User acceptance testing |

---

## 10. Timeline and Milestones

### 10.1 Implementation Schedule

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| Phase 1: LODLevel Enum | 2 hours | Enum with threshold properties |
| Phase 2: LODManager Core | 3 hours | State management, hysteresis |
| Phase 3: Qt Integration | 1 hour | SchematicCanvas integration |
| Phase 4: Testing | 1 hour | Unit and integration tests |
| **Total** | **6-7 hours** | Fully tested LODManager |

### 10.2 Milestones

| Milestone | Success Criteria |
|-----------|-----------------|
| M1: LODLevel Complete | Enum passes all unit tests |
| M2: Core Manager Complete | LODManager calculates levels correctly with hysteresis |
| M3: Integration Complete | SchematicCanvas zoom triggers LOD changes |
| M4: Testing Complete | All tests passing, 90%+ coverage |

---

## 11. References and Resources

### 11.1 Technical References

**Qt Graphics View LOD:**
- Qt Documentation: `QStyleOptionGraphicsItem::levelOfDetailFromTransform()`
- Qt Example: "Elastic Nodes" demo (LOD implementation)

**Hysteresis Patterns:**
- Wikipedia: Hysteresis (control systems)
- Game Development: LOD systems with hysteresis (Unity, Unreal)

**Observer Pattern:**
- Design Patterns (Gang of Four): Observer pattern
- Python Patterns: Callback-based notification systems

### 11.2 Code Examples

**Reference Implementations:**
- Qt Circuit Example: LOD in schematic rendering
- KiCad: Zoom-based detail level switching
- Blender: LOD management in 3D viewport

### 11.3 Internal Documentation

- `/home/joohan/dev/project-ink/ink/specs/E02/F04/E02-F04.spec.md` - Parent feature spec
- `/home/joohan/dev/project-ink/ink/specs/E02/E02.spec.md` - Epic spec
- `/home/joohan/dev/project-ink/ink/CLAUDE.md` - Project architecture guidelines

---

## Appendices

### Appendix A: LOD State Transition Diagram

```
Initial State: HIGH (zoom = 1.0)

                zoom < 23%           zoom >= 27%
    ┌─────┐  ◄─────────────  ┌────────┐  ─────────────►  ┌──────┐
    │ LOW │                  │ MEDIUM │                   │ HIGH │
    └─────┘  ─────────────►  └────────┘  ◄─────────────  └──────┘
                zoom >= 27%           zoom < 73%

Hysteresis Zones:
  - 23% - 27%: No transition (maintains current state)
  - 73% - 77%: No transition (maintains current state)

Hard Thresholds (large jumps):
  - zoom < 25%: → LOW
  - 25% ≤ zoom < 75%: → MEDIUM
  - zoom ≥ 75%: → HIGH
```

### Appendix B: Listener Lifecycle Pattern

```python
# Pattern 1: Graphics Item Lifecycle
class CellGraphicsItem(QGraphicsItem):
    def __init__(self, canvas: SchematicCanvas):
        super().__init__()
        self._canvas = canvas

        # Subscribe to LOD changes
        canvas.lod_changed.connect(self.set_lod_level)

    def __del__(self):
        # Cleanup (Qt handles signal disconnection automatically)
        pass

# Pattern 2: Manual Listener Management
class CustomListener:
    def __init__(self, lod_manager: LODManager):
        self._manager = lod_manager
        self._manager.add_listener(self._on_lod_changed)

    def cleanup(self):
        self._manager.remove_listener(self._on_lod_changed)

    def _on_lod_changed(self, level: LODLevel):
        # Handle LOD change
        pass
```

### Appendix C: Performance Profiling Guide

**Profiling LOD Manager Performance:**

```bash
# Run performance benchmarks
pytest tests/performance/test_lod_performance.py --benchmark-only

# Profile listener notification overhead
python -m cProfile -s cumtime tests/performance/test_lod_performance.py

# Memory profiling
python -m memory_profiler tests/performance/test_lod_performance.py
```

**Expected Results:**
- LOD calculation: <0.1ms per call
- 15 listener notifications: 5-10ms total
- Memory growth: <1KB per 1000 transitions

---

**Document Status**: Ready for Implementation
**Next Steps**: Begin Phase 1 (LODLevel enum implementation), schedule code review after Phase 2
