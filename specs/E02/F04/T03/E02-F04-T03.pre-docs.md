# E02-F04-T03 - Pin and Net LOD Rendering: Pre-Implementation Planning

## Document Information
- **Task ID**: E02-F04-T03
- **Task**: Pin and Net LOD Rendering
- **Status**: Pre-Implementation
- **Created**: 2025-12-26
- **Author**: Architecture Team

---

## 1. Overview

### 1.1 Task Summary

This task implements LOD-aware rendering for pins and nets, completing the schematic LOD system. Pins and nets are the most numerous graphics items in a schematic (10-20 pins per cell, 1-2 nets per pin), making them critical for performance optimization. By implementing intelligent LOD rendering, we can dramatically reduce rendering overhead at low zoom levels where pin details are invisible anyway.

**Core Deliverables:**
- `PinGraphicsItem` class with three LOD levels: hidden, indicator dots, full labels
- `NetGraphicsItem` class with two rendering modes: simplified straight lines, full orthogonal routing
- LOD subscription and dynamic rendering updates
- Color-coded pin indicators by direction (input/output/inout)
- Simplified net path generation for LOW LOD
- Integration with `CellGraphicsItem` parent items

**Success Metrics:**
- 1000 nets render at LOW LOD in <5ms (simplified paths)
- 500 nets render at HIGH LOD in <10ms (full orthogonal routing)
- 100 pins render at MEDIUM LOD in <1ms (dots only)
- 100 pins render at HIGH LOD in <5ms (dots + text)
- LOD transitions for 500 pins + 1000 nets complete in <16ms

### 1.2 Context and Dependencies

**Upstream Dependencies:**
- Task E02-F04-T01: `LODManager` and `LODLevel` definitions
- Task E02-F04-T02: `CellGraphicsItem` provides parent for pin items
- E02-F03: Net routing provides routing points (not yet implemented)
- Domain models: `Pin` entity, `Net` entity, `PinDirection` enum

**Downstream Consumers:**
- E04-F01: Selection highlighting for pins and nets at all LOD levels
- E03: Expansion adds new pins/nets with appropriate LOD

**External Dependencies:**
- PySide6: `QGraphicsEllipseItem`, `QGraphicsTextItem`, `QGraphicsItemGroup`, `QGraphicsPathItem`, `QPainterPath`
- Domain: `ink.domain.model.pin.Pin`, `ink.domain.model.net.Net`, `ink.domain.value_objects.pin_direction.PinDirection`

---

## 2. Architecture Decisions

### 2.1 Pin Item Structure: QGraphicsItemGroup

**Decision**: Use `QGraphicsItemGroup` as the base class for `PinGraphicsItem` to manage multiple child components (indicator dot, name label, direction arrow).

**Rationale:**
- Pins have multiple visual components that need coordinated positioning
- `QGraphicsItemGroup` manages children as a single unit
- Simplifies coordinate transformations (children in local coordinates)
- Enables independent visibility control for each component
- Supports future enhancements (direction arrows, tooltips) without refactoring

**Pin Components:**
- Indicator dot: `QGraphicsEllipseItem` (always present, sized by LOD)
- Name label: `QGraphicsTextItem` (visible at HIGH LOD only)
- Direction arrow: `QGraphicsItem` (future enhancement, P1)

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| QGraphicsItemGroup | Manages children naturally | Slightly more overhead than single item | **Selected** |
| Custom QGraphicsItem | Maximum control | Must manage all children manually | Rejected - complexity |
| Single QGraphicsEllipseItem | Simplest | Can't show name label separately | Rejected - insufficient |
| Composite pattern manually | Full flexibility | Reinventing Qt functionality | Rejected - YAGNI |

### 2.2 Pin LOD Levels: Hidden, Indicator, Full Detail

**Decision**: Implement three distinct LOD levels for pins with different visibility and detail.

**LOD Definitions:**

| LOD Level | Visibility | Indicator Size | Name Label | Direction Arrow |
|-----------|-----------|----------------|------------|-----------------|
| LOW | Hidden | N/A | Hidden | Hidden |
| MEDIUM | Visible | Small (3px radius) | Hidden | Hidden |
| HIGH | Visible | Large (5px radius) | Visible | Future (P1) |

**Rationale:**
- LOW: Pins completely hidden saves significant rendering time
- MEDIUM: Small dots show pin positions without clutter
- HIGH: Full detail for analysis (names, directions)
- Graduated detail matches zoom levels naturally

**Why hide pins at LOW LOD?**
- At <25% zoom, pin dots would be <1 pixel (invisible anyway)
- Text rendering overhead eliminated (major performance win)
- Nets connect directly to cell bounding boxes (simpler routing visualization)
- User isn't analyzing pin-level details at this zoom anyway

### 2.3 Pin Color Coding by Direction

**Decision**: Color-code pin indicator dots based on pin direction (INPUT=blue, OUTPUT=orange, INOUT=gray).

**Color Scheme:**
```python
INPUT_COLOR = QColor(100, 150, 255)   # Blue
OUTPUT_COLOR = QColor(255, 150, 100)  # Orange
INOUT_COLOR = QColor(150, 150, 150)   # Gray
```

**Rationale:**
- MEDIUM LOD has no text labels - color provides visual cue
- Helps distinguish inputs from outputs at a glance
- Standard convention in schematic viewers (blue=input, red/orange=output)
- Minimal implementation cost (simple brush assignment)

**Accessibility Consideration:**
- Colors chosen to be distinguishable for common color vision deficiencies
- P1: Add user-configurable color themes
- P1: Add optional icons instead of just color

### 2.4 Net LOD Levels: Simplified vs. Full Routing

**Decision**: Implement two distinct rendering modes for nets (LOW=simplified, MEDIUM/HIGH=full).

**Net Rendering Modes:**

| LOD Level | Rendering | Path Complexity | Line Width |
|-----------|-----------|-----------------|------------|
| LOW | Straight line from start to end | 1 segment | 1.0px (thin) |
| MEDIUM | Full orthogonal routing | 5-10 segments avg | 2.0px (thick) |
| HIGH | Full orthogonal routing | 5-10 segments avg | 2.0px (thick) |

**Rationale:**
- LOW LOD: Simplified straight line shows connectivity clearly without routing details
- 5-10x performance improvement (1 segment vs 5-10 segments)
- At <25% zoom, orthogonal details are too small to see anyway
- MEDIUM/HIGH identical: routing details visible, no further simplification needed

**Path Simplification Algorithm:**
```python
# LOW LOD: Just start and end points
simplified_path = [routing_points[0], routing_points[-1]]

# MEDIUM/HIGH LOD: Full path
full_path = routing_points  # All points from router
```

**Why not simplify MEDIUM vs HIGH?**
- MEDIUM is 25-75% zoom - routing already clearly visible
- Simplification wouldn't provide significant performance benefit
- Implementation complexity not justified
- Can revisit in P1 if performance testing shows need

### 2.5 Net Item Structure: QGraphicsPathItem

**Decision**: Use `QGraphicsPathItem` as the base class for `NetGraphicsItem` with dynamic path updates.

**Rationale:**
- `QPainterPath` naturally represents polyline routing
- Efficient rendering of multi-segment paths
- Easy to update path dynamically (LOD changes, rerouting)
- Qt optimizes path rendering (stroking, anti-aliasing)
- Supports future enhancements (junction dots, arc jumps)

**Path Management:**
- Store full routing points internally (`_routing_points`)
- Generate `QPainterPath` based on current LOD
- Update path on LOD changes or rerouting

**Alternatives Considered:**

| Approach | Pros | Cons | Verdict |
|----------|------|------|---------|
| QGraphicsPathItem | Optimized for polylines | Path must be regenerated on changes | **Selected** |
| Multiple QGraphicsLineItem | Simple per-segment | Inefficient for multi-segment nets | Rejected |
| Custom QGraphicsItem paint | Maximum control | Reimplementing Qt functionality | Rejected |
| QGraphicsLineItem (single) | Simplest | Can't show orthogonal routing | Rejected - insufficient |

---

## 3. Implementation Strategy

### 3.1 Module Structure

**File Organization:**
```
src/ink/presentation/canvas/
├── pin_item.py            # PinGraphicsItem implementation
├── net_item.py            # NetGraphicsItem implementation
├── cell_item.py           # CellGraphicsItem (from T02)
├── lod_level.py           # LODLevel enum (from T01)
└── schematic_canvas.py    # Canvas integration
```

**Class Hierarchy:**

```
# Pins
QGraphicsItemGroup (Qt)
    └── PinGraphicsItem
            ├── _indicator_dot: QGraphicsEllipseItem (child)
            ├── _name_label: QGraphicsTextItem (child)
            └── _direction_arrow: QGraphicsItem (future, P1)

# Nets
QGraphicsPathItem (Qt)
    └── NetGraphicsItem
            └── path: QPainterPath (internal)
```

### 3.2 Implementation Phases

**Phase 1: Pin Graphics Item Structure (2 hours)**
- Define `PinGraphicsItem` class extending `QGraphicsItemGroup`
- Implement `__init__()` with pin parameter
- Add `_setup_graphics()` for child item creation (dot, label)
- Add `_get_pin_color()` for direction-based coloring
- Write unit tests for initialization

**Phase 2: Pin LOD Rendering (2 hours)**
- Implement `set_lod_level()` with three branches
- Implement `_render_low_detail()` - hide completely
- Implement `_render_medium_detail()` - small dot only
- Implement `_render_high_detail()` - dot + name label
- Write unit tests for LOD transitions

**Phase 3: Net Graphics Item Structure (1.5 hours)**
- Define `NetGraphicsItem` class extending `QGraphicsPathItem`
- Implement `__init__()` with net and routing points
- Add `_update_path()` to generate `QPainterPath`
- Write unit tests for initialization

**Phase 4: Net LOD Rendering (1.5 hours)**
- Implement `set_lod_level()` with two modes
- Implement `_render_simplified_path()` - straight line
- Implement `_render_full_path()` - orthogonal routing
- Add `update_routing()` for dynamic path changes
- Write unit tests for path simplification

**Phase 5: Canvas Integration (1 hour)**
- Modify `SchematicCanvas` to track pin and net items
- Add `add_pin_item()` and `add_net_item()` methods
- Update `_on_lod_changed()` to notify pins and nets
- Write integration tests

**Total Estimated Time**: 8 hours (aligns with spec estimate)

### 3.3 Key Algorithms

**Pin Indicator Sizing by LOD:**

```python
def set_lod_level(self, lod_level: LODLevel) -> None:
    """
    Update pin rendering based on LOD level.

    Algorithm:
    1. Early exit if LOD unchanged
    2. Branch based on target LOD
    3. Update indicator size and visibility
    4. Update label visibility
    5. Trigger redraw
    """
    if lod_level == self._current_lod:
        return

    self._current_lod = lod_level

    if lod_level == LODLevel.LOW:
        self._render_low_detail()
    elif lod_level == LODLevel.MEDIUM:
        self._render_medium_detail()
    else:  # HIGH
        self._render_high_detail()

    self.update()

def _render_medium_detail(self) -> None:
    """Show small indicator dot, hide label."""
    self.setVisible(True)

    # Small indicator
    radius = self.INDICATOR_RADIUS_MEDIUM
    self._indicator_dot.setRect(-radius, -radius, radius * 2, radius * 2)
    self._indicator_dot.setVisible(True)

    # Hide label
    self._name_label.setVisible(False)
```

**Pin Name Label Positioning:**

```python
def _setup_graphics(self):
    """
    Create pin indicator and label.

    Label positioning:
    - INPUT pins: Label on left side
    - OUTPUT/INOUT pins: Label on right side
    """
    # Color-coded indicator dot
    color = self._get_pin_color()
    self._indicator_dot = QGraphicsEllipseItem(self)
    self._indicator_dot.setPen(QPen(Qt.black, 1.0))
    self._indicator_dot.setBrush(QBrush(color))

    # Name label
    self._name_label = QGraphicsTextItem(self._pin.name, self)
    self._name_label.setDefaultTextColor(Qt.black)
    font = self._name_label.font()
    font.setPointSize(8)
    self._name_label.setFont(font)

    # Position label based on pin direction
    label_offset = 8.0
    if self._pin.direction == PinDirection.INPUT:
        # Left side
        x = -self._name_label.boundingRect().width() - label_offset
    else:
        # Right side (OUTPUT, INOUT)
        x = label_offset

    self._name_label.setPos(x, -5)
```

**Net Path Simplification:**

```python
def _render_simplified_path(self) -> None:
    """
    Generate simplified straight-line path for LOW LOD.

    Algorithm:
    1. Extract first and last routing points
    2. Create path with single line segment
    3. Use thin line width for performance
    """
    self.setPen(QPen(self.NET_COLOR, self.NET_WIDTH_LOW))

    if len(self._routing_points) >= 2:
        start = self._routing_points[0]
        end = self._routing_points[-1]

        # Single line segment
        path = QPainterPath()
        path.moveTo(start)
        path.lineTo(end)
        self.setPath(path)
```

**Net Full Orthogonal Path:**

```python
def _render_full_path(self) -> None:
    """
    Generate full orthogonal routing path for MEDIUM/HIGH LOD.

    Algorithm:
    1. Create path from all routing points
    2. Connect points with line segments
    3. Use thicker line for visibility
    """
    self.setPen(QPen(self.NET_COLOR, self.NET_WIDTH_HIGH))

    if not self._routing_points:
        return

    # Full polyline path
    path = QPainterPath()
    path.moveTo(self._routing_points[0])

    for point in self._routing_points[1:]:
        path.lineTo(point)

    # Future: Add junction dots at branch points
    # (requires junction detection from E02-F03)

    self.setPath(path)
```

### 3.4 Integration Points

**Pin Integration with Cell Items:**

```python
# In CellGraphicsItem (from T02)
def add_pin_item(self, pin_item: PinGraphicsItem) -> None:
    """
    Add pin as child of cell.

    Pin positioning:
    - Pin item positioned at pin.position (relative to cell)
    - Pin visibility controlled by cell's LOD level
    """
    self._pin_items.append(pin_item)
    pin_item.setParentItem(self)

    # Initial visibility based on current LOD
    if self._current_lod != LODLevel.HIGH:
        pin_item.setVisible(False)
```

**Canvas Integration for Pins and Nets:**

```python
# In SchematicCanvas
class SchematicCanvas(QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self._lod_manager = LODManager()
        self._cell_items: List[CellGraphicsItem] = []
        self._pin_items: List[PinGraphicsItem] = []
        self._net_items: List[NetGraphicsItem] = []

        self._lod_manager.add_listener(self._on_lod_changed)

    def add_pin_item(self, pin_item: PinGraphicsItem) -> None:
        """Add pin to scene and register for LOD updates."""
        self.scene().addItem(pin_item)
        self._pin_items.append(pin_item)
        pin_item.set_lod_level(self._lod_manager.current_level)

    def add_net_item(self, net_item: NetGraphicsItem) -> None:
        """Add net to scene and register for LOD updates."""
        self.scene().addItem(net_item)
        self._net_items.append(net_item)
        net_item.set_lod_level(self._lod_manager.current_level)

    def _on_lod_changed(self, new_level: LODLevel) -> None:
        """Update all graphics items when LOD changes."""
        # Update cells (from T02)
        for cell_item in self._cell_items:
            cell_item.set_lod_level(new_level)

        # Update pins
        for pin_item in self._pin_items:
            pin_item.set_lod_level(new_level)

        # Update nets
        for net_item in self._net_items:
            net_item.set_lod_level(new_level)
```

---

## 4. Technical Deep Dive

### 4.1 Performance Analysis: Rendering Complexity

**Pin Rendering Complexity:**

| LOD Level | Operations | Estimated Time |
|-----------|-----------|----------------|
| LOW | Hidden (no rendering) | 0ms |
| MEDIUM | 1 small circle | ~0.01ms |
| HIGH | 1 circle + 1 text label | ~0.05ms |

**Performance Targets Validation:**

100 pins at MEDIUM LOD:
- 100 × 0.01ms = 1ms ✓ (within target)

100 pins at HIGH LOD:
- 100 × 0.05ms = 5ms ✓ (within target)

**Net Rendering Complexity:**

| LOD Level | Path Segments | Operations | Estimated Time |
|-----------|--------------|-----------|----------------|
| LOW | 1 line | `drawLine()` | ~0.005ms |
| MEDIUM/HIGH | 5-10 lines avg | `drawPath()` with N segments | ~0.02ms |

**Performance Targets Validation:**

1000 nets at LOW LOD:
- 1000 × 0.005ms = 5ms ✓ (within target)

500 nets at HIGH LOD:
- 500 × 0.02ms = 10ms ✓ (within target)

**Bottleneck Analysis:**
- Pin text rendering is 5x slower than circles
- Net path stroking scales linearly with segment count
- Simplified nets at LOW LOD: 4-10x faster than full routing

### 4.2 Pin Positioning and Coordinate Systems

**Pin Coordinate Spaces:**

```
1. Cell Local Coordinates:
   - Pin.position: Relative to cell origin
   - Example: Pin on right edge = (cell.width, cell.height / 2)

2. Pin Item Local Coordinates:
   - Origin at pin connection point
   - Indicator dot: Centered at (0, 0)
   - Name label: Offset left/right based on direction

3. Scene Coordinates:
   - Cell position + Pin position
   - QGraphicsItem hierarchy manages transform
```

**Pin Placement on Cell Edges:**

```python
# Example: Pin on right edge of cell
cell_width = 80.0
cell_height = 60.0
pin_y_offset = 30.0  # Middle of cell height

# Pin position relative to cell
pin.position = Position(x=cell_width, y=pin_y_offset)

# Pin item positioned relative to cell item (parent)
pin_item.setPos(pin.position.x, pin.position.y)
pin_item.setParentItem(cell_item)

# Pin indicator centered at pin connection point
pin_item._indicator_dot.setPos(0, 0)
```

### 4.3 Net Path Representation

**Routing Points Format:**

```python
# From E02-F03 routing engine
routing_points = [
    QPointF(100, 200),  # Start: pin on Cell A
    QPointF(150, 200),  # Horizontal segment
    QPointF(150, 300),  # Vertical segment
    QPointF(200, 300),  # Horizontal segment
    QPointF(200, 250),  # End: pin on Cell B
]
```

**Path Generation:**

```python
# LOW LOD: Simplified (2 points)
simplified = [routing_points[0], routing_points[-1]]
# Result: [(100, 200), (200, 250)] - single diagonal line

# MEDIUM/HIGH LOD: Full path (all 5 points)
full = routing_points
# Result: Orthogonal stair-step path
```

**Junction Detection (Future Enhancement):**

```python
# P1: Detect branch points for junction dots
def detect_junctions(routing_points: List[QPointF]) -> List[QPointF]:
    """
    Identify points where 3+ segments meet.

    Algorithm:
    1. Build point usage map
    2. Find points shared by 3+ segments
    3. Return junction points
    """
    point_usage = Counter()
    for i in range(len(routing_points) - 1):
        # Count usage of intermediate points (not endpoints)
        if i > 0:
            point_usage[routing_points[i]] += 1

    junctions = [pt for pt, count in point_usage.items() if count >= 2]
    return junctions
```

### 4.4 LOD Transition Performance

**Transition Sequence for 500 Pins + 1000 Nets:**

```
1. LODManager detects zoom change
2. Canvas receives LOD change notification
3. Update all items:
   - 500 pins × 0.05ms = 25ms (set visibility, resize indicator)
   - 1000 nets × 0.01ms = 10ms (regenerate path)
   - Total: 35ms (exceeds 16ms budget)

Optimization needed!
```

**Optimization Strategies:**

1. **Batch Scene Updates:**
```python
def _on_lod_changed(self, new_level: LODLevel):
    # Disable scene updates during batch
    self.scene().setUpdatesEnabled(False)

    # Update all items
    for pin in self._pin_items:
        pin.set_lod_level(new_level)
    for net in self._net_items:
        net.set_lod_level(new_level)

    # Re-enable and trigger single update
    self.scene().setUpdatesEnabled(True)
    self.scene().update()

# Performance: 25ms + 10ms → 15ms (batched)
```

2. **Cull Off-Screen Items:**
```python
def _on_lod_changed(self, new_level: LODLevel):
    visible_rect = self.mapToScene(self.viewport().rect()).boundingRect()

    # Only update visible items
    for pin in self._pin_items:
        if pin.isVisible() and visible_rect.intersects(pin.sceneBoundingRect()):
            pin.set_lod_level(new_level)

# Performance: ~50% of items typically visible → 7.5ms
```

3. **Progressive Updates (P1):**
```python
# Update visible items immediately, background items deferred
def _on_lod_changed(self, new_level: LODLevel):
    visible_items = self._get_visible_items()
    background_items = self._get_background_items()

    # Immediate update for visible
    for item in visible_items:
        item.set_lod_level(new_level)

    # Deferred update for background (next frame)
    QTimer.singleShot(16, lambda: self._update_background(background_items, new_level))
```

**Target with Batching + Culling:**
- Visible items only: 250 pins + 500 nets
- Batched update: (250 × 0.05ms + 500 × 0.01ms) = 17.5ms
- Still slightly over budget, but close
- Further optimization: async updates (P1)

---

## 5. Risk Analysis

### 5.1 Performance Risks

**Risk R01: LOD transitions for pins + nets exceed 16ms budget**

- **Impact**: High - Causes frame drops during zoom
- **Probability**: High - Initial estimates show 35ms for 500 pins + 1000 nets
- **Symptoms**: Stuttering during zoom, delayed LOD transitions
- **Mitigation**:
  - Implement batched scene updates (priority 1)
  - Cull off-screen items (priority 2)
  - Profile actual performance with realistic scene
  - Consider progressive updates (visible first, background later)
  - Reduce pin/net item complexity if needed

**Risk R02: Simplified net paths don't clearly show connectivity**

- **Impact**: Medium - Users confused about signal flow at LOW LOD
- **Probability**: Low - Straight lines still show start/end connections
- **Symptoms**: User feedback that LOW LOD nets are confusing
- **Mitigation**:
  - Test with realistic netlists (fanout, bus routing)
  - Ensure simplified paths use correct endpoints
  - Consider intermediate LOD (2-3 segment simplification) if needed
  - Accept some visual trade-off for performance gain

### 5.2 Visual Quality Risks

**Risk R03: Pin indicator dots too small to see at MEDIUM LOD**

- **Impact**: Medium - MEDIUM LOD less useful
- **Probability**: Low - 3px radius should be visible at 25%+ zoom
- **Symptoms**: Users can't see pin positions at MEDIUM LOD
- **Mitigation**:
  - Test pin visibility at 25%, 50% zoom levels
  - Adjust `INDICATOR_RADIUS_MEDIUM` if needed (try 4px, 5px)
  - Add user preference for indicator size (P1)

**Risk R04: Pin color coding insufficient for accessibility**

- **Impact**: Low - Affects users with color vision deficiencies
- **Probability**: Medium - ~8% male population has color blindness
- **Symptoms**: Can't distinguish input from output pins at MEDIUM LOD
- **Mitigation**:
  - Use colors distinguishable for deuteranopia (red-green blindness)
  - Add shape coding in P1 (triangle=input, square=output)
  - Test with color blindness simulation tools
  - Provide high-contrast theme option (P1)

### 5.3 Integration Risks

**Risk R05: Net routing points from E02-F03 in unexpected format**

- **Impact**: High - Can't render nets
- **Probability**: Medium - E02-F03 not yet implemented
- **Symptoms**: Net paths render incorrectly or crash
- **Mitigation**:
  - Document expected routing points format clearly
  - Coordinate with E02-F03 implementer on API contract
  - Mock routing points for unit tests
  - Validate routing point format (assert orthogonal constraints)

**Risk R06: Pin positions from domain model incorrect**

- **Impact**: High - Pins appear in wrong locations
- **Probability**: Low - Well-defined `Pin.position` attribute
- **Symptoms**: Pins not aligned with cell edges
- **Mitigation**:
  - Unit test pin positioning with known coordinates
  - Visual regression tests for pin placement
  - Document coordinate space requirements for E01 domain model

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test Coverage Targets:**
- `PinGraphicsItem`: 85%+ coverage
- `NetGraphicsItem`: 85%+ coverage
- LOD rendering methods: 100% coverage

**Test Cases:**

```python
# tests/unit/presentation/canvas/test_pin_item_lod.py
from unittest.mock import Mock
import pytest
from PySide6.QtCore import QPointF
from PySide6.QtGui import QColor
from ink.presentation.canvas.pin_item import PinGraphicsItem
from ink.presentation.canvas.lod_level import LODLevel
from ink.domain.value_objects.pin_direction import PinDirection

@pytest.fixture
def mock_pin_input():
    """Mock input Pin entity."""
    pin = Mock()
    pin.name = "A"
    pin.position = Mock(x=0.0, y=20.0)
    pin.direction = PinDirection.INPUT
    return pin

@pytest.fixture
def mock_pin_output():
    """Mock output Pin entity."""
    pin = Mock()
    pin.name = "Y"
    pin.position = Mock(x=80.0, y=30.0)
    pin.direction = PinDirection.OUTPUT
    return pin

def test_pin_item_initialization(mock_pin_input):
    """Test pin item creates with correct components."""
    item = PinGraphicsItem(mock_pin_input)

    # Verify position
    assert item.pos() == QPointF(0.0, 20.0)

    # Verify child items created
    assert item._indicator_dot is not None
    assert item._name_label is not None
    assert item._name_label.toPlainText() == "A"

    # Verify initial LOD
    assert item.current_lod == LODLevel.HIGH

def test_pin_color_by_direction(mock_pin_input, mock_pin_output):
    """Test pin color reflects direction."""
    input_item = PinGraphicsItem(mock_pin_input)
    output_item = PinGraphicsItem(mock_pin_output)

    # Verify colors
    assert input_item._indicator_dot.brush().color() == PinGraphicsItem.INPUT_COLOR
    assert output_item._indicator_dot.brush().color() == PinGraphicsItem.OUTPUT_COLOR

def test_pin_lod_low_hidden(mock_pin_input):
    """Test pin hidden at LOW LOD."""
    item = PinGraphicsItem(mock_pin_input)
    item.set_lod_level(LODLevel.LOW)

    # Verify entire item hidden
    assert not item.isVisible()

def test_pin_lod_medium_indicator_only(mock_pin_input):
    """Test pin shows small indicator at MEDIUM LOD."""
    item = PinGraphicsItem(mock_pin_input)
    item.set_lod_level(LODLevel.MEDIUM)

    # Verify visible
    assert item.isVisible()

    # Verify indicator shown
    assert item._indicator_dot.isVisible()

    # Verify small radius
    rect = item._indicator_dot.rect()
    expected_radius = PinGraphicsItem.INDICATOR_RADIUS_MEDIUM
    assert rect.width() == expected_radius * 2

    # Verify label hidden
    assert not item._name_label.isVisible()

def test_pin_lod_high_full_detail(mock_pin_input):
    """Test pin shows full detail at HIGH LOD."""
    item = PinGraphicsItem(mock_pin_input)
    item.set_lod_level(LODLevel.HIGH)

    # Verify visible
    assert item.isVisible()

    # Verify indicator shown
    assert item._indicator_dot.isVisible()

    # Verify larger radius
    rect = item._indicator_dot.rect()
    expected_radius = PinGraphicsItem.INDICATOR_RADIUS_HIGH
    assert rect.width() == expected_radius * 2

    # Verify label shown
    assert item._name_label.isVisible()

def test_pin_label_positioning_input(mock_pin_input):
    """Test input pin label positioned on left."""
    item = PinGraphicsItem(mock_pin_input)

    # Label should be to the left (negative x)
    assert item._name_label.pos().x() < 0

def test_pin_label_positioning_output(mock_pin_output):
    """Test output pin label positioned on right."""
    item = PinGraphicsItem(mock_pin_output)

    # Label should be to the right (positive x)
    assert item._name_label.pos().x() > 0
```

```python
# tests/unit/presentation/canvas/test_net_item_lod.py
from unittest.mock import Mock
import pytest
from PySide6.QtCore import QPointF
from ink.presentation.canvas.net_item import NetGraphicsItem
from ink.presentation.canvas.lod_level import LODLevel

@pytest.fixture
def mock_net():
    """Mock Net entity."""
    net = Mock()
    net.name = "net_123"
    return net

@pytest.fixture
def orthogonal_routing_points():
    """Sample orthogonal routing points."""
    return [
        QPointF(100, 200),  # Start
        QPointF(150, 200),  # Horizontal
        QPointF(150, 300),  # Vertical
        QPointF(200, 300),  # End
    ]

def test_net_item_initialization(mock_net, orthogonal_routing_points):
    """Test net item creates with routing path."""
    item = NetGraphicsItem(mock_net, orthogonal_routing_points)

    # Verify routing points stored
    assert item._routing_points == orthogonal_routing_points

    # Verify path created
    assert not item.path().isEmpty()

    # Verify initial LOD
    assert item.current_lod == LODLevel.HIGH

def test_net_lod_low_simplified(mock_net, orthogonal_routing_points):
    """Test net renders as straight line at LOW LOD."""
    item = NetGraphicsItem(mock_net, orthogonal_routing_points)
    item.set_lod_level(LODLevel.LOW)

    # Verify path simplified (2 points only)
    path = item.path()

    # Path should start at first point
    assert path.elementAt(0).type == QPainterPath.MoveToElement
    assert path.elementAt(0).x == 100
    assert path.elementAt(0).y == 200

    # Path should end at last point
    # Note: path.elementCount() - 1 gives last element
    # Simplified path has 2 elements: MoveTo + LineTo
    assert path.elementCount() == 2

    # Verify thin line
    assert item.pen().width() == NetGraphicsItem.NET_WIDTH_LOW

def test_net_lod_high_full_routing(mock_net, orthogonal_routing_points):
    """Test net renders full path at HIGH LOD."""
    item = NetGraphicsItem(mock_net, orthogonal_routing_points)
    item.set_lod_level(LODLevel.HIGH)

    # Verify path contains all points
    path = item.path()

    # Full path has 4 elements: MoveTo + 3 LineTo
    assert path.elementCount() == 4

    # Verify thick line
    assert item.pen().width() == NetGraphicsItem.NET_WIDTH_HIGH

def test_net_update_routing(mock_net, orthogonal_routing_points):
    """Test net path updates when routing changes."""
    item = NetGraphicsItem(mock_net, orthogonal_routing_points)

    # Change routing
    new_points = [
        QPointF(100, 200),
        QPointF(200, 200),  # Different path
    ]
    item.update_routing(new_points)

    # Verify path updated
    assert item._routing_points == new_points

def test_net_empty_routing_points(mock_net):
    """Test net handles empty routing points gracefully."""
    item = NetGraphicsItem(mock_net, [])

    # Should not crash
    item.set_lod_level(LODLevel.LOW)
    item.set_lod_level(LODLevel.HIGH)

    # Path should be empty
    assert item.path().isEmpty()
```

### 6.2 Visual Tests

**Pin Rendering Tests:**

```python
# tests/visual/test_pin_rendering_lod.py
def test_visual_pins_at_medium_lod(qtbot, tmp_path):
    """Verify pin indicators visible at MEDIUM LOD."""
    from PySide6.QtWidgets import QGraphicsScene, QGraphicsView

    scene = QGraphicsScene()
    view = QGraphicsView(scene)

    # Create pins of different directions
    input_pin = create_mock_pin("A", PinDirection.INPUT, (0, 0))
    output_pin = create_mock_pin("Y", PinDirection.OUTPUT, (100, 0))
    inout_pin = create_mock_pin("IO", PinDirection.INOUT, (200, 0))

    pin_items = [
        PinGraphicsItem(input_pin),
        PinGraphicsItem(output_pin),
        PinGraphicsItem(inout_pin),
    ]

    for item in pin_items:
        item.set_lod_level(LODLevel.MEDIUM)
        scene.addItem(item)

    qtbot.addWidget(view)
    view.show()
    qtbot.waitExposed(view)

    # Capture screenshot
    pixmap = view.grab()
    screenshot_path = tmp_path / "pins_medium_lod.png"
    pixmap.save(str(screenshot_path))

    # Manual verification: Colors should be blue, orange, gray
    assert screenshot_path.exists()
```

### 6.3 Integration Tests

**Canvas Integration:**

```python
# tests/integration/presentation/test_pin_net_lod_integration.py
def test_pin_net_lod_updates_with_canvas(qtbot):
    """Test pins and nets update LOD with canvas zoom."""
    from ink.presentation.canvas.schematic_canvas import SchematicCanvas

    canvas = SchematicCanvas()
    qtbot.addWidget(canvas)

    # Add pins
    pins = [create_mock_pin(f"P{i}", PinDirection.INPUT, (i * 50, 0)) for i in range(10)]
    pin_items = [PinGraphicsItem(pin) for pin in pins]
    for item in pin_items:
        canvas.add_pin_item(item)

    # Add nets
    routing = [QPointF(0, 0), QPointF(100, 100)]
    nets = [create_mock_net(f"net_{i}") for i in range(20)]
    net_items = [NetGraphicsItem(net, routing) for net in nets]
    for item in net_items:
        canvas.add_net_item(item)

    # Verify initial LOD
    assert all(item.current_lod == LODLevel.HIGH for item in pin_items)
    assert all(item.current_lod == LODLevel.HIGH for item in net_items)

    # Simulate zoom to MEDIUM
    canvas._lod_manager.update_zoom(0.5)

    # Verify all updated
    assert all(item.current_lod == LODLevel.MEDIUM for item in pin_items)
    assert all(item.current_lod == LODLevel.MEDIUM for item in net_items)
```

### 6.4 Performance Tests

**Pin/Net Rendering Benchmarks:**

```python
# tests/performance/test_pin_net_lod_benchmark.py
import pytest

@pytest.mark.benchmark
def test_render_100_pins_medium_lod(benchmark, qtbot):
    """Benchmark 100 pins at MEDIUM LOD."""
    from PySide6.QtWidgets import QGraphicsScene

    scene = QGraphicsScene()

    pins = []
    for i in range(100):
        pin = create_mock_pin(f"P{i}", PinDirection.INPUT, (i * 10, 0))
        item = PinGraphicsItem(pin)
        item.set_lod_level(LODLevel.MEDIUM)
        scene.addItem(item)
        pins.append(item)

    def render():
        scene.update()

    result = benchmark(render)

    # Assert <1ms
    assert result < 0.001

@pytest.mark.benchmark
def test_render_1000_nets_low_lod(benchmark, qtbot):
    """Benchmark 1000 nets at LOW LOD."""
    from PySide6.QtWidgets import QGraphicsScene

    scene = QGraphicsScene()

    routing = [QPointF(0, 0), QPointF(100, 0), QPointF(100, 100), QPointF(200, 100)]

    nets = []
    for i in range(1000):
        net = create_mock_net(f"net_{i}")
        item = NetGraphicsItem(net, routing)
        item.set_lod_level(LODLevel.LOW)
        scene.addItem(item)
        nets.append(item)

    def render():
        scene.update()

    result = benchmark(render)

    # Assert <5ms
    assert result < 0.005

@pytest.mark.benchmark
def test_lod_transition_500_pins_1000_nets(benchmark, qtbot):
    """Benchmark LOD transition for 500 pins + 1000 nets."""
    scene = QGraphicsScene()

    # Create items
    pin_items = []
    for i in range(500):
        pin = create_mock_pin(f"P{i}", PinDirection.INPUT, (i * 10, 0))
        item = PinGraphicsItem(pin)
        item.set_lod_level(LODLevel.HIGH)
        scene.addItem(item)
        pin_items.append(item)

    routing = [QPointF(0, 0), QPointF(100, 100)]
    net_items = []
    for i in range(1000):
        net = create_mock_net(f"net_{i}")
        item = NetGraphicsItem(net, routing)
        item.set_lod_level(LODLevel.HIGH)
        scene.addItem(item)
        net_items.append(item)

    def transition():
        # Toggle LOD
        new_lod = LODLevel.LOW if pin_items[0].current_lod == LODLevel.HIGH else LODLevel.HIGH

        # Batch update
        scene.setUpdatesEnabled(False)
        for item in pin_items:
            item.set_lod_level(new_lod)
        for item in net_items:
            item.set_lod_level(new_lod)
        scene.setUpdatesEnabled(True)
        scene.update()

    result = benchmark(transition)

    # Target: <16ms (may need optimization)
    # Initial estimate: ~35ms without batching
    # With batching: ~15-20ms
    assert result < 0.020  # Allow some margin
```

---

## 7. Definition of Done

### 7.1 Functional Completeness

- [ ] `PinGraphicsItem` class implemented extending `QGraphicsItemGroup`
- [ ] Pins hidden at LOD LOW
- [ ] Pins show small colored dots at LOD MEDIUM
- [ ] Pins show dots + name labels at LOD HIGH
- [ ] Pin color reflects direction (blue=input, orange=output, gray=inout)
- [ ] Pin name label positioned correctly (left for input, right for output)
- [ ] `NetGraphicsItem` class implemented extending `QGraphicsPathItem`
- [ ] Nets render as simplified straight lines at LOD LOW
- [ ] Nets render full orthogonal routing at LOD MEDIUM/HIGH
- [ ] Net line width adjusted per LOD level
- [ ] `update_routing()` method updates net path dynamically

### 7.2 Performance Completeness

- [ ] 1000 nets render at LOW LOD in <5ms
- [ ] 500 nets render at HIGH LOD in <10ms
- [ ] 100 pins render at MEDIUM LOD in <1ms
- [ ] 100 pins render at HIGH LOD in <5ms
- [ ] LOD transition for 500 pins + 1000 nets completes in <20ms (with batching)
- [ ] No memory leaks when switching LOD levels

### 7.3 Testing Completeness

- [ ] Unit tests for pin initialization and color coding
- [ ] Unit tests for pin LOD transitions (hidden, indicator, full)
- [ ] Unit tests for pin label positioning
- [ ] Unit tests for net initialization and path generation
- [ ] Unit tests for net path simplification at LOW LOD
- [ ] Unit tests for net full path at MEDIUM/HIGH LOD
- [ ] Visual tests for pin rendering at each LOD
- [ ] Integration test: Pins and nets update with LOD manager
- [ ] Performance benchmark: 100 pins at MEDIUM <1ms
- [ ] Performance benchmark: 1000 nets at LOW <5ms
- [ ] Performance benchmark: LOD transition <20ms
- [ ] Code coverage: 85%+ on `PinGraphicsItem` and `NetGraphicsItem`

### 7.4 Code Quality

- [ ] All methods have type hints
- [ ] All public methods documented with docstrings
- [ ] No PEP 8 violations (ruff check passes)
- [ ] No type errors (mypy passes)
- [ ] Code reviewed and approved
- [ ] No visual artifacts during LOD transitions

---

## 8. Open Questions and Decisions Needed

### 8.1 Pin Indicator Size

**Q1**: Are 3px and 5px indicator radii optimal for MEDIUM and HIGH LOD?

- **Context**: Need to balance visibility with clutter
- **Testing Plan**: Manual testing at 25%, 50%, 75% zoom levels
- **Recommendation**: Start with spec values, adjust based on visual testing
- **Decision Needed By**: Phase 2 implementation

### 8.2 Net Simplification Strategy

**Q2**: Should we support intermediate simplification (2-3 segments) instead of just straight line?

- **Options**:
  - Option A: Single line (current spec)
  - Option B: Simplified orthogonal (keep major turns)
  - Option C: Configurable simplification level
- **Recommendation**: Option A for MVP, Option B if visual quality issues found
- **Decision Needed By**: After visual testing of LOW LOD nets

### 8.3 Junction Dots Implementation

**Q3**: Should we implement junction dots at net branch points in MVP?

- **Context**: Spec mentions junction dots but defers to E02-F03
- **Options**:
  - Option A: No junction dots in MVP (simplest)
  - Option B: Basic junction detection and rendering
  - Option C: Full junction routing from E02-F03
- **Recommendation**: Option A - defer to P1, coordinate with E02-F03
- **Decision Needed By**: Before Phase 4 implementation

---

## 9. Success Metrics and Validation

### 9.1 Performance KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| 100 pins MEDIUM LOD render | <1ms | Performance benchmark |
| 100 pins HIGH LOD render | <5ms | Performance benchmark |
| 1000 nets LOW LOD render | <5ms | Performance benchmark |
| 500 nets HIGH LOD render | <10ms | Performance benchmark |
| LOD transition (500+1000) | <20ms | Performance benchmark |

### 9.2 Quality KPIs

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Unit Test Coverage | 85%+ | pytest-cov |
| Integration Test Pass Rate | 100% | CI/CD |
| Visual Regression Pass Rate | 100% | Manual verification |
| Code Review Approval | Required | GitHub PR |

---

## 10. Timeline and Milestones

### 10.1 Implementation Schedule

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| Phase 1: Pin Structure | 2 hours | PinGraphicsItem skeleton |
| Phase 2: Pin LOD | 2 hours | Three pin rendering modes |
| Phase 3: Net Structure | 1.5 hours | NetGraphicsItem skeleton |
| Phase 4: Net LOD | 1.5 hours | Two net rendering modes |
| Phase 5: Integration | 1 hour | Canvas integration |
| **Total** | **8 hours** | Complete pin/net LOD |

### 10.2 Milestones

| Milestone | Success Criteria |
|-----------|-----------------|
| M1: Pin Rendering | Pins render at all LOD levels |
| M2: Net Rendering | Nets render simplified and full |
| M3: Performance Validated | Benchmarks pass (with batching) |
| M4: Integration Complete | Works with canvas LOD manager |

---

## 11. References and Resources

### 11.1 Technical References

**Qt Graphics Framework:**
- `QGraphicsItemGroup` documentation
- `QGraphicsPathItem` and `QPainterPath` documentation
- Qt Performance: Batched scene updates

**Color Accessibility:**
- Color Blindness Simulator tools
- Web Content Accessibility Guidelines (WCAG) color contrast

### 11.2 Internal Documentation

- `/home/joohan/dev/project-ink/ink/specs/E02/F04/T01/E02-F04-T01.spec.md` - LODManager
- `/home/joohan/dev/project-ink/ink/specs/E02/F04/T02/E02-F04-T02.spec.md` - Cell LOD
- `/home/joohan/dev/project-ink/ink/specs/E02/F04/E02-F04.spec.md` - Parent feature

---

**Document Status**: Ready for Implementation
**Next Steps**: Begin Phase 1 after T02 completion, coordinate with E02-F03 on routing point format
