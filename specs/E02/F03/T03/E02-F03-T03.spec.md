---
id: E02-F03-T03
title: Multi-Fanout Net Handling
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F03
created: 2025-12-26
estimated_hours: 8
actual_hours:
effort: Medium
tags:
  - routing
  - visualization
clickup_task_id: '86evzm2m1'
---

# Spec: E02-F03-T03 - Multi-Fanout Net Handling

## 1. Overview

### 1.1 Problem Statement

Multi-fanout nets (one driver, multiple loads) require special routing topology to clearly show branching structure. Junction points where the net branches must be visually distinguished with junction dots to indicate electrical connection rather than simple crossing.

### 1.2 Goals

- Implement routing strategy for multi-fanout nets (1-to-N)
- Create branching tree structure with minimal total wire length
- Identify junction points where branches meet
- Provide visual distinction between junctions and crossings
- Support both star and tree topologies

---

## 2. Technical Requirements

### 2.1 Fanout Topology Strategies

**Star Topology** (Simple, higher wire length):
```
        Sink 1
         |
Source---+--- Sink 2
         |
        Sink 3
```
- Central junction point
- Each sink connects directly to junction
- Simple to implement, but longer total wire length

**Tree Topology** (Optimized, lower wire length):
```
Source
  |
  +--- Sink 1
  |
  +---+--- Sink 2
      |
      +--- Sink 3
```
- Hierarchical branching
- Minimizes total Manhattan distance
- More complex routing, better visual clarity

**For MVP: Use Star Topology**
- Simpler implementation
- Acceptable wire length for gate-level netlists
- Clear visual structure

### 2.2 Junction Point Detection

Enhance `ChannelRouter` with junction detection:

```python
class ChannelRouter:
    def _identify_junctions(
        self,
        segments: List[LineSegment]
    ) -> List[Point]:
        """
        Find junction points where >2 segments meet.

        Algorithm:
        1. Build endpoint-to-segments mapping
        2. For each endpoint:
           - Count connected segments
           - If count > 2: mark as junction
        3. Return unique junction points

        Returns:
            List of junction points (for dot rendering)
        """
        pass

    def _create_star_topology(
        self,
        source: Point,
        sinks: List[Point]
    ) -> Tuple[List[LineSegment], List[Point]]:
        """
        Create star topology for multi-fanout net.

        Args:
            source: Driver pin position
            sinks: List of load pin positions

        Returns:
            Tuple of (segments, junction_points)
        """
        pass
```

### 2.3 Star Topology Algorithm

```python
def _create_star_topology(
    self,
    source: Point,
    sinks: List[Point]
) -> Tuple[List[LineSegment], List[Point]]:
    """
    1. Calculate junction point:
       - X: median of sink x-coordinates
       - Y: channel Y-coordinate

    2. Route from source to junction:
       - Vertical from source to channel
       - Horizontal to junction X

    3. Route from junction to each sink:
       - Horizontal from junction to sink X
       - Vertical from channel to sink

    4. Mark junction point for visualization
    """
    segments = []

    # Step 1: Determine junction position
    sink_x_coords = [s.x for s in sinks]
    junction_x = median(sink_x_coords)
    junction_y = self._get_channel_y(source, sinks)
    junction = Point(junction_x, junction_y)

    # Step 2: Source to junction
    segments.extend(self._route_to_junction(source, junction))

    # Step 3: Junction to each sink
    for sink in sinks:
        segments.extend(self._route_from_junction(junction, sink))

    return segments, [junction]
```

### 2.4 Junction Point Criteria

A point is a junction if:
1. **>2 segments meet** at the point
2. Point is **not a pin connection** (pins have exactly 1 segment)
3. Segments form **T-junction or cross**

Example:
```
    |
----+----  Junction (4 segments meet)
    |

    |
----+      Junction (3 segments meet, T-shape)

----â€¢----  Pin connection (2 segments, not a junction)
```

### 2.5 NetGeometry Enhancement

The `NetGeometry` value object already includes junctions field (from T01):
```python
@dataclass(frozen=True)
class NetGeometry:
    net_id: NetId
    segments: Tuple[LineSegment, ...]
    junctions: Tuple[Point, ...]  # <- Populated by this task
    crossings: Tuple[Point, ...]
```

---

## 3. Dependencies

- **Upstream**:
  - E02-F03-T01 (NetGeometry with junctions field)
  - E02-F03-T02 (ChannelRouter base implementation)

- **Downstream**:
  - Presentation layer (`NetItem` renders junction dots)
  - E04 (Selection highlights multi-fanout structure)

---

## 4. Acceptance Criteria

- [ ] `_create_star_topology()` implemented in `ChannelRouter`
- [ ] `_identify_junctions()` detects branching points
- [ ] Multi-fanout nets (1-to-N) routed with star topology
- [ ] Junction points included in `NetGeometry.junctions`
- [ ] Junction detection correctly identifies:
  - T-junctions (3 segments)
  - Cross junctions (4 segments)
  - Excludes pin connections (2 segments)
- [ ] Junction position optimized (median X for balanced layout)
- [ ] Handle edge cases:
  - 1-to-1 net (no junctions)
  - 1-to-2 net (single junction)
  - 1-to-10+ net (multiple branches)
- [ ] Unit tests covering:
  - Star topology creation (various fanout counts)
  - Junction point detection
  - Median junction positioning
  - Edge cases (2, 3, 10+ sinks)
- [ ] Integration tests with multi-fanout nets
- [ ] Test coverage >85%
- [ ] Documentation with topology diagrams

---

## 5. Implementation Notes

### 5.1 Median vs Mean for Junction Positioning

**Use Median (not mean):**
- More robust to outliers
- Creates balanced branching
- Better visual symmetry

```python
def _calculate_junction_x(self, sinks: List[Point]) -> float:
    """Use median for balanced junction position."""
    x_coords = sorted([s.x for s in sinks])
    n = len(x_coords)
    if n % 2 == 0:
        return (x_coords[n//2 - 1] + x_coords[n//2]) / 2
    else:
        return x_coords[n//2]
```

### 5.2 Channel Y-Coordinate

```python
def _get_channel_y(self, source: Point, sinks: List[Point]) -> float:
    """
    Determine channel Y-coordinate for routing.

    Place channel between source and sink layers.
    """
    all_y = [source.y] + [s.y for s in sinks]
    min_y, max_y = min(all_y), max(all_y)
    return (min_y + max_y) / 2
```

### 5.3 Junction Point Equality

Use point equality with tolerance for floating-point comparison:

```python
def _points_equal(self, p1: Point, p2: Point, tol: float = 1e-6) -> bool:
    """Check if two points are equal within tolerance."""
    return (abs(p1.x - p2.x) < tol and abs(p1.y - p2.y) < tol)
```

### 5.4 Segment Connectivity

Build endpoint mapping for junction detection:

```python
def _build_endpoint_map(
    self,
    segments: List[LineSegment]
) -> Dict[Point, List[LineSegment]]:
    """
    Map each point to segments connected to it.

    Returns:
        Dict mapping Point to list of connected LineSegments
    """
    endpoint_map: Dict[Point, List[LineSegment]] = defaultdict(list)
    for seg in segments:
        endpoint_map[seg.start].append(seg)
        endpoint_map[seg.end].append(seg)
    return endpoint_map
```

---

## 6. Test Scenarios

### Unit Tests

**Star Topology Creation:**
- 1-to-2 fanout (single branch)
- 1-to-3 fanout (T-junction)
- 1-to-4 fanout (balanced branches)
- 1-to-10 fanout (many sinks)

**Junction Detection:**
- T-junction (3 segments)
- Cross junction (4 segments)
- No junction (simple point-to-point)
- Multiple junctions in one net

**Junction Positioning:**
- Sinks aligned horizontally (median = center)
- Sinks scattered (median balances branches)
- Edge case: 2 sinks (median between them)

**Edge Cases:**
- Net with no sinks (driver only)
- Net with single sink (no junction)
- All sinks at same x-coordinate (vertical stack)

### Integration Tests

**With Real Netlists:**
- Route design with multi-fanout clock net
- Route design with mixed 1-to-1 and 1-to-N nets
- Verify junction counts match expected topology

---

## 7. Visual Examples

### Example 1: 1-to-3 Star Topology
```
Cell A (driver)
  |
  | (vertical to channel)
  |
  +---+---+  (junction point - render dot here)
      |   |
      |   +----> Cell C (load)
      |
      +--------> Cell D (load)

Cell B (load)
  |
```

### Example 2: Junction vs Crossing
```
Junction (dot):        Crossing (arc/bridge):
    |                      |
----+----                  | (arc over)
    |                  ====+====
                           |
```

---

## 8. Future Enhancements (Post-MVP)

- **Tree Topology:** Hierarchical branching for better wire length
- **Steiner Tree:** Optimal wire length minimization
- **Bus Routing:** Special handling for multi-bit buses
- **Rectilinear Steiner Minimum Tree (RSMT):** Industry-standard algorithm

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F03 split |
