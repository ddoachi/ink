---
id: E02-F03-T02
title: Orthogonal Router Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F03
created: 2025-12-26
estimated_hours: 16
actual_hours:
effort: Large
tags:
  - infrastructure
  - routing
  - algorithms
clickup_task_id: '86evzm2ku'
---

# Spec: E02-F03-T02 - Orthogonal Router Implementation

## 1. Overview

### 1.1 Problem Statement

After the Sugiyama layout engine positions cells in layers, nets must be routed between connected pins using orthogonal (Manhattan) paths. The router must handle both simple point-to-point connections and multi-fanout nets while minimizing wire length, bends, and visual clutter.

### 1.2 Goals

- Implement channel-based orthogonal routing algorithm
- Route nets between layers using horizontal channels
- Minimize total wire length and number of bends
- Handle both single-driver and multi-fanout topologies
- Provide efficient routing for netlists with 1000+ nets

---

## 2. Technical Requirements

### 2.1 Router Interface (Domain Layer)

Define protocol in `src/ink/domain/services/net_router.py`:

```python
from typing import Protocol, Dict
from ink.domain.model.net import Net
from ink.domain.value_objects.identifiers import CellId
from ink.domain.value_objects.geometry import NetGeometry, Position

class NetRouter(Protocol):
    """
    Domain service interface for net routing.

    Routes nets between connected pins using orthogonal paths.
    """

    def route_net(
        self,
        net: Net,
        cell_positions: Dict[CellId, Position]
    ) -> NetGeometry:
        """
        Route a net between connected pins.

        Args:
            net: The net to route (contains connected pins)
            cell_positions: Position of each cell (from layout engine)

        Returns:
            NetGeometry containing routing segments and junctions

        Raises:
            ValueError: If net has no connected pins or invalid positions
        """
        ...

    def route_all_nets(
        self,
        nets: List[Net],
        cell_positions: Dict[CellId, Position]
    ) -> Dict[NetId, NetGeometry]:
        """
        Route all nets in a design.

        Args:
            nets: List of nets to route
            cell_positions: Position of each cell

        Returns:
            Mapping of net ID to routing geometry
        """
        ...
```

### 2.2 Channel Router Implementation (Infrastructure Layer)

Implement in `src/ink/infrastructure/routing/channel_router.py`:

```python
class ChannelRouter:
    """
    Orthogonal net router using channel-based algorithm.

    Routes nets through horizontal channels between Sugiyama layers.
    Minimizes wire length and bends for clean schematic appearance.
    """

    def __init__(
        self,
        channel_height: float = 50.0,
        via_clearance: float = 10.0
    ):
        """
        Initialize router.

        Args:
            channel_height: Vertical space between layers for routing
            via_clearance: Minimum spacing between vertical segments
        """
        self.channel_height = channel_height
        self.via_clearance = via_clearance
        self._geometry_cache: Dict[NetId, NetGeometry] = {}

    def route_net(
        self,
        net: Net,
        cell_positions: Dict[CellId, Position]
    ) -> NetGeometry:
        """Route single net using channel algorithm."""
        # Check cache first
        if net.id in self._geometry_cache:
            return self._geometry_cache[net.id]

        # Compute routing
        geometry = self._compute_routing(net, cell_positions)

        # Cache result
        self._geometry_cache[net.id] = geometry
        return geometry

    def _compute_routing(
        self,
        net: Net,
        cell_positions: Dict[CellId, Position]
    ) -> NetGeometry:
        """
        Core routing algorithm.

        Steps:
        1. Get pin positions from net and cell layout
        2. Identify source pin (driver) and sink pins (loads)
        3. For each sink:
           - Route vertical from source to channel
           - Route horizontal across layers
           - Route vertical from channel to sink
        4. Collect all segments and identify junctions
        """
        pass

    def _get_pin_position(
        self,
        pin: Pin,
        cell_positions: Dict[CellId, Position]
    ) -> Point:
        """
        Calculate absolute position of pin.

        Combines cell position with pin's relative offset.
        """
        pass

    def _create_point_to_point_route(
        self,
        source: Point,
        sink: Point
    ) -> List[LineSegment]:
        """
        Create orthogonal path between two points.

        Uses L-shaped or Z-shaped routing depending on relative positions.
        """
        pass

    def _identify_junctions(
        self,
        segments: List[LineSegment]
    ) -> List[Point]:
        """
        Find points where >2 segments meet (branching points).

        Used for multi-fanout junction dot visualization.
        """
        pass

    def clear_cache(self) -> None:
        """Clear routing geometry cache."""
        self._geometry_cache.clear()
```

### 2.3 Routing Algorithm (Channel-Based)

**For MVP: Simple channel routing**

1. **Pin Position Resolution:**
   - Get absolute position of each pin: `cell_position + pin_offset`
   - Identify driver pin (OUTPUT) and load pins (INPUT/INOUT)

2. **Point-to-Point Routing (2 pins):**
   ```
   Source Pin
       |  (vertical segment)
       +-------->  (horizontal segment in channel)
                |  (vertical segment)
           Sink Pin
   ```
   - Vertical from source to channel centerline
   - Horizontal across to sink x-coordinate
   - Vertical from channel to sink

3. **Multi-Fanout Routing (>2 pins):**
   ```
   Source Pin
       |
       +---+---+---> Sink 1
           |   |
           |   +---> Sink 2
           |
           +-------> Sink 3
   ```
   - Route from source to common distribution point
   - Branch to each sink using T-junctions
   - Mark junction points for dot rendering

4. **Optimization:**
   - Minimize total Manhattan distance
   - Prefer straight runs over multiple bends
   - Align parallel routes to reduce crossings

### 2.4 Performance Requirements

- Route 1000 nets in <3 seconds
- Cache routing geometry (invalidate on layout change)
- Lazy evaluation: route on-demand for visible area

---

## 3. Dependencies

- **Upstream**:
  - E02-F03-T01 (Net geometry data structures)
  - E01-F03 (Net domain model with connected pins)
  - E02-F02 (Cell positions from layout engine)
  - E02-F01 (Pin position offsets)

- **Downstream**:
  - E02-F03-T03 (Multi-fanout handling uses junction detection)
  - E02-F03-T04 (Route optimization)
  - Presentation layer (NetItem rendering)

---

## 4. Acceptance Criteria

- [ ] `NetRouter` protocol defined in domain layer
- [ ] `ChannelRouter` implementation in infrastructure layer
- [ ] `route_net()` produces valid orthogonal `NetGeometry`
- [ ] `route_all_nets()` routes complete netlist
- [ ] Point-to-point routing (2 pins) creates L-shape or Z-shape
- [ ] Multi-fanout routing (>2 pins) creates branching structure
- [ ] Junction points identified for multi-fanout nets
- [ ] Routing geometry cached for performance
- [ ] Cache invalidation on layout change
- [ ] All segments strictly horizontal or vertical
- [ ] Pin positions calculated correctly (cell position + offset)
- [ ] Handle edge cases:
  - Nets with single pin (no routing needed)
  - Nets with collinear pins (straight line)
  - Nets spanning multiple layers
- [ ] Performance: 1000 nets routed in <3 seconds
- [ ] Unit tests covering:
  - Point-to-point routing (various positions)
  - Multi-fanout routing
  - Junction detection
  - Cache behavior
  - Edge cases
- [ ] Integration tests with real layout data
- [ ] Test coverage >85%

---

## 5. Implementation Notes

### 5.1 Routing Strategy Selection

**L-Shape Routing** (2 segments):
- Source and sink on same layer or adjacent layers
- Vertical then horizontal, or horizontal then vertical

**Z-Shape Routing** (3 segments):
- Source and sink span multiple layers
- Vertical → Horizontal → Vertical

### 5.2 Channel Assignment

For MVP, use simple channel allocation:
- Channel Y-coordinate: `(source_layer_y + sink_layer_y) / 2`
- Future: more sophisticated channel assignment to reduce crossings

### 5.3 Driver/Load Identification

```python
def _identify_driver(self, net: Net) -> Optional[Pin]:
    """Find driver pin (OUTPUT direction)."""
    for pin in net.connected_pins:
        if pin.direction == PinDirection.OUTPUT:
            return pin
    return None  # No driver (e.g., input-only net)
```

### 5.4 Caching Strategy

- Cache key: `NetId`
- Invalidate cache when:
  - Cell positions change (layout update)
  - Net connectivity changes (expansion/collapse)
  - Router parameters change (channel height, etc.)

### 5.5 Error Handling

```python
if not net.connected_pins:
    raise ValueError(f"Net {net.id} has no connected pins")

if cell_id not in cell_positions:
    raise ValueError(f"Cell {cell_id} position not found in layout")
```

---

## 6. Test Scenarios

### Unit Tests

**Basic Routing:**
- Route horizontal net (same layer)
- Route vertical net (same column)
- Route diagonal net (L-shape)
- Route across multiple layers (Z-shape)

**Multi-Fanout:**
- 1-to-2 fanout (single branch)
- 1-to-4 fanout (multiple branches)
- Junction point detection

**Edge Cases:**
- Single-pin net (no routing)
- Two pins at same position (zero-length net)
- Collinear pins (straight line)
- No driver pin (input-only net)

**Performance:**
- Route 1000 simple nets in <3s
- Cache hit reduces computation time by >90%

### Integration Tests

**With Layout Engine:**
- Route nets after Sugiyama layout
- Verify segments connect to pin positions
- Check no overlap with cell bodies

---

## 7. Future Enhancements (Post-MVP)

- **A* Pathfinding:** Obstacle avoidance around cell bodies
- **Dynamic Channel Allocation:** Reduce crossings with track assignment
- **Bus Routing:** Special handling for multi-bit buses
- **Timing-Aware Routing:** Minimize critical path wire length

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F03 split |
