# E02-F03-T02: Orthogonal Router Implementation - Pre-Implementation Documentation

## Document Metadata
- **Task**: E02-F03-T02 - Orthogonal Router Implementation
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Opus 4.5

---

## 1. Overview

### 1.1 Task Summary

This task implements the core orthogonal (Manhattan) routing algorithm that converts logical net connectivity into visual geometric paths. The `ChannelRouter` infrastructure implementation consumes cell positions from the Sugiyama layout engine and produces `NetGeometry` objects for rendering. It must handle both simple point-to-point connections and complex multi-fanout topologies while minimizing wire length, bends, and visual clutter.

### 1.2 Problem Context

After the Sugiyama layout positions cells in hierarchical layers, nets exist as logical connections (pins on cells) without geometric representation. The router must:
- Convert pin positions to routed paths
- Use only horizontal and vertical segments (no diagonals)
- Route through horizontal channels between layers
- Minimize total wire length and number of bends
- Handle both 2-pin nets and N-pin multi-fanout nets
- Cache results for performance (1000+ nets must route in <3 seconds)

This is the critical path between layout (E02-F02) and rendering (E02-F03-T04) - without routing, there's no schematic to display.

### 1.3 Success Criteria

- Routes 1000 nets in <3 seconds
- All produced segments are strictly orthogonal
- Multi-fanout nets properly branch with junction identification
- Cache hit reduces computation time by >90%
- 85%+ test coverage with integration tests using real layout data
- Clean separation between domain protocol and infrastructure implementation

---

## 2. Implementation Approach

### 2.1 Architecture: Protocol + Implementation

**Domain Layer** (`src/ink/domain/services/net_router.py`):
```python
class NetRouter(Protocol):
    """Domain service interface for net routing"""
    def route_net(self, net: Net, cell_positions: Dict[CellId, Position]) -> NetGeometry: ...
    def route_all_nets(self, nets: List[Net], cell_positions: Dict[CellId, Position]) -> Dict[NetId, NetGeometry]: ...
```

**Infrastructure Layer** (`src/ink/infrastructure/routing/channel_router.py`):
```python
class ChannelRouter:
    """Concrete implementation using channel-based algorithm"""
    def __init__(self, channel_height: float = 50.0, via_clearance: float = 10.0): ...
    def route_net(self, net: Net, cell_positions: Dict[CellId, Position]) -> NetGeometry: ...
```

**Why this separation?**
- Domain protocol defines "what" (contract)
- Infrastructure implementation defines "how" (algorithm)
- Enables future alternative algorithms (A*, Steiner tree, etc.)
- Domain tests can mock router, infrastructure tests verify real routing

### 2.2 Channel-Based Routing Algorithm

**Core Concept**: Route nets through horizontal "channels" between Sugiyama layers

```
Layer 0:  [Cell A]           [Cell B]
            |                   |
            | (vertical to channel)
            |                   |
Channel: ---+-------------------+---  (horizontal routing area)
                |                   |
                | (vertical from channel)
                |                   |
Layer 1:     [Cell C]           [Cell D]
```

**Algorithm Steps**:

1. **Get Pin Positions** (absolute coordinates):
   - `pin_pos = cell_position + pin_offset`
   - Requires: Cell positions from layout engine, pin offsets from cell definition

2. **Identify Driver and Sinks**:
   - Driver: Pin with `PinDirection.OUTPUT`
   - Sinks: Pins with `PinDirection.INPUT` or `PinDirection.INOUT`
   - For nets with no driver: use first pin as source (warning)

3. **Route Point-to-Point** (2 pins):
   ```
   Source (x1, y1)
     |
     | (vertical to channel_y)
     |
     +---------> (horizontal to x2)
              |
              | (vertical to sink)
              |
         Sink (x2, y2)
   ```
   - L-shape (2 segments) if on same layer
   - Z-shape (3 segments) if spanning layers

4. **Route Multi-Fanout** (>2 pins):
   - Use star topology (MVP) - see T03 for details
   - Calculate junction position (median of sink X coordinates)
   - Route from source to junction
   - Branch from junction to each sink

5. **Collect Segments and Junctions**:
   - Return `NetGeometry` with all segments, junction points

### 2.3 Key Implementation Details

#### Pin Position Resolution
```python
def _get_pin_position(self, pin: Pin, cell_positions: Dict[CellId, Position]) -> Point:
    """Calculate absolute position of pin"""
    cell_pos = cell_positions[pin.cell.id]
    pin_offset = pin.position  # Relative to cell origin
    return Point(
        x=cell_pos.x + pin_offset.x,
        y=cell_pos.y + pin_offset.y
    )
```

**Challenge**: Pin offsets depend on cell symbol definition (E02-F01)
- May not be available in MVP
- **Fallback**: Use cell center position for all pins
- **Future**: Load pin offsets from symbol library

#### Channel Y-Coordinate Calculation
```python
def _get_channel_y(self, source: Point, sinks: List[Point]) -> float:
    """Determine Y coordinate for horizontal routing channel"""
    all_y = [source.y] + [s.y for s in sinks]
    return (min(all_y) + max(all_y)) / 2
```

**Trade-offs**:
- Midpoint: Balances vertical distance, may overlap cells
- Fixed offset: `source.y + channel_height`, simple but less optimal
- **MVP Choice**: Midpoint for simplicity

#### L-Shape vs Z-Shape Decision
```python
def _create_point_to_point_route(self, source: Point, sink: Point) -> List[LineSegment]:
    """Create orthogonal path between two points"""
    channel_y = (source.y + sink.y) / 2

    if abs(source.y - sink.y) < 10:  # Nearly same layer
        # L-shape (2 segments)
        return [
            LineSegment(source, Point(sink.x, source.y)),  # Horizontal
            LineSegment(Point(sink.x, source.y), sink)     # Vertical
        ]
    else:
        # Z-shape (3 segments)
        return [
            LineSegment(source, Point(source.x, channel_y)),           # Vertical
            LineSegment(Point(source.x, channel_y), Point(sink.x, channel_y)),  # Horizontal
            LineSegment(Point(sink.x, channel_y), sink)                # Vertical
        ]
```

#### Caching Strategy
```python
def route_net(self, net: Net, cell_positions: Dict[CellId, Position]) -> NetGeometry:
    # Cache key: net ID (assumes positions are stable)
    if net.id in self._geometry_cache:
        return self._geometry_cache[net.id]

    geometry = self._compute_routing(net, cell_positions)
    self._geometry_cache[net.id] = geometry
    return geometry

def clear_cache(self) -> None:
    """Invalidate cache (call after layout change)"""
    self._geometry_cache.clear()
```

**Cache Invalidation Triggers**:
- Cell positions change (expansion, collapse, layout re-run)
- Net connectivity changes (design modification)
- Router parameters change (channel height, etc.)

---

## 3. Key Design Decisions

### 3.1 Star Topology for Multi-Fanout (MVP)

**Decision**: Use star topology with central junction point

**Alternatives Considered**:

1. **Tree Topology**: Hierarchical branching
   - Pros: Optimal wire length (Steiner tree)
   - Cons: Complex algorithm, harder to understand visually
   - **Decision**: Defer to post-MVP

2. **Individual Routes**: Route each sink separately from source
   - Pros: Simplest algorithm
   - Cons: No junction visualization, confusing multi-fanout display
   - **Decision**: Reject - poor UX

**Rationale for Star**:
- Simple algorithm (median-based junction placement)
- Clear visual branching structure
- Acceptable wire length for gate-level (fanout typically <10)
- Easy junction detection (single point)

**Implementation in T03**: Star topology logic is part of multi-fanout handling

### 3.2 Channel Height Configuration

**Decision**: Configurable channel height with default 50.0

```python
def __init__(self, channel_height: float = 50.0, via_clearance: float = 10.0):
```

**Rationale**:
- Different designs may need different spacing
- Allows user tuning for visual clarity
- Default 50.0 based on typical cell height 30-40px + margin

**Future Enhancement**: Auto-calculate based on net density (more nets = larger channels)

### 3.3 Driver/Sink Identification

**Decision**: Use `PinDirection` with fallback to first pin

```python
def _identify_driver(self, net: Net) -> Pin:
    """Find driver pin (OUTPUT direction)"""
    for pin in net.connected_pins:
        if pin.direction == PinDirection.OUTPUT:
            return pin

    # No driver found - use first pin with warning
    logger.warning(f"Net {net.name} has no OUTPUT pin, using first pin as driver")
    return net.connected_pins[0]
```

**Edge Cases**:
- Input-only net (e.g., top-level input port): First pin as "driver"
- Multi-driver net (invalid): Take first OUTPUT, emit warning
- All INOUT pins: Take first, emit warning

**Validation**: Application layer should catch multi-driver nets (ERC check)

### 3.4 Crossing Detection (Deferred)

**Decision**: Populate `NetGeometry.crossings` as empty tuple in MVP

**Rationale**:
- Crossing detection requires comparing all net pairs: O(N²)
- For 1000 nets: 500K comparisons, too slow
- Need spatial indexing (R-tree, quadtree) for efficiency
- Not critical for MVP rendering (can draw overlapping nets)

**Future Enhancement**:
- Build spatial index during routing
- Detect crossings in post-processing pass
- Render crossing indicators (arc/bridge) in presentation layer

### 3.5 Error Handling Strategy

**Decision**: Raise `ValueError` for invalid inputs, warn for degraded cases

```python
def route_net(self, net: Net, cell_positions: Dict[CellId, Position]) -> NetGeometry:
    if not net.connected_pins:
        raise ValueError(f"Net {net.name} has no connected pins")

    for pin in net.connected_pins:
        if pin.cell.id not in cell_positions:
            raise ValueError(f"Cell {pin.cell.id} position not found in layout")

    # Warnings for non-critical issues
    if len(net.connected_pins) == 1:
        logger.warning(f"Net {net.name} has only one pin (unconnected)")

    # Continue with routing...
```

**Error Categories**:
- **Hard Errors** (raise): No pins, missing cell position (can't route)
- **Warnings** (log): Single pin, no driver, high fanout (can route, may be suboptimal)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E02-F03-T01 (Net Geometry Data Structure)**:
- `Point`, `LineSegment`, `NetGeometry` value objects
- Must be completed before T02 implementation starts

**E01-F03 (Net Domain Model)**:
- `Net` entity with `connected_pins` collection
- `Pin` entity with `direction`, `cell`, `position` properties
- `NetId` identifier type

**E02-F02 (Sugiyama Layout Engine)**:
- `cell_positions: Dict[CellId, Position]` output
- Assumes layout is complete before routing

**E02-F01 (Cell Symbol Rendering)**:
- Pin position offsets (relative to cell origin)
- **MVP Fallback**: If not available, use cell center for all pins

**Domain Value Objects**:
- `PinDirection` enum (INPUT, OUTPUT, INOUT)
- `Position` value object

### 4.2 Downstream Consumers

**E02-F03-T03 (Multi-Fanout Handling)**:
- Uses `ChannelRouter._create_star_topology()` method
- Populates `NetGeometry.junctions` field

**E02-F03-T04 (Net Graphics Item)**:
- Consumes `NetGeometry` for rendering
- Expects all segments to be orthogonal (validates in debug mode)

**Application Layer (Schematic Rendering Service)**:
- Calls `route_all_nets()` after layout complete
- Manages cache invalidation on expansion/collapse

**Presentation Layer (Canvas)**:
- Adds `NetItem` graphics items to scene
- Triggers re-routing on layout changes

### 4.3 Integration Workflow

```
Layout Engine (E02-F02)
    ↓ (produces cell_positions)
Router (E02-F03-T02)
    ↓ (produces NetGeometry)
Graphics Item (E02-F03-T04)
    ↓ (renders to canvas)
Qt Graphics Scene
```

**Data Flow**:
1. User expands cells → triggers layout
2. Layout engine positions cells → returns `cell_positions`
3. Router routes all visible nets → returns `Dict[NetId, NetGeometry]`
4. Canvas creates `NetItem` for each geometry
5. Qt renders items to screen

**Cache Invalidation Flow**:
1. User expands/collapses cells
2. Application service detects layout change
3. Calls `router.clear_cache()`
4. Next render triggers re-routing

---

## 5. Testing Strategy

### 5.1 Unit Test Structure

```
tests/unit/infrastructure/routing/
└── test_channel_router.py
    ├── TestPinPositionResolution
    │   ├── test_absolute_position_calculation
    │   ├── test_missing_cell_position_raises
    │   └── test_pin_offset_handling
    ├── TestDriverIdentification
    │   ├── test_single_driver_identified
    │   ├── test_no_driver_uses_first_pin
    │   ├── test_multi_driver_warns
    │   └── test_all_inout_pins
    ├── TestPointToPointRouting
    │   ├── test_horizontal_net_same_layer
    │   ├── test_vertical_net_same_column
    │   ├── test_l_shape_routing
    │   ├── test_z_shape_routing
    │   └── test_minimal_bends
    ├── TestCaching
    │   ├── test_cache_hit_returns_same_object
    │   ├── test_cache_miss_computes_routing
    │   ├── test_clear_cache_invalidates
    │   └── test_cache_performance_improvement
    └── TestErrorHandling
        ├── test_empty_net_raises
        ├── test_missing_cell_position_raises
        ├── test_single_pin_warns
        └── test_collinear_pins_straight_line
```

### 5.2 Integration Test Structure

```
tests/integration/routing/
└── test_routing_integration.py
    ├── test_route_after_layout
    ├── test_route_with_real_netlist
    ├── test_multi_fanout_junction_detection
    ├── test_cache_invalidation_after_expansion
    └── test_performance_1000_nets
```

### 5.3 Test Scenarios

#### Unit Tests

**Scenario 1: Horizontal Net (Same Layer)**
```python
def test_horizontal_net():
    """Route net between two cells on same layer"""
    router = ChannelRouter()

    # Mock net with two pins
    cell_a = Cell(id=CellId("A"), ...)
    cell_b = Cell(id=CellId("B"), ...)
    pin_a_out = Pin(cell=cell_a, direction=PinDirection.OUTPUT, ...)
    pin_b_in = Pin(cell=cell_b, direction=PinDirection.INPUT, ...)
    net = Net(id=NetId("net1"), connected_pins=[pin_a_out, pin_b_in])

    # Cell positions (same Y)
    positions = {
        CellId("A"): Position(x=0, y=100),
        CellId("B"): Position(x=200, y=100)
    }

    geometry = router.route_net(net, positions)

    # Should produce L-shape or straight line
    assert geometry.validate()
    assert all(seg.is_orthogonal for seg in geometry.segments)
    assert len(geometry.junctions) == 0  # No branching
```

**Scenario 2: Multi-Fanout Star Topology** (Deferred to T03 tests)

**Scenario 3: Cache Behavior**
```python
def test_cache_hit():
    """Second routing of same net uses cache"""
    router = ChannelRouter()
    geometry1 = router.route_net(net, positions)
    geometry2 = router.route_net(net, positions)

    assert geometry1 is geometry2  # Same object (cache hit)

def test_cache_clear():
    """Cache invalidation forces re-routing"""
    router = ChannelRouter()
    geometry1 = router.route_net(net, positions)
    router.clear_cache()
    geometry2 = router.route_net(net, positions)

    assert geometry1 is not geometry2  # Different objects
    assert geometry1 == geometry2      # But equal values
```

#### Integration Tests

**Scenario 4: End-to-End Routing**
```python
def test_route_after_sugiyama_layout():
    """Route nets after layout engine positions cells"""
    # 1. Parse netlist
    graph = NetlistGraph.from_files("examples/counter_8bit.ckt", "examples/counter_8bit.pindir")

    # 2. Run layout
    layout_engine = SugiyamaLayoutEngine()
    cell_positions = layout_engine.layout(graph.cells())

    # 3. Route nets
    router = ChannelRouter()
    geometries = router.route_all_nets(graph.nets(), cell_positions)

    # 4. Verify
    assert len(geometries) == len(graph.nets())
    for net_id, geom in geometries.items():
        assert geom.validate()  # All geometries valid
        assert geom.net_id == net_id
```

**Scenario 5: Performance Benchmark**
```python
@pytest.mark.benchmark
def test_route_1000_nets(benchmark):
    """Route 1000 nets in <3 seconds"""
    # Generate 1000 synthetic nets
    nets = generate_synthetic_nets(count=1000, avg_fanout=3)
    positions = generate_grid_positions(count=1000)

    router = ChannelRouter()
    result = benchmark(router.route_all_nets, nets, positions)

    assert benchmark.stats.mean < 3.0  # <3 seconds
```

### 5.4 Test Data

**Fixtures**:
```python
@pytest.fixture
def simple_two_cell_net():
    """Net connecting two cells (point-to-point)"""
    # Returns: (net, cell_positions)

@pytest.fixture
def multi_fanout_net():
    """Net with one driver, four sinks (star topology)"""
    # Returns: (net, cell_positions)

@pytest.fixture
def complex_layout():
    """Realistic layout from counter_8bit.ckt"""
    # Returns: (graph, cell_positions)
```

**Synthetic Data Generation**:
```python
def generate_synthetic_nets(count: int, avg_fanout: int) -> List[Net]:
    """Generate N nets with random fanout for stress testing"""
```

---

## 6. Risks and Mitigations

### 6.1 Technical Risks

#### Risk 1: Pin Position Unavailable (MVP)
**Impact**: High (can't route without pin positions)
**Probability**: High (symbol library may not be ready)

**Mitigation**:
- **Fallback**: Use cell center for all pins
- Produces valid (but less optimal) routing
- Document limitation in code comments
- Integration test verifies fallback works

**Contingency**:
- Hardcode common pin positions (e.g., "A" on left, "Y" on right for inverter)
- Load pin positions from config file
- Defer routing to post-MVP if critical

**Detection**: Unit test with missing pin offsets

#### Risk 2: Channel Overlap with Cell Bodies
**Impact**: Medium (visually confusing, nets overlap cells)
**Probability**: Medium (midpoint channel may intersect cells)

**Mitigation**:
- Use `via_clearance` parameter to avoid cells
- Future: Obstacle-aware routing (A* algorithm)
- Accept overlap for MVP (document as known issue)

**Contingency**:
- Increase channel height
- Use fixed offset instead of midpoint
- Add "smart channel allocation" in post-MVP

**Detection**: Visual inspection during integration testing

#### Risk 3: Performance Bottleneck on Large Netlists
**Impact**: Medium (slow rendering, poor UX)
**Probability**: Low (algorithm is O(E) where E = edges, should be fast)

**Estimation**:
```
1000 nets × 3 pins avg × 10μs/pin = 30ms (well under 3s target)
```

**Mitigation**:
- Profile early (Phase 3)
- Optimize hot paths (pin position calculation)
- Use caching aggressively
- Parallelize routing (future - each net independent)

**Contingency**:
- Lazy routing (route only visible area)
- LOD: Skip routing at low zoom levels
- Pre-compute routing offline, load from cache

**Detection**: Benchmark suite in CI

#### Risk 4: Diagonal Segments Due to FP Error
**Impact**: Medium (validation failures, rendering glitches)
**Probability**: Low (using explicit horizontal/vertical construction)

**Mitigation**:
- Always construct segments with explicit orthogonal coordinates
- Use `math.isclose()` in validation with tolerance
- Unit test with near-orthogonal coordinates

**Example**:
```python
# Bad: might produce diagonal due to FP error
LineSegment(source, sink)

# Good: explicit orthogonal construction
channel_y = (source.y + sink.y) / 2
LineSegment(Point(source.x, channel_y), Point(sink.x, channel_y))
```

**Detection**: Validation tests catch diagonal segments

### 6.2 Integration Risks

#### Risk 5: Layout-Router Coordinate Mismatch
**Impact**: High (routed nets don't connect to pins visually)
**Probability**: Low (both use domain `Position` type)

**Mitigation**:
- Integration test verifies pin positions match layout
- Visual regression test (screenshot comparison)
- Document coordinate system clearly

**Detection**: First end-to-end rendering test

#### Risk 6: Cache Invalidation Bugs
**Impact**: Medium (stale routing after expansion/collapse)
**Probability**: Medium (cache invalidation is notoriously hard)

**Mitigation**:
- Simple cache key (net ID only)
- Explicit `clear_cache()` method (no auto-invalidation)
- Application layer responsible for invalidation logic
- Integration test verifies cache cleared after expansion

**Contingency**:
- Disable caching if bugs persist
- Add cache versioning (invalidate on version mismatch)
- Log cache hits/misses for debugging

**Detection**: Integration test with expansion workflow

---

## 7. Implementation Plan

### 7.1 Development Phases

#### Phase 1: Domain Protocol (1 hour)
- Create `src/ink/domain/services/net_router.py`
- Define `NetRouter` protocol with type hints
- Write docstrings with usage examples
- No implementation yet (just interface)

**Deliverables**:
- `NetRouter` protocol class
- Docstrings with contract specification
- Type hints reviewed (mypy clean)

#### Phase 2: Basic Router Skeleton (2 hours)
- Create `src/ink/infrastructure/routing/channel_router.py`
- Implement `__init__` with configuration
- Implement `route_net()` with simple L-shape routing (2 pins only)
- Implement pin position resolution
- Implement driver/sink identification
- Basic unit tests

**Deliverables**:
- `ChannelRouter` class with basic routing
- Pin position calculation working
- Tests for 2-pin horizontal/vertical nets

#### Phase 3: Point-to-Point Routing (4 hours)
- Implement `_create_point_to_point_route()` with L/Z-shape logic
- Channel Y-coordinate calculation
- Edge case handling (collinear pins, zero distance)
- Comprehensive unit tests
- Validation that all segments are orthogonal

**Deliverables**:
- Full point-to-point routing working
- Tests for all routing shapes (L, Z, straight)
- 60%+ coverage

#### Phase 4: Route All Nets & Caching (3 hours)
- Implement `route_all_nets()` method
- Add caching logic
- Cache invalidation (`clear_cache()`)
- Error handling (missing positions, empty nets)
- Performance tests

**Deliverables**:
- Batch routing working
- Cache measurably improves performance
- Error handling tested
- 80%+ coverage

#### Phase 5: Integration Testing (4 hours)
- Integration test with Sugiyama layout output
- Integration test with real netlist (counter_8bit.ckt)
- Performance benchmark (1000 nets)
- Visual validation (manual inspection of rendered schematic)
- Bug fixes from integration testing

**Deliverables**:
- Integration tests passing
- Performance target met (<3s for 1000 nets)
- 85%+ coverage
- Ready for T03 (multi-fanout) integration

#### Phase 6: Documentation & Polish (2 hours)
- Docstrings for all public/private methods
- Algorithm documentation in module docstring
- Usage examples
- Code review and cleanup
- Linting and type checking

**Deliverables**:
- Complete documentation
- Clean code (mypy, ruff clean)
- Ready for peer review

**Total Estimated Time**: 16 hours (matches spec estimate)

### 7.2 Testing Milestones

- **After Phase 2**: Basic routing tests pass (2-pin nets)
- **After Phase 3**: 60%+ coverage, point-to-point complete
- **After Phase 4**: 80%+ coverage, batch routing works
- **After Phase 5**: 85%+ coverage, integration tests pass
- **After Phase 6**: Ready for merge

### 7.3 Integration Checkpoints

**Before T03 starts**:
- Basic routing (point-to-point) complete and tested
- `_identify_junctions()` stub exists (for T03 to implement)
- API stable

**Before T04 starts**:
- All routing complete (including multi-fanout from T03)
- Sample geometries available for testing
- Performance targets met

**Before E03 (Expansion) starts**:
- Routing integrates with layout engine
- Cache invalidation strategy documented
- End-to-end test passes

---

## 8. Open Questions

### 8.1 Design Questions

**Q1**: Should router handle power/ground nets specially?
- VDD/VSS often have high fanout (100+ pins)
- May need different routing strategy (grid, not star)
- **Decision**: Treat like regular nets for MVP. Filter out in application layer if too cluttered.

**Q2**: Should router optimize for minimal wire length?
- Current: Simple midpoint channel (acceptable but not optimal)
- Alternative: Minimize total Manhattan distance (Steiner tree)
- **Decision**: Defer optimization to post-MVP. Simple algorithm sufficient for MVP.

**Q3**: How to handle nets with no driver?
- Use case: Top-level input ports, tristated buses
- Current: Use first pin as "driver" with warning
- **Decision**: Accept for MVP. Application layer should validate.

**Q4**: Should crossing detection be in router or separate pass?
- Router: Add during routing (requires spatial index)
- Separate: Post-process after all routing complete
- **Decision**: Defer to post-MVP. Populate `crossings` as empty tuple.

### 8.2 Performance Questions

**Q5**: Should routing be parallelized?
- Each net is independent (embarrassingly parallel)
- Python GIL limits true parallelism
- **Decision**: Not for MVP. Profile first, then consider multiprocessing.

**Q6**: Should we use numba/cython for hot paths?
- Pin position calculation is tight loop
- Could JIT-compile with numba
- **Decision**: No for MVP. Keep pure Python. Optimize only if profiling shows bottleneck.

### 8.3 Future Enhancements

**Q7**: Support for bus routing?
- Multi-bit buses should route together (bundled)
- Requires bus detection and grouping
- **Decision**: Single-net routing for MVP. P1 feature.

**Q8**: Support for non-Manhattan routing?
- 45-degree angles (octilinear)
- Curved routing for aesthetics
- **Decision**: No. Orthogonal only for MVP.

---

## 9. Definition of Done

### 9.1 Code Completeness
- [ ] `NetRouter` protocol defined in domain layer
- [ ] `ChannelRouter` implementation in infrastructure layer
- [ ] `route_net()` produces valid `NetGeometry`
- [ ] `route_all_nets()` batch routing implemented
- [ ] Pin position resolution working (with fallback)
- [ ] Driver/sink identification implemented
- [ ] Point-to-point routing (L-shape, Z-shape) implemented
- [ ] Caching with `clear_cache()` implemented
- [ ] All segments strictly orthogonal (validated)

### 9.2 Testing
- [ ] 85%+ test coverage
- [ ] All unit tests pass
- [ ] Integration tests with layout engine
- [ ] Performance benchmark: 1000 nets in <3s
- [ ] Cache performance test: >90% reduction in computation
- [ ] Edge case tests (no driver, single pin, collinear pins)

### 9.3 Quality
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] Code reviewed
- [ ] No TODOs in production code

### 9.4 Documentation
- [ ] Protocol docstrings complete
- [ ] Implementation docstrings complete
- [ ] Algorithm documented in module docstring
- [ ] Usage examples provided
- [ ] Integration guide for T03/T04

### 9.5 Integration Readiness
- [ ] Integration test with Sugiyama layout passes
- [ ] Sample geometries created for T04
- [ ] Cache invalidation strategy documented
- [ ] Performance profiling complete
- [ ] No blocking issues for T03/T04

---

## 10. Next Steps

1. **Create domain protocol** - Define `NetRouter` interface
2. **Implement skeleton** - Basic `ChannelRouter` with 2-pin routing
3. **TDD cycle** - Implement features with tests first
4. **Integration testing** - Test with real layout data
5. **Performance profiling** - Verify <3s target
6. **Code review** - Coordinate with T03/T04 implementers

---

## Appendix A: Algorithm Pseudocode

### Point-to-Point Routing (2 Pins)

```python
def route_point_to_point(source: Point, sink: Point) -> List[LineSegment]:
    """
    Route orthogonal path from source to sink.

    Returns L-shape (2 segments) or Z-shape (3 segments).
    """
    # Calculate channel Y (midpoint between source and sink)
    channel_y = (source.y + sink.y) / 2

    # If nearly same layer, use L-shape
    if abs(source.y - sink.y) < 10:
        # Horizontal then vertical (or vice versa)
        return [
            LineSegment(source, Point(sink.x, source.y)),  # Horizontal
            LineSegment(Point(sink.x, source.y), sink)     # Vertical
        ]

    # Different layers, use Z-shape
    return [
        LineSegment(source, Point(source.x, channel_y)),           # Vertical down
        LineSegment(Point(source.x, channel_y), Point(sink.x, channel_y)),  # Horizontal across
        LineSegment(Point(sink.x, channel_y), sink)                # Vertical down
    ]
```

### Route All Nets

```python
def route_all_nets(nets: List[Net], cell_positions: Dict[CellId, Position]) -> Dict[NetId, NetGeometry]:
    """Route all nets and return geometries"""
    geometries = {}

    for net in nets:
        try:
            geom = route_net(net, cell_positions)
            geometries[net.id] = geom
        except ValueError as e:
            logger.error(f"Failed to route net {net.name}: {e}")
            # Continue routing other nets

    return geometries
```

---

## Appendix B: Performance Analysis

### Time Complexity

**Per-Net Routing**:
- Pin position calculation: O(P) where P = pins on net
- Driver identification: O(P)
- Segment creation: O(P) for multi-fanout
- **Total: O(P) per net**

**Batch Routing**:
- N nets, avg P pins per net
- **Total: O(N × P)**

**For 1000 nets with avg 3 pins**:
- 3000 pin position calculations
- Estimated 30ms (well under 3s target)

**Cache Hit**:
- Dictionary lookup: O(1)
- **Total: O(1) per net (instant)**

### Space Complexity

**Per-Net Geometry**:
- Avg 5 segments × 64 bytes/segment = 320 bytes
- Junctions/crossings: 80 bytes
- **Total: ~400 bytes per net**

**For 1000 nets**:
- 400KB (negligible)

**Cache Size**:
- Same as geometry size (400KB for 1000 nets)
- Acceptable memory overhead

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Opus 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
