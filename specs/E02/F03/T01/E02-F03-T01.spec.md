---
id: E02-F03-T01
title: Net Geometry Data Structure
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F03
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Small
tags:
  - domain
  - value-objects
clickup_task_id: ''
---

# Spec: E02-F03-T01 - Net Geometry Data Structure

## 1. Overview

### 1.1 Problem Statement

Nets need geometric representations for rendering on the schematic canvas. This requires data structures to store routing information including line segments, junction points, and crossing indicators. These structures must be efficient for rendering and support both simple point-to-point nets and complex multi-fanout topologies.

### 1.2 Goals

- Define value objects for net geometry representation
- Support orthogonal (Manhattan) routing with horizontal/vertical segments
- Track junction points for multi-fanout visualization
- Track crossing points for visual disambiguation
- Provide immutable, serializable structures

---

## 2. Technical Requirements

### 2.1 Value Objects

Create the following value objects in `src/ink/domain/value_objects/geometry.py`:

**Point**
```python
@dataclass(frozen=True)
class Point:
    """A 2D point in schematic coordinate space."""
    x: float
    y: float

    def distance_to(self, other: Point) -> float:
        """Calculate Euclidean distance to another point."""
        pass

    def manhattan_distance_to(self, other: Point) -> float:
        """Calculate Manhattan distance to another point."""
        pass
```

**LineSegment**
```python
@dataclass(frozen=True)
class LineSegment:
    """A line segment connecting two points."""
    start: Point
    end: Point

    @property
    def is_horizontal(self) -> bool:
        """True if segment is horizontal (same y)."""
        pass

    @property
    def is_vertical(self) -> bool:
        """True if segment is vertical (same x)."""
        pass

    @property
    def is_orthogonal(self) -> bool:
        """True if segment is horizontal or vertical."""
        pass

    @property
    def length(self) -> float:
        """Euclidean length of segment."""
        pass

    @property
    def manhattan_length(self) -> float:
        """Manhattan length (sum of dx and dy)."""
        pass
```

**NetGeometry**
```python
@dataclass(frozen=True)
class NetGeometry:
    """
    Routing geometry for a net.

    Contains all information needed to render a net on the schematic canvas,
    including line segments, junction points, and crossing indicators.
    """
    net_id: NetId
    segments: Tuple[LineSegment, ...]  # All routing segments
    junctions: Tuple[Point, ...]  # Branch points for multi-fanout
    crossings: Tuple[Point, ...]  # Where this net crosses other nets

    @property
    def total_length(self) -> float:
        """Total Manhattan length of all segments."""
        pass

    @property
    def bend_count(self) -> int:
        """Number of bends (segment direction changes)."""
        pass

    def validate(self) -> bool:
        """
        Validate geometry constraints.

        Returns:
            True if all segments are orthogonal

        Raises:
            ValueError: If geometry is invalid
        """
        pass
```

### 2.2 Layer Location

- File: `src/ink/domain/value_objects/geometry.py`
- Layer: Domain (no external dependencies)
- Import path: `from ink.domain.value_objects.geometry import Point, LineSegment, NetGeometry`

### 2.3 Validation Rules

**NetGeometry validation:**
- All segments must be orthogonal (horizontal or vertical)
- Segments should form connected paths
- Junctions should be located where segments meet
- Points should use finite float values (no NaN/infinity)

### 2.4 Serialization Support

All value objects must be serializable to/from dictionaries for session persistence:

```python
# NetGeometry example
def to_dict(self) -> Dict[str, Any]:
    """Serialize to dictionary."""
    pass

@classmethod
def from_dict(cls, data: Dict[str, Any]) -> NetGeometry:
    """Deserialize from dictionary."""
    pass
```

---

## 3. Dependencies

- **Upstream**:
  - E01-F03 (Net domain model - provides `NetId`)
  - Domain value objects infrastructure

- **Downstream**:
  - E02-F03-T02 (Orthogonal router uses these structures)
  - E02-F03-T03 (Multi-fanout handling uses junction points)
  - Presentation layer (`NetItem` QGraphicsItem)

---

## 4. Acceptance Criteria

- [ ] `Point` value object created with distance methods
- [ ] `LineSegment` value object with orthogonal detection
- [ ] `NetGeometry` value object with segments, junctions, crossings
- [ ] All value objects are immutable (`frozen=True`)
- [ ] Validation enforces orthogonal-only segments
- [ ] `total_length` and `bend_count` properties implemented
- [ ] Serialization methods (`to_dict`/`from_dict`) implemented
- [ ] Type hints for all methods and properties
- [ ] Unit tests covering:
  - Point distance calculations
  - LineSegment orthogonal detection
  - NetGeometry validation (rejects diagonal segments)
  - Serialization round-trip
  - Total length and bend count calculations
- [ ] Test coverage >90% for geometry module
- [ ] Documentation with usage examples

---

## 5. Implementation Notes

### 5.1 Coordinate System

- Origin (0, 0) at top-left of canvas
- X increases rightward
- Y increases downward
- Units: logical pixels (not scaled by zoom)

### 5.2 Floating Point Precision

Use `math.isclose()` for floating-point comparisons:
```python
def is_horizontal(self) -> bool:
    return math.isclose(self.start.y, self.end.y, abs_tol=1e-6)
```

### 5.3 Tuple vs List

Use `Tuple` for immutability in value objects:
- `segments: Tuple[LineSegment, ...]` (immutable)
- Not: `segments: List[LineSegment]` (mutable)

---

## 6. Test Scenarios

### Unit Tests

**Point Tests:**
- Euclidean distance calculation
- Manhattan distance calculation
- Equality and hashing

**LineSegment Tests:**
- Horizontal segment detection
- Vertical segment detection
- Diagonal segment detection (not orthogonal)
- Length calculations
- Edge cases: zero-length segments

**NetGeometry Tests:**
- Valid orthogonal routing
- Invalid diagonal segment rejection
- Total length calculation
- Bend counting
- Serialization/deserialization
- Empty geometry (no segments)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F03 split |
