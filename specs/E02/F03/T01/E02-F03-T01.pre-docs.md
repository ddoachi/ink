# E02-F03-T01: Net Geometry Data Structure - Pre-Implementation Documentation

## Document Metadata
- **Task**: E02-F03-T01 - Net Geometry Data Structure
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Opus 4.5

---

## 1. Overview

### 1.1 Task Summary

This task defines the foundational value objects for representing net routing geometry in the domain layer. These immutable data structures (`Point`, `LineSegment`, `NetGeometry`) will be consumed by both the infrastructure routing engine and the presentation layer for rendering. The geometry must support orthogonal (Manhattan) routing with explicit junction and crossing points for visual disambiguation.

### 1.2 Problem Context

Nets in gate-level schematics need visual representations beyond simple logical connectivity. The routing geometry must:
- Support orthogonal paths (no diagonal lines in Manhattan routing)
- Track junction points where multi-fanout nets branch
- Track crossing points where different nets intersect
- Be serializable for session persistence
- Remain immutable to prevent accidental mutations during rendering

These structures bridge the gap between the routing algorithm (which computes paths) and the graphics layer (which renders paths).

### 1.3 Success Criteria

- All value objects are immutable and type-safe
- Validation enforces orthogonal-only constraints
- Serialization round-trips without data loss
- 90%+ test coverage with comprehensive edge cases
- Clear API that's intuitive for both infrastructure and presentation layers

---

## 2. Implementation Approach

### 2.1 Core Data Structures

**Point** - Fundamental 2D coordinate:
```python
@dataclass(frozen=True)
class Point:
    x: float
    y: float
```
- Simple, immutable coordinate representation
- Both Euclidean and Manhattan distance methods
- Used by all other geometry structures

**LineSegment** - Connection between two points:
```python
@dataclass(frozen=True)
class LineSegment:
    start: Point
    end: Point
```
- Properties to detect horizontal/vertical/orthogonal orientation
- Length calculations (both Euclidean and Manhattan)
- Foundation for routing path representation

**NetGeometry** - Complete routing representation:
```python
@dataclass(frozen=True)
class NetGeometry:
    net_id: NetId
    segments: Tuple[LineSegment, ...]
    junctions: Tuple[Point, ...]
    crossings: Tuple[Point, ...]
```
- Aggregates all routing information for a single net
- Validation ensures all segments are orthogonal
- Computed properties: total length, bend count

### 2.2 Design Decisions

#### Decision 1: Immutable vs Mutable
**Choice**: Frozen dataclasses (immutable)

**Rationale**:
- Routing geometry won't change after computation (set once, read many)
- Thread-safe for future parallel rendering
- Prevents accidental mutations during multi-step rendering pipeline
- Functional programming style reduces bugs

**Trade-off**: Slightly more memory (can't modify in place), but negligible for typical netlists

#### Decision 2: Tuple vs List for Collections
**Choice**: `Tuple[LineSegment, ...]` not `List[LineSegment]`

**Rationale**:
- Enforces immutability at type level
- Slightly lower memory overhead
- Signals to consumers that collection won't change
- Matches frozen dataclass philosophy

#### Decision 3: Float vs Integer Coordinates
**Choice**: `float` for x, y coordinates

**Rationale**:
- Layout engine produces float coordinates (Sugiyama algorithm)
- Sub-pixel positioning for smoother rendering at high zoom
- Alignment with Qt's `QPointF` (float-based)
- Standard for graphics programming

**Trade-off**: Need `math.isclose()` for equality checks (floating-point precision)

#### Decision 4: Validation Strategy
**Choice**: Explicit `validate()` method, not automatic in `__post_init__`

**Rationale**:
- Allows construction of invalid geometry during routing algorithm development
- Validation can be selectively enabled (strict mode vs permissive)
- Better error messages (can accumulate all violations)
- Performance: skip validation for trusted sources

### 2.3 File Organization

```
src/ink/domain/value_objects/
├── __init__.py
├── geometry.py          # New file (Point, LineSegment, NetGeometry)
├── identifiers.py       # Existing (NetId, CellId, etc.)
├── position.py          # Existing (Position, BoundingBox)
└── pin_direction.py     # Existing (PinDirection enum)
```

**Why `geometry.py` as a single file?**
- Three closely related classes (high cohesion)
- Total ~200 LOC (not too large)
- Easy to import as unit: `from ink.domain.value_objects.geometry import Point, LineSegment, NetGeometry`

---

## 3. Key Design Decisions

### 3.1 Coordinate System Convention

**Decision**: Y-axis increases downward (screen coordinates)

```
(0,0) ────────> X
  │
  │
  │
  V
  Y
```

**Rationale**:
- Matches Qt/PySide6 coordinate system (QGraphicsScene)
- Common in UI frameworks (HTML Canvas, JavaFX, WPF)
- Avoids coordinate transformation between domain and presentation

**Alternative Considered**: Mathematical coordinates (Y up)
- Would require transformation in presentation layer
- Adds complexity and potential for errors
- No benefit for schematic viewer (not a math application)

### 3.2 Orthogonal Detection Tolerance

**Decision**: Use `abs_tol=1e-6` for floating-point comparison

```python
def is_horizontal(self) -> bool:
    return math.isclose(self.start.y, self.end.y, abs_tol=1e-6)
```

**Rationale**:
- Layout engine may produce coordinates like `100.0000001` due to FP arithmetic
- 1e-6 tolerance negligible at visual scale (< 0.001 pixels)
- Standard practice in graphics programming
- Prevents false negatives in validation

**Testing**: Include tests with near-orthogonal segments (e.g., 100.0 vs 100.0000005)

### 3.3 Serialization Format

**Decision**: Simple dictionary serialization (not Protocol Buffers)

```python
def to_dict(self) -> Dict[str, Any]:
    return {
        'net_id': str(self.net_id),
        'segments': [
            {'start': {'x': s.start.x, 'y': s.start.y},
             'end': {'x': s.end.x, 'y': s.end.y}}
            for s in self.segments
        ],
        'junctions': [{'x': p.x, 'y': p.y} for p in self.junctions],
        'crossings': [{'x': p.x, 'y': p.y} for p in self.crossings]
    }
```

**Rationale**:
- Human-readable for debugging
- Easy JSON serialization for session files
- No external dependencies (protobuf, msgpack)
- Fast enough for typical session sizes (<10K nets)

**Future Enhancement**: Switch to compact binary format if session save/load too slow

### 3.4 Validation Error Handling

**Decision**: Raise `ValueError` with detailed message on validation failure

```python
def validate(self) -> bool:
    errors = []
    for i, seg in enumerate(self.segments):
        if not seg.is_orthogonal:
            errors.append(f"Segment {i} is diagonal: {seg.start} -> {seg.end}")

    if errors:
        raise ValueError(f"NetGeometry validation failed:\n" + "\n".join(errors))

    return True
```

**Rationale**:
- Fail fast: catch invalid geometry immediately
- Detailed errors: helps debug routing algorithm
- Accumulate all errors: fix multiple issues in one pass
- Boolean return for optional validation checks

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**From E01-F03 (Net Domain Model)**:
- `NetId` value object (identifier type)
- Ensures type safety: `NetGeometry` references are unambiguous

**From Domain Value Objects Infrastructure**:
- `@dataclass(frozen=True)` pattern
- Type hints and validation conventions

**External Libraries**:
- `math` (standard library) - for `isclose()`, `sqrt()`, `hypot()`
- `typing` (standard library) - for `Tuple`, `Dict`, `Any`
- No external dependencies (pure Python)

### 4.2 Downstream Consumers

**E02-F03-T02 (Orthogonal Router)**:
- Router implementation creates `NetGeometry` instances
- Must construct valid segments (all orthogonal)
- Populates junctions during multi-fanout routing

**E02-F03-T03 (Multi-Fanout Handling)**:
- Identifies junction points in star/tree topologies
- Populates `junctions` field in `NetGeometry`

**E02-F03-T04 (Net Graphics Item)**:
- Consumes `NetGeometry` for rendering
- Converts `Point` to `QPointF`
- Draws `LineSegment` as QPainterPath
- Renders junction dots at junction points

**Presentation Layer (NetItem QGraphicsItem)**:
- Direct mapping: `NetGeometry.segments` → QPainterPath
- Direct mapping: `NetGeometry.junctions` → filled circles

### 4.3 Integration Constraints

**Must NOT depend on**:
- PySide6 (domain layer, no UI dependencies)
- NetworkX (domain layer, no infrastructure dependencies)
- Application layer (use cases, services)

**Must be usable from**:
- Infrastructure layer (routing implementations)
- Presentation layer (graphics items)
- Application layer (if needed for queries)

---

## 5. Testing Strategy

### 5.1 Unit Test Structure

```
tests/unit/domain/value_objects/
└── test_geometry.py
    ├── TestPoint
    │   ├── test_creation
    │   ├── test_distance_euclidean
    │   ├── test_distance_manhattan
    │   ├── test_equality
    │   └── test_immutability
    ├── TestLineSegment
    │   ├── test_horizontal_detection
    │   ├── test_vertical_detection
    │   ├── test_diagonal_detection
    │   ├── test_orthogonal_property
    │   ├── test_length_calculations
    │   └── test_edge_cases_zero_length
    └── TestNetGeometry
        ├── test_valid_orthogonal_routing
        ├── test_invalid_diagonal_rejection
        ├── test_total_length_calculation
        ├── test_bend_counting
        ├── test_serialization_roundtrip
        └── test_empty_geometry
```

### 5.2 Test Coverage Goals

**Target**: 90%+ line coverage, 100% branch coverage

**Critical Paths**:
- Orthogonal detection (horizontal, vertical, diagonal)
- Validation (must reject diagonal segments)
- Serialization (round-trip without data loss)
- Edge cases (zero-length segments, empty geometry)

### 5.3 Test Scenarios

#### Point Tests
```python
def test_euclidean_distance():
    p1 = Point(0, 0)
    p2 = Point(3, 4)
    assert p1.distance_to(p2) == 5.0  # 3-4-5 triangle

def test_manhattan_distance():
    p1 = Point(0, 0)
    p2 = Point(3, 4)
    assert p1.manhattan_distance_to(p2) == 7.0  # |3| + |4|

def test_immutability():
    p = Point(1, 2)
    with pytest.raises(FrozenInstanceError):
        p.x = 5  # Should fail
```

#### LineSegment Tests
```python
def test_horizontal_with_tolerance():
    seg = LineSegment(Point(0, 100.0), Point(10, 100.0000001))
    assert seg.is_horizontal  # Within tolerance

def test_diagonal_detection():
    seg = LineSegment(Point(0, 0), Point(5, 5))
    assert not seg.is_horizontal
    assert not seg.is_vertical
    assert not seg.is_orthogonal

def test_zero_length_segment():
    seg = LineSegment(Point(5, 5), Point(5, 5))
    assert seg.length == 0.0
    assert seg.is_horizontal  # Degenerate case
    assert seg.is_vertical    # Also degenerate
```

#### NetGeometry Tests
```python
def test_validate_rejects_diagonal():
    seg = LineSegment(Point(0, 0), Point(5, 5))  # Diagonal
    geom = NetGeometry(
        net_id=NetId("net1"),
        segments=(seg,),
        junctions=(),
        crossings=()
    )
    with pytest.raises(ValueError, match="diagonal"):
        geom.validate()

def test_bend_count_L_shape():
    # L-shape: horizontal then vertical (1 bend)
    geom = NetGeometry(
        net_id=NetId("net1"),
        segments=(
            LineSegment(Point(0, 0), Point(10, 0)),  # Horizontal
            LineSegment(Point(10, 0), Point(10, 5)), # Vertical
        ),
        junctions=(),
        crossings=()
    )
    assert geom.bend_count == 1

def test_serialization_roundtrip():
    original = NetGeometry(...)
    data = original.to_dict()
    restored = NetGeometry.from_dict(data)
    assert original == restored
```

### 5.4 Property-Based Testing

Use `hypothesis` for fuzz testing:

```python
from hypothesis import given, strategies as st

@given(
    x1=st.floats(min_value=-1000, max_value=1000),
    y1=st.floats(min_value=-1000, max_value=1000),
    x2=st.floats(min_value=-1000, max_value=1000),
    y2=st.floats(min_value=-1000, max_value=1000)
)
def test_distance_symmetry(x1, y1, x2, y2):
    """Distance is symmetric"""
    p1 = Point(x1, y1)
    p2 = Point(x2, y2)
    assert p1.distance_to(p2) == p2.distance_to(p1)
```

---

## 6. Risks and Mitigations

### 6.1 Technical Risks

#### Risk 1: Floating-Point Precision Issues
**Impact**: Medium (validation failures, rendering glitches)
**Probability**: Medium (common issue with FP arithmetic)

**Mitigation**:
- Use `math.isclose()` consistently with defined tolerance
- Test with near-orthogonal segments (e.g., 100.0 vs 100.0000005)
- Document tolerance value and rationale
- Consider future: quantize coordinates to fixed-point (e.g., 0.01 pixels)

**Detection**: Unit tests with FP edge cases, hypothesis property tests

#### Risk 2: Serialization Compatibility
**Impact**: Low (session load failures after code changes)
**Probability**: Medium (data format may evolve)

**Mitigation**:
- Version serialization format: `{'version': 1, 'data': {...}}`
- Include deserialization tests in CI
- Document breaking changes in CHANGELOG
- Future: schema migration utilities

**Contingency**: Provide manual conversion script for old session files

#### Risk 3: Memory Overhead for Large Netlists
**Impact**: Low (excessive memory for 100K+ nets)
**Probability**: Low (geometry is small: ~10 segments per net avg)

**Estimation**:
```
100K nets × 10 segments avg × 64 bytes/segment = 64MB
+ junctions/crossings overhead ≈ 80MB total
```
Acceptable for target hardware (16GB RAM)

**Mitigation**:
- Use `__slots__` on dataclasses if memory critical
- Lazy-load geometry (compute on-demand, don't store)
- Compress session files with gzip

**Monitoring**: Memory profiling during integration testing

### 6.2 Integration Risks

#### Risk 4: Coordinate System Mismatch
**Impact**: High (incorrect rendering, rotated/flipped schematics)
**Probability**: Low (well-defined convention)

**Mitigation**:
- Document coordinate system clearly in docstrings
- Integration tests verify Point → QPointF mapping
- Visual regression tests (screenshot comparisons)
- Explicit test: "Y increases downward" property

**Detection**: First rendering test will expose mismatches immediately

#### Risk 5: Validation Performance Bottleneck
**Impact**: Low (slow routing, poor user experience)
**Probability**: Low (validation is O(n) in segments, fast)

**Estimation**:
```
100K nets × 10 segments × 10 μs/check = 10 seconds
```
Only if validation runs on every render (shouldn't - validate once at creation)

**Mitigation**:
- Validate only at construction, cache result
- Provide `skip_validation` flag for trusted sources
- Profile validation in benchmark suite

---

## 7. Implementation Plan

### 7.1 Development Phases

#### Phase 1: Core Data Structures (2 hours)
- Create `geometry.py` file
- Implement `Point` dataclass with distance methods
- Implement `LineSegment` dataclass with orientation properties
- Implement `NetGeometry` dataclass (no validation yet)
- Basic unit tests for creation and immutability

#### Phase 2: Validation Logic (2 hours)
- Implement `is_orthogonal` properties on `LineSegment`
- Implement `validate()` method on `NetGeometry`
- Implement `total_length` and `bend_count` properties
- Comprehensive tests for validation edge cases
- Property-based tests with hypothesis

#### Phase 3: Serialization (1 hour)
- Implement `to_dict()` methods
- Implement `from_dict()` class methods
- Round-trip tests
- Handle edge cases (empty geometry, single segment)

#### Phase 4: Documentation & Polish (1 hour)
- Docstrings for all public APIs (Google style)
- Usage examples in module docstring
- Type hints validation (mypy --strict)
- Linting (ruff)
- Final code review

**Total Estimated Time**: 6 hours (matches spec estimate)

### 7.2 Testing Milestones

- **After Phase 1**: Basic creation tests pass
- **After Phase 2**: 80%+ coverage, validation tests pass
- **After Phase 3**: 90%+ coverage, serialization tests pass
- **After Phase 4**: 100% documentation, ready for integration

### 7.3 Integration Checkpoints

**Before T02 (Router) starts**:
- API stable (no breaking changes expected)
- All unit tests green
- Example usage code provided

**Before T04 (Graphics) starts**:
- Coordinate system documented
- Point → QPointF mapping verified
- Sample geometry objects for testing

---

## 8. Open Questions

### 8.1 Design Questions

**Q1**: Should `NetGeometry` include pin positions?
- Currently: No, only routing segments
- Alternative: Include `source_pin: Point` and `sink_pins: Tuple[Point, ...]`
- **Decision**: No, keep separation of concerns. Router knows pin positions, geometry is just the path.

**Q2**: Should zero-length segments be allowed?
- Use case: Net with pins at same position (short circuit)
- Alternative: Filter out during routing
- **Decision**: Allow, but document. `is_horizontal` and `is_vertical` both return True (degenerate case).

**Q3**: Should validation happen automatically in `__post_init__`?
- Pros: Can't create invalid geometry
- Cons: Can't construct partial geometry during algorithm development
- **Decision**: Manual `validate()` call for flexibility.

**Q4**: How to handle crossing detection?
- Currently: `crossings` field exists but isn't populated by T01
- Who computes crossings? Router (T02) or separate post-processing?
- **Decision**: Defer to T02. T01 just defines the structure.

### 8.2 Performance Questions

**Q5**: Should we use `__slots__` for memory optimization?
- Benefit: ~30% memory reduction
- Cost: Can't use frozen dataclasses with `__slots__` easily in Python <3.10
- **Decision**: Not for MVP. Monitor memory usage, add if needed.

**Q6**: Should geometry be cached or computed on-demand?
- Cache: Store `NetGeometry` after routing
- On-demand: Recompute from net connectivity each time
- **Decision**: Cache. Routing is expensive, geometry lookups are frequent.

### 8.3 Future Enhancements

**Q7**: Support curved/bezier routing for aesthetics?
- Would require `CurveSegment` type
- Complexity increase, limited visual benefit
- **Decision**: No for MVP. Orthogonal only. Consider for P1.

**Q8**: Support non-Manhattan routing (e.g., 45-degree angles)?
- Some EDA tools use octilinear routing
- Complexity increase, not needed for gate-level
- **Decision**: No. Stick to Manhattan for MVP.

---

## 9. Definition of Done

### 9.1 Code Completeness
- [ ] `Point` class with distance methods implemented
- [ ] `LineSegment` class with orientation detection implemented
- [ ] `NetGeometry` class with validation and properties implemented
- [ ] All classes frozen and immutable
- [ ] All methods have type hints
- [ ] All public APIs have docstrings (Google style)

### 9.2 Testing
- [ ] 90%+ test coverage on `geometry.py`
- [ ] All unit tests pass (0 failures)
- [ ] Property-based tests with hypothesis
- [ ] Serialization round-trip tests pass
- [ ] Edge case tests (zero-length, empty geometry)

### 9.3 Quality
- [ ] `mypy --strict` passes with no errors
- [ ] `ruff check` passes with no warnings
- [ ] Code reviewed by peer
- [ ] No TODOs or FIXMEs in production code

### 9.4 Documentation
- [ ] Module docstring with usage examples
- [ ] All classes/methods documented
- [ ] Coordinate system clearly documented
- [ ] Tolerance values documented and justified
- [ ] Examples in docstrings tested (doctest)

### 9.5 Integration Readiness
- [ ] API stable and reviewed by T02/T04 implementers
- [ ] Example geometry objects created for testing
- [ ] Coordinate system verified with presentation layer
- [ ] No blocking issues for downstream tasks

---

## 10. Next Steps

1. **Create skeleton `geometry.py`** with class definitions
2. **Implement `Point` class** with tests (TDD)
3. **Implement `LineSegment` class** with tests (TDD)
4. **Implement `NetGeometry` class** with tests (TDD)
5. **Add serialization methods** with round-trip tests
6. **Documentation pass** - docstrings and examples
7. **Integration review** - coordinate with T02/T04 implementers

---

## Appendix A: API Usage Examples

### Example 1: Creating Simple Point-to-Point Route

```python
from ink.domain.value_objects.geometry import Point, LineSegment, NetGeometry
from ink.domain.value_objects.identifiers import NetId

# L-shaped route from (0,0) to (10,5)
route = NetGeometry(
    net_id=NetId("net_a_to_b"),
    segments=(
        LineSegment(Point(0, 0), Point(10, 0)),    # Horizontal
        LineSegment(Point(10, 0), Point(10, 5)),   # Vertical
    ),
    junctions=(),   # No branching
    crossings=()    # No other nets cross
)

# Validate orthogonal constraint
route.validate()  # Passes

# Compute metrics
print(f"Total length: {route.total_length}")  # 15.0 (10 + 5)
print(f"Bends: {route.bend_count}")            # 1 (direction change)
```

### Example 2: Multi-Fanout with Junction

```python
# Star topology: one source, three sinks
junction = Point(10, 5)

route = NetGeometry(
    net_id=NetId("clock"),
    segments=(
        # Source to junction
        LineSegment(Point(0, 0), Point(0, 5)),     # Vertical
        LineSegment(Point(0, 5), Point(10, 5)),    # Horizontal

        # Junction to sink 1
        LineSegment(Point(10, 5), Point(10, 10)),  # Vertical

        # Junction to sink 2
        LineSegment(Point(10, 5), Point(15, 5)),   # Horizontal
        LineSegment(Point(15, 5), Point(15, 10)),  # Vertical

        # Junction to sink 3
        LineSegment(Point(10, 5), Point(20, 5)),   # Horizontal
        LineSegment(Point(20, 5), Point(20, 10)),  # Vertical
    ),
    junctions=(junction,),  # Mark branching point
    crossings=()
)

print(f"Junction at: ({junction.x}, {junction.y})")
print(f"Bends: {route.bend_count}")  # 5
```

### Example 3: Serialization

```python
# Save to session file
geometry_dict = route.to_dict()
json.dump(geometry_dict, session_file)

# Load from session file
loaded_dict = json.load(session_file)
restored_route = NetGeometry.from_dict(loaded_dict)

assert restored_route == route  # Round-trip successful
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Opus 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
