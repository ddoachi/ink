# E02-F03-T04: Net Graphics Item (QGraphicsItem) - Pre-Implementation Documentation

## Document Metadata
- **Task**: E02-F03-T04 - Net Graphics Item (QGraphicsItem)
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Opus 4.5

---

## 1. Overview

### 1.1 Task Summary

This task implements the Qt-based graphics item (`NetItem`) that renders routed net geometry on the schematic canvas. The `QGraphicsPathItem` subclass consumes `NetGeometry` from the routing engine and draws orthogonal line segments, junction dots, and (future) crossing indicators. It must support user interaction (selection, hover) and scale appropriately with zoom levels.

### 1.2 Problem Context

After routing produces `NetGeometry` (T01-T03), the schematic viewer needs visual representation on screen. This requires:
- Converting domain `Point`/`LineSegment` to Qt `QPainterPath`
- Rendering line segments with configurable width/color
- Drawing junction dots at branching points
- Handling selection highlighting (orange when selected)
- Scaling line width based on zoom for readability
- Efficient rendering for 1000+ nets on canvas

This is the final link in the rendering pipeline: Routing → Geometry → Graphics Item → Screen Pixels.

### 1.3 Success Criteria

- `NetItem` renders all segments from `NetGeometry`
- Junction dots appear at correct positions (3px radius filled circles)
- Selection changes line color to orange
- Hover changes line color to light gray
- Bounding rectangle correctly encompasses all segments + margins
- Anti-aliasing enabled for smooth lines
- 80%+ test coverage with Qt-specific tests (QTest)
- Visual regression tests confirm rendering correctness

---

## 2. Implementation Approach

### 2.1 Architecture: QGraphicsPathItem Subclass

**Why QGraphicsPathItem?**
- Built-in path rendering (efficient for many segments)
- Automatic bounding rectangle calculation
- Hit testing for selection
- Supports hover events
- Can override `paint()` for custom rendering

**Class Structure**:

```python
# src/ink/presentation/canvas/net_item.py

from PySide6.QtWidgets import QGraphicsPathItem, QGraphicsItem
from PySide6.QtCore import QRectF, Qt, QPointF
from PySide6.QtGui import QPen, QColor, QPainterPath, QBrush, QPainter
from ink.domain.value_objects.geometry import NetGeometry

class NetItem(QGraphicsPathItem):
    """
    QGraphicsItem for rendering a routed net.

    Displays orthogonal line segments, junction dots, and crossing
    indicators based on NetGeometry from the routing engine.
    """

    def __init__(self, geometry: NetGeometry, parent: Optional[QGraphicsItem] = None):
        super().__init__(parent)
        self._geometry = geometry
        self._selected = False
        self._hovered = False

        # Visual properties
        self._line_width = 1.5
        self._line_color = QColor(100, 100, 100)       # Gray
        self._selected_color = QColor(255, 165, 0)     # Orange
        self._hover_color = QColor(150, 150, 150)      # Light gray
        self._junction_radius = 3.0

        # Enable interaction
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        self.setZValue(-1)  # Below cells (Z=0)

        # Build graphics path
        self._build_path()

    def _build_path(self) -> None:
        """Build QPainterPath from NetGeometry segments"""
        path = QPainterPath()

        for segment in self._geometry.segments:
            start = self._to_qpoint(segment.start)
            end = self._to_qpoint(segment.end)

            if path.isEmpty():
                path.moveTo(start)
            else:
                # Connect to previous segment
                path.lineTo(start)
            path.lineTo(end)

        self.setPath(path)

    def paint(self, painter: QPainter, option, widget=None) -> None:
        """Custom paint: line segments + junction dots"""
        painter.setRenderHint(QPainter.Antialiasing, True)

        # Draw line segments
        pen = QPen(self._get_line_color())
        pen.setWidthF(self._line_width)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        painter.setPen(pen)
        painter.drawPath(self.path())

        # Draw junction dots
        self._draw_junctions(painter)

    def _draw_junctions(self, painter: QPainter) -> None:
        """Draw filled circles at junction points"""
        brush = QBrush(self._get_line_color())
        painter.setBrush(brush)
        painter.setPen(Qt.NoPen)

        for junction in self._geometry.junctions:
            center = self._to_qpoint(junction)
            painter.drawEllipse(center, self._junction_radius, self._junction_radius)

    def _get_line_color(self) -> QColor:
        """Get line color based on selection/hover state"""
        if self._selected:
            return self._selected_color
        elif self._hovered:
            return self._hover_color
        else:
            return self._line_color

    def _to_qpoint(self, point: Point) -> QPointF:
        """Convert domain Point to Qt QPointF"""
        return QPointF(point.x, point.y)

    def boundingRect(self) -> QRectF:
        """Bounding rectangle for hit testing and culling"""
        margin = max(self._line_width / 2, self._junction_radius) + 2
        return self.path().boundingRect().adjusted(-margin, -margin, margin, margin)

    # Event handlers
    def itemChange(self, change, value):
        """Handle selection changes"""
        if change == QGraphicsItem.ItemSelectedChange:
            self._selected = value
            self.update()
        return super().itemChange(change, value)

    def hoverEnterEvent(self, event) -> None:
        """Mouse hover enter"""
        self._hovered = True
        self.update()

    def hoverLeaveEvent(self, event) -> None:
        """Mouse hover leave"""
        self._hovered = False
        self.update()
```

### 2.2 QPainterPath Construction Strategy

**Challenge**: Connect multiple `LineSegment` objects into continuous path

**Algorithm**:
```python
path = QPainterPath()
first = True

for segment in geometry.segments:
    start = QPointF(segment.start.x, segment.start.y)
    end = QPointF(segment.end.x, segment.end.y)

    if first:
        path.moveTo(start)  # Move to first point (no line drawn)
        first = False
    else:
        path.lineTo(start)  # Connect from previous end to this start

    path.lineTo(end)  # Draw line to segment end
```

**Why this works**:
- Routing produces connected segments (end of seg[i] = start of seg[i+1])
- `lineTo()` automatically connects from current position
- Handles both simple nets and multi-fanout branching structures

**Example**: L-shape path
```python
segments = [
    LineSegment(Point(0, 0), Point(10, 0)),    # Horizontal
    LineSegment(Point(10, 0), Point(10, 5)),   # Vertical
]

# Resulting QPainterPath:
path.moveTo(0, 0)      # Move to start
path.lineTo(10, 0)     # Draw horizontal
path.lineTo(10, 0)     # Connect (no-op, same point)
path.lineTo(10, 5)     # Draw vertical
```

### 2.3 Junction Rendering

**Visual Representation**: Filled circle at junction point

```python
def _draw_junctions(self, painter: QPainter) -> None:
    """Draw junction dots"""
    brush = QBrush(self._get_line_color())  # Match line color
    painter.setBrush(brush)
    painter.setPen(Qt.NoPen)  # No outline

    for junction in self._geometry.junctions:
        center = self._to_qpoint(junction)
        painter.drawEllipse(center, self._junction_radius, self._junction_radius)
```

**Parameters**:
- Radius: 3.0 pixels (visible but not obtrusive)
- Color: Same as line (gray/orange/light gray)
- Style: Filled circle, no outline

**Why filled circle?**
- Industry standard (EDA tools, circuit diagrams)
- Clear visual indication of branching
- Distinguishable from crossings (future: arc/bridge)

### 2.4 Selection and Hover Handling

**Three Visual States**:
1. **Default**: Gray lines (`QColor(100, 100, 100)`)
2. **Hovered**: Light gray (`QColor(150, 150, 150)`)
3. **Selected**: Orange (`QColor(255, 165, 0)`)

**State Transitions**:
```
Default ---[hover enter]---> Hovered
Hovered ---[hover leave]---> Default
Default ---[click]----------> Selected
Selected --[click away]-----> Default
```

**Implementation**:
```python
def _get_line_color(self) -> QColor:
    """Priority: Selected > Hovered > Default"""
    if self._selected:
        return self._selected_color
    elif self._hovered:
        return self._hover_color
    else:
        return self._line_color
```

**Triggering Repaint**:
- Call `self.update()` when state changes
- Qt automatically schedules repaint
- Efficient: only repaints this item's bounding rect

---

## 3. Key Design Decisions

### 3.1 QGraphicsPathItem vs QGraphicsItem

**Decision**: Inherit from `QGraphicsPathItem`

**Alternatives**:

1. **QGraphicsPathItem** (chosen):
   - Built-in path rendering
   - Efficient for complex paths
   - Automatic shape/boundingRect from path
   - Pros: Less code, better performance
   - Cons: Less flexible (but sufficient)

2. **QGraphicsItem** (rejected):
   - More control over rendering
   - Manual path drawing in `paint()`
   - Pros: Maximum flexibility
   - Cons: More boilerplate, no performance benefit

3. **QGraphicsLineItem per segment** (rejected):
   - One item per `LineSegment`
   - Pros: Simple per-segment logic
   - Cons: 1000 nets × 10 segments = 10K items (poor performance)

**Rationale**: `QGraphicsPathItem` provides optimal balance of simplicity and performance.

### 3.2 Z-Order: Nets Below Cells

**Decision**: `self.setZValue(-1)` (nets behind cells)

**Visual Layering**:
```
Z-Order:
  +2: Selection highlights
  +1: Text labels
   0: Cell bodies (default)
  -1: Nets (this item)
  -2: Grid/background
```

**Rationale**:
- Nets connect cells, should be visually subordinate
- Cell bodies more important (larger, contain information)
- Prevents nets from obscuring cell text
- Standard in EDA schematic viewers

**Alternative Considered**: Nets on top (Z=+1)
- Rejected: Clutters cell visibility, obscures cell symbols

### 3.3 Line Width and Scaling

**Decision**: Fixed line width (1.5px) for MVP, future zoom-aware

**Current Implementation**:
```python
self._line_width = 1.5  # Fixed pixels
```

**Future Enhancement**:
```python
def set_zoom_level(self, zoom: float) -> None:
    """Adjust line width inversely with zoom"""
    base_width = 1.5
    self._line_width = base_width / zoom  # Thinner when zoomed in
    self.update()
```

**Rationale**:
- Zoom handling adds complexity (needs signal from canvas)
- Fixed width sufficient for MVP (typical zoom range 50%-200%)
- Defer to P1 when zoom/pan implemented

### 3.4 Anti-Aliasing

**Decision**: Always enable anti-aliasing in `paint()`

```python
painter.setRenderHint(QPainter.Antialiasing, True)
```

**Visual Impact**:
- Without AA: Jagged diagonal transitions (staircasing)
- With AA: Smooth lines, professional appearance
- Performance: Negligible cost on modern GPUs

**Rationale**: Visual quality is priority for schematic viewer, performance cost acceptable

### 3.5 Bounding Rectangle Margins

**Decision**: Margin = `max(line_width/2, junction_radius) + 2px`

```python
def boundingRect(self) -> QRectF:
    margin = max(self._line_width / 2, self._junction_radius) + 2
    return self.path().boundingRect().adjusted(-margin, -margin, margin, margin)
```

**Why this matters**:
- Qt uses bounding rect for:
  - Hit testing (selection)
  - Culling (skip rendering off-screen items)
  - Dirty region updates
- Too small: Clipping artifacts, missed clicks
- Too large: Inefficient rendering, incorrect hit testing

**Components**:
- Line width/2: Pen extends half-width on each side
- Junction radius: Junction dots extend beyond path
- +2px: Safety margin for anti-aliasing blur

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E02-F03-T01 (Net Geometry Data Structure)**:
- `NetGeometry` with segments, junctions, crossings
- `Point`, `LineSegment` value objects
- Must be complete before T04 starts

**E02-F03-T02 (Orthogonal Router)**:
- Produces `NetGeometry` instances
- Validates all segments are orthogonal

**E02-F03-T03 (Multi-Fanout Handling)**:
- Populates `NetGeometry.junctions`
- Star topology creates junction points

**PySide6 (Qt6)**:
- `QGraphicsPathItem`, `QPainter`, `QPen`, `QBrush`
- Graphics framework for rendering

### 4.2 Downstream Consumers

**Presentation Layer (SchematicCanvas)**:
- Adds `NetItem` instances to `QGraphicsScene`
- Manages net item lifecycle (create, update, delete)
- Connects selection signals

**E04 (Selection Service)**:
- Queries selected `NetItem` objects
- Highlights connected nets
- Shows net properties in property panel

**E03 (Incremental Expansion)**:
- Updates `NetItem` when nets change
- Removes `NetItem` for collapsed cells
- Triggers re-rendering after expansion

### 4.3 Integration Workflow

```
Routing Engine (T02/T03)
    ↓ (produces NetGeometry)
NetItem (T04)
    ↓ (added to scene)
QGraphicsScene
    ↓ (rendered by)
QGraphicsView
    ↓ (displayed in)
Canvas Widget
```

**Data Flow**:
1. User triggers expansion
2. Router produces `Dict[NetId, NetGeometry]`
3. Canvas creates `NetItem(geometry)` for each net
4. `NetItem._build_path()` constructs QPainterPath
5. Qt renders items to screen
6. User clicks → selection event → `itemChange()` → color change → `update()`

---

## 5. Testing Strategy

### 5.1 Unit Test Structure

```
tests/unit/presentation/canvas/
└── test_net_item.py
    ├── TestPathConstruction
    │   ├── test_empty_geometry
    │   ├── test_single_segment
    │   ├── test_l_shape_path
    │   ├── test_multi_segment_path
    │   └── test_multi_fanout_branching
    ├── TestJunctionRendering
    │   ├── test_single_junction
    │   ├── test_multiple_junctions
    │   └── test_no_junctions
    ├── TestVisualState
    │   ├── test_default_color_gray
    │   ├── test_selected_color_orange
    │   ├── test_hovered_color_light_gray
    │   └── test_color_priority_selected_over_hovered
    ├── TestBoundingRect
    │   ├── test_margin_includes_line_width
    │   ├── test_margin_includes_junction_radius
    │   └── test_all_segments_covered
    └── TestInteraction
        ├── test_selection_changes_color
        ├── test_hover_enter_changes_color
        └── test_hover_leave_restores_color
```

### 5.2 Qt-Specific Testing with QTest

**Setup**:
```python
from PySide6.QtTest import QTest
from PySide6.QtCore import Qt
from PySide6.QtWidgets import QGraphicsScene, QGraphicsView

@pytest.fixture
def graphics_scene():
    """QGraphicsScene for testing"""
    scene = QGraphicsScene()
    yield scene
    scene.clear()

@pytest.fixture
def sample_geometry():
    """Simple L-shape NetGeometry"""
    return NetGeometry(
        net_id=NetId("test_net"),
        segments=(
            LineSegment(Point(0, 0), Point(10, 0)),
            LineSegment(Point(10, 0), Point(10, 5)),
        ),
        junctions=(),
        crossings=()
    )
```

**Test Examples**:

```python
def test_path_construction_l_shape(sample_geometry):
    """Verify QPainterPath created from segments"""
    item = NetItem(sample_geometry)

    path = item.path()
    assert not path.isEmpty()

    # Path should contain two line segments
    # (Exact path verification is complex, check bounding rect instead)
    rect = path.boundingRect()
    assert rect.left() == pytest.approx(0)
    assert rect.top() == pytest.approx(0)
    assert rect.right() == pytest.approx(10)
    assert rect.bottom() == pytest.approx(5)

def test_selection_changes_color(graphics_scene, sample_geometry):
    """Clicking item changes color to orange"""
    item = NetItem(sample_geometry)
    graphics_scene.addItem(item)

    # Default color
    assert item._get_line_color() == QColor(100, 100, 100)

    # Select item
    item.setSelected(True)
    assert item._selected
    assert item._get_line_color() == QColor(255, 165, 0)  # Orange

def test_hover_changes_color(graphics_scene, sample_geometry):
    """Hovering changes color to light gray"""
    item = NetItem(sample_geometry)
    graphics_scene.addItem(item)

    # Simulate hover enter
    from PySide6.QtWidgets import QGraphicsSceneHoverEvent
    event = QGraphicsSceneHoverEvent()
    item.hoverEnterEvent(event)

    assert item._hovered
    assert item._get_line_color() == QColor(150, 150, 150)  # Light gray

def test_bounding_rect_margin(sample_geometry):
    """Bounding rect includes line width and junction radius"""
    item = NetItem(sample_geometry)

    path_rect = item.path().boundingRect()
    bounding_rect = item.boundingRect()

    # Should be larger due to margin
    margin = max(item._line_width / 2, item._junction_radius) + 2
    expected = path_rect.adjusted(-margin, -margin, margin, margin)

    assert bounding_rect == expected
```

### 5.3 Integration Tests

```
tests/integration/presentation/
└── test_net_rendering.py
    ├── test_add_net_to_scene
    ├── test_multiple_nets_render
    ├── test_net_with_junctions_renders
    └── test_selection_in_view
```

**Example**:
```python
def test_net_renders_in_view():
    """End-to-end: geometry → item → scene → view"""
    # Create geometry
    geometry = NetGeometry(...)

    # Create item
    item = NetItem(geometry)

    # Add to scene
    scene = QGraphicsScene()
    scene.addItem(item)

    # Create view
    view = QGraphicsView(scene)
    view.show()

    # Verify item is visible
    assert item.isVisible()
    assert item in scene.items()

    # Render to pixmap (visual validation)
    pixmap = QPixmap(200, 200)
    painter = QPainter(pixmap)
    scene.render(painter)
    painter.end()

    # Save for visual inspection
    pixmap.save("test_output/net_rendering.png")
```

### 5.4 Visual Regression Testing

**Manual Inspection** (during development):
1. Render sample net in canvas
2. Verify line segments appear
3. Verify junction dots at correct positions
4. Verify selection highlighting works
5. Verify hover effect works

**Screenshot Comparison** (future):
```python
def test_visual_regression_simple_net():
    """Compare rendered output to golden reference"""
    item = NetItem(sample_geometry)
    scene = QGraphicsScene()
    scene.addItem(item)

    pixmap = render_scene(scene)
    golden = QPixmap("tests/golden/simple_net.png")

    assert images_equal(pixmap, golden, threshold=0.95)
```

---

## 6. Risks and Mitigations

### 6.1 Technical Risks

#### Risk 1: Path Construction Errors
**Impact**: High (nets not visible, rendering crashes)
**Probability**: Low (algorithm is straightforward)

**Mitigation**:
- Unit test path construction with various geometries
- Validate path is not empty before rendering
- Handle empty geometry gracefully (no segments)

**Detection**: First rendering test will expose issues

#### Risk 2: Performance with Many Nets
**Impact**: Medium (slow rendering, laggy UI)
**Probability**: Medium (1000+ items in scene)

**Estimation**:
```
1000 nets × 10 segments avg × 1ms render = 10ms per frame (acceptable)
```

**Mitigation**:
- Qt handles culling automatically (only renders visible items)
- Use `setFlag(ItemUsesExtendedStyleOption)` for LOD
- Profile with 1000 nets, optimize if needed

**Contingency**:
- Implement LOD: skip junction dots at low zoom
- Lazy rendering: only create items for visible area
- Use `QGraphicsItemGroup` for batch operations

**Detection**: Performance benchmark with large netlist

#### Risk 3: Coordinate Conversion Errors
**Impact**: Medium (nets misaligned with cells)
**Probability**: Low (simple 1:1 mapping)

**Mitigation**:
- Integration test verifies net connects to cell pins
- Visual inspection during development
- Coordinate system documented in both domain and presentation

**Detection**: First integration test with layout + routing + rendering

#### Risk 4: Bounding Rectangle Too Small
**Impact**: Medium (clipping artifacts, incorrect hit testing)
**Probability**: Low (conservative margin)

**Mitigation**:
- Add safety margin (+2px beyond theoretical minimum)
- Test with thick lines and large junction radius
- Visual inspection for clipping

**Detection**: Unit test verifies margin calculation, visual tests show clipping

### 6.2 Integration Risks

#### Risk 5: Qt Version Compatibility
**Impact**: Low (API changes between Qt5/Qt6)
**Probability**: Low (using standard Qt6 API)

**Mitigation**:
- Use PySide6 (Qt6) exclusively
- Test on target platform (Linux)
- Document Qt version requirement

**Detection**: CI runs on target platform

#### Risk 6: Selection/Hover Event Conflicts
**Impact**: Low (selection doesn't work, hover stuck)
**Probability**: Low (standard Qt event handling)

**Mitigation**:
- Follow Qt best practices for event handling
- Don't block events (call `super()`)
- Test event handling explicitly

**Example Issue**: Forgetting to call `super().itemChange()`
**Prevention**: Code review checks event handler patterns

---

## 7. Implementation Plan

### 7.1 Development Phases

#### Phase 1: Basic Rendering (3 hours)
- Create `NetItem` class skeleton
- Implement `_build_path()` with simple segment
- Implement `paint()` with line drawing
- Implement `_to_qpoint()` conversion
- Basic unit tests

**Deliverables**:
- NetItem renders single segment
- Unit tests for path construction
- 40%+ coverage

#### Phase 2: Multi-Segment and Junction Rendering (3 hours)
- Extend `_build_path()` for multi-segment nets
- Implement `_draw_junctions()`
- Test with L-shape, Z-shape, star topology
- Visual validation

**Deliverables**:
- Multi-segment paths render correctly
- Junction dots appear
- 60%+ coverage

#### Phase 3: Selection and Hover (2 hours)
- Implement `_get_line_color()` state logic
- Implement `itemChange()` for selection
- Implement `hoverEnterEvent()` and `hoverLeaveEvent()`
- Test color changes

**Deliverables**:
- Selection highlighting works
- Hover effect works
- 75%+ coverage

#### Phase 4: Bounding Rectangle and Polish (1 hour)
- Implement `boundingRect()` with margins
- Set Z-order
- Enable anti-aliasing
- Configure item flags (selectable, hoverable)
- Edge case tests (empty geometry)

**Deliverables**:
- Bounding rect correct
- Visual polish complete
- 80%+ coverage

#### Phase 5: Integration Testing (1 hour)
- Integration test with QGraphicsScene
- Integration test with routing output
- Visual validation in full canvas
- Performance test with 100+ nets

**Deliverables**:
- Integration tests passing
- Performance acceptable
- Ready for merge

#### Phase 6: Documentation and Code Review (1 hour)
- Docstrings for all methods
- Usage examples
- Visual examples (screenshots)
- Code review

**Deliverables**:
- Complete documentation
- Clean code (mypy, ruff)
- Peer review passed

**Total Estimated Time**: 10 hours (slightly under spec estimate - buffer for issues)

### 7.2 Testing Milestones

- **After Phase 2**: Path construction tests pass
- **After Phase 3**: Interaction tests pass
- **After Phase 4**: 80%+ coverage
- **After Phase 5**: Integration tests pass
- **After Phase 6**: Ready for production

### 7.3 Visual Validation Checkpoints

**Manual Inspection**:
1. **Phase 1**: Single segment renders
2. **Phase 2**: Multi-segment path and junctions render
3. **Phase 3**: Selection/hover color changes visible
4. **Phase 5**: Full schematic with cells + nets renders

**Screenshot Capture**:
- Save rendering output at each phase
- Compare to expected visual appearance
- Document in test artifacts

---

## 8. Open Questions

### 8.1 Design Questions

**Q1**: Should junction size be configurable?
- Current: Hardcoded 3.0 pixels
- Alternative: Parameter in `NetItem.__init__(junction_radius=3.0)`
- **Decision**: Hardcode for MVP. Future: user preference setting.

**Q2**: Should nets support different visual styles?
- Use case: Clock nets (blue), data nets (gray), control (green)
- **Decision**: Not for MVP. All nets gray. Future: color-by-type.

**Q3**: Should crossing indicators be rendered?
- Current: `_geometry.crossings` ignored
- Future: Draw arc/bridge at crossing points
- **Decision**: Defer to post-MVP (T02 doesn't populate crossings yet).

**Q4**: Should line width scale with zoom?
- Current: Fixed 1.5px
- Alternative: Thinner when zoomed in (`width = base / zoom`)
- **Decision**: Fixed for MVP. Future: zoom-aware rendering.

### 8.2 Performance Questions

**Q5**: Should rendering be optimized with LOD?
- LOD: Level of detail (skip junctions at low zoom)
- **Decision**: Not for MVP. Profile first, optimize if needed.

**Q6**: Should path be cached or rebuilt?
- Current: Build once in `__init__`, cache in `_path`
- Alternative: Rebuild on every geometry change
- **Decision**: Cache (geometry immutable, no rebuilding needed).

### 8.3 Future Enhancements

**Q7**: Support for animated highlighting?
- Use case: Signal tracing, path highlighting
- Implementation: Animate color/width over time
- **Decision**: Post-MVP feature (P1).

**Q8**: Support for bezier curves for aesthetics?
- Smooth corners instead of sharp bends
- **Decision**: No. Orthogonal only for technical accuracy.

---

## 9. Definition of Done

### 9.1 Code Completeness
- [ ] `NetItem` class inherits from `QGraphicsPathItem`
- [ ] `_build_path()` constructs QPainterPath from segments
- [ ] `paint()` renders line segments with correct pen
- [ ] `_draw_junctions()` renders junction dots
- [ ] `_get_line_color()` returns color based on state
- [ ] `_to_qpoint()` converts domain Point to QPointF
- [ ] `boundingRect()` calculated with margins
- [ ] Event handlers: `itemChange()`, `hoverEnterEvent()`, `hoverLeaveEvent()`
- [ ] Anti-aliasing enabled
- [ ] Z-order set to -1 (below cells)
- [ ] Item flags set (selectable, hoverable)

### 9.2 Testing
- [ ] 80%+ test coverage
- [ ] All unit tests pass
- [ ] Path construction tests (empty, single, multi-segment)
- [ ] Junction rendering tests
- [ ] Visual state tests (default, selected, hovered)
- [ ] Bounding rect tests
- [ ] Interaction tests (selection, hover)
- [ ] Integration tests (scene, view)
- [ ] Visual regression tests (manual inspection)

### 9.3 Quality
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] Code reviewed
- [ ] No TODOs in production code

### 9.4 Documentation
- [ ] Class docstring with usage example
- [ ] All methods documented
- [ ] Visual examples (screenshots) captured
- [ ] Integration guide for canvas

### 9.5 Integration Readiness
- [ ] Integration test with SchematicCanvas passes
- [ ] Visual validation in full schematic
- [ ] Performance acceptable (100+ nets render smoothly)
- [ ] No blocking issues for E03/E04

---

## 10. Next Steps

1. **Create NetItem skeleton** - Class structure with `__init__`
2. **Implement path construction** - `_build_path()` with TDD
3. **Implement rendering** - `paint()` with line and junction drawing
4. **Implement interaction** - Selection and hover handling
5. **Integration testing** - Test in full canvas with routing
6. **Visual validation** - Manual inspection and screenshots

---

## Appendix A: Visual Examples

### Example 1: Simple Point-to-Point Net

**Geometry**:
```python
NetGeometry(
    net_id=NetId("net1"),
    segments=(
        LineSegment(Point(0, 0), Point(10, 0)),    # Horizontal
        LineSegment(Point(10, 0), Point(10, 5)),   # Vertical
    ),
    junctions=(),
    crossings=()
)
```

**Rendered Output**:
```
(0,0) -------- (10,0)
                |
                |
              (10,5)
```

### Example 2: Multi-Fanout Net with Junction

**Geometry**:
```python
NetGeometry(
    net_id=NetId("clock"),
    segments=(...),  # Star topology segments
    junctions=(Point(10, 5),),
    crossings=()
)
```

**Rendered Output**:
```
Source
  |
  |
  +---●---+  (junction dot at (10,5))
      |   |
    Sink1 Sink2
```

### Example 3: Selection Highlighting

**States**:
```
Default:   Gray lines (100, 100, 100)
           ─────────

Hovered:   Light gray lines (150, 150, 150)
           ═════════

Selected:  Orange lines (255, 165, 0)
           ━━━━━━━━━
```

---

## Appendix B: Qt Rendering Pipeline

### Paint Event Flow

```
User Action (expand, select)
    ↓
Canvas updates scene
    ↓
QGraphicsScene.update()
    ↓
QGraphicsView schedules repaint
    ↓
For each visible item:
    item.paint(painter, option, widget)
    ↓
NetItem.paint():
    1. Set anti-aliasing
    2. Configure pen (color, width, caps)
    3. Draw path (line segments)
    4. Draw junction dots
    ↓
Rendered to screen
```

### Bounding Rectangle Usage

```
QGraphicsScene needs to:
1. Determine which items are visible
2. Calculate dirty regions for repainting
3. Handle hit testing (mouse clicks)

For each operation:
    item.boundingRect() → QRectF

NetItem.boundingRect():
    path_rect = self.path().boundingRect()
    margin = max(line_width/2, junction_radius) + 2
    return path_rect.adjusted(-margin, -margin, margin, margin)
```

---

## Appendix C: Color Palette

### Standard Colors

```python
# Default colors
LINE_COLOR_DEFAULT = QColor(100, 100, 100)       # RGB(100, 100, 100) - Gray
LINE_COLOR_SELECTED = QColor(255, 165, 0)        # RGB(255, 165, 0) - Orange
LINE_COLOR_HOVER = QColor(150, 150, 150)         # RGB(150, 150, 150) - Light Gray

# Future colors (post-MVP)
CLOCK_NET_COLOR = QColor(0, 100, 255)            # Blue
DATA_NET_COLOR = QColor(100, 100, 100)           # Gray (default)
CONTROL_NET_COLOR = QColor(0, 150, 0)            # Green
POWER_NET_COLOR = QColor(200, 0, 0)              # Red
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Opus 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
