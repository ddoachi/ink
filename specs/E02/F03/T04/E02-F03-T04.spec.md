---
id: E02-F03-T04
title: Net Graphics Item (QGraphicsItem)
type: Task
priority: P0 (MVP)
status: Draft
parent: E02-F03
created: 2025-12-26
estimated_hours: 10
actual_hours:
effort: Medium
tags:
  - presentation
  - graphics
  - qt
clickup_task_id: '86evzm2ma'
---

# Spec: E02-F03-T04 - Net Graphics Item (QGraphicsItem)

## 1. Overview

### 1.1 Problem Statement

Routed net geometry must be rendered on the schematic canvas as visual elements. This requires a Qt `QGraphicsItem` subclass that can draw orthogonal line segments, junction dots, crossing indicators, and handle user interaction (selection, highlighting).

### 1.2 Goals

- Create `NetItem` QGraphicsItem for rendering net geometry
- Draw orthogonal line segments with configurable width/color
- Render junction dots at branching points
- Render crossing indicators where nets intersect
- Support selection and hover highlighting
- Scale line width based on zoom level for readability

---

## 2. Technical Requirements

### 2.1 NetItem Class

Create in `src/ink/presentation/canvas/net_item.py`:

```python
from PySide6.QtWidgets import QGraphicsItem, QGraphicsPathItem
from PySide6.QtCore import QRectF, Qt, QPointF
from PySide6.QtGui import QPen, QColor, QPainterPath, QBrush, QPainter
from ink.domain.value_objects.geometry import NetGeometry, LineSegment, Point

class NetItem(QGraphicsPathItem):
    """
    QGraphicsItem for rendering a routed net.

    Draws orthogonal line segments, junction dots, and crossing indicators
    based on NetGeometry from the routing engine.
    """

    def __init__(
        self,
        geometry: NetGeometry,
        parent: Optional[QGraphicsItem] = None
    ):
        """
        Initialize net item.

        Args:
            geometry: Routing geometry (from NetRouter)
            parent: Parent graphics item
        """
        super().__init__(parent)
        self._geometry = geometry
        self._selected = False
        self._hovered = False

        # Visual properties
        self._line_width = 1.5
        self._line_color = QColor(100, 100, 100)  # Gray
        self._selected_color = QColor(255, 165, 0)  # Orange
        self._junction_radius = 3.0

        # Enable interaction
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)

        # Build graphics path
        self._build_path()

    def _build_path(self) -> None:
        """
        Build QPainterPath from NetGeometry.

        Creates path containing:
        - Line segments (orthogonal)
        - Junction dots (filled circles)
        - Crossing indicators (arcs)
        """
        path = QPainterPath()

        # Draw all line segments
        for segment in self._geometry.segments:
            start = self._to_qpoint(segment.start)
            end = self._to_qpoint(segment.end)

            if path.isEmpty():
                path.moveTo(start)
            else:
                path.lineTo(start)
            path.lineTo(end)

        self.setPath(path)

    def paint(
        self,
        painter: QPainter,
        option,
        widget=None
    ) -> None:
        """
        Custom paint method.

        Draws:
        1. Net segments (lines)
        2. Junction dots (filled circles)
        3. Crossing indicators (arcs)
        """
        # Set pen for line segments
        pen = QPen(self._get_line_color())
        pen.setWidthF(self._line_width)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        painter.setPen(pen)

        # Draw path (line segments)
        painter.drawPath(self.path())

        # Draw junction dots
        self._draw_junctions(painter)

        # Draw crossing indicators (future)
        # self._draw_crossings(painter)

    def _draw_junctions(self, painter: QPainter) -> None:
        """
        Draw filled circles at junction points.

        Junctions indicate branching points for multi-fanout nets.
        """
        brush = QBrush(self._get_line_color())
        painter.setBrush(brush)
        painter.setPen(Qt.NoPen)

        for junction in self._geometry.junctions:
            center = self._to_qpoint(junction)
            painter.drawEllipse(
                center,
                self._junction_radius,
                self._junction_radius
            )

    def _get_line_color(self) -> QColor:
        """Get line color based on selection state."""
        if self._selected:
            return self._selected_color
        elif self._hovered:
            return QColor(150, 150, 150)  # Lighter gray
        else:
            return self._line_color

    def _to_qpoint(self, point: Point) -> QPointF:
        """Convert domain Point to Qt QPointF."""
        return QPointF(point.x, point.y)

    def boundingRect(self) -> QRectF:
        """Calculate bounding rectangle for item."""
        # Use path bounding rect plus margin for line width
        margin = self._line_width / 2 + self._junction_radius
        return self.path().boundingRect().adjusted(
            -margin, -margin, margin, margin
        )

    # Selection and hover handling
    def setSelected(self, selected: bool) -> None:
        """Update selection state."""
        self._selected = selected
        self.update()  # Trigger repaint

    def hoverEnterEvent(self, event) -> None:
        """Handle mouse hover enter."""
        self._hovered = True
        self.update()

    def hoverLeaveEvent(self, event) -> None:
        """Handle mouse hover leave."""
        self._hovered = False
        self.update()

    # Zoom-aware line width (future enhancement)
    def set_zoom_level(self, zoom: float) -> None:
        """
        Adjust line width based on zoom level.

        Args:
            zoom: Zoom factor (1.0 = 100%)
        """
        # Scale line width inversely with zoom to maintain readability
        base_width = 1.5
        self._line_width = base_width / zoom
        self.update()
```

### 2.2 Visual Rendering Details

**Line Segments:**
- Width: 1.5 pixels (base), scales with zoom
- Color: Gray (default), orange (selected), light gray (hovered)
- Style: Solid line with round caps/joins
- Anti-aliasing: Enabled for smooth rendering

**Junction Dots:**
- Radius: 3.0 pixels
- Color: Same as line color (gray/orange/light gray)
- Style: Filled circle
- Position: Center at junction point

**Crossing Indicators (Future):**
- Style: Small arc or bridge over crossing point
- Renders when two nets intersect (not junctions)

### 2.3 Coordinate Mapping

Domain `Point` uses logical coordinates (float). Qt uses `QPointF`:

```python
def _to_qpoint(self, point: Point) -> QPointF:
    """Convert domain Point to Qt QPointF."""
    return QPointF(point.x, point.y)
```

### 2.4 Bounding Rectangle

Calculate bounding rect from path plus margin:
- Margin includes line width and junction radius
- Used for hit testing and culling

### 2.5 Level of Detail (LOD)

Adjust rendering based on zoom:
- **Zoomed out (<50%):** Thinner lines, skip junction dots
- **Normal (50-200%):** Full rendering
- **Zoomed in (>200%):** Show full detail, thicker lines

---

## 3. Dependencies

- **Upstream**:
  - E02-F03-T01 (NetGeometry data structure)
  - E02-F03-T02 (Routed geometry from ChannelRouter)
  - E02-F03-T03 (Junction points in geometry)

- **Downstream**:
  - SchematicCanvas (adds NetItem to scene)
  - E04 (Selection service interacts with NetItem)
  - E03 (Incremental updates when nets change)

---

## 4. Acceptance Criteria

- [ ] `NetItem` class inherits from `QGraphicsPathItem`
- [ ] `_build_path()` creates QPainterPath from segments
- [ ] `paint()` renders line segments with correct pen
- [ ] Junction dots drawn at all junction points
- [ ] Line color changes on selection (orange)
- [ ] Line color changes on hover (light gray)
- [ ] Bounding rect calculated correctly
- [ ] Item is selectable and accepts hover events
- [ ] Anti-aliasing enabled for smooth lines
- [ ] Handle empty geometry (no segments)
- [ ] Handle single-segment nets
- [ ] Handle multi-fanout nets with junctions
- [ ] Line width configurable
- [ ] Junction radius configurable
- [ ] Unit tests (using QTest):
  - Path construction from geometry
  - Bounding rect calculation
  - Color changes on selection/hover
- [ ] Integration tests:
  - Add NetItem to QGraphicsScene
  - Verify rendering in QGraphicsView
  - Test selection interaction
- [ ] Visual regression tests (screenshots)
- [ ] Test coverage >80%

---

## 5. Implementation Notes

### 5.1 QPainterPath Construction

Build path by moving to first point, then drawing lines:

```python
path = QPainterPath()
first = True
for segment in self._geometry.segments:
    start = self._to_qpoint(segment.start)
    end = self._to_qpoint(segment.end)

    if first:
        path.moveTo(start)
        first = False
    else:
        path.lineTo(start)
    path.lineTo(end)
```

### 5.2 Anti-Aliasing

Enable in `paint()`:
```python
painter.setRenderHint(QPainter.Antialiasing, True)
```

### 5.3 Selection Handling

Override `itemChange()` for selection events:
```python
def itemChange(self, change, value):
    if change == QGraphicsItem.ItemSelectedChange:
        self._selected = value
        self.update()
    return super().itemChange(change, value)
```

### 5.4 Z-Order

Set Z-value so nets render below cells but above background:
```python
self.setZValue(-1)  # Below cells (Z=0)
```

### 5.5 Performance

- Cache QPainterPath (rebuild only when geometry changes)
- Use `update()` for minimal repaints (not `scene().update()`)
- Consider QGraphicsItemGroup for very large nets

---

## 6. Test Scenarios

### Unit Tests (QTest)

**Path Construction:**
- Empty geometry (no segments) → empty path
- Single segment → path with 2 points
- Multi-segment net → connected path
- Multi-fanout net → branching path

**Bounding Rect:**
- Verify margin includes line width
- Verify margin includes junction radius
- Check all segments covered by rect

**Visual State:**
- Default color (gray)
- Selected color (orange)
- Hovered color (light gray)

### Integration Tests

**Scene Integration:**
- Add NetItem to QGraphicsScene
- Verify item rendered in QGraphicsView
- Test selection via mouse click
- Test hover via mouse move

**With Real Geometry:**
- Render routed net from ChannelRouter
- Verify junctions appear at correct positions
- Verify segments align with pin positions

---

## 7. Visual Examples

### Example Rendering

```
Simple Point-to-Point Net:
    Pin A
      |
      |  (vertical segment, gray)
      +------  (horizontal segment, gray)
             |
             |  (vertical segment, gray)
           Pin B

Multi-Fanout Net with Junction:
    Pin A
      |
      |
      +---●---+  (junction dot at branch point)
          |   |
        Pin B Pin C
```

### Selection Highlight

```
Unselected: Gray lines
Selected:   Orange lines + orange junction dots
Hovered:    Light gray lines (preview)
```

---

## 8. Future Enhancements (Post-MVP)

- **Crossing Indicators:** Arc/bridge where nets cross (not junction)
- **Color Coding:** Nets colored by type (clock, data, control)
- **Animated Highlighting:** Pulse effect for signal tracing
- **Bezier Curves:** Smooth corners at high zoom (aesthetic)
- **Line Width Scaling:** Auto-adjust based on zoom level

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E02-F03 split |
