# E03-F04-T02 - Undo/Redo State Navigation: Pre-Implementation Documentation

## Document Information
- **Task**: E03-F04-T02 - Undo/Redo State Navigation
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task extends the `ExpansionState` aggregate with undo/redo functionality, enabling users to navigate backward and forward through expansion/collapse history. This is a critical UX feature that allows engineers to explore different connectivity paths without fear of making irreversible changes, and to quickly recover from accidental expansions or collapses.

### 1.2 Problem Context

In schematic exploration workflows, users frequently need to backtrack:

**Exploration Scenarios**:
- "I expanded too many hops, now the view is cluttered - undo 3 times"
- "I collapsed the wrong section by accident - undo immediately"
- "I want to compare two different expansion paths - undo to branch point, expand differently"
- "I undid too far - redo 2 times to get back"

**Without Undo/Redo**:
- Users must manually re-expand or re-collapse to fix mistakes
- Exploration becomes tedious and error-prone
- Users avoid experimenting for fear of losing their carefully curated view
- No way to compare alternative expansion paths

**With Undo/Redo**:
- One keystroke (`Ctrl+Z`) reverses last action
- Users can explore confidently, knowing changes are reversible
- Quick iteration on schematic views
- Standard UX pattern familiar from text editors, CAD tools, etc.

### 1.3 Core Capabilities

The undo/redo system provides:

1. **Action Reversal**: Undo applies inverse operations (expand → collapse, collapse → expand)
2. **History Navigation**: Track position in action history with forward/backward movement
3. **State Consistency**: Guarantee `visible_cells` matches history position after undo/redo
4. **Branching Behavior**: New actions after undo truncate future history (standard pattern)
5. **Query Interface**: Check if undo/redo available, get undoable/redoable action lists

---

## 2. Implementation Approach

### 2.1 History Position Model

**Conceptual Model**:

```
History: [Action0, Action1, Action2, Action3]
Position:    0        1        2        3       4
             ^                                   ^
          (start)                              (end)

Position = 0: No actions applied (initial state)
Position = 1: Action0 applied
Position = 2: Action0, Action1 applied
Position = 3: Action0, Action1, Action2 applied
Position = 4: All actions applied (current state)
```

**Undo Operation**:
```
Before: position = 4
Undo:   position = 3, reverse Action3
Undo:   position = 2, reverse Action2
```

**Redo Operation**:
```
Before: position = 2
Redo:   position = 3, reapply Action2
Redo:   position = 4, reapply Action3
```

### 2.2 Inverse Operation Logic

**Core Principle**: Undo reverses the effect, not the action type.

```python
def undo(self) -> Optional[ExpansionAction]:
    action = self.expansion_history[self._history_position - 1]

    if action.action_type == ActionType.EXPAND:
        # Undo expand = remove cells (collapse)
        self.remove_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )
    else:  # ActionType.COLLAPSE
        # Undo collapse = add cells back (expand)
        self.add_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )
```

**Why this works**:
- `ExpansionAction` records what changed, not how to undo it
- Inverse operation is deterministic: expand ↔ collapse
- No need to store separate undo commands (like Command pattern)
- Simple and efficient

### 2.3 History Truncation on New Action

**Standard Undo/Redo Behavior** (like text editors):

```
Initial:  [A0, A1, A2, A3], position = 4
Undo 2x:  [A0, A1, A2, A3], position = 2
New action: [A0, A1, A4], position = 3  # A2, A3 lost!
```

**Implementation**:
```python
def record_action(self, action: ExpansionAction) -> None:
    # Truncate future history
    if self._history_position < len(self.expansion_history):
        self.expansion_history = self.expansion_history[:self._history_position]

    # Append new action
    self.expansion_history.append(action)
    self._history_position = len(self.expansion_history)
```

**Rationale**:
- Prevents ambiguity: what does "redo" mean after branching?
- Standard behavior users expect from other applications
- Simpler than maintaining branching history (tree structure)
- Rare use case: users rarely want to redo after new action

---

## 3. Key Design Decisions

### 3.1 Return Value: Optional[ExpansionAction]

**Decision**: `undo()` and `redo()` return the action performed, or `None` if nothing to undo/redo.

```python
def undo(self) -> Optional[ExpansionAction]:
    if not self.can_undo():
        return None
    # ... perform undo ...
    return action
```

**Alternatives Considered**:

**Option 1: Return boolean**
```python
def undo(self) -> bool:
    # Returns True if successful, False if nothing to undo
```
- Pros: Simple success/failure indication
- Cons: Caller can't access action details for UI feedback

**Option 2: Raise exception**
```python
def undo(self) -> ExpansionAction:
    if not self.can_undo():
        raise UndoNotAvailableError()
```
- Pros: Forces caller to check `can_undo()` first
- Cons: Exceptions for control flow is anti-pattern in Python
- Cons: More verbose error handling for simple case

**Chosen: Return Optional[ExpansionAction]**
- Pros: Caller can check result and display feedback ("Undone: Expand 5 cells")
- Pros: Non-exceptional case (nothing to undo) doesn't throw
- Pros: Consistent with Python conventions (`list.pop()`, `dict.get()`, etc.)
- Cons: Caller must handle `None` case

**Usage Pattern**:
```python
action = state.undo()
if action:
    ui.show_notification(f"Undone: {action.action_type.value}")
else:
    ui.show_notification("Nothing to undo")
```

### 3.2 State Mutation: In-Place vs. Copy-on-Write

**Decision**: Mutate state in-place (same as T01 decision).

```python
def undo(self) -> Optional[ExpansionAction]:
    # Mutates self.visible_cells and self._history_position
    self._history_position -= 1
    self.remove_cells(...)
```

**Alternatives Considered**:

**Immutable approach**:
```python
def undo(self) -> Tuple[ExpansionState, Optional[ExpansionAction]]:
    new_state = self.copy()
    new_state._history_position -= 1
    # ...
    return (new_state, action)
```
- Pros: Functional style, no side effects
- Cons: Expensive copying for large state
- Cons: Caller must manage state references

**Chosen: In-place mutation**
- Consistent with T01 aggregate pattern
- Better performance (no copying)
- Caller can check `can_undo()` before calling to avoid side effects

### 3.3 History Position Invariants

**Critical Invariants** (must hold after every operation):

```python
# Bounds
assert 0 <= self._history_position <= len(self.expansion_history)

# can_undo/redo correctness
assert self.can_undo() == (self._history_position > 0)
assert self.can_redo() == (self._history_position < len(self.expansion_history))

# State consistency (conceptual, hard to verify programmatically)
# visible_cells should equal result of applying actions[0:position]
```

**Enforcement Strategy**:
- Unit tests verify invariants after every operation
- Optional assertion checks in debug mode
- Clear contracts in docstrings

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E03-F04-T01 (ExpansionState Aggregate Core)** - **BLOCKING**:
- Extends `ExpansionState` class with new methods
- Uses `expansion_history` and `_history_position` fields
- Depends on `add_cells()` and `remove_cells()` methods
- Uses `can_undo()` and `can_redo()` (defined in T01)

**Must wait for T01 completion** before implementing T02.

### 4.2 Downstream Consumers

**Application Layer (commands/undo_command.py)**:
```python
class UndoExpansionCommand:
    def execute(self) -> None:
        action = self.expansion_state.undo()
        if action:
            self.canvas.refresh()
            self.ui.show_notification(f"Undone: {action.action_type.value}")
```

**Presentation Layer (keyboard shortcuts)**:
```python
# main_window.py
QShortcut(QKeySequence.Undo, self, self.handle_undo)

def handle_undo(self):
    self.application_service.undo_expansion()
```

**E03-F04-T03 (Expansion State Events)**:
- `undo()` will emit `ExpansionUndone` event
- `redo()` will emit `ExpansionRedone` event
- UI subscribes to events for reactive updates

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Test Philosophy**:
- Test undo/redo in isolation (no UI, no graph)
- Verify state transitions with hand-crafted histories
- Test edge cases exhaustively
- Verify invariants after each operation

### 5.2 Core Test Cases

**Basic Undo/Redo**:
```python
def test_undo_returns_none_when_no_history():
    state = ExpansionState()
    result = state.undo()
    assert result is None

def test_undo_reverses_expand_action():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test"
    ))

    assert state.is_cell_visible("A")

    action = state.undo()

    assert action is not None
    assert action.cells_affected == frozenset({"A"})
    assert not state.is_cell_visible("A")
    assert state._history_position == 0

def test_undo_reverses_collapse_action():
    state = ExpansionState()
    # First add cells
    state.add_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test"
    ))

    # Then collapse them
    state.remove_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.COLLAPSE,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test"
    ))

    assert not state.is_cell_visible("A")

    action = state.undo()

    assert action is not None
    assert action.action_type == ActionType.COLLAPSE
    assert state.is_cell_visible("A")  # Cell restored
```

**Redo Tests**:
```python
def test_redo_returns_none_when_at_end():
    state = ExpansionState()
    result = state.redo()
    assert result is None

def test_redo_reapplies_expand_action():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))

    state.undo()
    assert not state.is_cell_visible("A")

    action = state.redo()
    assert action is not None
    assert state.is_cell_visible("A")
    assert state._history_position == 1
```

**History Navigation**:
```python
def test_multiple_undo_redo_cycles():
    state = ExpansionState()

    # Build history: A, B, C
    for cell in ["A", "B", "C"]:
        state.add_cells({cell}, set())
        state.record_action(create_expand_action({cell}, set()))

    assert state.get_visible_cell_count() == 3

    # Undo 2x (removes C, B)
    state.undo()
    state.undo()
    assert state.get_visible_cell_count() == 1
    assert state.is_cell_visible("A")

    # Redo 1x (adds B back)
    state.redo()
    assert state.get_visible_cell_count() == 2
    assert state.is_cell_visible("B")

    # Undo 2x again (back to initial)
    state.undo()
    state.undo()
    assert state.get_visible_cell_count() == 0
```

**History Truncation**:
```python
def test_new_action_after_undo_truncates_future():
    state = ExpansionState()

    # Build history: A, B, C
    for cell in ["A", "B", "C"]:
        state.add_cells({cell}, set())
        state.record_action(create_expand_action({cell}, set()))

    assert state.get_history_size() == 3

    # Undo 2x (position = 1)
    state.undo()
    state.undo()

    # New action (should truncate B, C)
    state.add_cells({"D"}, set())
    state.record_action(create_expand_action({"D"}, set()))

    assert state.get_history_size() == 2  # A, D
    assert state.can_redo() == False  # No future history
```

### 5.3 Invariant Verification

```python
def test_history_position_invariants():
    state = ExpansionState()

    # Always: 0 <= position <= history_size
    assert state._history_position == 0
    assert state._history_position <= len(state.expansion_history)

    state.add_cells({"A"}, set())
    state.record_action(create_expand_action({"A"}, set()))

    assert state._history_position == 1
    assert state.can_undo()
    assert not state.can_redo()

    state.undo()

    assert state._history_position == 0
    assert not state.can_undo()
    assert state.can_redo()

def test_undo_redo_state_consistency():
    """Verify visible_cells matches history position"""
    state = ExpansionState()

    cells_sequence = [{"A"}, {"B"}, {"C"}]

    for cells in cells_sequence:
        state.add_cells(cells, set())
        state.record_action(create_expand_action(cells, set()))

    # Position 3: A, B, C visible
    assert state.get_visible_cell_count() == 3

    state.undo()  # Position 2: A, B visible
    assert state.get_visible_cell_count() == 2
    assert state.is_cell_visible("A")
    assert state.is_cell_visible("B")
    assert not state.is_cell_visible("C")

    state.undo()  # Position 1: A visible
    assert state.get_visible_cell_count() == 1
    assert state.is_cell_visible("A")

    state.redo()  # Position 2: A, B visible
    assert state.get_visible_cell_count() == 2
    assert state.is_cell_visible("B")
```

### 5.4 Integration Test Scenario

**Complete Undo/Redo Workflow**:
```python
def test_undo_redo_scenario():
    """
    Simulates realistic user workflow:
    1. Expand A (1 cell)
    2. Expand B (1 cell)
    3. Expand C fanout (3 cells)
    4. Undo expand C
    5. Expand D fanin (2 cells)
    6. Undo D
    7. Redo D
    8. Verify final state
    """
    state = ExpansionState()

    # Step 1: Expand A
    state.add_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="double_click",
        direction=ExpansionDirection.FANOUT,
        hops=1
    ))
    assert state.get_visible_cell_count() == 1

    # Step 2: Expand B
    state.add_cells({"B"}, {"net2"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"B"}),
        nets_affected=frozenset({"net2"}),
        timestamp=datetime.now(),
        trigger="double_click",
        direction=ExpansionDirection.FANOUT,
        hops=1
    ))
    assert state.get_visible_cell_count() == 2

    # Step 3: Expand C fanout (3 cells)
    state.add_cells({"C1", "C2", "C3"}, {"net3", "net4"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"C1", "C2", "C3"}),
        nets_affected=frozenset({"net3", "net4"}),
        timestamp=datetime.now(),
        trigger="right_click",
        direction=ExpansionDirection.FANOUT,
        hops=2
    ))
    assert state.get_visible_cell_count() == 5

    # Step 4: Undo expand C (too many cells)
    action = state.undo()
    assert action.cells_affected == frozenset({"C1", "C2", "C3"})
    assert state.get_visible_cell_count() == 2

    # Step 5: Expand D fanin instead
    state.add_cells({"D1", "D2"}, {"net5"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"D1", "D2"}),
        nets_affected=frozenset({"net5"}),
        timestamp=datetime.now(),
        trigger="right_click",
        direction=ExpansionDirection.FANIN,
        hops=1
    ))
    assert state.get_visible_cell_count() == 4
    assert not state.can_redo()  # Future history truncated

    # Step 6: Accidentally undo D
    state.undo()
    assert state.get_visible_cell_count() == 2

    # Step 7: Redo to restore D
    action = state.redo()
    assert action.cells_affected == frozenset({"D1", "D2"})
    assert state.get_visible_cell_count() == 4

    # Final state: A, B, D1, D2 visible
    assert state.is_cell_visible("A")
    assert state.is_cell_visible("B")
    assert state.is_cell_visible("D1")
    assert state.is_cell_visible("D2")
    assert not state.is_cell_visible("C1")  # Truncated
```

---

## 6. Risks and Mitigations

### 6.1 Risk: State Desynchronization

**Scenario**: `visible_cells` doesn't match what history position implies

**Example**:
```python
# Bug: Forgot to decrement position
def undo(self):
    action = self.expansion_history[self._history_position - 1]
    self.remove_cells(...)
    # BUG: Forgot to update position!
    # self._history_position -= 1  # MISSING
```

**Impact**: High - Undo/redo becomes unpredictable, users lose trust

**Probability**: Low - Straightforward implementation, good tests

**Mitigation**:
- Comprehensive unit tests verify position after each operation
- Invariant assertions in debug mode
- Integration tests verify end-to-end consistency

### 6.2 Risk: Off-by-One Errors

**Scenario**: History position indexing is off by one

**Example**:
```python
# Confusion: Does position point to last applied action or next action?
action = self.expansion_history[self._history_position]  # Or position-1?
```

**Impact**: Medium - Undo/redo doesn't work, but caught in testing

**Probability**: Medium - Common indexing mistake

**Mitigation**:
- Clear documentation of position semantics
- Comprehensive tests covering edge cases (empty history, position 0, position at end)
- Use helper methods to encapsulate indexing logic

**Position Semantics** (documented in code):
```python
# Position points to "next action to apply"
# Position 0: No actions applied
# Position N: Actions 0..N-1 applied
# To undo: reverse action at position-1, then decrement position
# To redo: apply action at position, then increment position
```

### 6.3 Risk: Redo Not Idempotent

**Scenario**: Redoing same action twice produces different state

**Example**:
```python
# Bug: Redo adds cells without checking if already visible
def redo(self):
    action = self.expansion_history[self._history_position]
    self.add_cells(...)  # Adds even if already visible
    self._history_position += 1
```

**Impact**: Low - `add_cells()` uses set update (idempotent)

**Probability**: Very Low - Set operations are naturally idempotent

**Mitigation**:
- Unit test verifies redo is idempotent
- Set operations (`update()`, `difference_update()`) handle duplicates gracefully

### 6.4 Risk: Memory Overhead for Large Actions

**Scenario**: Actions with 10,000+ cells consume excessive memory

**Example**:
```python
# Large expansion
action = ExpansionAction(
    cells_affected=frozenset({...10,000 cell IDs...}),
    ...
)
```

**Impact**: Low - Frozensets are memory-efficient (8 bytes per ID + overhead)

**Analysis**:
- 10,000 cells × 10 chars/ID × 1 byte/char = 100 KB per action
- 100 actions × 100 KB = 10 MB total (acceptable)

**Probability**: Low - Most expansions are 10-100 cells

**Mitigation**:
- History limit (100 actions) caps maximum memory
- If needed, implement history compaction (merge sequential actions)

---

## 7. Open Questions

### 7.1 Should undo/redo be undoable?

**Question**: Can user undo an undo operation?

**Current Answer**: Yes, via redo.

**Reasoning**:
- Undo moves position backward
- Redo moves position forward
- Undo + Redo = identity operation (restore original state)

**No separate "undo the undo" needed** - redo serves this purpose.

---

### 7.2 Should we support undo to specific point?

**Question**: Allow user to jump to arbitrary history position?

**Example**:
```python
def undo_to(self, position: int) -> None:
    """Undo/redo to specific history position"""
    while self._history_position > position:
        self.undo()
    while self._history_position < position:
        self.redo()
```

**Current Answer**: Not for MVP.

**Reasoning**:
- Users can achieve this with multiple undo/redo calls
- Adds complexity without clear UX benefit
- Non-standard pattern (text editors don't have this)

**Future Enhancement**: Could add if user feedback indicates need.

---

### 7.3 Should clear() preserve history?

**Question**: When `clear()` is called (e.g., new design loaded), should history be preserved?

**Current Answer**: No, clear all state including history.

```python
def clear(self) -> None:
    self.visible_cells.clear()
    self.visible_nets.clear()
    self.expansion_history.clear()
    self._history_position = 0
```

**Reasoning**:
- New design load is a fresh start
- History from old design is not applicable to new design
- Keeping history would be confusing (cell IDs don't match new design)

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `undo()` method implemented in `ExpansionState`
- [ ] `redo()` method implemented in `ExpansionState`
- [ ] `get_current_position()` returns history position
- [ ] `get_history_size()` returns total actions
- [ ] `get_undoable_actions()` returns list of undoable actions
- [ ] `get_redoable_actions()` returns list of redoable actions
- [ ] `undo()` returns `None` when no history
- [ ] `redo()` returns `None` when at end
- [ ] Expand actions undo to collapse
- [ ] Collapse actions undo to expand
- [ ] Multiple undo/redo cycles work correctly
- [ ] New action after undo truncates future history
- [ ] `clear()` resets history position to 0

### 8.2 Quality Checklist

- [ ] Unit tests in `/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state_undo_redo.py`
- [ ] Test coverage >= 100% for new methods
- [ ] All edge cases tested (empty history, position bounds, truncation)
- [ ] Integration test scenario passes
- [ ] Invariant tests pass after every operation
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Type hints on all methods
- [ ] Docstrings on all methods
- [ ] Code review completed

### 8.3 Integration Checklist

- [ ] Ready for T03 (Events) to hook into `undo()`/`redo()`
- [ ] Ready for application layer to call `undo()`/`redo()`
- [ ] Ready for keyboard shortcut integration

---

## 9. Next Steps

After T02 completion:

1. **T03 (Expansion State Events)**:
   - Add event publishing to `undo()` and `redo()`
   - Emit `ExpansionUndone` and `ExpansionRedone` events
   - Enable UI to react to undo/redo

2. **Application Layer Integration**:
   - Create `UndoExpansionCommand` and `RedoExpansionCommand`
   - Wire up to keyboard shortcuts (`Ctrl+Z`, `Ctrl+Shift+Z`)
   - Add menu items (Edit → Undo, Edit → Redo)

3. **UI Feedback**:
   - Display notifications when undo/redo executes
   - Show undo/redo availability in menu (grayed out when unavailable)
   - Optionally: Add undo/redo history panel (P1)

---

## 10. References

- **Task Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T02/E03-F04-T02.spec.md`
- **T01 Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T01/E03-F04-T01.spec.md`
- **Feature Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/E03-F04.spec.md`
- **Epic Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/E03.spec.md`

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
