---
id: E03-F04-T02
title: Undo/Redo State Navigation
type: Task
priority: P0 (MVP)
status: Draft
parent: E03-F04
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - domain
  - undo-redo
  - history
---

# Spec: E03-F04-T02 - Undo/Redo State Navigation

## 1. Overview

### 1.1 Problem Statement

Users need the ability to undo and redo expansion/collapse actions to explore different views and recover from mistakes. The `ExpansionState` aggregate must support navigating through action history and applying inverse operations to restore previous states.

### 1.2 Goals

- Implement undo operation to reverse the last action
- Implement redo operation to reapply undone actions
- Maintain history position for navigation
- Apply inverse state mutations (expand → collapse, collapse → expand)
- Support multiple levels of undo/redo

---

## 2. Technical Requirements

### 2.1 Undo/Redo Methods

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/domain/model/expansion_state.py` (extend existing)

```python
# Add to ExpansionState class:

def undo(self) -> Optional[ExpansionAction]:
    """Undo the last action and return it.

    Returns:
        The action that was undone, or None if nothing to undo

    Side effects:
        - Decrements history position
        - Reverses the action's state changes
    """
    if not self.can_undo():
        return None

    # Move position back
    self._history_position -= 1
    action = self.expansion_history[self._history_position]

    # Apply inverse operation
    if action.action_type == ActionType.EXPAND:
        # Undo expand = collapse
        self.remove_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )
    else:  # ActionType.COLLAPSE
        # Undo collapse = expand
        self.add_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )

    return action


def redo(self) -> Optional[ExpansionAction]:
    """Redo the next action and return it.

    Returns:
        The action that was redone, or None if nothing to redo

    Side effects:
        - Increments history position
        - Reapplies the action's state changes
    """
    if not self.can_redo():
        return None

    # Get action at current position
    action = self.expansion_history[self._history_position]
    self._history_position += 1

    # Apply operation
    if action.action_type == ActionType.EXPAND:
        self.add_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )
    else:  # ActionType.COLLAPSE
        self.remove_cells(
            set(action.cells_affected),
            set(action.nets_affected)
        )

    return action


def get_current_position(self) -> int:
    """Get current position in history.

    Returns:
        Current history position (0 = before first action)
    """
    return self._history_position


def get_history_size(self) -> int:
    """Get total number of actions in history.

    Returns:
        Length of expansion_history
    """
    return len(self.expansion_history)


def get_undoable_actions(self, count: int = 10) -> List[ExpansionAction]:
    """Get list of actions that can be undone.

    Args:
        count: Maximum number of actions to return

    Returns:
        List of ExpansionActions from current position backwards
    """
    if self._history_position == 0:
        return []

    start = max(0, self._history_position - count)
    return list(reversed(self.expansion_history[start:self._history_position]))


def get_redoable_actions(self, count: int = 10) -> List[ExpansionAction]:
    """Get list of actions that can be redone.

    Args:
        count: Maximum number of actions to return

    Returns:
        List of ExpansionActions from current position forwards
    """
    if self._history_position >= len(self.expansion_history):
        return []

    end = min(len(self.expansion_history), self._history_position + count)
    return self.expansion_history[self._history_position:end]
```

### 2.2 History State Invariants

The following invariants must hold:

```python
# Position bounds
assert 0 <= self._history_position <= len(self.expansion_history)

# Consistency between position and state
# (visible_cells should match result of applying actions 0..position-1)

# can_undo/redo correctness
assert self.can_undo() == (self._history_position > 0)
assert self.can_redo() == (self._history_position < len(self.expansion_history))
```

### 2.3 Edge Cases

1. **Undo when history is empty**: Return `None`, no state change
2. **Redo when at end of history**: Return `None`, no state change
3. **New action after undo**: Truncate future history
4. **Multiple undo/redo cycles**: Position must track correctly
5. **Clear after undo**: Reset position to 0

### 2.4 Testing Requirements

**Unit Tests** (`/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state_undo_redo.py`):

```python
# Test cases:
- test_undo_returns_none_when_no_history()
- test_undo_reverses_expand_action()
- test_undo_reverses_collapse_action()
- test_redo_returns_none_when_at_end()
- test_redo_reapplies_expand_action()
- test_redo_reapplies_collapse_action()
- test_multiple_undo_redo_cycles()
- test_new_action_after_undo_truncates_future()
- test_get_undoable_actions_returns_correct_list()
- test_get_redoable_actions_returns_correct_list()
- test_history_position_tracks_correctly()
- test_clear_resets_history_position()
- test_undo_redo_state_consistency()
```

**Integration Test Scenario**:
```python
def test_undo_redo_scenario():
    state = ExpansionState()

    # Expand cell A
    state.add_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test"
    ))
    assert state.is_cell_visible("A")

    # Expand cell B
    state.add_cells({"B"}, {"net2"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"B"}),
        nets_affected=frozenset({"net2"}),
        timestamp=datetime.now(),
        trigger="test"
    ))
    assert state.is_cell_visible("B")

    # Undo (removes B)
    action = state.undo()
    assert action.cells_affected == frozenset({"B"})
    assert not state.is_cell_visible("B")
    assert state.is_cell_visible("A")  # A still visible

    # Undo (removes A)
    action = state.undo()
    assert action.cells_affected == frozenset({"A"})
    assert not state.is_cell_visible("A")

    # Redo (adds A back)
    action = state.redo()
    assert state.is_cell_visible("A")

    # Redo (adds B back)
    action = state.redo()
    assert state.is_cell_visible("B")

    # No more redos
    assert state.redo() is None
```

---

## 3. Dependencies

### 3.1 Upstream Dependencies
- E03-F04-T01 (ExpansionState Aggregate Core) - **BLOCKING**

### 3.2 Downstream Consumers
- E04 (Interaction - keyboard shortcuts for undo/redo)
- Application layer undo/redo commands

---

## 4. Acceptance Criteria

- [ ] `undo()` method implemented and reverses last action
- [ ] `redo()` method implemented and reapplies undone action
- [ ] `get_current_position()` returns correct history position
- [ ] `get_history_size()` returns total actions
- [ ] `get_undoable_actions()` returns list of undoable actions
- [ ] `get_redoable_actions()` returns list of redoable actions
- [ ] `undo()` returns `None` when no history
- [ ] `redo()` returns `None` when at end of history
- [ ] Multiple undo/redo cycles work correctly
- [ ] New action after undo truncates future history
- [ ] History position invariants maintained
- [ ] Expand actions undo to collapse
- [ ] Collapse actions undo to expand
- [ ] `visible_cells` and `visible_nets` stay consistent with history
- [ ] All unit tests pass with 100% coverage
- [ ] Integration test scenario passes

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why return `Optional[ExpansionAction]`?**
- Allows caller to display what was undone/redone
- Useful for UI feedback ("Undone: Expand 5 cells")
- Alternative: Return `bool` for success/failure

**Why modify state in-place?**
- Consistent with aggregate mutation pattern
- Avoids copying large state objects
- Caller can check `can_undo()`/`can_redo()` first

**Future history truncation**:
- When new action recorded after undo, future history is lost
- This is standard undo/redo behavior (like text editors)
- Alternative: Keep branching history (complex, not needed for MVP)

### 5.2 Performance Considerations

- Undo/redo is O(n) where n = cells_affected (set operations)
- History navigation is O(1) (index lookup)
- No performance issues expected for typical expansion sizes (10-100 cells)

### 5.3 Alternative Designs Considered

**Command Pattern**:
- Create `UndoableCommand` interface with `execute()/undo()`
- More flexible but adds complexity
- Not needed for simple expand/collapse operations

**Immutable State with Snapshots**:
- Store full state snapshot for each action
- Fast undo/redo (just swap references)
- High memory cost for large visible sets
- Rejected for MVP, reconsider if memory is not a constraint

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F04 split |
