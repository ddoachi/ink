# E03-F04-T03 - Expansion State Events: Pre-Implementation Documentation

## Document Information
- **Task**: E03-F04-T03 - Expansion State Events
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task adds domain event publishing to the `ExpansionState` aggregate, enabling decoupled components (particularly the UI layer) to react to state changes asynchronously. When cells are expanded, collapsed, or undo/redo operations occur, the aggregate emits immutable event objects that subscribers can observe and respond to without tight coupling to the domain layer.

### 1.2 Problem Context

**Without Events (Polling/Direct Coupling)**:

```python
# Bad: UI directly coupled to domain
class SchematicCanvas:
    def on_user_expand(self, pin):
        old_count = self.expansion_state.get_visible_cell_count()
        self.expansion_service.expand(pin, hops=1)
        new_count = self.expansion_state.get_visible_cell_count()

        if new_count > old_count:
            # Manually check for changes and update
            self.refresh_view()
```

**Problems**:
- UI must poll state or manually track changes
- Tight coupling between layers violates Clean Architecture
- Multiple UI components must coordinate updates
- No centralized notification mechanism
- Hard to add new observers (e.g., logging, analytics)

**With Events (Observer Pattern)**:

```python
# Good: UI reacts to domain events
class SchematicCanvas:
    def __init__(self, expansion_state):
        expansion_state.subscribe(self.handle_expansion_event)

    def handle_expansion_event(self, event: DomainEvent):
        if isinstance(event, CellsExpanded):
            self.add_cells_to_view(event.cells)
            self.route_nets(event.nets)
        elif isinstance(event, CellsCollapsed):
            self.remove_cells_from_view(event.cells)
```

**Benefits**:
- UI reacts automatically to state changes
- Decoupled: Domain doesn't know about UI
- Multiple subscribers can observe same events
- Easy to add logging, analytics, debugging observers
- Follows Open/Closed Principle (open for extension)

### 1.3 Core Capabilities

The event system provides:

1. **Domain Event Types**: Immutable value objects representing state changes
2. **Event Publishing**: Aggregate emits events when state mutates
3. **Subscription Management**: Components can subscribe/unsubscribe to events
4. **Error Isolation**: Subscriber exceptions don't crash the aggregate
5. **Event Metadata**: Timestamp, cells/nets affected, trigger, direction, etc.

---

## 2. Implementation Approach

### 2.1 Observer Pattern Architecture

**Classic Observer Pattern**:

```
┌─────────────────────────────────────────────┐
│         ExpansionState (Subject)            │
│  - _event_handlers: List[Handler]          │
│  + subscribe(handler)                       │
│  + unsubscribe(handler)                     │
│  + _publish_event(event)                    │
└─────────────────────────────────────────────┘
                  │
                  │ emits
                  ▼
          ┌──────────────────┐
          │   DomainEvent    │
          │ (Immutable VO)   │
          └──────────────────┘
                  │
                  │ receives
                  ▼
┌─────────────────────────────────────────────┐
│         Observers (Subscribers)             │
│  - SchematicCanvas                          │
│  - PropertyPanel                            │
│  - EventLogger                              │
│  - AnalyticsTracker                         │
└─────────────────────────────────────────────┘
```

**Key Components**:
1. **Subject** (`ExpansionState`): Maintains list of observers, publishes events
2. **Event** (`DomainEvent` subclasses): Immutable data objects
3. **Observers** (UI components, services): React to events via handler callbacks

### 2.2 Event Hierarchy Design

**Base Event**:
```python
@dataclass(frozen=True)
class DomainEvent:
    """Base class for all domain events."""
    timestamp: datetime
```

**Why frozen dataclass?**
- Immutable: Events represent facts that happened (past tense)
- Safe to pass between layers without risk of modification
- Can be stored in history, logs, or replayed
- Lightweight value objects (no methods, just data)

**Event Subclasses**:
```python
@dataclass(frozen=True)
class CellsExpanded(DomainEvent):
    cells: FrozenSet[str]          # Immutable set of affected cells
    nets: FrozenSet[str]
    trigger: str                    # What caused expansion
    direction: ExpansionDirection | None
    hops: int | None
    source_pin_id: str | None

@dataclass(frozen=True)
class CellsCollapsed(DomainEvent):
    cells: FrozenSet[str]
    nets: FrozenSet[str]
    trigger: str

@dataclass(frozen=True)
class ExpansionUndone(DomainEvent):
    action_type: ActionType         # What was undone (expand or collapse)
    cells: FrozenSet[str]
    nets: FrozenSet[str]

@dataclass(frozen=True)
class ExpansionRedone(DomainEvent):
    action_type: ActionType
    cells: FrozenSet[str]
    nets: FrozenSet[str]

@dataclass(frozen=True)
class ExpansionStateCleared(DomainEvent):
    pass  # No additional data needed
```

**Why separate events instead of single StateChanged event?**
- Type safety: Subscribers can pattern match on event type
- Semantic clarity: `CellsExpanded` is more expressive than `StateChanged(type="expand")`
- Extensibility: Each event can have specific fields relevant to that operation
- Filtering: Subscribers can react to specific events only

### 2.3 Subscription Mechanism

**Simple Callback List**:

```python
class ExpansionState:
    _event_handlers: List[Callable[[DomainEvent], None]] = field(
        default_factory=list,
        init=False,
        repr=False
    )

    def subscribe(self, handler: Callable[[DomainEvent], None]) -> None:
        self._event_handlers.append(handler)

    def unsubscribe(self, handler: Callable[[DomainEvent], None]) -> None:
        if handler in self._event_handlers:
            self._event_handlers.remove(handler)
```

**Why list instead of set?**
- Preserves subscription order (useful for priority)
- Allows same handler to subscribe multiple times (rare but valid)
- Simpler implementation (no need for hashable handlers)

**Why not use weak references?**
- Simplicity: Subscribers must explicitly unsubscribe
- Clear lifecycle management: No surprise handler removal
- Can add weak refs later if memory leaks become issue

### 2.4 Event Publishing Logic

**Core Publishing Method**:

```python
def _publish_event(self, event: DomainEvent) -> None:
    """Publish event to all subscribers.

    Args:
        event: DomainEvent instance

    Note: Subscriber exceptions are caught and logged to prevent
    cascading failures. The aggregate remains stable even if
    subscribers misbehave.
    """
    for handler in self._event_handlers:
        try:
            handler(event)
        except Exception as e:
            # Log error but don't let subscriber exceptions crash the aggregate
            # TODO: Use proper logging framework in production
            print(f"Error in event handler: {e}")
```

**Error Handling Strategy**:

**Why catch exceptions?**
- **Defensive**: Subscriber bugs shouldn't break domain logic
- **Isolation**: One bad subscriber shouldn't prevent others from receiving events
- **Robustness**: Aggregate remains stable regardless of subscriber behavior

**Alternatives Considered**:

1. **Let exceptions propagate**:
   ```python
   for handler in self._event_handlers:
       handler(event)  # Exception kills iteration
   ```
   - Rejected: One bad subscriber breaks entire event chain
   - Rejected: Domain logic fails due to presentation layer bug

2. **Retry on exception**:
   ```python
   for attempt in range(3):
       try:
           handler(event)
           break
       except Exception:
           if attempt == 2:
               raise
   ```
   - Rejected: Retrying likely won't fix the issue
   - Rejected: Adds latency without clear benefit

3. **Queue failed events for later**:
   ```python
   failed_events = []
   for handler in self._event_handlers:
       try:
           handler(event)
       except Exception:
           failed_events.append((handler, event))
   ```
   - Rejected: Complex, unclear when to retry
   - Rejected: Memory overhead for failed event queue

**Chosen: Catch and log**:
- Simple and robust
- Aggregate continues executing
- Developers can debug via logs
- Production: Replace `print()` with proper logging

### 2.5 Event Emission Points

**Where to Emit Events**:

```python
def record_action(self, action: ExpansionAction) -> None:
    # ... existing implementation ...

    # Emit event based on action type
    if action.action_type == ActionType.EXPAND:
        event = CellsExpanded(
            timestamp=action.timestamp,
            cells=action.cells_affected,
            nets=action.nets_affected,
            trigger=action.trigger,
            direction=action.direction,
            hops=action.hops,
            source_pin_id=action.source_pin_id
        )
    else:
        event = CellsCollapsed(
            timestamp=action.timestamp,
            cells=action.cells_affected,
            nets=action.nets_affected,
            trigger=action.trigger
        )

    self._publish_event(event)

def undo(self) -> Optional[ExpansionAction]:
    # ... existing implementation ...

    if action is not None:
        event = ExpansionUndone(
            timestamp=datetime.now(),
            action_type=action.action_type,
            cells=action.cells_affected,
            nets=action.nets_affected
        )
        self._publish_event(event)

    return action

def redo(self) -> Optional[ExpansionAction]:
    # ... existing implementation ...

    if action is not None:
        event = ExpansionRedone(
            timestamp=datetime.now(),
            action_type=action.action_type,
            cells=action.cells_affected,
            nets=action.nets_affected
        )
        self._publish_event(event)

    return action

def clear(self) -> None:
    # ... existing implementation ...

    event = ExpansionStateCleared(timestamp=datetime.now())
    self._publish_event(event)
```

**Why emit in record_action instead of add_cells/remove_cells?**
- `record_action` is the high-level operation (user intent)
- `add_cells`/`remove_cells` are low-level mutations (used by undo/redo)
- Emitting at high level prevents duplicate events during undo/redo
- `undo()` and `redo()` emit their own specific events

---

## 3. Key Design Decisions

### 3.1 Synchronous vs. Asynchronous Event Handling

**Decision**: Synchronous event publishing for MVP.

```python
def _publish_event(self, event: DomainEvent) -> None:
    for handler in self._event_handlers:
        handler(event)  # Blocks until handler completes
```

**Alternatives Considered**:

**Async with asyncio**:
```python
async def _publish_event(self, event: DomainEvent) -> None:
    tasks = [asyncio.create_task(handler(event)) for handler in self._event_handlers]
    await asyncio.gather(*tasks, return_exceptions=True)
```
- Pros: Non-blocking, handlers run concurrently
- Cons: Requires async/await throughout codebase
- Cons: Race conditions if handlers access shared state
- Cons: Harder to debug (stack traces across tasks)

**Threading**:
```python
def _publish_event(self, event: DomainEvent) -> None:
    for handler in self._event_handlers:
        threading.Thread(target=handler, args=(event,)).start()
```
- Pros: Handlers run in background
- Cons: Thread safety issues (Qt not thread-safe)
- Cons: No control over execution order
- Cons: Harder to test (non-deterministic)

**Chosen: Synchronous**:
- Simple and predictable
- No thread safety concerns (PySide6 is single-threaded)
- Easy to debug (linear stack traces)
- Handlers typically fast (update UI, log event)
- Can upgrade to async later if profiling shows need

**Performance Analysis**:
- Typical handler: O(1) to O(n) where n = cells affected
- SchematicCanvas.handle_expansion: Updates Qt scene (~1-10ms)
- EventLogger.handle_event: Appends to log (~0.1ms)
- Even with 10 subscribers, total overhead <100ms (acceptable)

### 3.2 Event Granularity

**Decision**: One event per logical operation (expand, collapse, undo, redo, clear).

**Alternatives Considered**:

**Fine-grained events**:
```python
# Emit separate events for cells and nets
event1 = CellsAdded(cells=...)
event2 = NetsAdded(nets=...)
```
- Rejected: Too noisy, subscribers must coordinate between events
- Rejected: No clear atomicity boundary

**Coarse-grained events**:
```python
# Single StateChanged event
event = StateChanged(old_state=..., new_state=...)
```
- Rejected: Loses semantic information (why did state change?)
- Rejected: Hard to pattern match on specific changes

**Chosen: Medium granularity**:
- One event per user operation
- Events contain all relevant data (cells + nets)
- Clear semantics (expand, collapse, undo, redo)

### 3.3 Event Immutability Enforcement

**Decision**: Use `@dataclass(frozen=True)` and `FrozenSet` for collections.

**Why frozen dataclass?**
```python
@dataclass(frozen=True)
class CellsExpanded(DomainEvent):
    cells: FrozenSet[str]  # Cannot be modified after creation

# Attempting to modify raises FrozenInstanceError
event.cells.add("new_cell")  # AttributeError: 'frozenset' has no 'add'
```

**Alternatives Considered**:

**Regular dataclass with sets**:
```python
@dataclass
class CellsExpanded(DomainEvent):
    cells: Set[str]  # Mutable!
```
- Rejected: Subscribers could accidentally modify event
- Rejected: No compile-time guarantee of immutability

**Manual __setattr__ override**:
```python
class CellsExpanded:
    def __setattr__(self, name, value):
        raise AttributeError("Event is immutable")
```
- Rejected: More verbose than frozen dataclass
- Rejected: Doesn't prevent collection mutation

**Chosen: frozen dataclass + FrozenSet**:
- Compile-time enforcement via type checker
- Runtime enforcement via frozen dataclass
- No manual immutability boilerplate
- Standard Python pattern (PEP 557)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E03-F04-T01 (ExpansionState Aggregate Core)** - **BLOCKING**:
- Extends `ExpansionState` with event publishing
- Hooks into `record_action()`, `add_cells()`, `remove_cells()`

**E03-F04-T02 (Undo/Redo State Navigation)** - **BLOCKING**:
- Hooks into `undo()` and `redo()` methods
- Emits `ExpansionUndone` and `ExpansionRedone` events

**Must wait for T01 and T02 completion** before implementing T03.

### 4.2 Downstream Consumers

**Presentation Layer (SchematicCanvas)**:
```python
class SchematicCanvas(QGraphicsScene):
    def __init__(self, expansion_state: ExpansionState):
        super().__init__()
        expansion_state.subscribe(self.handle_expansion_event)

    def handle_expansion_event(self, event: DomainEvent):
        if isinstance(event, CellsExpanded):
            self.add_cells_to_scene(event.cells)
            self.route_nets(event.nets)
            self.animate_expansion(event.cells)
        elif isinstance(event, CellsCollapsed):
            self.remove_cells_from_scene(event.cells)
            self.remove_nets(event.nets)
        elif isinstance(event, ExpansionUndone):
            self.refresh_scene()
        elif isinstance(event, ExpansionRedone):
            self.refresh_scene()
        elif isinstance(event, ExpansionStateCleared):
            self.clear_scene()
```

**Property Panel**:
```python
class PropertyPanel(QWidget):
    def __init__(self, expansion_state: ExpansionState):
        super().__init__()
        expansion_state.subscribe(self.handle_expansion_event)

    def handle_expansion_event(self, event: DomainEvent):
        if isinstance(event, CellsExpanded):
            self.update_statistics(
                f"Expanded {len(event.cells)} cells via {event.trigger}"
            )
```

**Event Logger (Debugging)**:
```python
class ExpansionEventLogger:
    def __init__(self, expansion_state: ExpansionState):
        expansion_state.subscribe(self.log_event)

    def log_event(self, event: DomainEvent):
        timestamp = event.timestamp.isoformat()
        event_type = event.__class__.__name__
        logging.info(f"[{timestamp}] {event_type}: {event}")
```

**Analytics Tracker (P1)**:
```python
class AnalyticsTracker:
    def __init__(self, expansion_state: ExpansionState):
        expansion_state.subscribe(self.track_event)

    def track_event(self, event: DomainEvent):
        if isinstance(event, CellsExpanded):
            self.analytics.track("expansion", {
                "cell_count": len(event.cells),
                "direction": event.direction,
                "hops": event.hops,
                "trigger": event.trigger
            })
```

---

## 5. Testing Strategy

### 5.1 Event Immutability Tests

```python
def test_cells_expanded_event_immutable():
    event = CellsExpanded(
        timestamp=datetime.now(),
        cells=frozenset({"A", "B"}),
        nets=frozenset({"net1"}),
        trigger="test",
        direction=ExpansionDirection.FANOUT,
        hops=1,
        source_pin_id="pin1"
    )

    # Cannot modify frozen dataclass
    with pytest.raises(FrozenInstanceError):
        event.cells = frozenset({"C"})

    # Cannot modify frozenset
    with pytest.raises(AttributeError):
        event.cells.add("C")

def test_all_event_types_frozen():
    """Verify all event classes use frozen dataclass"""
    event_classes = [
        CellsExpanded,
        CellsCollapsed,
        ExpansionUndone,
        ExpansionRedone,
        ExpansionStateCleared
    ]

    for cls in event_classes:
        assert cls.__dataclass_fields__  # Is dataclass
        # Check if frozen (frozen dataclasses have __setattr__ and __delattr__)
        instance = cls(timestamp=datetime.now(), **get_test_data(cls))
        with pytest.raises((FrozenInstanceError, AttributeError)):
            instance.timestamp = datetime.now()
```

### 5.2 Subscription Tests

```python
def test_subscribe_adds_handler():
    state = ExpansionState()
    handler = Mock()

    state.subscribe(handler)

    assert handler in state._event_handlers

def test_unsubscribe_removes_handler():
    state = ExpansionState()
    handler = Mock()

    state.subscribe(handler)
    state.unsubscribe(handler)

    assert handler not in state._event_handlers

def test_multiple_subscribers_receive_event():
    state = ExpansionState()
    handler1 = Mock()
    handler2 = Mock()

    state.subscribe(handler1)
    state.subscribe(handler2)

    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))

    assert handler1.call_count == 1
    assert handler2.call_count == 1

    # Both received same event
    event1 = handler1.call_args[0][0]
    event2 = handler2.call_args[0][0]
    assert event1 is event2  # Same instance
```

### 5.3 Event Publishing Tests

```python
def test_record_action_emits_cells_expanded():
    state = ExpansionState()
    handler = Mock()
    state.subscribe(handler)

    state.add_cells({"A", "B"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"A", "B"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test",
        direction=ExpansionDirection.FANOUT,
        hops=1
    ))

    handler.assert_called_once()
    event = handler.call_args[0][0]

    assert isinstance(event, CellsExpanded)
    assert event.cells == frozenset({"A", "B"})
    assert event.nets == frozenset({"net1"})
    assert event.trigger == "test"
    assert event.direction == ExpansionDirection.FANOUT
    assert event.hops == 1

def test_record_action_emits_cells_collapsed():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))

    handler = Mock()
    state.subscribe(handler)

    state.remove_cells({"A"}, {"net1"})
    state.record_action(ExpansionAction(
        action_type=ActionType.COLLAPSE,
        cells_affected=frozenset({"A"}),
        nets_affected=frozenset({"net1"}),
        timestamp=datetime.now(),
        trigger="test"
    ))

    handler.assert_called_once()
    event = handler.call_args[0][0]

    assert isinstance(event, CellsCollapsed)
    assert event.cells == frozenset({"A"})

def test_undo_emits_expansion_undone():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))

    handler = Mock()
    state.subscribe(handler)

    state.undo()

    handler.assert_called_once()
    event = handler.call_args[0][0]

    assert isinstance(event, ExpansionUndone)
    assert event.action_type == ActionType.EXPAND
    assert event.cells == frozenset({"A"})

def test_redo_emits_expansion_redone():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))
    state.undo()

    handler = Mock()
    state.subscribe(handler)

    state.redo()

    handler.assert_called_once()
    event = handler.call_args[0][0]

    assert isinstance(event, ExpansionRedone)
    assert event.action_type == ActionType.EXPAND

def test_clear_emits_expansion_state_cleared():
    state = ExpansionState()
    handler = Mock()
    state.subscribe(handler)

    state.clear()

    handler.assert_called_once()
    event = handler.call_args[0][0]

    assert isinstance(event, ExpansionStateCleared)
```

### 5.4 Error Handling Tests

```python
def test_subscriber_exception_does_not_crash():
    state = ExpansionState()

    def bad_handler(event):
        raise ValueError("Handler bug!")

    good_handler = Mock()

    state.subscribe(bad_handler)
    state.subscribe(good_handler)

    # Should not raise despite bad_handler exception
    state.add_cells({"A"}, {"net1"})
    state.record_action(create_expand_action({"A"}, {"net1"}))

    # Good handler should still receive event
    good_handler.assert_called_once()

def test_unsubscribe_stops_receiving_events():
    state = ExpansionState()
    handler = Mock()

    state.subscribe(handler)
    state.add_cells({"A"}, set())
    state.record_action(create_expand_action({"A"}, set()))

    assert handler.call_count == 1

    state.unsubscribe(handler)
    state.add_cells({"B"}, set())
    state.record_action(create_expand_action({"B"}, set()))

    # Still 1 (not called again after unsubscribe)
    assert handler.call_count == 1
```

### 5.5 Event Data Correctness Tests

```python
def test_event_contains_correct_data():
    state = ExpansionState()
    handler = Mock()
    state.subscribe(handler)

    timestamp_before = datetime.now()

    state.add_cells({"cell1", "cell2", "cell3"}, {"net1", "net2"})
    state.record_action(ExpansionAction(
        action_type=ActionType.EXPAND,
        cells_affected=frozenset({"cell1", "cell2", "cell3"}),
        nets_affected=frozenset({"net1", "net2"}),
        timestamp=datetime.now(),
        trigger="double_click",
        direction=ExpansionDirection.FANOUT,
        hops=2,
        source_pin_id="pin_X"
    ))

    event = handler.call_args[0][0]

    assert event.cells == frozenset({"cell1", "cell2", "cell3"})
    assert event.nets == frozenset({"net1", "net2"})
    assert event.trigger == "double_click"
    assert event.direction == ExpansionDirection.FANOUT
    assert event.hops == 2
    assert event.source_pin_id == "pin_X"
    assert event.timestamp >= timestamp_before
```

---

## 6. Risks and Mitigations

### 6.1 Risk: Subscriber Performance Degradation

**Scenario**: Slow subscriber blocks event publishing

**Example**:
```python
def slow_handler(event):
    time.sleep(5)  # Expensive operation

state.subscribe(slow_handler)
state.record_action(...)  # Blocks for 5 seconds!
```

**Impact**: Medium - UI freezes during expansion

**Probability**: Low - Most handlers are fast (UI updates)

**Mitigation**:
- Document handler performance expectations
- Profiling: Add timing instrumentation to detect slow handlers
- Future: Move to async if becomes issue
- Guideline: Handlers should be <10ms

### 6.2 Risk: Memory Leaks from Subscriptions

**Scenario**: Subscribers not unsubscribed, preventing garbage collection

**Example**:
```python
class TemporaryCanvas:
    def __init__(self, state):
        state.subscribe(self.handle_event)
        # Forgot to unsubscribe in destructor!

# Canvas instance deleted, but state holds reference via subscription
# Canvas never garbage collected
```

**Impact**: Low - Gradual memory growth

**Probability**: Low - Subscribers typically have same lifetime as state

**Mitigation**:
- Document subscription lifecycle in docstrings
- Use context managers for temporary subscriptions:
  ```python
  with state.subscription(handler):
      # Handler active only in this scope
  ```
- Consider weak references (future enhancement)

### 6.3 Risk: Event Ordering Ambiguity

**Scenario**: Multiple state changes in single operation

**Example**:
```python
# What if we add_cells() multiple times before record_action()?
state.add_cells({"A"}, {"net1"})
state.add_cells({"B"}, {"net2"})
state.record_action(...)  # Only one event emitted
```

**Impact**: Low - Current design emits one event per record_action

**Probability**: Very Low - Application layer controls record_action calls

**Mitigation**:
- Clear documentation: Events emitted per record_action, not per add_cells
- Application layer responsibility to batch operations correctly

### 6.4 Risk: Event Replay Complexity

**Scenario**: Replaying events to rebuild state (event sourcing)

**Current**: Not supported (aggregate maintains mutable state)

**Impact**: None for MVP (event sourcing not required)

**Probability**: N/A

**Future Enhancement**: If event sourcing needed (P2):
```python
def rebuild_from_events(events: List[DomainEvent]) -> ExpansionState:
    state = ExpansionState()
    for event in events:
        if isinstance(event, CellsExpanded):
            state.add_cells(event.cells, event.nets)
        elif isinstance(event, CellsCollapsed):
            state.remove_cells(event.cells, event.nets)
    return state
```

---

## 7. Open Questions

### 7.1 Should events be persisted?

**Question**: Store events to disk for session replay or debugging?

**Current Answer**: No for MVP.

**Reasoning**:
- Adds complexity (serialization, storage)
- Not required for core functionality
- Can add later if debugging or analytics needs it

**Future Enhancement**: Event log file
```python
class EventPersistence:
    def __init__(self, log_file):
        self.log_file = log_file

    def handle_event(self, event: DomainEvent):
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(event.to_dict()) + '\n')
```

---

### 7.2 Should we support event filtering?

**Question**: Allow subscribers to filter by event type?

**Example**:
```python
state.subscribe(handler, event_types=[CellsExpanded, CellsCollapsed])
```

**Current Answer**: No for MVP.

**Reasoning**:
- Subscribers can filter via isinstance checks
- Simple handler pattern sufficient for MVP
- Adds API complexity without clear benefit

**Subscriber-side filtering**:
```python
def handle_event(event):
    if not isinstance(event, (CellsExpanded, CellsCollapsed)):
        return
    # Handle event
```

---

### 7.3 Should events include old and new state?

**Question**: Include before/after state snapshots in events?

**Example**:
```python
@dataclass(frozen=True)
class CellsExpanded(DomainEvent):
    cells_added: FrozenSet[str]
    old_visible_cells: FrozenSet[str]
    new_visible_cells: FrozenSet[str]
```

**Current Answer**: No, only deltas (cells added).

**Reasoning**:
- Memory overhead: Copying entire visible set per event
- Subscribers can query state if needed: `state.visible_cells`
- Events represent changes, not full snapshots
- Standard event sourcing pattern (only deltas)

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `DomainEvent` base class defined in `/home/joohan/dev/project-ink/ink/src/ink/domain/events/expansion_events.py`
- [ ] `CellsExpanded` event defined with all fields
- [ ] `CellsCollapsed` event defined
- [ ] `ExpansionUndone` event defined
- [ ] `ExpansionRedone` event defined
- [ ] `ExpansionStateCleared` event defined
- [ ] All events are immutable (`@dataclass(frozen=True)`)
- [ ] All events use `FrozenSet` for collections
- [ ] `subscribe()` method adds handler to `ExpansionState`
- [ ] `unsubscribe()` method removes handler
- [ ] `_publish_event()` method calls all handlers
- [ ] `record_action()` emits appropriate event (Expanded or Collapsed)
- [ ] `undo()` emits `ExpansionUndone` event
- [ ] `redo()` emits `ExpansionRedone` event
- [ ] `clear()` emits `ExpansionStateCleared` event
- [ ] Subscriber exceptions caught and logged

### 8.2 Quality Checklist

- [ ] Event tests in `/home/joohan/dev/project-ink/ink/tests/unit/domain/events/test_expansion_events.py`
- [ ] State event tests in `/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state_events.py`
- [ ] Test coverage >= 100% for event classes and publishing logic
- [ ] All edge cases tested (empty handlers, exceptions, unsubscribe)
- [ ] Immutability tests pass
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Type hints on all methods
- [ ] Docstrings on all classes and methods
- [ ] Code review completed

### 8.3 Integration Checklist

- [ ] Events can be imported by presentation layer
- [ ] UI can subscribe to events without compilation errors
- [ ] Example subscriber implemented (e.g., debug logger)
- [ ] Ready for SchematicCanvas integration

---

## 9. Next Steps

After T03 completion:

1. **Presentation Layer Integration**:
   - Implement `SchematicCanvas.handle_expansion_event()`
   - Subscribe canvas to `ExpansionState` events
   - Test reactive UI updates

2. **Additional Subscribers**:
   - PropertyPanel: Update statistics on expansion
   - HierarchyPanel: Reflect expanded cells in tree view
   - StatusBar: Show expansion notifications

3. **Debugging Tools**:
   - Event logger for development
   - Event viewer UI (optional P1)
   - Performance profiling of handlers

---

## 10. References

- **Task Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T03/E03-F04-T03.spec.md`
- **T01 Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T01/E03-F04-T01.spec.md`
- **T02 Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T02/E03-F04-T02.spec.md`
- **Feature Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/E03-F04.spec.md`
- **Observer Pattern**: Gang of Four Design Patterns

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
