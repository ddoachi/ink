---
id: E03-F04-T03
title: Expansion State Events
type: Task
priority: P0 (MVP)
status: Draft
parent: E03-F04
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - domain
  - events
  - state-management
clickup_task_id: '86evzm2rp'
---

# Spec: E03-F04-T03 - Expansion State Events

## 1. Overview

### 1.1 Problem Statement

The presentation layer (UI) needs to react to expansion state changes to update the schematic view. The `ExpansionState` aggregate should emit domain events when state mutations occur, allowing decoupled components to observe and respond to state changes without tight coupling.

### 1.2 Goals

- Define domain events for expansion state changes
- Emit events when cells/nets are added or removed
- Emit events when actions are recorded
- Support event subscribers/observers
- Enable UI to react to state changes asynchronously

---

## 2. Technical Requirements

### 2.1 Domain Events

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/domain/events/expansion_events.py`

```python
from dataclasses import dataclass
from datetime import datetime
from typing import FrozenSet
from ink.domain.model.expansion_state import ActionType, ExpansionDirection


@dataclass(frozen=True)
class DomainEvent:
    """Base class for all domain events."""

    timestamp: datetime


@dataclass(frozen=True)
class CellsExpanded(DomainEvent):
    """Emitted when cells are added to visible set."""

    cells: FrozenSet[str]
    nets: FrozenSet[str]
    trigger: str
    direction: ExpansionDirection | None
    hops: int | None
    source_pin_id: str | None


@dataclass(frozen=True)
class CellsCollapsed(DomainEvent):
    """Emitted when cells are removed from visible set."""

    cells: FrozenSet[str]
    nets: FrozenSet[str]
    trigger: str


@dataclass(frozen=True)
class ExpansionUndone(DomainEvent):
    """Emitted when an action is undone."""

    action_type: ActionType
    cells: FrozenSet[str]
    nets: FrozenSet[str]


@dataclass(frozen=True)
class ExpansionRedone(DomainEvent):
    """Emitted when an action is redone."""

    action_type: ActionType
    cells: FrozenSet[str]
    nets: FrozenSet[str]


@dataclass(frozen=True)
class ExpansionStateCleared(DomainEvent):
    """Emitted when expansion state is cleared."""

    pass
```

### 2.2 Event Publishing

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/domain/model/expansion_state.py` (extend existing)

```python
from typing import Callable, List
from ink.domain.events.expansion_events import (
    DomainEvent,
    CellsExpanded,
    CellsCollapsed,
    ExpansionUndone,
    ExpansionRedone,
    ExpansionStateCleared
)


# Add to ExpansionState class:

_event_handlers: List[Callable[[DomainEvent], None]] = field(
    default_factory=list,
    init=False,
    repr=False
)


def subscribe(self, handler: Callable[[DomainEvent], None]) -> None:
    """Subscribe to state change events.

    Args:
        handler: Callable that receives DomainEvent instances
    """
    self._event_handlers.append(handler)


def unsubscribe(self, handler: Callable[[DomainEvent], None]) -> None:
    """Unsubscribe from state change events.

    Args:
        handler: Previously subscribed handler
    """
    if handler in self._event_handlers:
        self._event_handlers.remove(handler)


def _publish_event(self, event: DomainEvent) -> None:
    """Publish event to all subscribers.

    Args:
        event: DomainEvent instance
    """
    for handler in self._event_handlers:
        try:
            handler(event)
        except Exception as e:
            # Log error but don't let subscriber exceptions crash the aggregate
            # In production, use proper logging
            print(f"Error in event handler: {e}")


# Modify existing methods to emit events:

def record_action(self, action: ExpansionAction) -> None:
    """Record an expansion action in history.

    Args:
        action: ExpansionAction to record

    Side effects:
        - Appends to expansion_history
        - Trims history if exceeds max_history_size
        - Resets history position to end
        - Emits CellsExpanded or CellsCollapsed event
    """
    # ... existing implementation ...

    # Emit event
    if action.action_type == ActionType.EXPAND:
        event = CellsExpanded(
            timestamp=action.timestamp,
            cells=action.cells_affected,
            nets=action.nets_affected,
            trigger=action.trigger,
            direction=action.direction,
            hops=action.hops,
            source_pin_id=action.source_pin_id
        )
    else:  # COLLAPSE
        event = CellsCollapsed(
            timestamp=action.timestamp,
            cells=action.cells_affected,
            nets=action.nets_affected,
            trigger=action.trigger
        )

    self._publish_event(event)


def undo(self) -> Optional[ExpansionAction]:
    """Undo the last action and return it.

    Returns:
        The action that was undone, or None if nothing to undo

    Side effects:
        - Decrements history position
        - Reverses the action's state changes
        - Emits ExpansionUndone event
    """
    # ... existing implementation ...

    if action is not None:
        event = ExpansionUndone(
            timestamp=datetime.now(),
            action_type=action.action_type,
            cells=action.cells_affected,
            nets=action.nets_affected
        )
        self._publish_event(event)

    return action


def redo(self) -> Optional[ExpansionAction]:
    """Redo the next action and return it.

    Returns:
        The action that was redone, or None if nothing to redo

    Side effects:
        - Increments history position
        - Reapplies the action's state changes
        - Emits ExpansionRedone event
    """
    # ... existing implementation ...

    if action is not None:
        event = ExpansionRedone(
            timestamp=datetime.now(),
            action_type=action.action_type,
            cells=action.cells_affected,
            nets=action.nets_affected
        )
        self._publish_event(event)

    return action


def clear(self) -> None:
    """Clear all state (for new design load).

    Side effects:
        - Emits ExpansionStateCleared event
    """
    # ... existing implementation ...

    event = ExpansionStateCleared(timestamp=datetime.now())
    self._publish_event(event)
```

### 2.3 Usage Example

```python
from ink.domain.model.expansion_state import ExpansionState
from ink.domain.events.expansion_events import CellsExpanded, DomainEvent


# Create state
state = ExpansionState()


# Subscribe to events
def handle_expansion_event(event: DomainEvent):
    if isinstance(event, CellsExpanded):
        print(f"Expanded {len(event.cells)} cells")
        # Update UI, trigger layout, etc.


state.subscribe(handle_expansion_event)


# Perform expansion (triggers event)
state.add_cells({"cell1", "cell2"}, {"net1"})
state.record_action(ExpansionAction(
    action_type=ActionType.EXPAND,
    cells_affected=frozenset({"cell1", "cell2"}),
    nets_affected=frozenset({"net1"}),
    timestamp=datetime.now(),
    trigger="double_click"
))
# Output: "Expanded 2 cells"
```

### 2.4 Testing Requirements

**Unit Tests** (`/home/joohan/dev/project-ink/ink/tests/unit/domain/events/test_expansion_events.py`):

```python
# Test cases:
- test_cells_expanded_event_immutable()
- test_cells_collapsed_event_immutable()
- test_expansion_undone_event_immutable()
- test_expansion_redone_event_immutable()
- test_expansion_state_cleared_event_immutable()
```

**Unit Tests** (`/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state_events.py`):

```python
# Test cases:
- test_subscribe_adds_handler()
- test_unsubscribe_removes_handler()
- test_record_action_emits_cells_expanded()
- test_record_action_emits_cells_collapsed()
- test_undo_emits_expansion_undone()
- test_redo_emits_expansion_redone()
- test_clear_emits_expansion_state_cleared()
- test_multiple_subscribers_receive_event()
- test_subscriber_exception_does_not_crash()
- test_unsubscribe_stops_receiving_events()
- test_event_contains_correct_data()
```

---

## 3. Dependencies

### 3.1 Upstream Dependencies
- E03-F04-T01 (ExpansionState Aggregate Core) - **BLOCKING**
- E03-F04-T02 (Undo/Redo State Navigation) - **BLOCKING**

### 3.2 Downstream Consumers
- Presentation layer (schematic canvas, property panel)
- Application layer (event handlers, view updates)

---

## 4. Acceptance Criteria

- [ ] `DomainEvent` base class defined
- [ ] `CellsExpanded` event defined with all fields
- [ ] `CellsCollapsed` event defined
- [ ] `ExpansionUndone` event defined
- [ ] `ExpansionRedone` event defined
- [ ] `ExpansionStateCleared` event defined
- [ ] All events are immutable (`@dataclass(frozen=True)`)
- [ ] `subscribe()` method adds event handler
- [ ] `unsubscribe()` method removes event handler
- [ ] `record_action()` emits appropriate event
- [ ] `undo()` emits `ExpansionUndone` event
- [ ] `redo()` emits `ExpansionRedone` event
- [ ] `clear()` emits `ExpansionStateCleared` event
- [ ] Multiple subscribers receive events
- [ ] Subscriber exceptions don't crash aggregate
- [ ] Events contain correct data from action
- [ ] All unit tests pass with 100% coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why use observer pattern instead of callbacks?**
- Decouples aggregate from presentation layer
- Multiple subscribers can react to same event
- Events are immutable value objects (safe to pass around)
- Easy to add event logging, debugging, replay

**Why not use a centralized event bus?**
- Simpler for MVP (no additional infrastructure)
- Aggregate owns its events (better encapsulation)
- Easy to add event bus later if needed
- Reduces external dependencies

**Error handling in event handlers**:
- Catch exceptions to prevent subscriber bugs from breaking aggregate
- Log errors (in production, use proper logging framework)
- Don't retry or recover (fire-and-forget semantics)

### 5.2 Alternative Designs Considered

**Event Sourcing**:
- Store all events as source of truth
- Rebuild state by replaying events
- Pros: Complete audit trail, time travel debugging
- Cons: High complexity for MVP, not needed yet

**Async Event Publishing**:
- Use `asyncio` or threading for async handlers
- Pros: Non-blocking, better for I/O-heavy handlers
- Cons: More complex, race conditions, not needed for UI updates

**Typed Event Bus (e.g., PyPubSub)**:
- Use third-party event bus library
- Pros: More features, battle-tested
- Cons: External dependency, overkill for simple use case

### 5.3 Future Enhancements

- Add event filtering (subscribe to specific event types)
- Add event priority/ordering
- Add async event handlers with `asyncio`
- Add event persistence for debugging
- Add event replay for testing

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F04 split |
