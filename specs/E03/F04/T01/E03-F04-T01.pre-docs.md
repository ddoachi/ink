# E03-F04-T01 - ExpansionState Aggregate Core: Pre-Implementation Documentation

## Document Information
- **Task**: E03-F04-T01 - ExpansionState Aggregate Core
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements the foundational `ExpansionState` aggregate - the core domain entity responsible for tracking which cells and nets are currently visible in Ink's schematic view. This is the cornerstone of the incremental exploration feature, providing the single source of truth for expansion state and enabling efficient duplicate detection, state queries, and history management.

### 1.2 Problem Context

In a traditional schematic viewer, all cells are rendered at once. Ink's incremental exploration model requires tracking a subset of visible cells that grows and shrinks as users expand and collapse sections. The system must:

- Maintain O(1) visibility checks for potentially millions of cells
- Prevent duplicate rendering when expanding overlapping regions
- Support atomic state updates to prevent UI inconsistencies
- Track history for undo/redo functionality
- Filter new candidates efficiently to avoid redundant work

Without a well-designed aggregate, expansion logic would be scattered across the application, leading to state inconsistencies, performance issues, and difficult-to-debug edge cases.

### 1.3 Core Capabilities

The `ExpansionState` aggregate provides:

1. **Visible Set Management**: Maintain sets of visible cell and net IDs with O(1) membership testing
2. **Duplicate Filtering**: Efficiently identify which cells/nets are truly new vs. already visible
3. **Action Recording**: Track expansion/collapse history with metadata (timestamp, trigger, direction)
4. **History Management**: Limit history size and support position tracking for undo/redo
5. **State Queries**: Provide visibility checks and statistics (count, last action, etc.)

---

## 2. Implementation Approach

### 2.1 Core Design Pattern

**Aggregate Pattern (DDD)**:
- `ExpansionState` is the aggregate root
- Encapsulates mutable state (visible sets, history)
- All mutations go through controlled methods
- External code cannot directly modify internal sets
- Provides query methods for safe read access

**Why Not Immutable State?**

While immutability is often preferred in functional programming, we chose mutable internal state for performance:

```python
# Immutable approach (rejected):
@dataclass(frozen=True)
class ExpansionState:
    visible_cells: frozenset[str]

    def add_cells(self, cells: Set[str]) -> 'ExpansionState':
        # Creates new ExpansionState with copied sets
        return ExpansionState(visible_cells=self.visible_cells | cells)
```

**Problems with immutable approach**:
- Copying 10,000+ cell IDs on every expansion is expensive
- No performance benefit since state isn't shared across threads
- Aggregate pattern provides encapsulation without immutability tax

**Chosen approach**:
```python
@dataclass
class ExpansionState:
    visible_cells: Set[str]  # Mutable, but encapsulated

    def add_cells(self, cells: Set[str], nets: Set[str]) -> None:
        # In-place update, no copying
        self.visible_cells.update(cells)
```

### 2.2 Data Structure Choices

**Visible Sets - `Set[str]`**:
- **Why sets?**: O(1) membership testing (`cell_id in visible_cells`)
- **Why strings?**: Cell/net IDs are already strings from CDL parser
- **Alternative considered**: `Dict[str, Cell]` to store full objects
  - Rejected: Would duplicate cell data (cells already in graph)
  - State only needs to track IDs, not full entities

**History - `List[ExpansionAction]`**:
- **Why list?**: Ordered sequence needed for undo/redo navigation
- **Why not deque?**: List provides simpler slicing for history truncation
- **Size management**: Circular buffer behavior (trim oldest when exceeds limit)

**Action Records - `ExpansionAction` dataclass**:
- **Immutable**: Uses `frozenset` for affected cells/nets
- **Why immutable?**: History entries should never change after recording
- **Why frozenset?**: Prevents accidental modification, enables set operations if needed

### 2.3 Key Implementation Decisions

**Decision 1: Separate add/remove from record_action**

```python
# Low-level mutations (used internally)
state.add_cells(cells, nets)
state.remove_cells(cells, nets)

# High-level operation (used by application layer)
state.record_action(ExpansionAction(...))
```

**Rationale**:
- `add_cells`/`remove_cells`: Pure state mutations, no history tracking
- `record_action`: Records action metadata for undo/redo
- Separation allows undo/redo to mutate state without creating new history entries
- Application layer always uses `record_action` to ensure history consistency

**Decision 2: History position tracking**

```python
_history_position: int  # Points to "next action to undo"
```

**Position semantics**:
- `position = 0`: At beginning, nothing to undo
- `position = len(history)`: At end, nothing to redo
- Undo decrements position, redo increments position

**Why this design?**:
- Standard undo/redo pattern used by text editors
- Simple integer arithmetic for navigation
- Easy to visualize: position is "cursor" in history timeline

**Decision 3: Validation in `__post_init__`**

```python
def __post_init__(self):
    if self.action_type == ActionType.EXPAND and not self.cells_affected:
        raise ValueError("Expand action must affect at least one cell")
```

**Rationale**:
- Fail fast at construction time
- Prevents invalid actions from being recorded
- Makes debugging easier (exception at source, not later usage)

---

## 3. Key Design Decisions

### 3.1 Thread Safety

**Decision**: NOT thread-safe for MVP

**Rationale**:
- PySide6 UI runs on single main thread
- Expansion logic executes on main thread (synchronous for MVP)
- No concurrent access to `ExpansionState` expected
- Adding locks would add overhead without benefit

**Future Considerations**:
If async expansion is needed (P1 feature):
```python
import threading

class ThreadSafeExpansionState:
    def __init__(self):
        self._state = ExpansionState()
        self._lock = threading.Lock()

    def add_cells(self, cells, nets):
        with self._lock:
            self._state.add_cells(cells, nets)
```

### 3.2 History Size Limits

**Decision**: Default max_history_size = 100

**Rationale**:
- 100 actions covers typical exploration session
- Memory overhead: ~100 KB (1000 cells/action * 100 actions * 8 bytes/ID)
- Users rarely undo >10 actions, so 100 provides ample buffer
- Configurable via constructor for power users

**Alternative considered**: Unlimited history
- Rejected: Risk of memory exhaustion in long sessions
- Rejected: No clear use case for >100 undos

**History Trimming Strategy**:
```python
# When history exceeds limit, remove oldest entries
if len(self.expansion_history) > self.max_history_size:
    self.expansion_history = self.expansion_history[-self.max_history_size:]
```

### 3.3 Duplicate Detection Strategy

**Decision**: Set difference operations

```python
def get_new_cells(self, candidates: Set[str]) -> Set[str]:
    return candidates - self.visible_cells
```

**Performance Analysis**:
- Set difference is O(n) where n = len(candidates)
- In practice, candidates is typically 10-100 cells (1-hop expansion)
- Even for 1000 candidates, set difference is <1ms
- No need for more complex data structures (bloom filters, etc.)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Python Standard Library**:
- `dataclasses`: For `@dataclass` decorator
- `datetime`: For action timestamps
- `enum`: For `ActionType` and `ExpansionDirection` enums
- `typing`: For type hints (`Set`, `List`, `Optional`, `FrozenSet`)

**No external dependencies**: This is a pure domain model, which aligns with DDD principles.

### 4.2 Downstream Consumers

**E03-F04-T02 (Undo/Redo State Navigation)**:
- Extends `ExpansionState` with `undo()` and `redo()` methods
- Uses `_history_position` for navigation
- Depends on `record_action()` history management

**E03-F04-T03 (Expansion State Events)**:
- Adds event publishing to state mutations
- Hooks into `record_action()`, `add_cells()`, `remove_cells()`
- UI subscribes to events for reactive updates

**E03-F01 (Hop-Based Expansion)**:
- Uses `get_new_cells()` to filter traversal results
- Uses `add_cells()` to update visible set
- Uses `record_action()` to track expansion

**E03-F02 (Collapse Functionality)**:
- Uses `is_cell_visible()` to check collapse candidates
- Uses `remove_cells()` to hide cells
- Uses `record_action()` to track collapse

**Application Layer (services/expansion_service.py)**:
- Orchestrates expansion by calling graph traversal + state updates
- Manages `ExpansionState` lifecycle
- Bridges domain and presentation layers

---

## 5. Testing Strategy

### 5.1 Unit Testing Philosophy

**Pure Domain Testing**:
- No mocks needed (pure functions, no external dependencies)
- Test state transitions directly
- Verify invariants after each operation
- Use property-based testing for exhaustive coverage

### 5.2 Critical Test Cases

**State Mutation Tests**:
```python
def test_add_cells_updates_visible_set():
    state = ExpansionState()
    state.add_cells({"A", "B"}, {"net1"})

    assert "A" in state.visible_cells
    assert "B" in state.visible_cells
    assert "net1" in state.visible_nets

def test_add_cells_idempotent():
    state = ExpansionState()
    state.add_cells({"A"}, {"net1"})
    state.add_cells({"A"}, {"net1"})  # Add again

    assert state.get_visible_cell_count() == 1  # Still only 1
```

**Duplicate Filtering Tests**:
```python
def test_get_new_cells_filters_existing():
    state = ExpansionState()
    state.add_cells({"A", "B"}, set())

    candidates = {"B", "C", "D"}
    new_cells = state.get_new_cells(candidates)

    assert new_cells == {"C", "D"}  # B filtered out
```

**History Management Tests**:
```python
def test_history_trimming_when_exceeds_max():
    state = ExpansionState(max_history_size=3)

    for i in range(5):
        action = create_test_action(f"cell_{i}")
        state.record_action(action)

    assert len(state.expansion_history) == 3
    # Oldest 2 actions trimmed, newest 3 retained
    assert state.expansion_history[0].cells_affected == frozenset({"cell_2"})
```

**Validation Tests**:
```python
def test_expansion_action_validates_empty_cells():
    with pytest.raises(ValueError, match="at least one cell"):
        ExpansionAction(
            action_type=ActionType.EXPAND,
            cells_affected=frozenset(),  # Empty!
            nets_affected=frozenset({"net1"}),
            timestamp=datetime.now(),
            trigger="test"
        )

def test_expansion_action_validates_invalid_hops():
    with pytest.raises(ValueError, match="Hops must be >= 1"):
        ExpansionAction(
            action_type=ActionType.EXPAND,
            cells_affected=frozenset({"A"}),
            nets_affected=frozenset(),
            timestamp=datetime.now(),
            trigger="test",
            hops=0  # Invalid!
        )
```

### 5.3 Invariant Testing

**State Invariants to Verify**:
```python
def verify_state_invariants(state: ExpansionState):
    # Position bounds
    assert 0 <= state._history_position <= len(state.expansion_history)

    # History size limit
    assert len(state.expansion_history) <= state.max_history_size

    # No None values in sets
    assert None not in state.visible_cells
    assert None not in state.visible_nets
```

### 5.4 Property-Based Testing

**Using Hypothesis** (optional but recommended):
```python
from hypothesis import given, strategies as st

@given(
    cells=st.sets(st.text(min_size=1, max_size=10), max_size=100),
    nets=st.sets(st.text(min_size=1, max_size=10), max_size=100)
)
def test_add_cells_commutative(cells, nets):
    """Adding same cells in different order produces same state"""
    state1 = ExpansionState()
    state1.add_cells(cells, nets)

    state2 = ExpansionState()
    # Add in different order (split into two calls)
    half = len(cells) // 2
    cells_list = list(cells)
    state2.add_cells(set(cells_list[:half]), set())
    state2.add_cells(set(cells_list[half:]), nets)

    assert state1.visible_cells == state2.visible_cells
```

---

## 6. Risks and Mitigations

### 6.1 Risk: State Inconsistency

**Scenario**: `visible_cells` and `visible_nets` become desynchronized

**Example**:
```python
# Bad: Cells added but nets forgotten
state.add_cells({"A"}, set())  # Oops, nets should include "net1"
```

**Impact**: Medium - Nets won't render, users see disconnected cells

**Probability**: Low - Clear API contracts, good testing

**Mitigation**:
- Application layer responsible for computing both cells and nets
- Unit tests verify cells and nets updated together
- Add validation method (future):
  ```python
  def validate_consistency(self, graph: NetlistGraph):
      # Verify all visible cells' pins have visible nets
      for cell_id in self.visible_cells:
          cell = graph.get_cell(cell_id)
          for pin in cell.pins:
              if pin.net_id and pin.net_id not in self.visible_nets:
                  raise StateInconsistencyError(...)
  ```

### 6.2 Risk: Memory Leaks in History

**Scenario**: History grows unbounded despite max_history_size

**Example**:
```python
# Bug: History not trimmed after record_action
if len(self.expansion_history) > self.max_history_size:
    # Forgot to actually trim!
    pass  # BUG: Should assign trimmed list
```

**Impact**: Low - Gradual memory growth over long sessions

**Probability**: Low - Straightforward implementation

**Mitigation**:
- Unit test explicitly verifies trimming behavior
- Memory profiling during integration testing
- Monitoring: Log warning if history exceeds limit unexpectedly

### 6.3 Risk: Invalid Action Records

**Scenario**: Application layer creates malformed `ExpansionAction`

**Example**:
```python
# Bug: Collapse action with empty cells_affected
action = ExpansionAction(
    action_type=ActionType.COLLAPSE,
    cells_affected=frozenset(),  # Empty collapse?
    ...
)
```

**Impact**: Medium - Confusing undo/redo behavior, incorrect history

**Probability**: Low - Validation in `__post_init__` catches this

**Mitigation**:
- Comprehensive validation in `ExpansionAction.__post_init__`
- Unit tests for all invalid construction cases
- Type system prevents many errors (frozenset vs set)

### 6.4 Risk: Performance Degradation with Large Sets

**Scenario**: Visible set grows to 100,000+ cells

**Example**:
```python
# Worst case: User expands entire netlist incrementally
for pin in all_pins:
    new_cells = traverser.get_fanout(pin, hops=1)
    state.add_cells(new_cells, ...)  # Eventually 100K+ cells
```

**Impact**: Low - Set operations remain O(1) and O(n), no significant slowdown

**Probability**: Low - Users typically keep visible sets small (100-1000 cells)

**Mitigation**:
- Benchmark with 100K+ cells to verify performance
- If needed, add warning when visible_cells exceeds threshold
- Set operations in CPython are highly optimized, should handle 100K+ fine

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should `ExpansionAction` include layout information (cell positions)?

**Current Answer**: No, layout is presentation layer concern.

**Reasoning**:
- `ExpansionState` is domain model (layer 3)
- Layout belongs in presentation layer (layer 1)
- Including positions would violate DDD layering
- Undo/redo only restores visibility, not positions (acceptable trade-off)

**Alternative**: Store layout snapshots for each action
- Pros: Perfect undo (restores positions)
- Cons: High memory cost, couples domain to presentation
- Decision: Defer until user feedback indicates need

---

**Q2**: Should history track individual cell adds or batch operations?

**Current Answer**: Batch operations only.

**Reasoning**:
- Each `record_action` represents user intent (e.g., "expand fanout from pin X")
- Granular per-cell tracking would create 100s of history entries for single expansion
- Users think in terms of operations, not individual cells

**Example**:
```python
# One action for entire expansion
state.record_action(ExpansionAction(
    action_type=ActionType.EXPAND,
    cells_affected=frozenset({"A", "B", "C", ...}),  # All cells in batch
    ...
))
```

---

**Q3**: What happens if `max_history_size` is changed after actions recorded?

**Current Answer**: Undefined behavior for MVP.

**Options**:
1. Trim history immediately to new limit
2. Only apply limit to new actions
3. Prevent changing max_history_size after initialization

**Decision for MVP**: Option 3 (prevent changes)
- `max_history_size` is init-only parameter
- If user wants different limit, create new `ExpansionState` instance
- Simpler implementation, clearer semantics

---

### 7.2 UX Questions

**Q1**: Should history persist across sessions?

**Current Answer**: P1 feature (session save/load).

**MVP Behavior**: History cleared on application close.

**Future Enhancement**:
```python
def to_snapshot(self) -> dict:
    return {
        "visible_cells": list(self.visible_cells),
        "visible_nets": list(self.visible_nets),
        "history": [action.to_dict() for action in self.expansion_history]
    }
```

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `ExpansionState` class defined in `/home/joohan/dev/project-ink/ink/src/ink/domain/model/expansion_state.py`
- [ ] `ExpansionAction` dataclass with validation
- [ ] `ActionType` and `ExpansionDirection` enums defined
- [ ] `add_cells()` updates visible sets correctly
- [ ] `remove_cells()` updates visible sets correctly
- [ ] `is_cell_visible()` returns correct boolean
- [ ] `is_net_visible()` returns correct boolean
- [ ] `get_new_cells()` filters duplicates correctly
- [ ] `get_new_nets()` filters duplicates correctly
- [ ] `record_action()` appends to history
- [ ] History trimmed when exceeds `max_history_size`
- [ ] `can_undo()` and `can_redo()` return correct state
- [ ] `get_last_action()` returns most recent action
- [ ] `clear()` resets all state
- [ ] All methods have type hints
- [ ] All methods have docstrings

### 8.2 Quality Checklist

- [ ] Unit tests in `/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state.py`
- [ ] Test coverage >= 100% for `expansion_state.py`
- [ ] All edge cases tested (empty sets, max history, validation)
- [ ] Property-based tests for commutative operations (optional but recommended)
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Code review completed

### 8.3 Integration Checklist

- [ ] Module imports successfully in other layers
- [ ] Ready for T02 (Undo/Redo) implementation
- [ ] Ready for T03 (Events) implementation
- [ ] Can be instantiated and used by application layer

---

## 9. Next Steps

After T01 completion:

1. **T02 (Undo/Redo State Navigation)**:
   - Extend `ExpansionState` with `undo()` and `redo()` methods
   - Implement inverse operations (expand → collapse, collapse → expand)
   - Test history navigation

2. **T03 (Expansion State Events)**:
   - Add event publishing to state mutations
   - Define domain events (`CellsExpanded`, `CellsCollapsed`, etc.)
   - Enable UI reactive updates

3. **Integration with E03-F01**:
   - Use `ExpansionState` in expansion service
   - Connect to graph traversal logic
   - Wire up to UI double-click handlers

---

## 10. References

- **Task Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/T01/E03-F04-T01.spec.md`
- **Feature Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F04/E03-F04.spec.md`
- **Epic Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/E03.spec.md`
- **Architecture**: `/home/joohan/dev/project-ink/ink/docs/architecture/ddd-architecture.md`
- **Domain Models**: `/home/joohan/dev/project-ink/ink/CLAUDE.md` (§ Key Domain Concepts)

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
