# Spec: E03-F04-T01 - ExpansionState Aggregate Core

## Metadata
- **ID**: E03-F04-T01
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E03-F04](../E03-F04.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Small
- **Tags**: [domain, aggregate, state-management]

---

## 1. Overview

### 1.1 Problem Statement

The `ExpansionState` aggregate is the root entity responsible for tracking which cells and nets are currently visible in the schematic view. It must provide efficient membership testing, prevent duplicate expansions, and support atomic state updates while maintaining consistency between visible cells and nets.

### 1.2 Goals

- Implement `ExpansionState` aggregate with visible cells/nets tracking
- Implement `ExpansionAction` value object for history entries
- Provide efficient O(1) visibility checks
- Support atomic state mutations
- Enable filtering of new vs. already-visible cells

---

## 2. Technical Requirements

### 2.1 ExpansionState Domain Model

**Location**: `/home/joohan/dev/project-ink/ink/src/ink/domain/model/expansion_state.py`

```python
from dataclasses import dataclass, field
from typing import Set, List, Optional
from datetime import datetime
from enum import Enum


class ActionType(Enum):
    """Type of expansion action"""
    EXPAND = "expand"
    COLLAPSE = "collapse"


class ExpansionDirection(Enum):
    """Direction of expansion"""
    FANIN = "fanin"
    FANOUT = "fanout"
    BIDIRECTIONAL = "bidirectional"


@dataclass
class ExpansionAction:
    """Value object representing a single expansion or collapse action.

    Immutable record of state change for history tracking and undo/redo.
    """

    action_type: ActionType
    cells_affected: frozenset[str]  # Immutable set of cell IDs
    nets_affected: frozenset[str]   # Immutable set of net IDs
    timestamp: datetime
    trigger: str  # e.g., "double_click_pin", "keyboard_expand", "api_call"
    direction: Optional[ExpansionDirection] = None
    hops: Optional[int] = None
    source_pin_id: Optional[str] = None  # Which pin triggered expansion

    def __post_init__(self):
        """Validate action data"""
        if self.action_type == ActionType.EXPAND and not self.cells_affected:
            raise ValueError("Expand action must affect at least one cell")
        if self.hops is not None and self.hops < 1:
            raise ValueError("Hops must be >= 1")


@dataclass
class ExpansionState:
    """Aggregate root managing the current expansion state.

    Tracks which cells and nets are visible in the schematic view and
    maintains history of expansion/collapse actions for undo/redo.

    Thread-safety: This implementation is NOT thread-safe. Wrap with
    locks if concurrent access is needed.
    """

    # State
    visible_cells: Set[str] = field(default_factory=set)
    visible_nets: Set[str] = field(default_factory=set)
    expansion_history: List[ExpansionAction] = field(default_factory=list)
    max_history_size: int = 100

    # History navigation (for undo/redo)
    _history_position: int = field(default=0, init=False, repr=False)

    def add_cells(self, cells: Set[str], nets: Set[str]) -> None:
        """Add cells and nets to visible sets.

        Args:
            cells: Set of cell IDs to add
            nets: Set of net IDs to add

        Note: This is a low-level mutation. Use record_action() for
        history tracking.
        """
        self.visible_cells.update(cells)
        self.visible_nets.update(nets)

    def remove_cells(self, cells: Set[str], nets: Set[str]) -> None:
        """Remove cells and nets from visible sets.

        Args:
            cells: Set of cell IDs to remove
            nets: Set of net IDs to remove

        Note: This is a low-level mutation. Use record_action() for
        history tracking.
        """
        self.visible_cells.difference_update(cells)
        self.visible_nets.difference_update(nets)

    def is_cell_visible(self, cell_id: str) -> bool:
        """Check if a cell is currently visible.

        Args:
            cell_id: Cell identifier

        Returns:
            True if cell is in visible set
        """
        return cell_id in self.visible_cells

    def is_net_visible(self, net_id: str) -> bool:
        """Check if a net is currently visible.

        Args:
            net_id: Net identifier

        Returns:
            True if net is in visible set
        """
        return net_id in self.visible_nets

    def get_new_cells(self, candidates: Set[str]) -> Set[str]:
        """Filter candidates to only cells not currently visible.

        Args:
            candidates: Set of candidate cell IDs

        Returns:
            Set of cell IDs not in visible_cells
        """
        return candidates - self.visible_cells

    def get_new_nets(self, candidates: Set[str]) -> Set[str]:
        """Filter candidates to only nets not currently visible.

        Args:
            candidates: Set of candidate net IDs

        Returns:
            Set of net IDs not in visible_nets
        """
        return candidates - self.visible_nets

    def record_action(self, action: ExpansionAction) -> None:
        """Record an expansion action in history.

        Args:
            action: ExpansionAction to record

        Side effects:
            - Appends to expansion_history
            - Trims history if exceeds max_history_size
            - Resets history position to end
        """
        # Trim future history if we're in the middle of undo/redo
        if self._history_position < len(self.expansion_history):
            self.expansion_history = self.expansion_history[:self._history_position]

        # Add new action
        self.expansion_history.append(action)

        # Trim old history if exceeds limit
        if len(self.expansion_history) > self.max_history_size:
            self.expansion_history = self.expansion_history[-self.max_history_size:]

        # Reset position to end
        self._history_position = len(self.expansion_history)

    def can_undo(self) -> bool:
        """Check if undo is available.

        Returns:
            True if there are actions to undo
        """
        return self._history_position > 0

    def can_redo(self) -> bool:
        """Check if redo is available.

        Returns:
            True if there are actions to redo
        """
        return self._history_position < len(self.expansion_history)

    def get_last_action(self) -> Optional[ExpansionAction]:
        """Get the most recent action.

        Returns:
            Last ExpansionAction or None if history is empty
        """
        if not self.expansion_history:
            return None
        return self.expansion_history[-1]

    def clear(self) -> None:
        """Clear all state (for new design load)."""
        self.visible_cells.clear()
        self.visible_nets.clear()
        self.expansion_history.clear()
        self._history_position = 0

    def get_visible_cell_count(self) -> int:
        """Get count of visible cells."""
        return len(self.visible_cells)

    def get_visible_net_count(self) -> int:
        """Get count of visible nets."""
        return len(self.visible_nets)
```

### 2.2 Implementation Requirements

1. **Data Structures**:
   - Use `Set[str]` for O(1) membership testing
   - Use `frozenset` for immutable action records
   - Use `List[ExpansionAction]` for ordered history

2. **Validation**:
   - Validate `ExpansionAction` in `__post_init__`
   - Ensure expand actions have at least one affected cell
   - Ensure hops >= 1 if specified

3. **History Management**:
   - Limit history to `max_history_size` (default 100)
   - Trim oldest entries when limit exceeded
   - Support undo/redo position tracking

4. **Atomicity**:
   - State mutations should be atomic (all or nothing)
   - No partial updates visible to callers
   - Consider making ExpansionState methods transactional

### 2.3 Testing Requirements

**Unit Tests** (`/home/joohan/dev/project-ink/ink/tests/unit/domain/model/test_expansion_state.py`):

```python
# Test cases:
- test_add_cells_updates_visible_set()
- test_remove_cells_updates_visible_set()
- test_is_cell_visible_returns_correct_state()
- test_get_new_cells_filters_correctly()
- test_record_action_appends_to_history()
- test_history_trimming_when_exceeds_max()
- test_can_undo_returns_true_when_history_exists()
- test_can_redo_returns_false_initially()
- test_get_last_action_returns_most_recent()
- test_clear_resets_all_state()
- test_expansion_action_validation()
- test_immutable_action_frozensets()
```

---

## 3. Dependencies

### 3.1 Upstream Dependencies
- Python 3.10+ standard library (`dataclasses`, `datetime`, `enum`)
- No external dependencies (pure domain model)

### 3.2 Downstream Consumers
- E03-F04-T02 (State Persistence)
- E03-F04-T03 (State Events)
- E03-F01 (Hop-Based Expansion)
- E03-F02 (Collapse Functionality)

---

## 4. Acceptance Criteria

- [ ] `ExpansionState` class implemented at `/home/joohan/dev/project-ink/ink/src/ink/domain/model/expansion_state.py`
- [ ] `ExpansionAction` dataclass defined with all required fields
- [ ] `ActionType` and `ExpansionDirection` enums defined
- [ ] `add_cells()` and `remove_cells()` methods update visible sets
- [ ] `is_cell_visible()` and `is_net_visible()` return correct boolean
- [ ] `get_new_cells()` and `get_new_nets()` filter correctly
- [ ] `record_action()` appends to history and trims old entries
- [ ] History limited to `max_history_size` (default 100)
- [ ] `can_undo()` and `can_redo()` return correct state
- [ ] `get_last_action()` returns most recent action
- [ ] `clear()` resets all state
- [ ] `ExpansionAction` validates data in `__post_init__`
- [ ] All unit tests pass with 100% coverage
- [ ] Type hints on all methods
- [ ] Docstrings on all public methods

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why mutable sets?**
- `ExpansionState` is an aggregate root that encapsulates mutation
- Internal sets are mutable for performance (avoid copying)
- External API controls all mutations through methods
- `ExpansionAction` uses `frozenset` for immutability

**Why not use immutable state?**
- Immutable state requires copying on every mutation
- For large visible sets (1000+ cells), this is expensive
- Aggregate pattern provides encapsulation without immutability cost
- Future: Consider copy-on-write for thread safety

**Thread Safety**:
- Current implementation is NOT thread-safe
- If concurrent access needed, wrap with `threading.Lock`
- Alternative: Use immutable state with structural sharing

### 5.2 Future Enhancements

- Add `snapshot()` method for state persistence
- Add `restore_from_snapshot()` for state loading
- Consider weak references for memory efficiency
- Add state validation invariants
- Add metrics/telemetry hooks

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F04 split |
