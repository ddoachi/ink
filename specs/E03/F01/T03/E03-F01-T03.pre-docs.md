# Pre-Implementation Documentation: E03-F01-T03 - Duplicate Prevention

## Overview

### Problem Context

As users explore the schematic by expanding from different points, cells that are already visible may be included in new expansion results. Without duplicate prevention, the same cell would be rendered multiple times at different positions, creating visual clutter, user confusion, and wasted computational resources. The system needs a reliable mechanism to track which cells are currently visible and filter expansion results accordingly.

### Scope

This task implements visibility tracking and duplicate filtering:
1. `ExpansionState` aggregate to maintain visible cell state
2. Efficient visibility lookup (O(1) complexity using sets)
3. Filtering logic in `ExpansionService` to exclude already-visible cells
4. State update operations for expansion and collapse
5. Support for visibility queries and state persistence

### Success Criteria

- Expansion never creates duplicate cells in the schematic
- Visibility checks complete in O(1) time
- State accurately tracks all visible cells
- Sequential expansions from different points work correctly
- Collapse operations properly update state
- 90%+ test coverage with comprehensive edge case handling

## Implementation Approach

### High-Level Strategy

1. **Create Domain Aggregate**: Implement `ExpansionState` as aggregate root managing visible cell IDs
2. **Set-Based Storage**: Use `Set[CellId]` for O(1) membership testing
3. **Filter in Service**: Modify `ExpansionService.expand_*()` methods to filter results before rendering
4. **State Updates**: Add visible cells after successful expansion, remove on collapse
5. **Persistence Support**: Add serialization methods for session save/load

### Architecture Pattern

**Domain-Driven Design:**

```
ExpansionState (Aggregate Root)
    ├─ visible_cells: Set[CellId]
    └─ Methods: is_visible(), add_visible_cells(), remove_visible_cells()
```

**Integration in Application Layer:**

```
ExpansionService
    ├─ _traverser: GraphTraverser
    ├─ _state: ExpansionState
    └─ expand_fanout():
        1. Get cells from traverser
        2. Filter using _state.is_visible()
        3. Update _state with new cells
        4. Trigger rendering
```

### Data Structure Design

**Why Set[CellId] instead of Set[Cell]?**

Advantages:
- Lightweight (store IDs, not full entities)
- Fast equality comparison (ID comparison vs entity comparison)
- Serializable (easy to save/load sessions)
- Immutable references (cell entities may change, IDs don't)

**Implementation:**

```python
@dataclass
class ExpansionState:
    visible_cells: Set[CellId] = field(default_factory=set)
```

## Key Design Decisions

### Decision 1: Aggregate Placement

**Chosen:** `ExpansionState` in domain layer

**Rationale:**
- Encapsulates business rule: "no duplicate visible cells"
- Core domain concept (not infrastructure concern)
- Allows future expansion of state (undo history, expansion metadata)
- Clear ownership and lifecycle

**Alternative Considered:** Track visibility in `ExpansionService`. Rejected due to lack of domain encapsulation.

### Decision 2: Filtering Location

**Chosen:** Filter in `ExpansionService` before rendering

**Options Evaluated:**
1. Filter in presentation layer (canvas)
2. Filter in application layer (service)
3. Filter in domain service (traverser)

**Rationale for Option 2:**
- Application layer owns workflow orchestration
- Keeps traverser pure (doesn't know about visibility)
- Presentation layer only handles rendering (no business logic)
- Allows service to return filtered results for undo/redo

### Decision 3: Granularity (Cell vs Pin/Net)

**Chosen:** Track visibility at cell level only

**Rationale:**
- Pins and nets are rendered as part of cells
- Cell is the unit of expansion/collapse
- Simpler state management
- Sufficient for MVP requirements

**Future Enhancement:** May need to track visible nets separately for net-only expansion.

### Decision 4: Idempotency

**Chosen:** `add_visible_cells()` and `remove_visible_cells()` are idempotent

**Implementation:**
- `add_visible_cells()`: Use set union (duplicates automatically handled)
- `remove_visible_cells()`: Use set difference (non-existent IDs safely ignored)

**Rationale:**
- Safer API (multiple calls don't cause errors)
- Handles edge cases gracefully
- Matches set semantics

### Decision 5: State Initialization

**Problem:** How to populate initial visible cells?

**Chosen:** Explicit initialization method `set_initial_visible_cells()`

**Use Cases:**
1. User selects initial cells to explore
2. Load from saved session
3. Auto-expand from top-level ports

**Alternative Considered:** Auto-populate on first expansion. Rejected as too implicit.

### Decision 6: Thread Safety

**Chosen:** No thread safety initially

**Rationale:**
- All UI operations happen on main thread (Qt requirement)
- Expansion is synchronous for MVP
- Adds complexity without clear benefit

**Future Enhancement:** Add `threading.Lock` if background expansion is needed (P1).

## Dependencies and Integration Points

### Upstream Dependencies

1. **Domain Model (CellId)** - CRITICAL
   - Need stable `CellId` type definition
   - Likely `str` or `UUID`
   - Must be hashable for set membership

2. **E03-F01-T01 (Graph Traverser)** - SEQUENTIAL
   - Traverser returns `Set[Cell]`
   - Service extracts IDs for filtering

### Downstream Dependencies

1. **E03-F01-T02 (Expansion Trigger Handling)** - INTEGRATION
   - `ExpansionService` created in T02 will be modified here
   - Need to inject `ExpansionState` into service

2. **E03-F01-T04 (Expansion Animation)** - SEQUENTIAL
   - Receives filtered cell set (only new cells)
   - No direct dependency, but affects input size

3. **E03-F02 (Collapse)** - FUTURE CONSUMER
   - Will call `remove_visible_cells()` to hide cells
   - Need to design API with collapse in mind

4. **E04 (Undo/Redo)** - FUTURE CONSUMER
   - Must save/restore `ExpansionState` snapshots
   - Need serialization methods

### Integration Challenges

**Challenge 1: Service Constructor Changes**
- Risk: T02 may already implement `ExpansionService` without `ExpansionState`
- Mitigation: Coordinate implementation order, or refactor T02 after T03

**Challenge 2: CellId Extraction**
- Risk: Cell entity may not expose ID directly
- Mitigation: Verify domain model, add accessor if needed

**Challenge 3: State Lifecycle**
- Risk: Unclear when to create/destroy `ExpansionState`
- Mitigation: Create at application startup, persist through session, destroy on exit

## Testing Strategy

### Unit Tests (Domain Layer)

**Test File:** `tests/unit/domain/model/test_expansion_state.py`

**Test Categories:**

1. **Basic Operations**
   - `is_visible()` returns False for new ID
   - `is_visible()` returns True after `add_visible_cells()`
   - `add_visible_cells()` updates set correctly
   - `remove_visible_cells()` removes IDs
   - `clear()` removes all IDs
   - `get_visible_count()` returns correct count

2. **Edge Cases**
   - `add_visible_cells()` with empty set (no-op)
   - `add_visible_cells()` with duplicate IDs (idempotent)
   - `remove_visible_cells()` with non-existent IDs (safe)
   - `is_visible()` with None (should handle gracefully or raise)

3. **Performance**
   - `is_visible()` on large set (100K IDs) completes in <1ms
   - `add_visible_cells()` with 1000 IDs completes quickly

**Test Data:**
- Use simple string IDs: "cell_001", "cell_002", etc.
- Generate large sets for performance tests

### Unit Tests (Application Layer)

**Test File:** `tests/unit/application/services/test_expansion_service_filtering.py`

**Test Categories:**

1. **Filtering Logic**
   - `expand_fanout()` filters out already-visible cells
   - `expand_fanout()` returns empty set if all cells visible
   - `expand_fanout()` updates state with new cells
   - `expand_fanin()` filters correctly
   - `_filter_new_cells()` returns only non-visible cells

2. **Sequential Expansions**
   - Expand A → B, then expand A again (B not duplicated)
   - Expand A → B, then expand C → B (B not duplicated)
   - Expand 2 hops, then expand 1 hop from intermediate (no duplicates)

**Mocking Strategy:**
- Mock `GraphTraverser` to return known cell sets
- Use real `ExpansionState` (simple object, no external dependencies)
- Create simple test cells with known IDs

### Integration Tests

**Test File:** `tests/integration/application/test_expansion_duplicate_prevention.py`

**Test Scenarios:**

1. **Linear Chain Expansion:**
   - Design: A → B → C → D
   - Expand from A (fanout 1-hop): see B
   - Expand from A again: no change
   - Expand from B: see C, B not duplicated

2. **Convergent Expansion:**
   - Design: A → C, B → C
   - Expand from A: see C
   - Expand from B: C not duplicated

3. **Deep Multi-Hop:**
   - Expand 2-hop from A: see {B, C}
   - Expand 1-hop from B: see {C}, C not duplicated

4. **Collapse and Re-Expand:**
   - Expand A → B
   - Collapse B
   - Expand A → B again: B appears

**Test Data:** Use synthetic designs with known topology.

## Risks and Considerations

### Technical Risks

**Risk 1: Memory Growth**
- Likelihood: Medium (large designs with many expansions)
- Impact: Medium (memory usage)
- Mitigation: Set is memory-efficient, IDs are small
- Contingency: Add max visible cell limit, warn user

**Risk 2: State Synchronization**
- Likelihood: Medium (state may become stale)
- Impact: High (duplicate cells appear)
- Mitigation: Strict update discipline, test coverage
- Contingency: Add state validation/repair methods

**Risk 3: CellId Uniqueness**
- Likelihood: Low
- Impact: Critical (collisions cause wrong filtering)
- Mitigation: Verify domain model ensures unique IDs
- Contingency: Use composite keys if needed

### Architectural Risks

**Risk 1: Single Responsibility**
- Likelihood: Low
- Impact: Low
- Mitigation: `ExpansionState` has clear single responsibility
- Contingency: N/A

**Risk 2: State Leakage**
- Likelihood: Low
- Impact: Medium (direct manipulation breaks invariants)
- Mitigation: Encapsulate `visible_cells` (no direct access)
- Contingency: Add validation in methods

### Implementation Risks

**Risk 1: Incorrect Filtering**
- Likelihood: Low
- Impact: High (duplicates or missing cells)
- Mitigation: Comprehensive test coverage
- Contingency: Fix based on test failures

**Risk 2: Performance Degradation**
- Likelihood: Low (sets are fast)
- Impact: Medium
- Mitigation: Benchmark with large sets
- Contingency: Optimize or use alternative data structure

## Open Questions

### Design Questions

1. **Initial State:** Should `visible_cells` start with top-level ports or empty?
   - **Decision needed by:** Before implementation
   - **Fallback:** Start empty, require explicit initialization

2. **Persistence Format:** How to serialize `ExpansionState` for session save?
   - **Decision needed by:** Before implementing persistence (may defer to later)
   - **Fallback:** JSON with list of cell IDs

3. **State Validation:** Should we validate state integrity (e.g., all visible cells exist in design)?
   - **Decision needed by:** After MVP if needed
   - **Fallback:** Assume state is correct, add validation if bugs appear

### Technical Questions

1. **CellId Type:** Is `CellId` a string, UUID, or custom type?
   - **Resolution:** Check domain model value objects

2. **Entity ID Access:** Does `Cell` entity expose `id` property directly?
   - **Resolution:** Verify domain model implementation

## Implementation Sequence

### Phase 1: Domain Aggregate (1 hour)
1. Create `ExpansionState` class in `src/ink/domain/model/expansion_state.py`
2. Implement `visible_cells` field as `Set[CellId]`
3. Add methods: `is_visible()`, `add_visible_cells()`, `remove_visible_cells()`, `clear()`, `get_visible_count()`
4. Add type hints and docstrings

### Phase 2: Service Integration (1 hour)
1. Modify `ExpansionService` to accept `ExpansionState` in constructor
2. Implement `_filter_new_cells()` helper method
3. Update `expand_fanout()` to filter and update state
4. Update `expand_fanin()` similarly
5. Add `set_initial_visible_cells()` method

### Phase 3: Collapse Support (30 min)
1. Add `collapse_cells()` method to service
2. Call `_state.remove_visible_cells()`

### Phase 4: Testing (2 hours)
1. Write unit tests for `ExpansionState`
2. Write unit tests for filtering logic in `ExpansionService`
3. Write integration tests for duplicate scenarios
4. Add performance benchmarks

### Phase 5: Persistence (30 min, optional)
1. Add `to_dict()` and `from_dict()` to `ExpansionState`
2. Test serialization round-trip

**Total Estimate:** 4 hours (with buffer)

## Success Metrics

### Functional Metrics
- All unit tests pass (target: 15+ tests, 90%+ coverage)
- All integration tests pass (target: 4+ scenarios)
- Zero duplicate cells in manual testing

### Performance Metrics
- `is_visible()` completes in <1ms for 100K visible cells
- Filtering 1000 cells completes in <10ms
- Memory usage scales linearly with visible cell count

### Quality Metrics
- mypy type checking passes
- All docstrings complete
- Code review approved

## Notes and Assumptions

### Assumptions
1. `CellId` type is hashable (required for set membership)
2. Cell IDs are unique within a design
3. Expansion and collapse happen on UI thread (no concurrency)
4. `ExpansionState` lifecycle managed by application layer

### Out of Scope
- Pin/net visibility tracking (cell-level only)
- Hierarchical visibility (parent/child cell relationships)
- Partial visibility (cell visible but some pins hidden)
- Background expansion (thread safety)

### Documentation Requirements
- Docstrings for all public methods
- State lifecycle documentation
- Integration guide for service layer
- Serialization format specification (if persistence added)

### Coordination Needed
- Sync with domain model team on `CellId` type
- Sync with T02 on `ExpansionService` constructor
- Sync with E03-F02 on collapse requirements
- Sync with E04 on undo/redo state management
