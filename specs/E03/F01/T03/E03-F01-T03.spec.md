# Spec: E03-F01-T03 - Duplicate Prevention

## Metadata
- **ID**: E03-F01-T03
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E03-F01](../E03-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Low
- **Tags**: [application, state-management, filtering]

---

## 1. Overview

### 1.1 Problem Statement

When expanding from different points in the schematic, users may expand cells that are already visible in the canvas. Without duplicate prevention, the same cell would be rendered multiple times in different positions, creating visual clutter and confusion. The system must track which cells are currently visible and filter expansion results to only add new cells.

### 1.2 Goals

- Maintain accurate state of visible cells in the schematic
- Filter expansion results to exclude already-visible cells
- Provide efficient lookup for visibility checks (O(1) complexity)
- Update visible cell set after successful expansion
- Support visibility queries for UI state (e.g., disable "expand" on already-expanded cells)

---

## 2. Technical Requirements

### 2.1 Expansion State Management

**Location**: `src/ink/domain/model/expansion_state.py`

```python
from typing import Set
from dataclasses import dataclass, field
from ink.domain.value_objects.identifiers import CellId

@dataclass
class ExpansionState:
    """
    Aggregate root managing the state of visible cells and expansion history.

    This is the single source of truth for which cells are currently visible
    in the schematic canvas.
    """

    visible_cells: Set[CellId] = field(default_factory=set)
    """Set of cell IDs currently visible in the schematic"""

    def is_visible(self, cell_id: CellId) -> bool:
        """
        Check if a cell is currently visible.

        Args:
            cell_id: Cell identifier to check

        Returns:
            True if cell is visible, False otherwise
        """
        return cell_id in self.visible_cells

    def add_visible_cells(self, cell_ids: Set[CellId]) -> None:
        """
        Mark cells as visible.

        Args:
            cell_ids: Set of cell IDs to add
        """
        self.visible_cells.update(cell_ids)

    def remove_visible_cells(self, cell_ids: Set[CellId]) -> None:
        """
        Mark cells as no longer visible (for collapse).

        Args:
            cell_ids: Set of cell IDs to remove
        """
        self.visible_cells.difference_update(cell_ids)

    def clear(self) -> None:
        """Clear all visible cells (reset to empty schematic)"""
        self.visible_cells.clear()

    def get_visible_count(self) -> int:
        """Get count of currently visible cells"""
        return len(self.visible_cells)
```

### 2.2 Filtering in Expansion Service

**Location**: `src/ink/application/services/expansion_service.py`

```python
from typing import Set
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.expansion_state import ExpansionState
from ink.domain.services.graph_traverser import GraphTraverser
from ink.domain.value_objects.identifiers import CellId

class ExpansionService:
    """Application service for expansion operations"""

    def __init__(
        self,
        graph_traverser: GraphTraverser,
        expansion_state: ExpansionState
    ):
        self._traverser = graph_traverser
        self._state = expansion_state

    def expand_fanout(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """
        Expand fanout from a pin, filtering out already-visible cells.

        Args:
            pin: Starting pin (typically output)
            hops: Number of hops to expand

        Returns:
            Set of newly expanded cells (excludes already-visible)
        """
        # 1. Get all cells from graph traversal
        all_cells = self._traverser.get_fanout(pin, hops)

        # 2. Filter out already-visible cells
        new_cells = self._filter_new_cells(all_cells)

        if not new_cells:
            # Nothing new to expand
            return set()

        # 3. Mark new cells as visible
        new_cell_ids = {cell.id for cell in new_cells}
        self._state.add_visible_cells(new_cell_ids)

        # 4. Trigger layout and rendering (handled by caller or event)
        # 5. Record action for undo/redo (handled by command pattern)

        return new_cells

    def _filter_new_cells(self, cells: Set[Cell]) -> Set[Cell]:
        """
        Filter cells to only those not currently visible.

        Args:
            cells: Set of cells to filter

        Returns:
            Set containing only cells not in visible_cells
        """
        return {
            cell for cell in cells
            if not self._state.is_visible(cell.id)
        }

    def expand_fanin(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """Expand fanin with duplicate filtering"""
        all_cells = self._traverser.get_fanin(pin, hops)
        new_cells = self._filter_new_cells(all_cells)

        if new_cells:
            new_cell_ids = {cell.id for cell in new_cells}
            self._state.add_visible_cells(new_cell_ids)

        return new_cells

    def get_expansion_state(self) -> ExpansionState:
        """Get current expansion state for queries"""
        return self._state
```

### 2.3 Initial Population of Visible Cells

When the schematic is first loaded or user selects initial cells:

```python
class ExpansionService:
    # ...

    def set_initial_visible_cells(self, cells: Set[Cell]) -> None:
        """
        Set initial visible cells (e.g., top-level ports or user selection).

        Args:
            cells: Initial set of cells to display
        """
        cell_ids = {cell.id for cell in cells}
        self._state.clear()
        self._state.add_visible_cells(cell_ids)
```

### 2.4 Collapse Support

When cells are collapsed (hidden), remove them from visible set:

```python
class ExpansionService:
    # ...

    def collapse_cells(self, cells: Set[Cell]) -> None:
        """
        Hide cells from schematic.

        Args:
            cells: Cells to collapse/hide
        """
        cell_ids = {cell.id for cell in cells}
        self._state.remove_visible_cells(cell_ids)
```

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `tests/unit/domain/model/test_expansion_state.py`

Test `ExpansionState` aggregate:
- [ ] `is_visible()` returns False for non-existent cell
- [ ] `is_visible()` returns True after `add_visible_cells()`
- [ ] `add_visible_cells()` handles empty set
- [ ] `add_visible_cells()` handles duplicate additions (idempotent)
- [ ] `remove_visible_cells()` removes specified cells
- [ ] `remove_visible_cells()` handles non-existent cells gracefully
- [ ] `clear()` removes all visible cells
- [ ] `get_visible_count()` returns correct count

**Location**: `tests/unit/application/services/test_expansion_service_filtering.py`

Test filtering logic:
- [ ] `expand_fanout()` filters out already-visible cells
- [ ] `expand_fanout()` returns empty set if all cells already visible
- [ ] `expand_fanout()` updates `expansion_state` with new cells
- [ ] `expand_fanin()` filters correctly
- [ ] `_filter_new_cells()` returns only non-visible cells
- [ ] Sequential expansions don't create duplicates

### 3.2 Integration Tests

**Location**: `tests/integration/application/test_expansion_duplicate_prevention.py`

Test realistic scenarios:
- [ ] Expand A -> B, then expand A again (B should not be duplicated)
- [ ] Expand A -> B, then expand C -> B (B should not be duplicated)
- [ ] Expand fanout 2 hops, then expand 1 hop from intermediate cell (no duplicates)
- [ ] Collapse cells, then re-expand (cells appear again correctly)

---

## 4. Dependencies

- **Upstream**:
  - E03-F01-T01 (Graph Traverser Service) - provides traversal results to filter
  - Domain Model (Cell, CellId)
- **Downstream**:
  - E03-F01-T04 (Expansion Animation) - receives filtered cell set
  - E03-F02 (Collapse) - uses `remove_visible_cells()`
  - E04 (Undo/Redo) - must save/restore `ExpansionState`

---

## 5. Acceptance Criteria

- [ ] `ExpansionState` aggregate correctly tracks visible cells
- [ ] `is_visible()` provides O(1) lookup
- [ ] `ExpansionService` filters expansion results against visible cells
- [ ] Sequential expansions from different points never create duplicate cells
- [ ] `add_visible_cells()` is idempotent
- [ ] `remove_visible_cells()` supports collapse operations
- [ ] All unit tests pass with 90%+ coverage
- [ ] Integration tests verify no duplicates in complex expansion sequences
- [ ] Performance: visibility check completes in <1ms for 100K visible cells

---

## 6. Implementation Notes

### 6.1 Why Set[CellId] Instead of Set[Cell]?

Using `CellId` (likely a string or UUID) instead of `Cell` objects:
- **Memory efficiency**: Store lightweight IDs instead of full entities
- **Serialization**: Easier to save/load state
- **Equality**: ID comparison is simpler than entity comparison

### 6.2 Thread Safety Considerations

If expansion can happen from background threads:
- Use `threading.Lock` around `visible_cells` updates
- Or ensure all expansion happens on UI thread

### 6.3 Persistence

For session save/load:
```python
def to_dict(self) -> dict:
    return {
        "visible_cells": list(self.visible_cells)
    }

@classmethod
def from_dict(cls, data: dict) -> "ExpansionState":
    return cls(visible_cells=set(data["visible_cells"]))
```

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F01 split |
