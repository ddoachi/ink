# Spec: E03-F01-T01 - Graph Traverser Service

## Metadata
- **ID**: E03-F01-T01
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E03-F01](../E03-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 8
- **Actual Hours**:
- **Effort**: Medium
- **Tags**: [domain, graph-traversal, core-logic]

---

## 1. Overview

### 1.1 Problem Statement

The hop-based expansion feature requires efficient graph traversal to find all cells within N hops of a given pin in both fanin and fanout directions. This traversal logic is a core domain service that must be implemented with performance in mind while maintaining clean architecture boundaries.

### 1.2 Goals

- Implement domain service interface for graph traversal
- Provide fanin traversal (upstream cells)
- Provide fanout traversal (downstream cells)
- Support configurable hop depth (1 to 5+)
- Achieve performance targets (<100ms for 1-hop, <500ms for 5-hop)
- Maintain clean separation between domain interface and infrastructure implementation

---

## 2. Technical Requirements

### 2.1 Domain Service Interface

**Location**: `src/ink/domain/services/graph_traverser.py`

```python
from typing import Protocol, Set
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin

class GraphTraverser(Protocol):
    """Domain service for graph traversal operations"""

    def get_fanout(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """
        Get all cells within N hops downstream of pin.

        Args:
            pin: Starting pin (typically an output pin)
            hops: Number of hops to traverse (default 1)

        Returns:
            Set of Cell entities within the specified hop distance

        Raises:
            ValueError: If hops < 1 or pin is None
        """
        ...

    def get_fanin(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """
        Get all cells within N hops upstream of pin.

        Args:
            pin: Starting pin (typically an input pin)
            hops: Number of hops to traverse (default 1)

        Returns:
            Set of Cell entities within the specified hop distance

        Raises:
            ValueError: If hops < 1 or pin is None
        """
        ...
```

### 2.2 Infrastructure Implementation

**Location**: `src/ink/infrastructure/graph/networkx_graph_traverser.py`

```python
from typing import Set
import networkx as nx
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.services.graph_traverser import GraphTraverser

class NetworkXGraphTraverser(GraphTraverser):
    """NetworkX-based implementation of GraphTraverser"""

    def __init__(self, graph: nx.DiGraph):
        """
        Initialize traverser with NetworkX directed graph.

        Args:
            graph: NetworkX DiGraph representing the circuit netlist
                   Nodes: Cell instances
                   Edges: Connectivity via nets (driver -> load)
        """
        self._graph = graph

    def get_fanout(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """
        Traverse downstream from pin using BFS to depth N.

        Algorithm:
        1. Get net connected to pin
        2. Find all load pins on that net
        3. For each load pin, get parent cell
        4. If hops > 1, recursively expand from output pins of those cells
        5. Return all discovered cells
        """
        if hops < 1:
            raise ValueError(f"hops must be >= 1, got {hops}")
        if pin is None:
            raise ValueError("pin cannot be None")

        # Implementation details...
        pass

    def get_fanin(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """
        Traverse upstream from pin using BFS to depth N.

        Algorithm:
        1. Get net connected to pin
        2. Find driver pin on that net
        3. Get parent cell of driver pin
        4. If hops > 1, recursively expand from input pins of that cell
        5. Return all discovered cells
        """
        if hops < 1:
            raise ValueError(f"hops must be >= 1, got {hops}")
        if pin is None:
            raise ValueError("pin cannot be None")

        # Implementation details...
        pass

    def _bfs_fanout(self, start_cell: Cell, remaining_hops: int) -> Set[Cell]:
        """Breadth-first search for fanout traversal"""
        pass

    def _bfs_fanin(self, start_cell: Cell, remaining_hops: int) -> Set[Cell]:
        """Breadth-first search for fanin traversal"""
        pass
```

### 2.3 Graph Structure Assumptions

The NetworkX graph should be structured as:

```python
# Nodes: Cell entities with attributes
graph.add_node(cell_id, cell=cell_entity)

# Edges: Connectivity via nets
# From driver cell to load cell
graph.add_edge(driver_cell_id, load_cell_id,
               net=net_entity,
               driver_pin=driver_pin,
               load_pin=load_pin)
```

### 2.4 Performance Optimizations

- Use BFS (not DFS) to avoid deep recursion
- Short-circuit when hop limit reached
- Cache net connectivity lookups
- Consider lazy evaluation for large result sets
- Profile with realistic netlists (1K-100K cells)

### 2.5 Edge Cases

- **Power/Ground nets**: Should skip VDD/VSS nets to avoid expanding entire design
- **Unconnected pins**: Return empty set
- **Self-loops**: Handle combinational loops gracefully
- **Bidirectional pins**: Treat INOUT pins as both drivers and loads
- **Multiple drivers**: Handle tri-state nets with multiple drivers

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `tests/unit/infrastructure/graph/test_networkx_graph_traverser.py`

Test cases:
- [ ] 1-hop fanout from output pin
- [ ] 1-hop fanin from input pin
- [ ] N-hop fanout (2, 3, 5 hops)
- [ ] N-hop fanin (2, 3, 5 hops)
- [ ] Empty result for unconnected pin
- [ ] ValueError for invalid hop count
- [ ] ValueError for None pin
- [ ] Power/ground net filtering
- [ ] Combinational loop handling
- [ ] Bidirectional pin handling

### 3.2 Integration Tests

**Location**: `tests/integration/infrastructure/graph/test_graph_traversal_integration.py`

Test with realistic netlists:
- [ ] Simple chain: A -> B -> C -> D (test 1, 2, 3 hop traversal)
- [ ] Fanout tree: A -> [B, C, D] (test fanout expansion)
- [ ] Fanin merge: [A, B, C] -> D (test fanin expansion)
- [ ] Complex logic path (10+ cells, 5+ hops)

### 3.3 Performance Tests

Benchmark with synthetic netlists:
- [ ] 1-hop fanout on 100K cell design (<100ms)
- [ ] 5-hop fanout on 100K cell design (<500ms)
- [ ] Memory usage stays reasonable for deep traversals

---

## 4. Dependencies

- **Upstream**:
  - E01-F03 (Graph Construction) - provides NetworkX graph
  - E01 (Data Model) - Cell, Pin, Net entities
- **Downstream**:
  - E03-F01-T02 (Expansion Trigger Handling) - consumes traversal results

---

## 5. Acceptance Criteria

- [ ] `GraphTraverser` protocol defined in domain layer
- [ ] `NetworkXGraphTraverser` implemented in infrastructure layer
- [ ] `get_fanout()` correctly traverses downstream N hops
- [ ] `get_fanin()` correctly traverses upstream N hops
- [ ] All unit tests pass with 90%+ coverage
- [ ] Integration tests pass with realistic netlists
- [ ] 1-hop traversal completes in <100ms on 100K cell design
- [ ] 5-hop traversal completes in <500ms on 100K cell design
- [ ] Power/ground nets are filtered out
- [ ] Edge cases handled gracefully (unconnected, loops, INOUT)
- [ ] Type hints complete and mypy passes
- [ ] Docstrings complete with examples

---

## 6. Implementation Notes

### 6.1 BFS Algorithm Outline

```python
def _bfs_fanout(self, start_cell: Cell, remaining_hops: int) -> Set[Cell]:
    if remaining_hops == 0:
        return set()

    result = set()
    current_level = {start_cell}

    for hop in range(remaining_hops):
        next_level = set()
        for cell in current_level:
            # For each output pin of the cell
            for output_pin in cell.output_pins:
                # Get the net connected to this pin
                net = output_pin.net
                if net and not net.is_power_ground():
                    # Find all load pins on this net
                    for load_pin in net.load_pins:
                        load_cell = load_pin.parent_cell
                        if load_cell not in result:
                            result.add(load_cell)
                            next_level.add(load_cell)

        current_level = next_level

    return result
```

### 6.2 Dependency Injection

The application layer should inject `GraphTraverser` implementation:

```python
# In application service
class ExpansionService:
    def __init__(self, graph_traverser: GraphTraverser):
        self._traverser = graph_traverser
```

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F01 split |
