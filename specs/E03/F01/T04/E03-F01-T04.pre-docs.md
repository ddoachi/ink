# Pre-Implementation Documentation: E03-F01-T04 - Expansion Animation

## Overview

### Problem Context

When new cells are expanded into the schematic view, they need to be positioned correctly and rendered on the canvas. Without animation, cells would suddenly appear, creating a jarring experience that makes it hard for users to understand what changed and where new elements are located. Smooth animation provides visual continuity, helps users track spatial relationships, and creates a polished, professional user experience.

### Scope

This task implements layout calculation and animated rendering for newly expanded cells:
1. Incremental layout computation (position new cells relative to existing schematic)
2. Net routing for connections between new and existing cells
3. Animated fade-in and scale-up effects for cells
4. Animated fade-in for nets
5. Performance optimization to maintain 60 FPS
6. Animation configuration and cancellation support

### Success Criteria

- New cells smoothly animate into view with fade-in and scale-up
- Nets animate with fade-in effect
- Animation completes in 250ms with smooth easing
- Maintains 60 FPS for up to 50 cells
- User can interact during animation (non-blocking)
- Animation can be disabled for accessibility or performance
- Incremental layout positions cells correctly

## Implementation Approach

### High-Level Strategy

1. **Layout Engine Protocol**: Define `LayoutEngine` domain service interface
2. **Incremental Layout**: Implement Sugiyama-based layout that respects existing cell positions
3. **Net Routing**: Route orthogonal paths between new and existing cells
4. **Animation Framework**: Use Qt's `QPropertyAnimation` for smooth transitions
5. **Batch Rendering**: Animate all new cells/nets simultaneously using `QParallelAnimationGroup`
6. **Service Integration**: Extend `ExpansionService` to trigger layout and animation

### Architecture Pattern

**Layered Integration:**

```
ExpansionService (Application)
    ↓ calls
LayoutEngine (Domain Protocol → Infrastructure Implementation)
    ↓ produces
LayoutResult (positions, routing hints)
    ↓ passed to
SchematicCanvas.animate_expansion() (Presentation)
    ↓ creates
QPropertyAnimation objects (Qt Framework)
```

**Workflow:**

```
expand_fanout()
  → Get filtered cells
  → calculate_incremental_layout()
  → route_nets()
  → animate_expansion()
    → Create graphic items at target positions
    → Set initial state (opacity=0, scale=0.5)
    → Animate to final state (opacity=1, scale=1)
```

### Component Design

**LayoutEngine (Domain Protocol):**
- Defines contract for layout computation
- Returns `LayoutResult` with positions and routing hints
- Agnostic to implementation (Sugiyama, force-directed, etc.)

**SugiyamaLayoutEngine (Infrastructure):**
- Implements hierarchical layout algorithm
- Supports incremental layout (fixes existing cell positions)
- Uses grandalf library or custom implementation

**SchematicCanvas (Presentation):**
- Creates graphic items for new cells/nets
- Configures and starts animations
- Handles animation lifecycle (start, cancel, completion)

## Key Design Decisions

### Decision 1: Animation Type

**Chosen:** Combined fade-in and scale-up for cells, fade-in only for nets

**Rationale:**
- **Fade-in**: Provides smooth transition from invisible to visible
- **Scale-up**: Creates "growing into place" effect that draws attention
- **Nets fade-in only**: Scaling lines is visually awkward

**Parameters:**
- Cell: opacity 0→1, scale 0.5→1.0
- Net: opacity 0→1
- Duration: 250ms
- Easing: OutCubic (fade), OutBack (scale with slight overshoot)

**Alternative Considered:** Slide-in from anchor point. Rejected due to complexity and less natural feel.

### Decision 2: Animation Duration

**Chosen:** 250ms (quarter second)

**Rationale:**
- Fast enough to feel responsive
- Slow enough to be perceptible and smooth
- Standard duration for UI transitions
- Allows 60 FPS (15 frames at 60 FPS)

**Trade-offs:**
- Shorter (100ms): Too fast, may miss animation
- Longer (500ms): Feels sluggish

### Decision 3: Incremental Layout Strategy

**Problem:** How to layout new cells without repositioning existing cells?

**Chosen:** Constrained Sugiyama layout

**Algorithm:**
1. Build subgraph with existing + new cells
2. Fix existing cell positions as constraints
3. Run Sugiyama layout with constraints
4. Extract positions for new cells only

**Alternative Considered:**
- Force-directed from anchor: Less predictable, harder to control
- Fixed grid placement: Too rigid, doesn't respect connectivity

**Rationale:**
- Maintains hierarchical structure
- Respects existing layout
- Predictable, consistent results

### Decision 4: Parallel vs Sequential Animation

**Chosen:** Parallel animation using `QParallelAnimationGroup`

**Rationale:**
- All cells appear simultaneously (cohesive experience)
- More efficient than sequential
- Matches user expectation (expansion is atomic operation)

**Implementation:** Create all cell/net animations, add to group, start once

**Alternative Considered:** Sequential (one cell at a time). Rejected as too slow for multi-cell expansion.

### Decision 5: Animation Cancellation

**Problem:** User triggers new expansion during animation

**Chosen:** Cancel current animation, start new one

**Implementation:**
```python
if self._current_animation and self._current_animation.state() == Running:
    self._current_animation.stop()
self._current_animation = new_animation_group
new_animation_group.start()
```

**Rationale:**
- Prevents overlapping animations
- Respects most recent user action
- Avoids visual conflicts

### Decision 6: Performance Optimization

**Strategies:**

1. **Batch Animations**: Single animation group for all items
2. **GPU Acceleration**: Enable `QGraphicsItem.DeviceCoordinateCache`
3. **Progressive Rendering**: If >100 cells, animate in batches
4. **Disable Animation**: User setting for slow systems or accessibility

**Thresholds:**
- <50 cells: Full animation
- 50-100 cells: Simplified animation (fade-in only)
- >100 cells: Optional instant rendering or progress dialog

## Dependencies and Integration Points

### Upstream Dependencies

1. **E03-F01-T03 (Duplicate Prevention)** - CRITICAL
   - Provides filtered set of new cells
   - Ensures we only animate truly new cells

2. **E02-F02 (Sugiyama Layout)** - CRITICAL
   - Provides layout algorithm implementation
   - May need to extend for incremental layout support

3. **E02-F03 (Net Routing)** - CRITICAL
   - Provides orthogonal routing algorithm
   - Routes nets between new and existing cells

4. **Domain Model** - CRITICAL
   - `Cell`, `Pin`, `Net`, `Position`, `BoundingBox` entities

### Downstream Dependencies

1. **User Experience** - PRIMARY BENEFIT
   - Smooth, professional feel
   - Visual continuity during exploration

2. **E03-F02 (Collapse)** - FUTURE
   - May need collapse animation (reverse of expansion)
   - Can reuse animation framework

### Integration Challenges

**Challenge 1: Layout Engine Interface**
- Risk: E02-F02 may not support incremental layout
- Mitigation: Define protocol with incremental method, implement in infrastructure
- Contingency: Add incremental support to Sugiyama engine, or use simpler placement

**Challenge 2: Routing Performance**
- Risk: Routing 100+ nets may be slow, blocking animation start
- Mitigation: Profile routing, optimize critical paths
- Contingency: Simplify routing (straight lines) for large expansions

**Challenge 3: Qt Animation API**
- Risk: Complex API, potential for resource leaks
- Mitigation: Careful lifecycle management, cleanup on completion
- Contingency: Use simpler timer-based animation if needed

**Challenge 4: Item Creation Timing**
- Risk: Creating graphic items may be slow for large expansions
- Mitigation: Profile item creation, optimize constructors
- Contingency: Create items incrementally, animate in batches

## Testing Strategy

### Unit Tests (Application Layer)

**Test File:** `tests/unit/application/services/test_expansion_layout.py`

**Test Categories:**

1. **Service Integration**
   - `expand_fanout()` calls `layout_engine.calculate_incremental_layout()`
   - Layout result contains positions for all new cells
   - `net_router.route_nets()` called with correct parameters
   - Animation triggered after layout/routing

**Mocking Strategy:**
- Mock `LayoutEngine` to return fixed positions
- Mock `NetRouter` to return fixed routes
- Verify calls and parameters

### Unit Tests (Presentation Layer)

**Test File:** `tests/unit/presentation/canvas/test_expansion_animation.py`

**Test Categories:**

1. **Animation Setup**
   - `animate_expansion()` creates animations for all new cells
   - Cell animations include opacity and scale properties
   - Net animations include opacity property
   - Animation group duration is 250ms
   - Easing curves applied correctly (OutCubic, OutBack)

2. **Animation Lifecycle**
   - Cancellation works correctly
   - Cleanup happens on completion
   - Multiple animations don't interfere

**Mocking Strategy:**
- Use `QTest` helpers for Qt objects
- Mock or spy on `QPropertyAnimation` creation
- Verify animation parameters without actually running (too slow)

### UI Tests (Manual/Semi-Automated)

**Test File:** `tests/ui/test_expansion_animation_visual.py`

**Test Scenarios:**

1. **Visual Quality**
   - Cells fade in smoothly over 250ms
   - Cells scale up from 0.5x to 1.0x
   - Nets fade in simultaneously
   - No flickering or visual glitches

2. **Performance**
   - 10 cells: Smooth 60 FPS
   - 50 cells: Stable frame rate
   - 100 cells: Acceptable performance

3. **Interaction**
   - User can click during animation
   - New expansion cancels current animation
   - Animation doesn't block UI

**Testing Method:**
- Manual testing with visual inspection
- Screen recording for frame rate analysis
- Qt profiler for performance metrics

### Integration Tests

**Test File:** `tests/integration/infrastructure/layout/test_incremental_layout.py`

**Test Scenarios:**

1. **Layout Correctness**
   - New cells positioned near anchor pin
   - Existing cells unchanged
   - Hierarchical structure maintained
   - No overlapping cells

2. **Routing Correctness**
   - Nets connect new to existing cells
   - Orthogonal paths used
   - No crossing other cells

**Test Data:** Synthetic designs with known topology.

## Risks and Considerations

### Technical Risks

**Risk 1: Performance Targets Not Met**
- Likelihood: Medium
- Impact: High (poor UX)
- Mitigation: Profile early, optimize hot paths, simplify for large expansions
- Contingency: Add "instant mode" toggle, warn on large expansions

**Risk 2: Layout Quality Issues**
- Likelihood: Medium
- Impact: Medium (poor positioning)
- Mitigation: Test with diverse topologies, tune layout algorithm
- Contingency: Use simpler placement (grid, cluster), manual adjustment

**Risk 3: Animation Artifacts**
- Likelihood: Low
- Impact: Medium (visual glitches)
- Mitigation: Test on different platforms, use stable Qt APIs
- Contingency: Simplify animation (fade-in only)

### Architectural Risks

**Risk 1: Layout Engine Coupling**
- Likelihood: Low
- Impact: Low (protocol abstracts implementation)
- Mitigation: Keep protocol simple, stable
- Contingency: N/A (design prevents tight coupling)

### UX Risks

**Risk 1: Motion Sensitivity**
- Likelihood: Medium (some users sensitive to motion)
- Impact: Medium (accessibility issue)
- Mitigation: Add "reduce motion" setting
- Contingency: Instant rendering mode

**Risk 2: Large Expansion Overwhelming**
- Likelihood: Medium
- Impact: Medium (too much motion)
- Mitigation: Batch animation, warn user
- Contingency: Simplify or disable for >100 cells

## Open Questions

### Design Questions

1. **Incremental Layout Algorithm:** Does existing Sugiyama implementation support constraints?
   - **Decision needed by:** Before implementation
   - **Fallback:** Extend Sugiyama or use alternative placement

2. **Animation on Collapse:** Should collapse animate (reverse)?
   - **Decision needed by:** T04 implementation
   - **Fallback:** No collapse animation for MVP, add in P1

3. **Routing Simplification:** For large expansions, use straight lines instead of orthogonal?
   - **Decision needed by:** After performance testing
   - **Fallback:** Yes, add threshold-based simplification

### Technical Questions

1. **LayoutEngine Location:** Domain service or infrastructure?
   - **Resolution:** Protocol in domain, implementation in infrastructure (follows DDD)

2. **Animation Cleanup:** How to prevent memory leaks?
   - **Resolution:** Connect to `finished` signal, delete animations on completion

3. **Anchor Pin Position:** How to get current position of anchor pin?
   - **Resolution:** Query canvas for item position, or store in layout result

## Implementation Sequence

### Phase 1: Layout Protocol (1 hour)
1. Define `LayoutEngine` protocol in `src/ink/domain/services/layout_engine.py`
2. Define `LayoutResult` dataclass
3. Add type hints and docstrings

### Phase 2: Incremental Layout Implementation (3 hours)
1. Extend `SugiyamaLayoutEngine` in `src/ink/infrastructure/layout/sugiyama_engine.py`
2. Implement `calculate_incremental_layout()` method
3. Add constraint handling (fix existing positions)
4. Test with synthetic graphs

### Phase 3: Service Integration (1 hour)
1. Modify `ExpansionService.expand_fanout()` to call layout engine
2. Call net router with layout result
3. Trigger animation via event or canvas method
4. Pass layout result and routes to canvas

### Phase 4: Animation Implementation (2 hours)
1. Add `animate_expansion()` to `SchematicCanvas`
2. Implement `_animate_cell_item()` helper
3. Implement `_animate_net_item()` helper
4. Create `QParallelAnimationGroup`, configure, start
5. Add cancellation support

### Phase 5: Testing (2 hours)
1. Write unit tests for layout integration
2. Write unit tests for animation setup
3. Manual visual testing
4. Performance profiling

### Phase 6: Optimization (1 hour if needed)
1. Profile performance with 10, 50, 100 cells
2. Add batching or simplification if needed
3. Add "reduce motion" setting

**Total Estimate:** 8 hours (with buffer for debugging)

## Success Metrics

### Functional Metrics
- Incremental layout positions new cells correctly
- Nets routed orthogonally
- All animations complete successfully
- Cancellation works correctly

### Performance Metrics
- Animation maintains 60 FPS for 50 cells
- Layout calculation <100ms for 50 cells
- Routing <100ms for 50 nets
- Total expansion-to-animation time <500ms

### Quality Metrics
- No visual glitches or flickering
- Smooth, professional appearance
- User can interact during animation
- mypy passes, 90%+ test coverage

## Notes and Assumptions

### Assumptions
1. Qt animation framework is stable and performant
2. Sugiyama layout can be extended for incremental use
3. Net routing is fast enough for real-time use
4. Graphic item creation is not a bottleneck

### Out of Scope
- Collapse animation (defer to E03-F02)
- Path highlighting animation (P2 feature)
- Custom easing curves (use Qt built-ins)
- GPU shader-based animation (use Qt framework)

### Documentation Requirements
- Docstrings for layout protocol methods
- Animation parameter documentation
- Performance tuning guide
- Accessibility notes (reduce motion)

### Coordination Needed
- Sync with E02-F02 on incremental layout support
- Sync with E02-F03 on routing API
- Sync with T03 on filtered cell set format
- Sync with UX team on animation parameters (duration, easing)
