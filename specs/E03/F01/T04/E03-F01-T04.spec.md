# Spec: E03-F01-T04 - Expansion Animation

## Metadata
- **ID**: E03-F01-T04
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E03-F01](../E03-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 8
- **Actual Hours**:
- **Effort**: Medium
- **Tags**: [presentation, animation, rendering, ux]

---

## 1. Overview

### 1.1 Problem Statement

When new cells are expanded into view, they need to be positioned using the layout engine and rendered on the canvas. Without smooth animation, cells would suddenly appear, creating a jarring user experience. Animated expansion provides visual continuity, helps users understand spatial relationships, and makes the tool feel polished and responsive.

### 1.2 Goals

- Calculate layout positions for newly expanded cells using Sugiyama algorithm
- Route nets connecting new cells to existing cells
- Animate new cells and nets into view with smooth transitions
- Support fade-in and scale-up effects
- Maintain 60 FPS performance during animation
- Allow user to interact during animation (non-blocking)

---

## 2. Technical Requirements

### 2.1 Layout Calculation for New Cells

**Location**: `src/ink/application/services/expansion_service.py`

After filtering, calculate positions for new cells:

```python
from ink.domain.services.layout_engine import LayoutEngine
from ink.domain.services.net_router import NetRouter

class ExpansionService:
    def __init__(
        self,
        graph_traverser: GraphTraverser,
        expansion_state: ExpansionState,
        layout_engine: LayoutEngine,
        net_router: NetRouter
    ):
        self._traverser = graph_traverser
        self._state = expansion_state
        self._layout = layout_engine
        self._router = net_router

    def expand_fanout(self, pin: Pin, hops: int = 1) -> Set[Cell]:
        """Expand fanout with layout and animation"""
        # 1. Get traversal results
        all_cells = self._traverser.get_fanout(pin, hops)

        # 2. Filter duplicates
        new_cells = self._filter_new_cells(all_cells)
        if not new_cells:
            return set()

        # 3. Calculate incremental layout
        layout_result = self._layout.calculate_incremental_layout(
            existing_cells=self._get_visible_cells(),
            new_cells=new_cells,
            anchor_pin=pin  # Layout new cells relative to this pin
        )

        # 4. Route nets for new cells
        nets_to_route = self._get_affected_nets(new_cells)
        routes = self._router.route_nets(nets_to_route, layout_result.positions)

        # 5. Update state
        new_cell_ids = {cell.id for cell in new_cells}
        self._state.add_visible_cells(new_cell_ids)

        # 6. Trigger animation (emit event or call presentation layer)
        self._trigger_expansion_animation(new_cells, layout_result, routes)

        return new_cells
```

### 2.2 Incremental Layout

**Location**: `src/ink/domain/services/layout_engine.py` (Protocol)

```python
from typing import Protocol, Set, Dict
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.value_objects.position import Position

@dataclass
class LayoutResult:
    """Result of layout calculation"""
    positions: Dict[CellId, Position]  # Cell positions
    routing_hints: Dict[NetId, List[Position]]  # Routing waypoints

class LayoutEngine(Protocol):
    """Domain service for layout computation"""

    def calculate_incremental_layout(
        self,
        existing_cells: Set[Cell],
        new_cells: Set[Cell],
        anchor_pin: Pin
    ) -> LayoutResult:
        """
        Calculate layout positions for new cells relative to existing schematic.

        Args:
            existing_cells: Currently visible cells (fixed positions)
            new_cells: Newly expanded cells (need positions)
            anchor_pin: Pin from which expansion originated (spatial anchor)

        Returns:
            LayoutResult with positions and routing hints
        """
        ...
```

**Location**: `src/ink/infrastructure/layout/sugiyama_engine.py` (Implementation)

```python
class SugiyamaLayoutEngine(LayoutEngine):
    """Sugiyama hierarchical layout implementation"""

    def calculate_incremental_layout(
        self,
        existing_cells: Set[Cell],
        new_cells: Set[Cell],
        anchor_pin: Pin
    ) -> LayoutResult:
        """
        Incremental layout strategy:
        1. Keep existing cells at current positions (frozen)
        2. Build subgraph with existing + new cells
        3. Run Sugiyama on subgraph with position constraints
        4. Extract positions for new cells only
        """
        # Implementation using grandalf or custom Sugiyama
        pass
```

### 2.3 Animation in Presentation Layer

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

```python
from PySide6.QtCore import QPropertyAnimation, QEasingCurve, QParallelAnimationGroup
from PySide6.QtWidgets import QGraphicsOpacityEffect

class SchematicCanvas(QGraphicsView):
    """Canvas with expansion animation support"""

    def animate_expansion(
        self,
        new_cells: Set[Cell],
        layout_result: LayoutResult,
        routes: Dict[NetId, List[Position]]
    ) -> None:
        """
        Animate new cells and nets into view.

        Strategy:
        1. Create graphic items for new cells at target positions
        2. Set initial state: opacity=0, scale=0.5
        3. Animate to final state: opacity=1.0, scale=1.0
        4. Animate nets simultaneously with fade-in
        """
        animation_group = QParallelAnimationGroup(self)

        # Animate cells
        for cell in new_cells:
            cell_item = self._create_cell_item(cell, layout_result.positions[cell.id])
            self._animate_cell_item(cell_item, animation_group)

        # Animate nets
        for net_id, route_points in routes.items():
            net_item = self._create_net_item(net_id, route_points)
            self._animate_net_item(net_item, animation_group)

        # Start animation
        animation_group.setDuration(250)  # 250ms animation
        animation_group.start()

    def _animate_cell_item(
        self,
        cell_item: CellItem,
        group: QParallelAnimationGroup
    ) -> None:
        """Animate single cell: fade-in + scale-up"""
        # Opacity animation
        opacity_effect = QGraphicsOpacityEffect()
        cell_item.setGraphicsEffect(opacity_effect)
        opacity_effect.setOpacity(0.0)

        opacity_anim = QPropertyAnimation(opacity_effect, b"opacity")
        opacity_anim.setStartValue(0.0)
        opacity_anim.setEndValue(1.0)
        opacity_anim.setEasingCurve(QEasingCurve.OutCubic)
        group.addAnimation(opacity_anim)

        # Scale animation
        cell_item.setScale(0.5)
        scale_anim = QPropertyAnimation(cell_item, b"scale")
        scale_anim.setStartValue(0.5)
        scale_anim.setEndValue(1.0)
        scale_anim.setEasingCurve(QEasingCurve.OutBack)  # Slight overshoot
        group.addAnimation(scale_anim)

    def _animate_net_item(
        self,
        net_item: NetItem,
        group: QParallelAnimationGroup
    ) -> None:
        """Animate net: fade-in only"""
        opacity_effect = QGraphicsOpacityEffect()
        net_item.setGraphicsEffect(opacity_effect)
        opacity_effect.setOpacity(0.0)

        opacity_anim = QPropertyAnimation(opacity_effect, b"opacity")
        opacity_anim.setStartValue(0.0)
        opacity_anim.setEndValue(1.0)
        opacity_anim.setEasingCurve(QEasingCurve.InOutQuad)
        group.addAnimation(opacity_anim)
```

### 2.4 Animation Parameters

```python
# Animation configuration (can be user-configurable in settings)
ANIMATION_DURATION_MS = 250  # Total animation time
CELL_FADE_CURVE = QEasingCurve.OutCubic
CELL_SCALE_CURVE = QEasingCurve.OutBack
NET_FADE_CURVE = QEasingCurve.InOutQuad

INITIAL_CELL_OPACITY = 0.0
FINAL_CELL_OPACITY = 1.0
INITIAL_CELL_SCALE = 0.5
FINAL_CELL_SCALE = 1.0
```

### 2.5 Performance Considerations

- **Batch animations**: Use `QParallelAnimationGroup` for simultaneous animations
- **Limit concurrent animations**: If expanding 100+ cells, consider batching or simplifying
- **Animation toggle**: Provide setting to disable animations for performance
- **GPU acceleration**: Enable if available (`QGraphicsItem.setCacheMode()`)

---

## 3. Testing Requirements

### 3.1 Unit Tests

**Location**: `tests/unit/presentation/canvas/test_expansion_animation.py`

Test animation setup:
- [ ] `animate_expansion()` creates animations for all new cells
- [ ] Cell animations include both opacity and scale
- [ ] Net animations include opacity
- [ ] Animation group duration is correct (250ms)
- [ ] Easing curves are applied correctly

**Location**: `tests/unit/application/services/test_expansion_layout.py`

Test layout integration:
- [ ] `expand_fanout()` calls `layout_engine.calculate_incremental_layout()`
- [ ] Layout result contains positions for all new cells
- [ ] `net_router.route_nets()` is called with correct parameters

### 3.2 UI Tests

**Location**: `tests/ui/test_expansion_animation_visual.py`

Manual or semi-automated visual tests:
- [ ] Cells fade in smoothly over 250ms
- [ ] Cells scale up from 0.5x to 1.0x
- [ ] Nets fade in simultaneously
- [ ] No visual glitches or flickering
- [ ] Animation maintains 60 FPS (monitor with profiler)
- [ ] User can interact during animation

### 3.3 Performance Tests

Benchmark animation performance:
- [ ] Animating 10 cells: <250ms total, 60 FPS
- [ ] Animating 50 cells: <300ms total, stable frame rate
- [ ] Animating 100 cells: <500ms, acceptable frame rate

---

## 4. Dependencies

- **Upstream**:
  - E03-F01-T03 (Duplicate Prevention) - provides filtered cell set
  - E02-F02 (Sugiyama Layout) - layout engine implementation
  - E02-F03 (Net Routing) - routing implementation
- **Downstream**:
  - User experience (visual polish)

---

## 5. Acceptance Criteria

- [ ] New cells animate into view with fade-in effect
- [ ] New cells animate with scale-up from 0.5x to 1.0x
- [ ] Nets animate with fade-in effect
- [ ] Animation duration is 250ms
- [ ] Animation uses smooth easing curves (OutCubic, OutBack)
- [ ] Animation maintains 60 FPS for up to 50 cells
- [ ] User can interact with schematic during animation
- [ ] Animation can be disabled via settings
- [ ] Incremental layout positions new cells correctly relative to anchor
- [ ] Nets are routed orthogonally between new and existing cells
- [ ] All unit tests pass with 90%+ coverage
- [ ] Visual tests confirm smooth, professional appearance

---

## 6. Implementation Notes

### 6.1 Alternative Animation Strategies

If performance is an issue:
- **Progressive rendering**: Animate cells in batches (10 at a time)
- **Simplified animation**: Fade-in only, no scale
- **Instant rendering**: No animation, immediate display

### 6.2 Cancellation

If user triggers new expansion during animation:
- Stop current animation
- Clean up incomplete items
- Start new animation

```python
def animate_expansion(self, ...):
    # Cancel previous animation if still running
    if self._current_animation and self._current_animation.state() == QAbstractAnimation.Running:
        self._current_animation.stop()

    # Start new animation
    self._current_animation = animation_group
    animation_group.start()
```

### 6.3 Accessibility

For users with motion sensitivity:
- Provide "Reduce motion" setting
- If enabled, use instant rendering or very fast fade (50ms)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E03-F01 split |
