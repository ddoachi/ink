# E03 - Incremental Expansion: Pre-Implementation Documentation

## Document Information
- **Epic**: E03 - Incremental Expansion
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Epic Summary

E03 implements Ink's core differentiating feature - incremental schematic exploration. Unlike traditional schematic viewers that render entire netlists, Ink allows engineers to start from specific points of interest (cells, pins, or ports) and progressively expand connectivity in controlled increments. This approach minimizes rendering overhead and maximizes analysis efficiency when working with large gate-level netlists containing hundreds of thousands of cells.

### 1.2 Core Capabilities

The epic delivers four primary capabilities:

1. **Hop-Based Expansion**: Traverse N levels of fanin/fanout from any point, revealing immediate connectivity patterns
2. **Semantic Boundary Expansion** (P1): Expand until reaching sequential boundaries (latches) or I/O ports, exposing complete combinational cones
3. **Collapse Functionality**: Hide previously expanded sections to simplify views and reduce visual clutter
4. **Expansion State Management**: Track visible elements and maintain history for undo/redo operations

### 1.3 Success Metrics

- 1-hop expansion completes in <100ms for typical netlists
- 5-hop expansion completes in <500ms
- Collapse operations update view in <100ms
- Support for 100+ expansion/collapse actions in history
- Zero duplicate cells regardless of expansion sequence

---

## 2. Architecture Decisions

### 2.1 Separation of Concerns

**Decision**: Separate graph traversal, expansion logic, and rendering concerns into distinct layers.

**Rationale**:
- Graph traversal (`core/graph/`) focuses purely on connectivity queries
- Expansion service (`services/expansion/`) manages state and orchestration
- Canvas (`ui/canvas/`) handles visual representation and animation

**Alternatives Considered**:
- **Monolithic canvas approach**: Rejected - would couple rendering with business logic, making testing difficult
- **Event-driven pub/sub**: Deferred - adds complexity without clear benefit for MVP

**Trade-offs**:
- **Pro**: Clear separation enables independent testing of graph queries, expansion logic, and rendering
- **Pro**: Easier to optimize traversal algorithms without affecting UI
- **Con**: Requires coordination between layers via defined interfaces

### 2.2 Expansion State Model

**Decision**: Maintain a centralized `ExpansionState` object tracking visible cells, nets, and action history.

**Rationale**:
- Single source of truth prevents inconsistencies
- Simplifies undo/redo implementation
- Enables efficient duplicate detection

**Alternatives Considered**:
- **Canvas-owned state**: Rejected - couples state to UI, complicates testing
- **Database-backed state**: Over-engineered for MVP, deferred to session persistence (P1)

**Implementation**:
```python
@dataclass
class ExpansionState:
    visible_cells: Set[str]           # Cell IDs currently rendered
    visible_nets: Set[str]            # Net IDs currently rendered
    expansion_history: List[ExpansionAction]

    def add_cells(self, cells: Set[str]) -> Set[str]:
        """Add cells, return only newly visible ones"""
        new_cells = cells - self.visible_cells
        self.visible_cells.update(new_cells)
        return new_cells
```

### 2.3 Graph Traversal Strategy

**Decision**: Use NetworkX (MVP) with upgrade path to rustworkx for performance.

**Rationale**:
- NetworkX provides proven algorithms (BFS/DFS) with simple API
- Python-native enables rapid prototyping
- rustworkx (Rust-backed) offers 10-100x speedup for large graphs when needed

**Traversal Approach**:
- **Fanout**: BFS from pin's net → downstream pins → their cells
- **Fanin**: BFS from pin's net → upstream pins → their cells
- **Semantic Boundary**: BFS with early termination at latches/ports

**Performance Considerations**:
- Cache traversal results for frequently accessed paths
- Limit default hop count to 3 (configurable)
- Show warning dialog for expansions exceeding 1000 cells

### 2.4 Layout Integration

**Decision**: Incremental layout updates instead of full relayout on expansion.

**Rationale**:
- Full relayout causes jarring visual changes (existing cells move)
- Incremental updates preserve spatial context
- Better performance for small expansions

**Strategy**:
1. New cells positioned adjacent to expansion origin
2. Sugiyama layout constraints applied locally
3. Spring-force relaxation for final positions (optional)

**Trade-offs**:
- **Pro**: Stable visual experience, users maintain spatial orientation
- **Con**: May accumulate layout inefficiencies over many expansions
- **Mitigation**: Offer "Optimize Layout" command to trigger full relayout

### 2.5 Collapse Algorithm

**Decision**: Smart collapse that preserves cells connected to unexpanded regions.

**Rationale**:
- Naive collapse could orphan cells with multiple fanin/fanout sources
- Smart algorithm identifies safe-to-hide cells (only connected to collapsed subtree)

**Algorithm**:
```
1. Mark selected cells for collapse
2. For each marked cell:
   a. Identify all connected nets
   b. Check if net connects to non-marked cells
   c. If yes, cell is NOT safe to collapse
3. Hide safe cells and their exclusive nets
4. Update layout to close gaps (optional)
```

**Edge Cases**:
- Cell connected to both collapsed and expanded regions: Keep visible
- Net with multiple drivers: Hide only if all drivers hidden
- Collapsing last visible cell: Prevented - show warning

---

## 3. Implementation Strategy

### 3.1 Phased Rollout

**Phase 1: Foundation (Week 1)**
- Implement `ExpansionState` data model
- Build `GraphTraverser` with basic fanout/fanin queries
- Create expansion service skeleton
- Unit tests for state management and graph queries

**Phase 2: Basic Expansion (Week 2)**
- Implement 1-hop fanout expansion
- Integrate with canvas rendering
- Add duplicate detection
- Hook up double-click event handling
- Manual testing with simple test cases

**Phase 3: Extended Expansion (Week 3)**
- Add N-hop expansion capability
- Implement fanin expansion
- Add right-click context menu
- Performance optimization and caching
- Load testing with larger netlists

**Phase 4: Collapse (Week 4)**
- Implement collapse algorithm
- Add collapse action to UI
- Integrate with keyboard shortcuts
- Test edge cases (orphaned cells, multiple drivers)

**Phase 5: Polish (Week 5)**
- Add expansion animations
- Implement semantic boundary expansion (P1)
- Performance tuning
- Integration testing
- Documentation

### 3.2 Incremental Deliverables

Each phase produces a demonstrable increment:

1. **Foundation**: Expansion state can be queried and modified programmatically
2. **Basic Expansion**: User can double-click pin to see 1-hop fanout
3. **Extended Expansion**: User can configure hop count and expand fanin
4. **Collapse**: User can hide previously expanded sections
5. **Polish**: Smooth animations and semantic expansion

### 3.3 Integration Points

**With E01 (Data Model)**:
- Graph traversal depends on `Cell`, `Pin`, `Net` models
- Requires bidirectional navigation (pin → net → connected pins → cells)

**With E02 (Rendering)**:
- Expansion service provides new cells to render
- Canvas handles layout positioning and animation
- Service notifies canvas of visibility changes

**With E04 (Interaction)**:
- Expansion actions recorded in history for undo/redo
- Undo reverses expansion (triggers collapse)
- Redo replays expansion from history

---

## 4. Technical Deep Dive

### 4.1 Graph Traversal Implementation

**Bidirectional Graph Construction**:
```python
# During netlist parsing, build adjacency structures:
fanout_map: Dict[str, Set[str]]  # pin_id -> {downstream_pin_ids}
fanin_map: Dict[str, Set[str]]   # pin_id -> {upstream_pin_ids}
```

**Fanout Traversal**:
```python
def get_fanout(self, pin: Pin, hops: int) -> Set[Cell]:
    visited_pins = set()
    current_layer = {pin.id}
    result_cells = set()

    for _ in range(hops):
        next_layer = set()
        for pin_id in current_layer:
            if pin_id in visited_pins:
                continue
            visited_pins.add(pin_id)

            # Get net connected to this pin
            net = self.graph.get_net_for_pin(pin_id)

            # Get all downstream pins on this net
            downstream = self.fanout_map.get(pin_id, set())
            next_layer.update(downstream)

            # Add cells owning downstream pins
            for down_pin_id in downstream:
                cell = self.graph.get_cell_for_pin(down_pin_id)
                result_cells.add(cell)

        current_layer = next_layer

    return result_cells
```

**Optimization - Early Termination**:
```python
# Stop expanding if layer exceeds threshold
MAX_CELLS_PER_HOP = 500

if len(next_layer) > MAX_CELLS_PER_HOP:
    raise ExpansionLimitError(
        f"Expansion would add {len(next_layer)} cells. "
        f"Consider reducing hop count."
    )
```

### 4.2 Duplicate Detection

**Challenge**: Prevent adding cells already visible from previous expansions.

**Solution**: Set-based filtering in `ExpansionState`:
```python
def expand(self, new_cells: Set[Cell]) -> Set[Cell]:
    new_cell_ids = {c.id for c in new_cells}
    truly_new = new_cell_ids - self.visible_cells
    self.visible_cells.update(truly_new)
    return {c for c in new_cells if c.id in truly_new}
```

**Performance**: Set operations are O(1) average case, scales to millions of cells.

### 4.3 Layout Integration

**Challenge**: Position new cells without disrupting existing layout.

**Approach**:
1. **Anchor Point**: Use expansion origin (clicked pin) as reference
2. **Directional Placement**:
   - Fanout: Place new cells to the right
   - Fanin: Place new cells to the left
3. **Vertical Spacing**: Distribute new cells vertically to avoid overlap
4. **Sugiyama Constraints**: Assign new cells to levels based on topological distance

**Algorithm Sketch**:
```python
def position_new_cells(origin_pin: Pin, new_cells: Set[Cell], direction: str):
    # Get origin position
    origin_x, origin_y = origin_pin.position

    # Calculate base offset
    x_offset = CELL_WIDTH + SPACING if direction == "fanout" else -(CELL_WIDTH + SPACING)

    # Distribute vertically
    y_positions = distribute_vertical(len(new_cells), origin_y)

    for i, cell in enumerate(sorted(new_cells, key=lambda c: c.id)):
        cell.position = (origin_x + x_offset, y_positions[i])
        cell.level = origin_pin.cell.level + (1 if direction == "fanout" else -1)
```

### 4.4 Net Routing for New Cells

**Challenge**: Route nets connecting new cells to existing cells and each other.

**Approach**:
1. Identify nets requiring routing (those touching new cells)
2. Use orthogonal routing algorithm from E02
3. Route in two phases:
   - **Phase 1**: Nets between new and existing cells
   - **Phase 2**: Nets between new cells only

**Optimization**: Only re-route affected nets, not entire schematic.

### 4.5 Semantic Boundary Expansion

**Challenge**: Identify sequential elements (latches) to stop expansion.

**Approach**:
1. **Cell Classification**: During parsing, mark cells with types:
   - `COMBINATIONAL`: Gates (AND, OR, INV, etc.)
   - `SEQUENTIAL`: Latches, flip-flops
   - `PORT`: Top-level I/O
2. **Boundary Detection**: BFS stops when encountering `SEQUENTIAL` or `PORT` cells

**Implementation**:
```python
def expand_to_boundary(self, pin: Pin, direction: str) -> Set[Cell]:
    visited = set()
    frontier = {pin}
    result = set()

    while frontier:
        current_pins = frontier.copy()
        frontier.clear()

        for p in current_pins:
            if p.id in visited:
                continue
            visited.add(p.id)

            cell = self.graph.get_cell_for_pin(p.id)

            # Stop at boundary
            if cell.type in (CellType.SEQUENTIAL, CellType.PORT):
                result.add(cell)
                continue

            # Continue traversal
            result.add(cell)
            next_pins = self.get_connected_pins(p, direction)
            frontier.update(next_pins)

    return result
```

### 4.6 Collapse Safety Analysis

**Challenge**: Determine which cells can be safely hidden without breaking connectivity.

**Algorithm**:
```python
def get_safe_to_collapse(self, selected_cells: Set[str]) -> Set[str]:
    safe = set()

    for cell_id in selected_cells:
        # Get all nets connected to this cell
        connected_nets = self.graph.get_nets_for_cell(cell_id)

        is_safe = True
        for net in connected_nets:
            # Get all cells on this net
            cells_on_net = self.graph.get_cells_for_net(net.id)

            # Check if any non-selected cells are on this net
            visible_others = cells_on_net - selected_cells
            if visible_others & self.expansion_state.visible_cells:
                is_safe = False
                break

        if is_safe:
            safe.add(cell_id)

    return safe
```

**User Feedback**: If selected cells aren't safe to collapse, show dialog:
```
Cannot collapse X cells - they are connected to other visible cells.
Collapse anyway (may orphan cells)?  [Yes] [No]
```

---

## 5. Risk Analysis

### 5.1 Performance Risks

**Risk**: Large N-hop expansions overwhelm rendering engine

**Impact**: High - Application freeze, poor user experience
**Probability**: High - Engineers may request 5+ hop expansions on dense netlists
**Mitigation**:
- Set default hop count to 1, max recommended to 3
- Show warning dialog if expansion exceeds 1000 cells
- Implement background expansion with progress bar for large operations
- Add cancel button during expansion
- Provide "Expand to Limit" with cell count cap instead of hop count

**Monitoring**:
```python
@timed
def expand(self, pin: Pin, hops: int):
    if hops > 3:
        logger.warning(f"Large expansion requested: {hops} hops")

    new_cells = self.traverser.get_fanout(pin, hops)

    if len(new_cells) > 1000:
        response = self.ui.show_warning(
            f"Expansion will add {len(new_cells)} cells. Continue?"
        )
        if not response:
            return
```

### 5.2 Layout Thrashing

**Risk**: Incremental layout accumulates inefficiencies, causing poor positioning

**Impact**: Medium - Cluttered schematics, reduced readability
**Probability**: Medium - Occurs after 10+ expansion operations
**Mitigation**:
- Implement "Optimize Layout" command to trigger full Sugiyama relayout
- Auto-suggest optimization after N expansions (e.g., 20)
- Use spring-force relaxation to smooth incremental layouts
- Provide layout quality metrics (wire crossings, vertical spread)

### 5.3 Orphaned Cell Bugs

**Risk**: Collapse logic incorrectly hides cells that should remain visible

**Impact**: High - Data loss, user confusion, loss of trust
**Probability**: Medium - Complex connectivity patterns may expose edge cases
**Mitigation**:
- Comprehensive unit tests covering all edge cases:
  - Multi-driver nets
  - Cells with fanin/fanout to both collapsed and visible regions
  - Circular dependencies
- Conservative collapse (keep cell if any doubt)
- Undo functionality allows recovery from mistakes
- Collapse preview mode (highlight cells that will be hidden)

**Test Cases**:
```python
def test_collapse_preserves_bridge_cells():
    # Cell A expanded from port X
    # Cell B expanded from cell A
    # Cell C expanded from both A and Y (another port)
    # Collapse B should not hide C (connected to Y)
```

### 5.4 Expansion History Memory

**Risk**: Expansion history grows unbounded, consuming memory

**Impact**: Low - Memory exhaustion after extended sessions
**Probability**: Low - Requires hundreds of operations
**Mitigation**:
- Cap history at 100 actions (configurable)
- Implement history compaction (merge sequential expansions)
- Provide "Clear History" command
- Monitor memory usage and warn if approaching limits

### 5.5 State Inconsistency

**Risk**: `ExpansionState` and canvas rendering become desynchronized

**Impact**: High - Cells appear/disappear unexpectedly, duplicate rendering
**Probability**: Medium - Multi-threaded rendering or event race conditions
**Mitigation**:
- Single-threaded expansion logic
- Canvas renders only cells in `visible_cells` set
- State changes trigger canvas refresh via observer pattern
- Validation mode: Assert canvas cells match `visible_cells`

```python
def validate_state(self):
    canvas_cells = {c.id for c in self.canvas.get_rendered_cells()}
    state_cells = self.expansion_state.visible_cells

    assert canvas_cells == state_cells, \
        f"State mismatch: {canvas_cells ^ state_cells}"
```

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Graph Traversal** (`tests/core/graph/test_traversal.py`):
```python
def test_fanout_1_hop():
    # Given: Pin P1 drives net N1, N1 connects to pins P2, P3
    # When: get_fanout(P1, hops=1)
    # Then: Returns cells owning P2, P3

def test_fanout_2_hops():
    # Test transitive fanout through intermediate cells

def test_fanout_stops_at_port():
    # Expansion should include top-level port but not go beyond

def test_fanin_through_multi_driver_net():
    # Net with multiple drivers should return all driver cells
```

**Expansion State** (`tests/services/expansion/test_state.py`):
```python
def test_add_cells_filters_duplicates():
    state = ExpansionState()
    cells = {Cell("A"), Cell("B")}

    new = state.add_cells(cells)
    assert len(new) == 2

    new2 = state.add_cells(cells)
    assert len(new2) == 0  # Already visible

def test_expansion_history_records_actions():
    # Verify each expansion creates history entry

def test_visible_nets_updated_with_cells():
    # When cells added, their nets should be marked visible
```

**Collapse Algorithm** (`tests/services/expansion/test_collapse.py`):
```python
def test_collapse_basic():
    # Collapse single cell with no external connections

def test_collapse_preserves_bridge_cells():
    # Cell connected to collapsed and non-collapsed regions stays

def test_collapse_multi_driver_net():
    # Net with multiple drivers, hide only if all hidden

def test_collapse_all_cells_prevented():
    # Cannot collapse last visible cell
```

### 6.2 Integration Testing

**End-to-End Expansion** (`tests/integration/test_expansion_flow.py`):
```python
def test_double_click_expands_fanout():
    # Given: Schematic with cell A visible
    # When: User double-clicks output pin of A
    # Then: Fanout cells appear on canvas
    # And: Nets are routed
    # And: Expansion history updated

def test_sequential_expansions_no_duplicates():
    # Expand A → B, then expand A → C
    # B should not be added twice if it's in both paths

def test_expand_collapse_expand_idempotent():
    # Expand, collapse, expand again should produce same state
```

**Performance Testing** (`tests/performance/test_expansion_perf.py`):
```python
@pytest.mark.benchmark
def test_1_hop_expansion_performance(benchmark):
    result = benchmark(expansion_service.expand, pin, hops=1)
    assert benchmark.stats.mean < 0.1  # <100ms

@pytest.mark.benchmark
def test_5_hop_expansion_performance(benchmark):
    result = benchmark(expansion_service.expand, pin, hops=5)
    assert benchmark.stats.mean < 0.5  # <500ms
```

### 6.3 Manual Testing

**Test Plan**:

1. **Basic Expansion**:
   - Load `examples/counter.ckt`
   - Double-click output pin of D flip-flop
   - Verify fanout cells appear
   - Verify nets are routed correctly

2. **Multi-Hop Expansion**:
   - Right-click pin → Expand Fanout (3 hops)
   - Verify correct number of cells appear
   - Check no duplicates exist

3. **Fanin Expansion**:
   - Right-click input pin → Expand Fanin (1 hop)
   - Verify driver cells appear to the left

4. **Collapse**:
   - Select expanded cells
   - Press Delete key
   - Verify cells disappear
   - Verify nets update correctly

5. **Edge Cases**:
   - Expand from port (should work)
   - Expand cell with no fanout (no change)
   - Collapse cell with fanout to visible cells (should warn)

6. **Performance**:
   - Load large netlist (10K+ cells)
   - Measure expansion time with profiler
   - Verify UI remains responsive

### 6.4 Acceptance Testing

**Checklist** (from spec):

- [ ] 1-hop expansion completes in <100ms
- [ ] 5-hop expansion completes in <500ms
- [ ] Collapse updates view in <100ms
- [ ] No duplicate cells after any expansion sequence
- [ ] Expansion history supports 100+ actions
- [ ] Double-click on output pin triggers expansion
- [ ] 1-hop expansion shows immediate fanout cells
- [ ] Newly expanded cells are positioned and routed
- [ ] Already visible cells are not duplicated
- [ ] Expansion animates smoothly
- [ ] Right-click menu offers "Expand Fanin"
- [ ] Fanin expansion shows driver cells
- [ ] Configurable hop count (1, 2, 3, or custom)
- [ ] Right-click menu offers "Collapse"
- [ ] Collapse hides selected cells and their dependencies
- [ ] Cells connected to other visible cells remain visible
- [ ] Keyboard shortcut (Delete/Backspace) for collapse

---

## 7. Definition of Done

### 7.1 Functionality Criteria

**Core Features**:
- [ ] User can double-click pin to expand 1-hop fanout
- [ ] User can right-click pin and select "Expand Fanout (N hops)"
- [ ] User can right-click pin and select "Expand Fanin (N hops)"
- [ ] User can configure default hop count in settings
- [ ] User can select cells and press Delete to collapse
- [ ] User can right-click cells and select "Collapse"
- [ ] Expansion never creates duplicate cells
- [ ] Collapse preserves cells connected to non-collapsed regions

**P1 Features**:
- [ ] User can select "Expand to Boundary" from context menu
- [ ] Semantic expansion stops at latches and ports
- [ ] Semantic expansion works for both fanin and fanout

### 7.2 Performance Criteria

- [ ] 1-hop expansion completes in <100ms (95th percentile)
- [ ] 3-hop expansion completes in <300ms (95th percentile)
- [ ] 5-hop expansion completes in <500ms (95th percentile)
- [ ] Collapse operation completes in <100ms
- [ ] Memory usage remains stable after 100+ expansion operations
- [ ] No memory leaks detected in 1-hour stress test

### 7.3 Quality Criteria

**Test Coverage**:
- [ ] Unit test coverage >90% for `services/expansion/`
- [ ] Unit test coverage >85% for `core/graph/traversal.py`
- [ ] All edge cases covered by tests (see section 6.1)
- [ ] Integration tests pass for all user stories
- [ ] Performance benchmarks pass

**Code Quality**:
- [ ] Type hints on all public APIs
- [ ] Docstrings for all public functions
- [ ] No mypy errors
- [ ] No ruff linting errors
- [ ] Code review completed by peer

**User Experience**:
- [ ] Expansion animations are smooth (60 fps)
- [ ] Progress indicators shown for operations >500ms
- [ ] Clear error messages for expansion limits
- [ ] Context menus are intuitive
- [ ] Keyboard shortcuts documented in help

### 7.4 Documentation Criteria

- [ ] API documentation for `GraphTraverser`
- [ ] API documentation for `ExpansionService`
- [ ] User guide section on expansion workflow
- [ ] Architecture diagram showing expansion flow
- [ ] Performance tuning guide for large netlists

### 7.5 Integration Criteria

**With E01 (Data Model)**:
- [ ] Graph traversal works with all cell types
- [ ] Pin-to-net-to-cell navigation is efficient
- [ ] Multi-driver nets handled correctly

**With E02 (Rendering)**:
- [ ] New cells positioned without overlapping
- [ ] Nets routed correctly after expansion
- [ ] Layout remains readable after 10+ expansions
- [ ] Canvas updates reflect `ExpansionState` accurately

**With E04 (Interaction)**:
- [ ] Expansion actions recorded in history
- [ ] Undo reverses expansion (triggers collapse)
- [ ] Redo replays expansion from history
- [ ] History serialization works for session persistence

### 7.6 Release Criteria

- [ ] All acceptance criteria from spec met
- [ ] No P0/P1 bugs open
- [ ] Performance benchmarks pass on reference hardware
- [ ] User acceptance testing completed
- [ ] Documentation published
- [ ] Demo video recorded showing key workflows
- [ ] Release notes drafted

---

## 8. Open Questions

### 8.1 Technical Questions

**Q1**: Should expansion be synchronous or asynchronous?
**Answer**: Start synchronous for MVP. If >500ms, refactor to async with progress bar.

**Q2**: How to handle circular dependencies in fanin/fanout?
**Answer**: BFS with visited set prevents infinite loops. Circular paths are valid and should be shown.

**Q3**: Should collapsed cells be removed from memory or just hidden?
**Answer**: Hidden only (set `visible=False`). Keeps undo simple and fast.

**Q4**: How to represent expansion in the graph? New subgraph or annotations?
**Answer**: Annotations on existing graph. Subgraph approach complicates merging.

### 8.2 UX Questions

**Q1**: Should expansion be modal (block UI) or non-modal (allow other actions)?
**Answer**: Non-modal for <500ms, modal with cancel for >500ms.

**Q2**: What visual feedback during expansion?
**Answer**: Fade-in animation for new cells (200ms duration). Loading spinner for >500ms.

**Q3**: Should collapse require confirmation?
**Answer**: No confirmation for safe collapse. Warning dialog if cells would be orphaned.

**Q4**: Default hop count?
**Answer**: 1 hop (safest). Power users can configure higher.

### 8.3 Product Questions

**Q1**: Priority of semantic boundary expansion?
**Answer**: P1 (not MVP blocker). Important for analog designers but not all users.

**Q2**: Should we support "Expand All" (entire netlist)?
**Answer**: No. Defeats purpose of incremental exploration. May reconsider for small netlists (<100 cells).

**Q3**: Should expansion be undoable?
**Answer**: Yes. Integration with E04 undo/redo system is critical.

---

## 9. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/E03.spec.md`
- **PRD**: `/home/joohan/dev/project-ink/ink/docs/prd.md` (§5.1, §5.2, §5.3)
- **Related Epics**:
  - E01: Data Model (graph construction)
  - E02: Rendering (layout and display)
  - E04: Interaction (undo/redo)

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
