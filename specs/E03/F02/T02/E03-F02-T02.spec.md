---
id: E03-F02-T02
title: Subtree Collapse Logic
type: Task
priority: P0 (MVP)
status: Draft
parent: E03-F02
created: 2025-12-26
estimated_hours: 5
actual_hours:
effort: Medium
tags:
  - collapse
  - subtree
  - expansion-tracking
---

# Spec: E03-F02-T02 - Subtree Collapse Logic

## 1. Overview

### 1.1 Problem Statement
When collapsing a cell, users may want to collapse the entire subtree of cells that were expanded from it, not just the single cell. This requires tracking the expansion dependency tree (which cells were expanded from which parent cells) and implementing recursive subtree collapse logic.

### 1.2 Goals
- Track parent-child relationships during expansion operations
- Implement subtree traversal to identify all descendant cells
- Provide separate commands for single-cell vs subtree collapse
- Ensure subtree collapse respects safety validation
- Support "Collapse All Below" functionality

---

## 2. Technical Requirements

### 2.1 File Structure

```
src/ink/application/
├── commands/
│   └── collapse_command.py    # Add CollapseSubtreeCommand
└── services/
    └── collapse_service.py    # Add subtree collapse logic
```

### 2.2 Expansion Tracking Extension

**File**: `src/ink/application/services/collapse_service.py` (additions)

```python
from typing import Dict, Set
from ...domain.value_objects.identifiers import CellId

class ExpansionStateRepository(Protocol):
    """Extended interface for expansion tracking"""
    # ... existing methods ...

    def get_expansion_parent(self, cell_id: CellId) -> Optional[CellId]:
        """Get the parent cell that this cell was expanded from"""
        ...

    def get_expansion_children(self, cell_id: CellId) -> Set[CellId]:
        """Get all cells that were directly expanded from this cell"""
        ...

    def get_expansion_tree(self, root_cell_id: CellId) -> Dict[CellId, Set[CellId]]:
        """Get the complete expansion tree rooted at the given cell"""
        ...
```

### 2.3 Subtree Collapse Command

**File**: `src/ink/application/commands/collapse_command.py` (additions)

```python
@dataclass(frozen=True)
class CollapseSubtreeCommand:
    """Command to collapse a cell and all its expansion descendants"""
    root_cell_ids: Set[CellId]  # Root cells to collapse subtrees from
    force: bool = False          # Skip safety validation if True

    def __post_init__(self):
        if not self.root_cell_ids:
            raise ValueError("root_cell_ids cannot be empty")
```

### 2.4 Subtree Collapse Service Logic

**File**: `src/ink/application/services/collapse_service.py` (additions)

```python
class CollapseService:
    # ... existing methods ...

    def execute_subtree(self, command: CollapseSubtreeCommand) -> CollapseResult:
        """Execute subtree collapse command"""
        visible_cells = self.expansion_state_repo.get_visible_cells()

        # Collect all cells in the subtrees
        all_cells_to_collapse = set()
        for root_id in command.root_cell_ids:
            if root_id not in visible_cells:
                continue
            subtree_cells = self._collect_subtree_cells(root_id)
            all_cells_to_collapse.update(subtree_cells)

        if not all_cells_to_collapse:
            return CollapseResult(
                collapsed_cell_ids=set(),
                removed_net_ids=set(),
                skipped_cell_ids=set(),
                success=False,
                message="No cells found in subtree(s)"
            )

        # Use standard collapse logic for the collected cells
        collapse_cmd = CollapseCommand(
            cell_ids=all_cells_to_collapse,
            force=command.force
        )
        return self.execute(collapse_cmd)

    def _collect_subtree_cells(self, root_cell_id: CellId) -> Set[CellId]:
        """Recursively collect all cells in the expansion subtree"""
        result = {root_cell_id}  # Include the root itself
        to_visit = [root_cell_id]

        while to_visit:
            current_id = to_visit.pop()
            children = self.expansion_state_repo.get_expansion_children(current_id)

            for child_id in children:
                if child_id not in result:
                    result.add(child_id)
                    to_visit.append(child_id)

        return result

    def collapse_to_boundary(self, cell_id: CellId) -> CollapseResult:
        """Collapse all cells expanded from cell_id back to the original boundary

        This is useful for "reset to initial expansion" functionality.
        """
        # Find all cells that were expanded from this cell
        subtree_cells = self._collect_subtree_cells(cell_id)

        # Exclude the root cell itself (we want to collapse TO it, not including it)
        cells_to_collapse = subtree_cells - {cell_id}

        if not cells_to_collapse:
            return CollapseResult(
                collapsed_cell_ids=set(),
                removed_net_ids=set(),
                skipped_cell_ids=set(),
                success=False,
                message=f"No cells to collapse below {cell_id}"
            )

        collapse_cmd = CollapseCommand(cell_ids=cells_to_collapse, force=False)
        return self.execute(collapse_cmd)
```

### 2.5 Expansion State Tracking

The expansion state repository must track parent-child relationships when cells are expanded.

**Conceptual implementation** (actual implementation in E03-F04):

```python
class ExpansionState:
    """Tracks expansion relationships"""
    def __init__(self):
        self._visible_cells: Set[CellId] = set()
        self._expansion_parents: Dict[CellId, CellId] = {}  # child -> parent
        self._expansion_children: Dict[CellId, Set[CellId]] = {}  # parent -> children

    def add_expanded_cells(
        self,
        parent_cell_id: CellId,
        new_cell_ids: Set[CellId]
    ) -> None:
        """Record cells that were expanded from a parent"""
        self._visible_cells.update(new_cell_ids)

        # Track parent-child relationships
        for cell_id in new_cell_ids:
            self._expansion_parents[cell_id] = parent_cell_id

        if parent_cell_id not in self._expansion_children:
            self._expansion_children[parent_cell_id] = set()
        self._expansion_children[parent_cell_id].update(new_cell_ids)

    def remove_cells(self, cell_ids: Set[CellId]) -> None:
        """Remove cells and clean up parent-child tracking"""
        self._visible_cells -= cell_ids

        for cell_id in cell_ids:
            # Remove from parent's children list
            if cell_id in self._expansion_parents:
                parent_id = self._expansion_parents[cell_id]
                if parent_id in self._expansion_children:
                    self._expansion_children[parent_id].discard(cell_id)
                del self._expansion_parents[cell_id]

            # Remove this cell's children mapping
            if cell_id in self._expansion_children:
                del self._expansion_children[cell_id]

    def get_expansion_parent(self, cell_id: CellId) -> Optional[CellId]:
        return self._expansion_parents.get(cell_id)

    def get_expansion_children(self, cell_id: CellId) -> Set[CellId]:
        return self._expansion_children.get(cell_id, set()).copy()
```

---

## 3. Dependencies

- **Upstream**:
  - E03-F02-T01 (Collapse Command) - builds on basic collapse logic
  - E03-F04 (Expansion State Management) - requires parent-child tracking
  - E03-F01 (Hop-Based Expansion) - parent-child relationships created during expansion
- **Downstream**:
  - E03-F02-T04 (Context Menu Integration) - provides "Collapse Subtree" menu option

---

## 4. Acceptance Criteria

- [ ] `CollapseSubtreeCommand` dataclass with `root_cell_ids` field
- [ ] `CollapseService.execute_subtree()` method handles subtree collapse
- [ ] `_collect_subtree_cells()` recursively traverses expansion tree
- [ ] Subtree collapse includes root cell and all descendants
- [ ] Safety validation applied to all cells in subtree (unless `force=True`)
- [ ] `collapse_to_boundary()` collapses descendants but keeps root visible
- [ ] `ExpansionStateRepository` protocol extended with parent/children methods
- [ ] Expansion state tracks parent-child relationships during expansion
- [ ] Parent-child tracking cleaned up when cells are collapsed
- [ ] Subtree collapse handles multiple root cells correctly
- [ ] Empty subtree returns appropriate error message
- [ ] Unit tests with 95%+ coverage
- [ ] Integration tests verify full subtree collapse

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
