# E03-F02-T02 - Subtree Collapse Logic: Pre-Implementation Documentation

## Document Information
- **Task**: E03-F02-T02 - Subtree Collapse Logic
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task extends the collapse functionality to support subtree operations - collapsing not just individual cells, but entire branches of the expansion tree. When users expand cells progressively (A expands to B, B expands to C, C expands to D), they often want to collapse the entire chain in one operation rather than individually collapsing each level.

The subtree collapse feature tracks parent-child relationships during expansion and provides commands to collapse entire dependency trees efficiently.

### 1.2 Problem Context

In incremental schematic exploration, users build up complex views through sequences of expansion operations:

```
Initial: [Port X]
Expand X → [Port X] → [Cell A, Cell B]
Expand A → [Port X] → [Cell A, Cell B] → [Cell C, Cell D]
Expand B → [Port X] → [Cell A, Cell B] → [Cell C, Cell D, Cell E]
```

When the user wants to simplify the view, they may want to:

1. **Collapse Individual Cell**: Hide just Cell D (simple collapse from T01)
2. **Collapse Subtree**: Hide Cell A and everything expanded from it (C, D)
3. **Collapse to Boundary**: Hide C and D but keep A visible (reset A's expansion)

Without subtree tracking, users must manually select all descendant cells, which is tedious and error-prone. This task makes collapse operations more intelligent by understanding the expansion dependency tree.

### 1.3 Success Criteria

- Parent-child relationships tracked during all expansion operations
- Subtree traversal correctly identifies all descendants
- `CollapseSubtreeCommand` collapses root cell plus all descendants
- `collapse_to_boundary()` preserves root while collapsing descendants
- Performance: Subtree collection completes in <50ms for trees with 100+ nodes
- Memory overhead: <100 bytes per expansion relationship

---

## 2. Implementation Approach

### 2.1 Expansion Tracking Data Structure

**Core Idea**: Maintain bidirectional mappings between cells and their expansion relationships.

```python
_expansion_parents: Dict[CellId, CellId]        # child → parent
_expansion_children: Dict[CellId, Set[CellId]]  # parent → {children}
```

**Example**:
```
User expands Port X → reveals Cell A, Cell B
User expands Cell A → reveals Cell C, Cell D

_expansion_parents = {
  A: X,
  B: X,
  C: A,
  D: A
}

_expansion_children = {
  X: {A, B},
  A: {C, D}
}
```

**Tracking Updates**:

During expansion:
```python
def add_expanded_cells(parent_id: CellId, new_cells: Set[CellId]):
    for cell_id in new_cells:
        _expansion_parents[cell_id] = parent_id
    _expansion_children[parent_id] = new_cells
```

During collapse:
```python
def remove_cells(cell_ids: Set[CellId]):
    for cell_id in cell_ids:
        # Remove from parent's children list
        if cell_id in _expansion_parents:
            parent_id = _expansion_parents[cell_id]
            _expansion_children[parent_id].discard(cell_id)
            del _expansion_parents[cell_id]

        # Remove this cell's children mapping
        if cell_id in _expansion_children:
            del _expansion_children[cell_id]
```

### 2.2 Subtree Collection Algorithm

**Goal**: Given a root cell, collect all cells in its expansion subtree using depth-first search.

```
Algorithm: collect_subtree_cells(root_id)

1. Initialize result set with root_id
2. Initialize work queue with root_id
3. While queue not empty:
   a. Pop cell_id from queue
   b. Get children of cell_id from _expansion_children
   c. For each child:
      - If not already in result, add to result and queue
4. Return result set
```

**Complexity**: O(N) where N is number of cells in subtree
**Performance**: Linear scan, very fast for typical subtrees (<100 cells)

**Implementation**:
```python
def _collect_subtree_cells(self, root_cell_id: CellId) -> Set[CellId]:
    result = {root_cell_id}
    to_visit = [root_cell_id]

    while to_visit:
        current_id = to_visit.pop()
        children = self.expansion_state_repo.get_expansion_children(current_id)

        for child_id in children:
            if child_id not in result:
                result.add(child_id)
                to_visit.append(child_id)

    return result
```

### 2.3 Subtree Collapse Command

**CollapseSubtreeCommand**:
- Similar to `CollapseCommand` but operates on subtrees
- Takes `root_cell_ids` (plural - can collapse multiple subtrees)
- Includes `force` flag for safety override
- Delegates to regular collapse after collecting subtree cells

**Execution Flow**:
```
1. For each root_id in root_cell_ids:
   a. Call _collect_subtree_cells(root_id)
   b. Add all subtree cells to collapse set
2. Create CollapseCommand with collected cells
3. Delegate to CollapseService.execute()
4. Return CollapseResult
```

This approach reuses the safety validation and net removal logic from T01, avoiding duplication.

### 2.4 Collapse to Boundary

**Use Case**: User wants to "reset" a cell's expansion state without hiding the cell itself.

```
Example:
- Cell A is visible
- User expanded A → B, C
- User expanded B → D, E
- "Collapse to A boundary" hides B, C, D, E but keeps A visible
```

**Implementation**:
```python
def collapse_to_boundary(self, cell_id: CellId) -> CollapseResult:
    # Get all descendants (not including root)
    subtree = self._collect_subtree_cells(cell_id)
    descendants = subtree - {cell_id}

    if not descendants:
        return CollapseResult(success=False, message="No descendants to collapse")

    # Collapse descendants only
    cmd = CollapseCommand(cell_ids=descendants, force=False)
    return self.execute(cmd)
```

---

## 3. Key Design Decisions

### 3.1 Bidirectional Tracking vs Single Direction

**Decision**: Use bidirectional tracking (parent→children AND child→parent)

**Rationale**:
- Parent→children: Needed for subtree traversal (downward)
- Child→parent: Needed for "Collapse to Root" feature (upward)
- Enables future features like "Show Expansion Path" or breadcrumb navigation

**Alternative**: Only track parent→children
- Simpler data structure
- Cannot efficiently answer "What expanded this cell?"

**Trade-offs**:
- Pro: Supports both downward and upward queries efficiently
- Pro: Enables richer UX features (show expansion history, path highlighting)
- Con: Double memory overhead (two dictionaries)
- Con: Must keep both structures synchronized

### 3.2 Subtree Command vs Service Method

**Decision**: Provide both `CollapseSubtreeCommand` (for UI) and `collapse_to_boundary()` method (for internal use)

**Rationale**:
- Command pattern for user-initiated subtree collapse (fits undo/redo)
- Service method for "collapse to boundary" (internal operation, simpler API)
- Both delegate to core `execute()` after collecting cells

**Alternative**: Only provide command, no service method
- More consistent API
- Less convenient for internal use cases

**Trade-offs**:
- Pro: Flexibility for different use cases
- Pro: Commands enable undo/redo for subtree operations
- Con: Slightly more API surface area

### 3.3 Eager vs Lazy Subtree Collection

**Decision**: Eager collection (compute full subtree immediately)

**Rationale**:
- Subtrees are typically small (<100 cells)
- Eager collection simplifies logic (one-time cost)
- Results can be validated before collapse

**Alternative**: Lazy iterative collapse (collapse layer by layer)
- More complex state management
- Harder to implement atomic undo

**Trade-offs**:
- Pro: Simpler implementation, easier to test
- Pro: Atomic operation (all-or-nothing)
- Con: May be slower for very deep trees (deferred until profiling shows issue)

### 3.4 Expansion Parent Cleanup Strategy

**Decision**: Clean up tracking data when cells are collapsed

**Rationale**:
- Prevents memory leaks from stale expansion relationships
- Keeps data structures consistent with visible state
- Enables accurate subtree queries

**Implementation**:
```python
# When collapsing cell C (child of A):
1. Remove C from A's children set: _expansion_children[A].discard(C)
2. Remove C's parent mapping: del _expansion_parents[C]
3. Remove C's children mapping: del _expansion_children[C]
```

**Alternative**: Lazy cleanup (remove when parent is also collapsed)
- Simpler immediate logic
- Accumulates stale data

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E03-F02-T01 (Collapse Command)**:
- Requires `CollapseService` and `CollapseCommand`
- Reuses safety validation logic
- Depends on `_is_safe_to_collapse()` implementation

**E03-F04 (Expansion State Management)**:
- Requires `ExpansionStateRepository` implementation
- Must support parent-child tracking methods:
  - `get_expansion_parent(cell_id)`
  - `get_expansion_children(cell_id)`
  - `add_expanded_cells(parent_id, children)`

**E03-F01 (Hop-Based Expansion)**:
- Expansion operations must record parent-child relationships
- `ExpansionService.execute()` must call `add_expanded_cells()`

### 4.2 Downstream Integration

**E03-F02-T04 (Context Menu Integration)**:
- Provides "Collapse Subtree" menu option
- Calls `CollapseService.execute_subtree()`
- Enables/disables based on whether cell has children

**E04 (Undo/Redo)**:
- Subtree collapse must be undoable
- Undo rebuilds entire subtree (complex - may need special handling)
- History records subtree relationships

**Presentation Layer**:
- Canvas invokes subtree collapse from context menu
- Status messages reflect subtree size ("Collapsed 15 cells in subtree")

### 4.3 Integration Risks

**Risk**: Expansion service (E03-F01) doesn't record parent-child relationships
- Mitigation: Define interface upfront, coordinate with E03-F01 implementer
- Mitigation: Add validation to ensure tracking is working

**Risk**: Parent-child tracking becomes inconsistent
- Mitigation: Add debug assertions to validate consistency
- Mitigation: Unit tests verify cleanup after collapse

**Risk**: Circular expansion references (cell A expanded from B, B expanded from A)
- Mitigation: Should be impossible (cells can't expand themselves)
- Mitigation: Add detection and error handling if it occurs

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Subtree Collection Tests**:
```python
def test_collect_subtree_single_cell():
    # Cell with no children
    # Should return set containing only root

def test_collect_subtree_linear_chain():
    # A → B → C → D
    # collect_subtree(A) should return {A, B, C, D}

def test_collect_subtree_branching():
    # A → {B, C}, B → {D, E}
    # collect_subtree(A) should return {A, B, C, D, E}

def test_collect_subtree_multiple_roots():
    # A → {B, C}, X → {Y, Z}
    # Collapse subtrees [A, X] should return {A, B, C, X, Y, Z}

def test_collect_subtree_deep_tree():
    # 10-level deep expansion tree
    # Should handle efficiently (<50ms)
```

**Parent-Child Tracking Tests**:
```python
def test_add_expanded_cells_records_parent():
    state.add_expanded_cells(parent_id=A, new_cells={B, C})
    assert state.get_expansion_parent(B) == A
    assert state.get_expansion_parent(C) == A

def test_add_expanded_cells_records_children():
    state.add_expanded_cells(parent_id=A, new_cells={B, C})
    assert state.get_expansion_children(A) == {B, C}

def test_remove_cells_cleans_up_tracking():
    state.add_expanded_cells(A, {B, C})
    state.remove_cells({B})
    assert B not in state.get_expansion_children(A)
    assert state.get_expansion_parent(B) is None
```

**Subtree Collapse Tests**:
```python
def test_execute_subtree_collapses_all_descendants():
    # Build tree: A → {B, C}, B → {D}
    # Execute CollapseSubtreeCommand({A})
    # Should collapse A, B, C, D

def test_execute_subtree_respects_safety():
    # Cell B in subtree has connection to external cell
    # Should skip B but collapse safe cells

def test_execute_subtree_multiple_roots():
    # Collapse subtrees rooted at A and X simultaneously
    # Should handle both trees correctly
```

**Collapse to Boundary Tests**:
```python
def test_collapse_to_boundary_preserves_root():
    # A → {B, C}
    # collapse_to_boundary(A)
    # Should collapse B, C but keep A visible

def test_collapse_to_boundary_no_children():
    # Cell with no expansion children
    # Should return failure message
```

### 5.2 Integration Tests

**With Expansion Service**:
```python
def test_expansion_records_parent_child():
    expansion_service.expand(cell_A, hops=1)  # Reveals B, C
    children = expansion_state_repo.get_expansion_children(A)
    assert B in children and C in children

def test_sequential_expansions_build_tree():
    expansion_service.expand(cell_A, hops=1)  # A → {B, C}
    expansion_service.expand(cell_B, hops=1)  # B → {D, E}

    subtree = collapse_service._collect_subtree_cells(A)
    assert subtree == {A, B, C, D, E}
```

**With Canvas**:
```python
def test_canvas_collapse_subtree_removes_all_cells():
    # Render tree A → {B, C, D}
    # User right-clicks A, selects "Collapse Subtree"
    # Canvas should remove all four cells
```

### 5.3 Edge Cases

- Collapse subtree where root has no children (degenerate case)
- Collapse subtree with circular parent references (should be impossible, but test)
- Collapse subtree where some descendants are already hidden
- Multiple subtrees with overlapping cells (shouldn't happen, but test)
- Collapse subtree where safety check fails for some descendants

### 5.4 Performance Tests

```python
@pytest.mark.benchmark
def test_subtree_collection_performance():
    # Build tree with 100 cells (10 levels deep)
    tree = build_deep_tree(depth=10, branching=2)

    result = benchmark(collect_subtree_cells, root=tree.root)
    assert benchmark.stats.mean < 0.05  # <50ms
    assert len(result) == 100

@pytest.mark.benchmark
def test_parent_child_lookup_performance():
    # 1000 cells with random parent-child relationships
    result = benchmark(get_expansion_children, cell_id=random_cell)
    assert benchmark.stats.mean < 0.001  # <1ms (O(1) lookup)
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk**: Parent-child tracking data structures become inconsistent

**Impact**: High - Incorrect subtree collapse, memory leaks
**Probability**: Medium - Complex state updates during collapse
**Mitigation**:
- Encapsulate tracking updates in single methods
- Add validation checks in debug mode
- Unit tests verify consistency after every operation
- Consider immutable data structures (rebuild on change)

**Risk**: Memory overhead from tracking large expansion trees

**Impact**: Low - Each relationship is ~100 bytes (2 dict entries)
**Probability**: Low - Typical sessions have <1000 expansion relationships
**Mitigation**:
- Profile memory usage in realistic scenarios
- Consider compression (store tree as parent array)
- Provide "Clear Expansion History" if memory becomes issue

**Risk**: Subtree collection is slow for deep trees

**Impact**: Low - Collapse feels sluggish
**Probability**: Low - Typical trees are <10 levels deep
**Mitigation**:
- Profile with realistic data
- Implement iterative (non-recursive) traversal to avoid stack overflow
- Consider caching subtree results if repeated queries occur

### 6.2 UX Risks

**Risk**: Users confused by subtree vs single-cell collapse

**Impact**: Medium - Unintended collapse of large trees
**Probability**: Medium - Similar menu options may cause misclicks
**Mitigation**:
- Clear menu labels ("Collapse Cell" vs "Collapse Subtree")
- Show preview dialog with count ("Collapse 15 cells?")
- Make subtree collapse undoable
- Document behavior in help system

**Risk**: Collapse to boundary is not discoverable

**Impact**: Low - Useful feature goes unused
**Probability**: High - Not exposed in UI initially
**Mitigation**:
- Defer to P1 - focus on subtree collapse for MVP
- Consider adding to context menu if user feedback indicates need

### 6.3 Integration Risks

**Risk**: Expansion service forgets to record parent-child relationships

**Impact**: High - Subtree collapse doesn't work
**Probability**: Medium - Easy to forget in expansion implementation
**Mitigation**:
- Make `add_expanded_cells()` mandatory in expansion service
- Add integration test verifying tracking
- Code review to catch missing calls

**Risk**: Undo/redo for subtree collapse is complex

**Impact**: Medium - Undo may not fully restore state
**Probability**: Medium - Rebuilding subtree from history is non-trivial
**Mitigation**:
- Store full subtree state in undo history
- Test undo/redo extensively
- Consider special handling for subtree operations in undo system

---

## 7. Open Questions

### 7.1 Resolved Questions

**Q**: Should we track grandparent relationships (full ancestry)?
**A**: No, immediate parent-child is sufficient. Can reconstruct ancestry by traversing upward.

**Q**: What happens if user expands same cell from multiple parents?
**A**: Should not happen - cells can only be visible once. Expansion deduplication prevents this.

**Q**: Should collapsed subtrees be cached for faster re-expansion?
**A**: Defer to P1. For MVP, re-expansion recomputes from graph.

### 7.2 Open Questions

**Q**: Should "Collapse Subtree" be default collapse behavior?
**A**: **Needs decision**. Options:
  - Default to single-cell collapse (safer, more predictable)
  - Default to subtree collapse (more powerful, matches user intent)
  - Make configurable in settings
  - Use modifier key (Shift+Collapse = subtree)

**Q**: How to handle subtree collapse when descendants have external connections?
**A**: **Needs UX decision**. Options:
  - Collapse safe descendants, keep unsafe ones (partial collapse)
  - Fail entire operation if any descendant is unsafe
  - Show dialog listing unsafe descendants, let user decide

**Q**: Should we support "Collapse to Level N" (collapse all descendants beyond depth N)?
**A**: **Defer to P1**. Interesting feature but adds complexity. Wait for user feedback.

**Q**: Should parent-child relationships persist across sessions?
**A**: **Yes, but defer to session save/load (P1)**. For MVP, relationships lost on close.

---

## 8. Implementation Checklist

### 8.1 Phase 1: Tracking Infrastructure
- [ ] Extend `ExpansionStateRepository` protocol with parent-child methods
- [ ] Implement tracking data structures in expansion state
- [ ] Add `add_expanded_cells()` method
- [ ] Add `get_expansion_parent()` method
- [ ] Add `get_expansion_children()` method
- [ ] Write unit tests for tracking operations

### 8.2 Phase 2: Subtree Collection
- [ ] Implement `_collect_subtree_cells()` algorithm
- [ ] Write unit tests for linear chains
- [ ] Write unit tests for branching trees
- [ ] Write unit tests for deep trees
- [ ] Performance benchmarks for large subtrees

### 8.3 Phase 3: Subtree Collapse Command
- [ ] Create `CollapseSubtreeCommand` dataclass
- [ ] Implement `execute_subtree()` service method
- [ ] Integrate with existing collapse logic
- [ ] Write unit tests for subtree command
- [ ] Write integration tests with expansion service

### 8.4 Phase 4: Collapse to Boundary
- [ ] Implement `collapse_to_boundary()` method
- [ ] Write unit tests
- [ ] Document API usage
- [ ] Consider UI exposure (defer if time-constrained)

### 8.5 Phase 5: Cleanup and Integration
- [ ] Implement parent-child cleanup in `remove_cells()`
- [ ] Add validation for tracking consistency
- [ ] Integration tests with expansion service
- [ ] Update collapse service exports
- [ ] Complete documentation

---

## 9. References

- **Task Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F02/T02/E03-F02-T02.spec.md`
- **Feature Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F02/E03-F02.spec.md`
- **Epic Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/E03.spec.md`
- **Related Tasks**:
  - E03-F02-T01: Collapse Command Implementation (base logic)
  - E03-F02-T04: Context Menu Integration (UI exposure)
  - E03-F04: Expansion State Management (tracking implementation)
  - E03-F01: Hop-Based Expansion (records relationships)

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
