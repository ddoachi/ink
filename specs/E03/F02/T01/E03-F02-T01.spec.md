---
id: E03-F02-T01
title: Collapse Command Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E03-F02
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - collapse
  - command
  - application-layer
clickup_task_id: '86evzm2q3'
---

# Spec: E03-F02-T01 - Collapse Command Implementation

## 1. Overview

### 1.1 Problem Statement
The collapse functionality requires an application service and command handler to orchestrate the collapse operation. This includes validating which cells can be safely collapsed, updating the expansion state, and coordinating with the view layer to remove cells and nets from the visible schematic.

### 1.2 Goals
- Implement `CollapseCommand` in the application layer
- Create `CollapseService` to handle collapse orchestration
- Implement safety validation to prevent orphaning connected cells
- Support both single-cell and multi-cell collapse operations
- Record collapse actions in expansion history for undo/redo
- Provide clear error messages for invalid collapse attempts

---

## 2. Technical Requirements

### 2.1 File Structure

```
src/ink/application/
├── commands/
│   ├── __init__.py
│   └── collapse_command.py    # CollapseCommand handler
└── services/
    ├── __init__.py
    └── collapse_service.py    # CollapseService
```

### 2.2 Collapse Command

**File**: `src/ink/application/commands/collapse_command.py`

```python
from dataclasses import dataclass
from typing import Set
from ...domain.value_objects.identifiers import CellId

@dataclass(frozen=True)
class CollapseCommand:
    """Command to collapse selected cells"""
    cell_ids: Set[CellId]
    force: bool = False  # Skip safety validation if True

    def __post_init__(self):
        if not self.cell_ids:
            raise ValueError("cell_ids cannot be empty")


@dataclass(frozen=True)
class CollapseResult:
    """Result of collapse operation"""
    collapsed_cell_ids: Set[CellId]
    removed_net_ids: Set[str]
    skipped_cell_ids: Set[CellId]  # Cells that couldn't be safely collapsed
    success: bool
    message: str
```

### 2.3 Collapse Service

**File**: `src/ink/application/services/collapse_service.py`

```python
from typing import Set, Protocol
from ...domain.model import Cell, Net
from ...domain.value_objects.identifiers import CellId, NetId
from ...domain.repositories import DesignRepository
from ..commands.collapse_command import CollapseCommand, CollapseResult

class ExpansionStateRepository(Protocol):
    """Interface for expansion state management"""
    def get_visible_cells(self) -> Set[CellId]:
        ...

    def remove_cells(self, cell_ids: Set[CellId]) -> None:
        ...

    def get_cells_connected_to(self, cell_id: CellId) -> Set[CellId]:
        ...

    def record_collapse(self, cell_ids: Set[CellId]) -> None:
        """Record collapse action in history"""
        ...


class CollapseService:
    """Application service for collapsing cells"""

    def __init__(
        self,
        design_repo: DesignRepository,
        expansion_state_repo: ExpansionStateRepository
    ):
        self.design_repo = design_repo
        self.expansion_state_repo = expansion_state_repo

    def execute(self, command: CollapseCommand) -> CollapseResult:
        """Execute collapse command"""
        visible_cells = self.expansion_state_repo.get_visible_cells()

        # Validate cells exist and are visible
        invalid_cells = command.cell_ids - visible_cells
        if invalid_cells and not command.force:
            return CollapseResult(
                collapsed_cell_ids=set(),
                removed_net_ids=set(),
                skipped_cell_ids=invalid_cells,
                success=False,
                message=f"Cannot collapse invisible cells: {invalid_cells}"
            )

        # Determine which cells are safe to collapse
        safe_to_collapse = set()
        skipped = set()

        for cell_id in command.cell_ids:
            if command.force or self._is_safe_to_collapse(cell_id, visible_cells):
                safe_to_collapse.add(cell_id)
            else:
                skipped.add(cell_id)

        if not safe_to_collapse:
            return CollapseResult(
                collapsed_cell_ids=set(),
                removed_net_ids=set(),
                skipped_cell_ids=skipped,
                success=False,
                message="No cells can be safely collapsed. Use force=True to override."
            )

        # Calculate nets to remove
        removed_nets = self._calculate_nets_to_remove(safe_to_collapse, visible_cells)

        # Update expansion state
        self.expansion_state_repo.remove_cells(safe_to_collapse)
        self.expansion_state_repo.record_collapse(safe_to_collapse)

        message = f"Collapsed {len(safe_to_collapse)} cell(s)"
        if skipped:
            message += f", skipped {len(skipped)} cell(s) (connected to other visible cells)"

        return CollapseResult(
            collapsed_cell_ids=safe_to_collapse,
            removed_net_ids=removed_nets,
            skipped_cell_ids=skipped,
            success=True,
            message=message
        )

    def _is_safe_to_collapse(self, cell_id: CellId, visible_cells: Set[CellId]) -> bool:
        """Check if cell can be safely hidden without orphaning other cells"""
        # Get all cells connected to this cell
        connected = self.expansion_state_repo.get_cells_connected_to(cell_id)

        # Check if any other visible cells (excluding the cell itself) depend on it
        other_visible = connected.intersection(visible_cells) - {cell_id}

        # Safe to collapse if no other visible cells are connected
        return len(other_visible) == 0

    def _calculate_nets_to_remove(
        self,
        cells_to_collapse: Set[CellId],
        visible_cells: Set[CellId]
    ) -> Set[NetId]:
        """Determine which nets should be hidden after collapse"""
        design = self.design_repo.get_current_design()
        if not design:
            return set()

        nets_to_remove = set()
        remaining_visible = visible_cells - cells_to_collapse

        # For each net connected to collapsing cells
        for cell_id in cells_to_collapse:
            cell = design.get_cell(cell_id)
            if not cell:
                continue

            for pin_id in cell.pin_ids:
                pin = design.get_pin(pin_id)
                if not pin or not pin.net_id:
                    continue

                net = design.get_net(pin.net_id)
                if not net:
                    continue

                # Check if net is still connected to any remaining visible cells
                net_still_visible = False
                for net_pin_id in net.connected_pin_ids:
                    net_pin = design.get_pin(net_pin_id)
                    if net_pin:
                        # Find the cell that owns this pin
                        for visible_cell_id in remaining_visible:
                            visible_cell = design.get_cell(visible_cell_id)
                            if visible_cell and net_pin_id in visible_cell.pin_ids:
                                net_still_visible = True
                                break
                    if net_still_visible:
                        break

                if not net_still_visible:
                    nets_to_remove.add(net.id)

        return nets_to_remove
```

### 2.4 Module Exports

**File**: `src/ink/application/commands/__init__.py`

```python
from .expand_command import ExpandCommand, ExpandResult
from .collapse_command import CollapseCommand, CollapseResult

__all__ = [
    'ExpandCommand',
    'ExpandResult',
    'CollapseCommand',
    'CollapseResult',
]
```

---

## 3. Dependencies

- **Upstream**:
  - E03-F01 (Hop-Based Expansion) - requires expansion to exist before collapse
  - E03-F04 (Expansion State Management) - requires `ExpansionStateRepository`
  - E01-F03 (Domain Model) - uses Cell, Net, Pin entities
- **Downstream**:
  - E03-F02-T03 (Collapse Visual Feedback) - uses `CollapseResult`
  - E04 (Undo/Redo) - uses collapse history recording

---

## 4. Acceptance Criteria

- [ ] `CollapseCommand` dataclass with `cell_ids` and `force` fields
- [ ] `CollapseResult` dataclass with collapsed/removed/skipped cells and message
- [ ] `CollapseService` with `execute()` method
- [ ] `_is_safe_to_collapse()` validates cell has no connections to other visible cells
- [ ] `_calculate_nets_to_remove()` identifies nets that become invisible
- [ ] Collapse validation prevents orphaning connected cells (unless `force=True`)
- [ ] Empty `cell_ids` raises `ValueError`
- [ ] Invalid (non-visible) cell IDs return failure with error message
- [ ] Collapse action recorded in expansion history via `record_collapse()`
- [ ] Success message includes count of collapsed cells
- [ ] Warning message includes count of skipped cells
- [ ] Unit tests with 95%+ coverage
- [ ] Integration tests with mock repositories

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
