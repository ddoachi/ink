# E03-F02-T01 - Collapse Command Implementation: Pre-Implementation Documentation

## Document Information
- **Task**: E03-F02-T01 - Collapse Command Implementation
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements the application layer command and service for the collapse functionality. It provides the business logic for safely hiding previously expanded cells from the schematic view, ensuring that cells remain visible if they have connections to other visible parts of the schematic.

The collapse operation is the inverse of expansion - while expansion reveals new cells connected to a selected point, collapse hides cells that are no longer needed in the current view. This is essential for managing visual complexity in large netlists.

### 1.2 Problem Context

When users expand multiple cells during schematic exploration, the view can become cluttered with cells that are no longer relevant to the current analysis. The collapse operation provides a way to clean up the view by hiding selected cells. However, naive collapse (simply hiding all selected cells) can create problems:

1. **Orphaned Cells**: If we hide a cell that connects two visible regions, we break visual connectivity
2. **Disconnected Nets**: Nets may become partially visible if some but not all connected cells are hidden
3. **State Inconsistency**: The expansion state must be updated to reflect which cells are visible

The collapse service must intelligently determine which cells can be safely hidden without breaking the logical flow of the schematic.

### 1.3 Success Criteria

- Collapse command executes in <100ms for typical selections (1-10 cells)
- Safety validation correctly identifies cells that cannot be collapsed
- Expansion state remains consistent after collapse operations
- Clear error messages guide users when collapse cannot proceed
- Collapse history enables undo/redo functionality

---

## 2. Implementation Approach

### 2.1 Core Components

**CollapseCommand** (Immutable Command Object):
- Encapsulates collapse intent as a value object
- Contains set of cell IDs to collapse
- Includes `force` flag to override safety checks
- Validates that cell_ids is non-empty on construction

**CollapseResult** (Result Value Object):
- Reports outcome of collapse operation
- Lists successfully collapsed cells
- Lists nets that were removed from view
- Lists cells that were skipped due to safety concerns
- Provides user-friendly success/error messages

**CollapseService** (Application Service):
- Orchestrates collapse operation across domain and infrastructure layers
- Validates that requested cells are currently visible
- Performs safety analysis to prevent orphaning cells
- Calculates which nets should be removed
- Updates expansion state repository
- Records action in history for undo/redo

### 2.2 Collapse Safety Algorithm

The key challenge is determining which cells can be safely hidden. A cell is safe to collapse if and only if:

1. The cell is currently visible
2. No other visible cells (besides those being collapsed) are connected to it via shared nets

**Algorithm Steps**:

```
For each cell C in collapse_request:
  1. Get all nets connected to C
  2. For each net N:
     a. Get all cells connected to N
     b. Filter to visible cells
     c. Exclude cells in collapse_request
     d. If any cells remain → C is NOT safe (has external connections)
  3. If all nets have no external connections → C is safe
```

**Example**:
```
Visible cells: A, B, C, D
Nets: N1 (A→B), N2 (B→C), N3 (C→D)

Request: Collapse B
- N1 connects to A (visible, not in request) → B is NOT safe
- Cannot collapse B without orphaning the A→B→C path

Request: Collapse D
- N3 connects only to C→D
- If C is also being collapsed → D is safe
- If C is staying visible → D is NOT safe
```

### 2.3 Net Removal Logic

After determining safe cells to collapse, we must identify nets to remove. A net should be removed from view if:

1. All cells connected to the net are being collapsed, OR
2. The net has no remaining visible endpoints after collapse

**Algorithm**:
```
1. Collect all nets connected to cells being collapsed
2. For each net:
   a. Get all pins on the net
   b. Find cells that own those pins
   c. Check if any cells are still visible (not being collapsed)
   d. If no visible cells → mark net for removal
```

This ensures nets disappear when they no longer connect visible cells, but remain if they still have visible endpoints.

### 2.4 Expansion State Updates

The expansion state repository must be updated to:
1. Remove collapsed cells from `visible_cells` set
2. Remove hidden nets from `visible_nets` set
3. Clean up parent-child expansion tracking (if cell was an expansion parent)
4. Record the collapse action in history for undo/redo

---

## 3. Key Design Decisions

### 3.1 Command Pattern vs Direct Service Calls

**Decision**: Use Command pattern with immutable command objects

**Rationale**:
- Commands can be serialized for undo/redo
- Commands are testable in isolation
- Commands decouple UI from business logic
- Commands enable future features like scripting/macros

**Alternative**: Direct service method calls (`collapse_service.collapse_cells(cell_ids)`)
- Simpler implementation
- Harder to implement undo/redo
- Tight coupling between UI and service

**Trade-offs**:
- Pro: Better separation of concerns, future-proof for undo/redo
- Con: Slightly more boilerplate (command + result classes)

### 3.2 Safety Validation Strategy

**Decision**: Conservative safety checking with `force` override option

**Rationale**:
- Prevents accidental orphaning of cells
- Gives users control via force flag
- Provides clear feedback about why cells can't be collapsed

**Alternative**: No safety checking, always collapse requested cells
- Simpler implementation
- Risk of confusing user experience (cells mysteriously orphaned)

**Alternative**: Show preview dialog before every collapse
- Maximum safety
- Annoying for power users, slows workflow

**Trade-offs**:
- Pro: Balances safety with flexibility
- Pro: Educates users about schematic connectivity
- Con: Requires additional UI for force collapse confirmation

### 3.3 Repository Interface Design

**Decision**: Define `ExpansionStateRepository` as a Protocol (interface)

**Rationale**:
- Decouples service from concrete state implementation
- Enables testing with mock repositories
- Follows dependency inversion principle
- Future-proofs for different state storage mechanisms (memory, database, file)

**Implementation Note**: Actual implementation will be in E03-F04 (Expansion State Management) task

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**E01-F03 (Domain Model)**:
- Requires `Cell`, `Net`, `Pin` entities
- Uses `CellId`, `NetId` value objects
- Needs `DesignRepository` interface

**E03-F01 (Hop-Based Expansion)**:
- Collapse is the inverse of expansion
- Assumes expansion operations have populated `visible_cells`
- May reference `ExpansionService` patterns for consistency

**E03-F04 (Expansion State Management)**:
- Requires `ExpansionStateRepository` implementation
- Depends on parent-child tracking for subtree collapse (T02)
- Uses history recording for undo/redo

### 4.2 Downstream Integration

**E03-F02-T03 (Collapse Visual Feedback)**:
- Consumes `CollapseResult` to drive animations
- Uses `collapsed_cell_ids` and `removed_net_ids` for fade-out
- Displays warning dialogs based on `skipped_cell_ids`

**E04 (Undo/Redo)**:
- History recording enables undo of collapse
- Undo converts collapse back to expansion
- Redo replays collapse from history

**Presentation Layer Integration**:
- `SchematicCanvas` will call `CollapseService.execute()`
- Canvas receives `CollapseResult` and updates view accordingly
- Status bar displays result messages

### 4.3 Integration Risks

**Risk**: Expansion state implementation may not support all required operations
- Mitigation: Define complete `ExpansionStateRepository` protocol upfront
- Mitigation: Create mock implementation for testing

**Risk**: Domain model may not efficiently support net-to-cells queries
- Mitigation: Profile performance with realistic netlists
- Mitigation: Add caching layer if needed

---

## 5. Testing Strategy

### 5.1 Unit Tests

**Command Validation Tests**:
```python
def test_collapse_command_rejects_empty_cell_ids():
    with pytest.raises(ValueError):
        CollapseCommand(cell_ids=set())

def test_collapse_command_is_immutable():
    cmd = CollapseCommand(cell_ids={CellId("A")})
    with pytest.raises(AttributeError):
        cmd.cell_ids.add(CellId("B"))
```

**Safety Analysis Tests**:
```python
def test_is_safe_to_collapse_single_isolated_cell():
    # Cell with no connections to other visible cells
    # Should return True

def test_is_safe_to_collapse_cell_with_external_connections():
    # Cell connected to other visible cells via net
    # Should return False

def test_is_safe_to_collapse_multiple_cells_same_net():
    # Cells A, B on same net, no other connections
    # Should return True for both

def test_force_flag_bypasses_safety_check():
    # Cell with external connections + force=True
    # Should proceed with collapse
```

**Net Removal Tests**:
```python
def test_calculate_nets_to_remove_isolated_net():
    # Net connecting only collapsing cells
    # Should be marked for removal

def test_calculate_nets_to_remove_shared_net():
    # Net connecting collapsing cells + visible cells
    # Should NOT be removed

def test_calculate_nets_to_remove_multi_driver_net():
    # Net with multiple drivers, some collapsing
    # Should remain if any driver is still visible
```

**Service Execution Tests**:
```python
def test_execute_collapse_success():
    # Valid collapse request
    # Should return CollapseResult with success=True

def test_execute_collapse_invalid_cell_ids():
    # Cell IDs not in visible_cells
    # Should return failure with clear message

def test_execute_collapse_records_history():
    # Successful collapse
    # Should call expansion_state_repo.record_collapse()

def test_execute_collapse_skips_unsafe_cells():
    # Request includes safe and unsafe cells
    # Should collapse safe cells, skip unsafe ones
```

### 5.2 Integration Tests

**With Mock Repository**:
```python
def test_collapse_updates_expansion_state():
    mock_repo = MockExpansionStateRepository()
    service = CollapseService(design_repo, mock_repo)

    result = service.execute(CollapseCommand(cell_ids={...}))

    assert mock_repo.remove_cells_called
    assert mock_repo.record_collapse_called
```

**With Real Domain Model**:
```python
def test_collapse_complex_netlist():
    # Load realistic netlist (counter example)
    # Expand several cells
    # Collapse subset
    # Verify state consistency
```

### 5.3 Edge Cases

- Collapse all visible cells (should fail or warn)
- Collapse non-existent cell ID
- Collapse already-hidden cell
- Collapse cell that is expansion parent (impacts T02)
- Multi-driver nets with partial collapse
- Circular connectivity patterns

### 5.4 Performance Tests

```python
@pytest.mark.benchmark
def test_collapse_performance_10_cells(benchmark):
    result = benchmark(service.execute, collapse_10_cells_cmd)
    assert benchmark.stats.mean < 0.1  # <100ms

@pytest.mark.benchmark
def test_collapse_performance_100_cells(benchmark):
    result = benchmark(service.execute, collapse_100_cells_cmd)
    assert benchmark.stats.mean < 0.5  # <500ms for large operations
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk**: Safety algorithm is too conservative, preventing valid collapses

**Impact**: Medium - User frustration, workflow interruption
**Probability**: Medium - Complex connectivity patterns may trigger false positives
**Mitigation**:
- Provide detailed explanation in error message
- Offer `force` flag as escape hatch
- Add unit tests for all edge cases
- Consider relaxed safety mode as future enhancement

**Risk**: Net removal calculation is inefficient for large netlists

**Impact**: Medium - Slow collapse operations
**Probability**: Low - Most collapses involve <100 cells
**Mitigation**:
- Profile with realistic data
- Cache net-to-cells mappings if needed
- Consider incremental net updates instead of full recalculation

**Risk**: Expansion state repository interface is incomplete

**Impact**: High - Cannot implement service without required operations
**Probability**: Low - Interface defined in spec
**Mitigation**:
- Define complete protocol before implementation
- Create mock implementation for early testing
- Coordinate with E03-F04 task owner

### 6.2 UX Risks

**Risk**: Error messages are too technical, confusing users

**Impact**: Medium - Users don't understand why collapse failed
**Probability**: Medium - Graph theory concepts may not map to user mental model
**Mitigation**:
- Use plain language (avoid "orphan", "connectivity graph")
- Show visual preview of affected cells
- Provide actionable suggestions ("Try collapsing connected cells together")

**Risk**: Force collapse is too easy to trigger accidentally

**Impact**: Medium - Users break schematic connectivity
**Probability**: Low - Requires explicit confirmation
**Mitigation**:
- Show warning dialog with affected cells listed
- Require explicit "Force Collapse" button click
- Make force collapse undoable

### 6.3 Integration Risks

**Risk**: Collapse state becomes desynchronized with canvas

**Impact**: High - Visual inconsistency, duplicate cells
**Probability**: Low - Service updates state atomically
**Mitigation**:
- Canvas renders only cells in `visible_cells` set
- Add validation checks in debug mode
- Emit events for state changes (observer pattern)

---

## 7. Open Questions

### 7.1 Resolved Questions

**Q**: Should collapse be synchronous or asynchronous?
**A**: Synchronous for MVP. Collapse is typically fast (<100ms), and async adds complexity.

**Q**: What happens if user collapses while expansion is in progress?
**A**: Serialize operations - expansion must complete before collapse (or vice versa).

**Q**: Should we support batch collapse of multiple selections?
**A**: Yes - command accepts `Set[CellId]` for multiple cells.

### 7.2 Open Questions

**Q**: Should `force` collapse be a separate command or a flag?
**A**: Flag for now (simpler). Could refactor to `ForceCollapseCommand` later if needed.

**Q**: How to handle collapse of cells that are expansion parents?
**A**: To be addressed in T02 (Subtree Collapse). Should we collapse children automatically or warn?

**Q**: Should collapse operation be cancellable?
**A**: Not for MVP (operation is fast). Defer to P1 if slow collapse becomes an issue.

**Q**: Should we show collapse preview before execution?
**A**: Not for MVP. Could add as enhancement - show which cells/nets will disappear.

---

## 8. Implementation Checklist

### 8.1 Phase 1: Command Infrastructure
- [ ] Create `collapse_command.py` with `CollapseCommand` dataclass
- [ ] Create `CollapseResult` dataclass
- [ ] Add validation to `CollapseCommand.__post_init__()`
- [ ] Write unit tests for command validation
- [ ] Update `commands/__init__.py` exports

### 8.2 Phase 2: Service Implementation
- [ ] Create `collapse_service.py` with `CollapseService` class
- [ ] Implement `execute()` method skeleton
- [ ] Add `_is_safe_to_collapse()` helper method
- [ ] Add `_calculate_nets_to_remove()` helper method
- [ ] Write unit tests for helper methods

### 8.3 Phase 3: Safety Logic
- [ ] Implement safety validation algorithm
- [ ] Add support for `force` flag
- [ ] Generate appropriate error messages
- [ ] Write tests for safety edge cases

### 8.4 Phase 4: Integration
- [ ] Define `ExpansionStateRepository` protocol
- [ ] Integrate with domain model repositories
- [ ] Add history recording
- [ ] Write integration tests with mock repos

### 8.5 Phase 5: Polish
- [ ] Performance profiling and optimization
- [ ] Improve error messages based on user feedback
- [ ] Add debug logging
- [ ] Complete documentation and docstrings
- [ ] Code review and refactoring

---

## 9. References

- **Task Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F02/T01/E03-F02-T01.spec.md`
- **Feature Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/F02/E03-F02.spec.md`
- **Epic Spec**: `/home/joohan/dev/project-ink/ink/specs/E03/E03.spec.md`
- **Architecture**: `/home/joohan/dev/project-ink/ink/docs/architecture/ddd-architecture.md`
- **Related Tasks**:
  - E03-F02-T02: Subtree Collapse Logic
  - E03-F02-T03: Collapse Visual Feedback
  - E03-F04: Expansion State Management

---

## 10. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
