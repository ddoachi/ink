---
id: E01-F01-T03
title: Cell Instance Parser
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F01
created: 2025-12-26
estimated_hours: 4-5
actual_hours:
effort: Small
tags:
  - parsing
  - infrastructure
  - domain-model
clickup_task_id: ''
---

# Spec: E01-F01-T03 - Cell Instance Parser

## 1. Overview

### 1.1 Problem Statement
CDL instance lines (X-prefixed) declare cell instantiations and their net connections. The parser must extract instance names, cell types, and map connection lists to cell ports using subcircuit definitions. This creates the fundamental connectivity graph needed for schematic visualization.

### 1.2 Goals
- Parse X-prefixed instance lines to extract instance name, nets, and cell type
- Map positional net list to port names using subcircuit definitions
- Create `CellInstance` data structures with port-to-net mappings
- Handle instances with missing or extra connections gracefully
- Report warnings for unknown cell types

---

## 2. Technical Requirements

### 2.1 Implementation Details

**Location**: `src/ink/infrastructure/parsing/instance_parser.py`

**Domain Model** (add to `src/ink/domain/value_objects/instance.py`):
```python
from dataclasses import dataclass
from typing import Dict

@dataclass(frozen=True)
class CellInstance:
    """Parsed cell instance from CDL"""
    name: str                      # Instance name (e.g., "XI1", "U_CORE/U_ALU/XI_ADD")
    cell_type: str                 # Cell type reference (e.g., "INV_X1")
    connections: Dict[str, str]    # Port -> Net mapping (e.g., {"A": "net1", "Y": "net2"})

    def __post_init__(self):
        """Validate instance"""
        if not self.name:
            raise ValueError("Instance name cannot be empty")
        if not self.cell_type:
            raise ValueError(f"Instance {self.name} missing cell type")
        if not self.name.startswith('X'):
            raise ValueError(f"Instance name {self.name} must start with 'X'")
```

**Parser Class**:
```python
from typing import Optional, List
from ..domain.value_objects.instance import CellInstance
from ..domain.value_objects.subcircuit import SubcircuitDefinition
from .cdl_lexer import CDLToken

class InstanceParser:
    """Parser for X-prefixed cell instances"""

    def __init__(self, subcircuit_defs: Dict[str, SubcircuitDefinition]):
        """Initialize with subcircuit definitions for port mapping

        Args:
            subcircuit_defs: Map of cell_type -> SubcircuitDefinition
        """
        self._subcircuit_defs = subcircuit_defs
        self._warnings: List[str] = []

    def parse_instance_line(self, token: CDLToken) -> CellInstance:
        """Parse instance line

        Format: X<instance_name> net1 net2 ... netN cell_type

        Args:
            token: INSTANCE token from lexer

        Returns:
            CellInstance value object

        Raises:
            ValueError: If line format is invalid
        """
        pass

    def _map_connections(
        self,
        nets: List[str],
        cell_type: str
    ) -> Dict[str, str]:
        """Map positional net list to port names

        Uses subcircuit definition port order to create mapping.

        Args:
            nets: Ordered list of net names from instance line
            cell_type: Cell type to look up port definition

        Returns:
            Dict mapping port_name -> net_name

        Raises:
            ValueError: If connection count mismatch is severe
        """
        pass

    def _validate_connection_count(
        self,
        net_count: int,
        port_count: int,
        instance_name: str
    ) -> None:
        """Validate net/port count match, log warning if mismatch"""
        pass

    def get_warnings(self) -> List[str]:
        """Return accumulated parsing warnings"""
        return self._warnings
```

### 2.2 API/Interface

**Usage Example**:
```python
# After parsing subcircuit definitions
instance_parser = InstanceParser(subcircuit_defs)

for token in lexer.tokenize():
    if token.line_type == LineType.INSTANCE:
        instance = instance_parser.parse_instance_line(token)
        # Add to design graph

# Check for warnings
for warning in instance_parser.get_warnings():
    logger.warning(warning)
```

**Connection Mapping Example**:
```python
# Given:
# .SUBCKT INV A Y VDD VSS
# XI1 net1 net2 VDD VSS INV

# Results in:
instance = CellInstance(
    name="XI1",
    cell_type="INV",
    connections={
        "A": "net1",
        "Y": "net2",
        "VDD": "VDD",
        "VSS": "VSS"
    }
)
```

### 2.3 Testing Requirements

**Unit Tests** (`tests/unit/infrastructure/parsing/test_instance_parser.py`):
```python
def test_parse_simple_instance():
    """Test basic instance parsing with known cell type"""
    subckt_def = SubcircuitDefinition("INV", ["A", "Y", "VDD", "VSS"])
    defs = {"INV": subckt_def}
    parser = InstanceParser(defs)

    token = CDLToken(5, LineType.INSTANCE, "XI1 net1 net2 VDD VSS INV", "...")
    instance = parser.parse_instance_line(token)

    assert instance.name == "XI1"
    assert instance.cell_type == "INV"
    assert instance.connections == {
        "A": "net1",
        "Y": "net2",
        "VDD": "VDD",
        "VSS": "VSS"
    }

def test_parse_hierarchical_instance_name():
    """Test instance with hierarchical path in name"""
    # XI_CORE/U_ALU/XI_ADD net1 net2 ADDER
    pass

def test_unknown_cell_type_warning():
    """Test warning logged for unknown cell type"""
    parser = InstanceParser({})  # No definitions
    token = CDLToken(5, LineType.INSTANCE, "XI1 net1 net2 UNKNOWN", "...")

    instance = parser.parse_instance_line(token)
    assert instance.cell_type == "UNKNOWN"
    assert len(parser.get_warnings()) > 0
    assert "UNKNOWN" in parser.get_warnings()[0]

def test_connection_count_mismatch():
    """Test handling of too few/too many connections"""
    subckt_def = SubcircuitDefinition("INV", ["A", "Y", "VDD", "VSS"])
    parser = InstanceParser({"INV": subckt_def})

    # Too few connections
    token = CDLToken(5, LineType.INSTANCE, "XI1 net1 net2 INV", "...")
    instance = parser.parse_instance_line(token)
    assert len(parser.get_warnings()) > 0

def test_power_ground_net_names():
    """Test instances connected to VDD/VSS"""
    subckt_def = SubcircuitDefinition("INV", ["A", "Y", "VDD", "VSS"])
    parser = InstanceParser({"INV": subckt_def})

    token = CDLToken(5, LineType.INSTANCE, "XI1 in out VDD VSS INV", "...")
    instance = parser.parse_instance_line(token)
    assert instance.connections["VDD"] == "VDD"
    assert instance.connections["VSS"] == "VSS"

def test_instance_name_validation():
    """Test error on invalid instance name (missing X prefix)"""
    parser = InstanceParser({})
    token = CDLToken(5, LineType.INSTANCE, "I1 net1 net2 INV", "...")

    with pytest.raises(ValueError, match="must start with 'X'"):
        parser.parse_instance_line(token)
```

**Edge Cases**:
- Instance with no nets (just name and cell type)
- Very long instance names with deep hierarchy
- Cell types with underscores and numbers
- Connections to numbered nets (net<0>, net<7>)
- Multiple instances of same cell type
- Instance with all connections to same net

---

## 3. Dependencies
- **Upstream**:
  - E01-F01-T01 (Lexer) - provides INSTANCE tokens
  - E01-F01-T02 (Subcircuit Parser) - provides port definitions
- **Downstream**:
  - E01-F01-T05 (Parser Integration) - assembles instances into Design

---

## 4. Acceptance Criteria
- [ ] Parse X-prefixed instance lines to extract name, nets, and cell type
- [ ] Map positional net list to port names using subcircuit definitions
- [ ] Create `CellInstance` value objects with complete port-to-net mapping
- [ ] Handle unknown cell types gracefully with warnings (don't fail)
- [ ] Detect connection count mismatches and log warnings
- [ ] Validate instance names start with 'X' prefix
- [ ] Support hierarchical instance names with '/' separators
- [ ] 95%+ test coverage with all edge cases
- [ ] Successfully parse all instances from sample CDL file

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F01 split |
