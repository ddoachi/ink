# Pre-Implementation Documentation: E01-F01-T03 - Cell Instance Parser

## Overview

### Problem Context
CDL instance lines (X-prefixed) are the core connectivity data in gate-level netlists. Each instance line declares:
- An instance name (e.g., `XI1`)
- A list of nets connected to the instance ports
- A cell type reference (e.g., `INV`)

The challenge is mapping the positional net list to named ports using subcircuit definitions. For example:

```
.SUBCKT INV A Y VDD VSS
XI1 net1 net2 VDD VSS INV
```

Here, the parser must map:
- `net1` → port `A` (position 0)
- `net2` → port `Y` (position 1)
- `VDD` → port `VDD` (position 2)
- `VSS` → port `VSS` (position 3)

This component is critical for building the connectivity graph that drives schematic visualization.

### Goals
Build a robust instance parser that creates validated `CellInstance` value objects with complete port-to-net mappings, while gracefully handling missing definitions and connection mismatches.

---

## Implementation Approach

### High-Level Strategy

**Architecture Pattern**: Parser with dependency injection of subcircuit definitions

**Key Components**:
1. `CellInstance` value object - Immutable domain model
2. `InstanceParser` - Stateful parser with warning collection
3. Port-to-net mapping algorithm

**Processing Flow**:
```
INSTANCE Token → Parse Line → Extract Name/Nets/Type →
Lookup Definition → Map Ports → Validate → Create Instance
```

### Algorithm Design

**Parsing Instance Line**:
```
Input: "XI1 net1 net2 VDD VSS INV"
Steps:
1. Split on whitespace: ["XI1", "net1", "net2", "VDD", "VSS", "INV"]
2. Instance name = tokens[0]
3. Cell type = tokens[-1]
4. Net list = tokens[1:-1]
5. Lookup subcircuit definition for cell type
6. Map nets to ports positionally
7. Validate connection count
8. Create CellInstance with connections dict
```

**Port-to-Net Mapping**:
```python
def _map_connections(nets: List[str], cell_type: str) -> Dict[str, str]:
    definition = self._subcircuit_defs.get(cell_type)

    if not definition:
        # Unknown cell type - create dummy mapping
        self._warnings.append(f"Unknown cell type: {cell_type}")
        return {f"port{i}": net for i, net in enumerate(nets)}

    if len(nets) != len(definition.ports):
        # Connection count mismatch - warn and map available
        self._validate_connection_count(len(nets), len(definition.ports), instance_name)

    # Zip ports and nets positionally
    return dict(zip(definition.ports, nets))
```

### Data Structures

```python
@dataclass(frozen=True)
class CellInstance:
    name: str                      # Instance name (must start with X)
    cell_type: str                 # Cell type reference
    connections: Dict[str, str]    # port_name -> net_name

    def __post_init__(self):
        # Validate name starts with X
        # Validate cell_type not empty
        # Convert connections to immutable mapping

class InstanceParser:
    _subcircuit_defs: Dict[str, SubcircuitDefinition]
    _warnings: List[str]           # Accumulated warnings
```

---

## Key Design Decisions

### Decision 1: Unknown Cell Type Handling

**Options**:
- A) Raise error, halt parsing
- B) Log warning, create instance with dummy port mapping
- C) Skip instance entirely

**Recommendation**: Option B (Warn and continue)

**Rationale**:
- Supports partial loading of designs with missing library cells
- User can still visualize known portions of design
- Warnings provide feedback for debugging
- Consistent with "graceful degradation" principle

**Implementation**:
```python
if cell_type not in self._subcircuit_defs:
    self._warnings.append(
        f"Line {token.line_num}: Unknown cell type '{cell_type}' "
        f"for instance '{instance_name}'"
    )
    # Create generic port names: port0, port1, etc.
    connections = {f"port{i}": net for i, net in enumerate(nets)}
```

### Decision 2: Connection Count Mismatch Handling

**Options**:
- A) Raise error on any mismatch
- B) Warn and pad/truncate to match
- C) Warn and map available, leave unconnected ports as None

**Recommendation**: Option C (Warn and partial map)

**Rationale**:
- Some CDL variations allow optional ports (e.g., bulk connections)
- Better to have partial connectivity than fail completely
- Warnings alert user to potential issues

**Mapping Rules**:
- Too few nets: Map available, remaining ports → None (or skip)
- Too many nets: Map up to port count, ignore extra nets

**Implementation**:
```python
if len(nets) < len(ports):
    self._warnings.append(f"Instance {name} has too few connections")
    # Map available nets, leave rest unmapped
    connections = {p: n for p, n in zip(ports, nets)}

elif len(nets) > len(ports):
    self._warnings.append(f"Instance {name} has too many connections")
    # Map first N nets, ignore extras
    connections = dict(zip(ports, nets[:len(ports)]))
```

### Decision 3: Hierarchical Instance Name Format

**Options**:
- A) Accept any format (no validation)
- B) Validate flat names only (no `/` separators)
- C) Support hierarchical paths with `/` separators

**Recommendation**: Option C (Support hierarchical)

**Rationale**:
- Some CDL files use hierarchical naming (e.g., `U_CORE/U_ALU/XI1`)
- Needed for proper hierarchy panel display
- No performance penalty for supporting

**Validation**: Name must start with `X`, can contain `/` for hierarchy

### Decision 4: Connection Dict Immutability

**Options**:
- A) Store as regular dict (mutable)
- B) Store as `MappingProxyType` (read-only view)
- C) Convert to frozendict or tuple of pairs

**Recommendation**: Option B (MappingProxyType)

**Rationale**:
- Prevents accidental mutation
- Compatible with dict API (no changes needed by consumers)
- Standard library solution

**Implementation**:
```python
from types import MappingProxyType

@dataclass(frozen=True)
class CellInstance:
    name: str
    cell_type: str
    connections: Dict[str, str]

    def __post_init__(self):
        # Freeze connections dict
        object.__setattr__(
            self, 'connections',
            MappingProxyType(self.connections)
        )
```

### Decision 5: Warning Collection Strategy

**Options**:
- A) Raise warnings immediately with `warnings.warn()`
- B) Collect in list, return at end
- C) Use logging module

**Recommendation**: Option B (Collect in list)

**Rationale**:
- Allows caller to decide how to present warnings
- Supports progress UI (show warnings after completion)
- Testable (check warning count/content in tests)

**Interface**:
```python
def get_warnings(self) -> List[str]:
    return self._warnings.copy()
```

---

## Dependencies and Integration Points

### Upstream Dependencies

**E01-F01-T01 (CDL Lexer)**:
- Requires `CDLToken` with `LineType.INSTANCE`
- Expects cleaned content (comments removed, continuation joined)

**E01-F01-T02 (Subcircuit Parser)**:
- Requires `SubcircuitDefinition` objects
- Needs definitions map passed to constructor
- Port list must be in correct order

**Required Imports**:
```python
from .cdl_lexer import CDLToken, LineType
from .subcircuit_parser import SubcircuitDefinition
from ..domain.value_objects.instance import CellInstance
```

### Downstream Consumers

**E01-F01-T05 (Parser Integration)**:
- Collects instances from parser
- Aggregates warnings for error reporting
- Builds `Design` aggregate with instances

**E01-F03 (Graph Construction)**:
- Uses `CellInstance.connections` to build graph edges
- Relies on complete port-to-net mapping

### Interface Contract

**Input**:
- `CDLToken` with type `INSTANCE`
- `Dict[str, SubcircuitDefinition]` (constructor)

**Output**: `CellInstance` value object

**Guarantees**:
- All returned instances have valid names (X-prefix)
- Connections dict is immutable
- Warnings accumulated for retrieval

**Error Conditions**:
- Invalid instance name format → `ValueError`
- Empty cell type → `ValueError`
- Unknown cell type → Warning (not error)
- Connection mismatch → Warning (not error)

---

## Testing Strategy

### Unit Test Coverage

**Core Functionality**:
1. `test_parse_simple_instance` - Basic instance with known cell type
2. `test_parse_hierarchical_instance_name` - Path with `/` separators
3. `test_parse_power_ground_connections` - VDD/VSS net names
4. `test_connection_mapping_order` - Verify positional mapping

**Unknown Cell Types**:
5. `test_unknown_cell_type_warning` - Warning logged, instance created
6. `test_unknown_cell_generic_ports` - Dummy port names generated
7. `test_multiple_unknown_cells` - Multiple warnings accumulated

**Connection Mismatches**:
8. `test_too_few_connections` - Partial mapping, warning
9. `test_too_many_connections` - Truncated mapping, warning
10. `test_exact_connection_count` - No warning

**Validation**:
11. `test_instance_name_starts_with_x` - X-prefix validation
12. `test_instance_name_invalid_prefix` - Error on wrong prefix
13. `test_empty_cell_type` - Error on missing type

**Edge Cases**:
14. `test_single_port_instance` - Minimal case
15. `test_large_instance_100_ports` - Stress test
16. `test_instance_all_same_net` - All connections to VDD (valid)
17. `test_instance_with_bus_nets` - Nets like `data<7>`

### Test Data Strategy

**Sample Tokens**:
```python
# Simple instance
subckt = SubcircuitDefinition("INV", ["A", "Y", "VDD", "VSS"])
defs = {"INV": subckt}
token = CDLToken(5, LineType.INSTANCE, "XI1 net1 net2 VDD VSS INV", "...")

parser = InstanceParser(defs)
instance = parser.parse_instance_line(token)

assert instance.name == "XI1"
assert instance.cell_type == "INV"
assert instance.connections == {
    "A": "net1", "Y": "net2", "VDD": "VDD", "VSS": "VSS"
}
```

**Fixtures**:
- `sample_subcircuit_defs` - Common cell types (INV, NAND, NOR)
- `sample_instance_tokens` - Various instance formats

### Integration Testing

**With Lexer and Subcircuit Parser**:
```python
def test_end_to_end_instance_parsing(tmp_path):
    cdl = """
    .SUBCKT INV A Y VDD VSS
    .ENDS INV

    .SUBCKT TOP IN OUT VDD VSS
    XI1 IN net1 VDD VSS INV
    XI2 net1 OUT VDD VSS INV
    .ENDS TOP
    """

    file_path = tmp_path / "test.ckt"
    file_path.write_text(cdl)

    # Full parsing pipeline
    lexer = CDLLexer(file_path)
    subckt_parser = SubcircuitParser()

    tokens = list(lexer.tokenize())
    for token in tokens:
        if token.line_type == LineType.SUBCKT:
            subckt_parser.parse_subckt_line(token)

    instance_parser = InstanceParser(subckt_parser._definitions)
    instances = []

    for token in tokens:
        if token.line_type == LineType.INSTANCE:
            instances.append(instance_parser.parse_instance_line(token))

    assert len(instances) == 2
    assert instances[0].connections["A"] == "IN"
    assert instances[1].connections["Y"] == "OUT"
```

---

## Risks and Considerations

### Risk 1: Port Ordering Ambiguity
**Likelihood**: Medium
**Impact**: High

**Description**: If subcircuit definitions have incorrect port order, all instances will have wrong connectivity

**Mitigation**:
- Rely on CDL generation tools to produce correct order
- Document that port order is positional, not named
- Add validation in E01-F01-T02 (subcircuit parser) to detect common issues

### Risk 2: Hierarchical Path Parsing
**Likelihood**: Low
**Impact**: Low

**Description**: Some tools may use different hierarchy separators (`.`, `/`, `_`)

**Mitigation**:
- Support `/` as primary separator for MVP
- Document supported format
- Add configuration option in future if needed

### Risk 3: Special Net Name Characters
**Likelihood**: Medium
**Impact**: Low

**Description**: Net names with brackets, backslashes (e.g., `net<0>`, `\net[7]`)

**Mitigation**:
- E01-F01-T04 (Net Normalizer) handles special characters
- Instance parser just stores raw names
- Normalization happens downstream

### Risk 4: Warning Overload
**Likelihood**: Medium
**Impact**: Low

**Description**: Large designs with many missing cells could generate thousands of warnings

**Mitigation**:
- Limit warnings to unique cell types (deduplicate)
- Provide summary (e.g., "100 instances of unknown cell UNKNOWN_X1")
- Add warning threshold in integration layer

### Implementation Complexity
**Overall**: Medium

**Rationale**:
- Mapping algorithm is straightforward
- Error handling adds complexity (graceful degradation)
- Domain model validation requires care
- Good test coverage needed for edge cases

### Integration Challenges
**Level**: Medium

**Considerations**:
- Depends on both lexer and subcircuit parser (two dependencies)
- Timing: Must wait for subcircuit definitions before parsing instances
- Error handling: Balance strictness vs. flexibility

---

## Success Metrics

### Functional Requirements
- [ ] 95%+ code coverage
- [ ] Parse all instances from PRD sample file
- [ ] Correct port-to-net mapping for all instances
- [ ] Graceful handling of unknown cell types (no crashes)

### Non-Functional Requirements
- [ ] Parse 100K instances in <2 seconds
- [ ] Warning messages include line numbers and instance names
- [ ] Memory efficient (immutable value objects)

### Quality Gates
- [ ] All unit and integration tests pass
- [ ] Mypy strict type checking passes
- [ ] Connection dict immutability enforced
- [ ] Clear documentation with examples

---

## Implementation Checklist

### Phase 1: Domain Model (0.5-1 hour)
- [ ] Create `src/ink/domain/value_objects/instance.py`
- [ ] Implement `CellInstance` dataclass
- [ ] Add validation in `__post_init__`
- [ ] Implement connection dict freezing
- [ ] Write domain model tests

### Phase 2: Parser Core (1.5-2 hours)
- [ ] Create `src/ink/infrastructure/parsing/instance_parser.py`
- [ ] Implement `InstanceParser.__init__`
- [ ] Implement `parse_instance_line` method
- [ ] Implement `_map_connections` method
- [ ] Implement `_validate_connection_count` method
- [ ] Add warning collection

### Phase 3: Testing (1.5-2 hours)
- [ ] Write parsing tests (simple, hierarchical, various cell types)
- [ ] Write unknown cell type tests
- [ ] Write connection mismatch tests
- [ ] Write validation tests
- [ ] Write edge case tests

### Phase 4: Integration (0.5-1 hour)
- [ ] Integration test with lexer + subcircuit parser
- [ ] Performance test with large instance count
- [ ] Type checking
- [ ] Linting

**Total Estimated Time**: 4-5 hours (matches spec estimate)
