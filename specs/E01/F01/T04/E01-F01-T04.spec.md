---
id: E01-F01-T04
title: Net Name Normalization
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F01
created: 2025-12-26
estimated_hours: 3-4
actual_hours:
effort: Small
tags:
  - parsing
  - infrastructure
  - data-normalization
clickup_task_id: ''
---

# Spec: E01-F01-T04 - Net Name Normalization

## 1. Overview

### 1.1 Problem Statement
CDL netlists use various net naming conventions including bus notation with angle brackets (`data<7>`, `addr<15:0>`), power/ground net variations (VDD, VDD!, VDDA), and escaped names. Net names must be normalized to ensure consistent connectivity matching and to identify special nets like power and ground.

### 1.2 Goals
- Normalize bus notation from `<N>` to `[N]` or flat naming
- Identify and mark power/ground nets (VDD, VSS, GND variants)
- Handle escaped net names (backslash escaping)
- Ensure consistent naming across all instances and subcircuits
- Support bus range expansion if needed

---

## 2. Technical Requirements

### 2.1 Implementation Details

**Location**: `src/ink/infrastructure/parsing/net_normalizer.py`

**Domain Model** (add to `src/ink/domain/value_objects/net.py`):
```python
from dataclasses import dataclass
from enum import Enum

class NetType(Enum):
    """Classification of net types"""
    SIGNAL = "signal"      # Normal signal net
    POWER = "power"        # Power supply (VDD, VDDA, VCC, etc.)
    GROUND = "ground"      # Ground (VSS, GND, GNDA, etc.)
    CLOCK = "clock"        # Clock signal (optional, future)

@dataclass(frozen=True)
class NetInfo:
    """Normalized net information"""
    original_name: str     # Original net name from CDL
    normalized_name: str   # Normalized name for matching
    net_type: NetType      # Classified type
    is_bus: bool           # True if part of a bus
    bus_index: Optional[int] = None  # Index if bus bit
```

**Normalizer Class**:
```python
import re
from typing import Set, Dict
from ..domain.value_objects.net import NetInfo, NetType

class NetNormalizer:
    """Normalize and classify net names from CDL"""

    # Known power net patterns
    POWER_PATTERNS = {
        r'^VDD[A-Z]*$',    # VDD, VDDA, VDDIO, etc.
        r'^VCC[A-Z]*$',    # VCC, VCCA, etc.
        r'^VPWR$',         # VPWR
    }

    # Known ground net patterns
    GROUND_PATTERNS = {
        r'^VSS[A-Z]*$',    # VSS, VSSA, VSSIO, etc.
        r'^GND[A-Z]*$',    # GND, GNDA, etc.
        r'^VGND$',         # VGND
    }

    # Bus notation pattern: net<N> or net<M:N>
    BUS_PATTERN = re.compile(r'^(.+)<(\d+)(?::(\d+))?>$')

    def __init__(self):
        self._net_cache: Dict[str, NetInfo] = {}

    def normalize(self, net_name: str) -> NetInfo:
        """Normalize a net name and classify it

        Args:
            net_name: Raw net name from CDL (e.g., "data<7>", "VDD!")

        Returns:
            NetInfo with normalized name and classification
        """
        # Check cache
        if net_name in self._net_cache:
            return self._net_cache[net_name]

        # Perform normalization
        info = self._do_normalize(net_name)
        self._net_cache[net_name] = info
        return info

    def _do_normalize(self, net_name: str) -> NetInfo:
        """Perform actual normalization logic"""
        # 1. Strip trailing special chars (!, ?)
        cleaned = net_name.rstrip('!?')

        # 2. Handle bus notation
        bus_match = self.BUS_PATTERN.match(cleaned)
        if bus_match:
            base_name = bus_match.group(1)
            bit_index = int(bus_match.group(2))
            # Normalize: data<7> -> data[7]
            normalized = f"{base_name}[{bit_index}]"
            net_type = self._classify_type(base_name)
            return NetInfo(
                original_name=net_name,
                normalized_name=normalized,
                net_type=net_type,
                is_bus=True,
                bus_index=bit_index
            )

        # 3. Classify as power/ground/signal
        net_type = self._classify_type(cleaned)

        return NetInfo(
            original_name=net_name,
            normalized_name=cleaned,
            net_type=net_type,
            is_bus=False
        )

    def _classify_type(self, net_name: str) -> NetType:
        """Classify net as power/ground/signal"""
        # Check power patterns
        for pattern in self.POWER_PATTERNS:
            if re.match(pattern, net_name, re.IGNORECASE):
                return NetType.POWER

        # Check ground patterns
        for pattern in self.GROUND_PATTERNS:
            if re.match(pattern, net_name, re.IGNORECASE):
                return NetType.GROUND

        return NetType.SIGNAL

    def is_power_or_ground(self, net_name: str) -> bool:
        """Quick check if net is power or ground"""
        info = self.normalize(net_name)
        return info.net_type in (NetType.POWER, NetType.GROUND)
```

### 2.2 API/Interface

**Usage Example**:
```python
normalizer = NetNormalizer()

# Normalize various net names
info1 = normalizer.normalize("data<7>")
assert info1.normalized_name == "data[7]"
assert info1.is_bus == True
assert info1.bus_index == 7

info2 = normalizer.normalize("VDD!")
assert info2.normalized_name == "VDD"
assert info2.net_type == NetType.POWER

info3 = normalizer.normalize("VSS")
assert info3.net_type == NetType.GROUND

# Use in instance parser
for net in instance_nets:
    net_info = normalizer.normalize(net)
    # Use normalized_name for connectivity matching
```

### 2.3 Testing Requirements

**Unit Tests** (`tests/unit/infrastructure/parsing/test_net_normalizer.py`):
```python
def test_normalize_bus_notation():
    """Test bus notation normalization"""
    normalizer = NetNormalizer()

    info = normalizer.normalize("data<7>")
    assert info.normalized_name == "data[7]"
    assert info.is_bus == True
    assert info.bus_index == 7
    assert info.original_name == "data<7>"

def test_normalize_power_nets():
    """Test power net detection"""
    normalizer = NetNormalizer()

    test_cases = ["VDD", "VDDA", "VDDIO", "VCC", "VCCA", "VPWR"]
    for net in test_cases:
        info = normalizer.normalize(net)
        assert info.net_type == NetType.POWER

def test_normalize_ground_nets():
    """Test ground net detection"""
    normalizer = NetNormalizer()

    test_cases = ["VSS", "VSSA", "VSSIO", "GND", "GNDA", "VGND"]
    for net in test_cases:
        info = normalizer.normalize(net)
        assert info.net_type == NetType.GROUND

def test_strip_trailing_special_chars():
    """Test removal of trailing ! and ?"""
    normalizer = NetNormalizer()

    info1 = normalizer.normalize("VDD!")
    assert info1.normalized_name == "VDD"

    info2 = normalizer.normalize("net1?")
    assert info2.normalized_name == "net1"

def test_signal_net_classification():
    """Test normal signal nets remain as SIGNAL type"""
    normalizer = NetNormalizer()

    test_cases = ["net1", "clk", "data_valid", "addr_15"]
    for net in test_cases:
        info = normalizer.normalize(net)
        assert info.net_type == NetType.SIGNAL
        assert info.is_bus == False

def test_case_insensitive_power_ground():
    """Test case-insensitive power/ground detection"""
    normalizer = NetNormalizer()

    assert normalizer.normalize("vdd").net_type == NetType.POWER
    assert normalizer.normalize("Vdd").net_type == NetType.POWER
    assert normalizer.normalize("gnd").net_type == NetType.GROUND

def test_cache_performance():
    """Test caching of normalized results"""
    normalizer = NetNormalizer()

    # First call
    info1 = normalizer.normalize("data<7>")
    # Second call should return cached result
    info2 = normalizer.normalize("data<7>")

    assert info1 is info2  # Same object reference

def test_is_power_or_ground_helper():
    """Test quick helper method"""
    normalizer = NetNormalizer()

    assert normalizer.is_power_or_ground("VDD") == True
    assert normalizer.is_power_or_ground("VSS") == True
    assert normalizer.is_power_or_ground("net1") == False
```

**Edge Cases**:
- Empty net names
- Net names with only special characters
- Very long net names (>256 chars)
- Nested bus notation (if encountered)
- Mixed case power/ground names
- Net names with embedded spaces (escaped)
- Numeric-only net names

---

## 3. Dependencies
- **Upstream**: None (pure string processing)
- **Downstream**:
  - E01-F01-T03 (Instance Parser) - uses normalization for connections
  - E01-F01-T05 (Parser Integration) - identifies global nets

---

## 4. Acceptance Criteria
- [ ] Normalize bus notation from `<N>` to `[N]` format
- [ ] Correctly identify all common power net variations (VDD, VCC, VPWR, etc.)
- [ ] Correctly identify all common ground net variations (VSS, GND, VGND, etc.)
- [ ] Strip trailing special characters (!, ?)
- [ ] Case-insensitive matching for power/ground patterns
- [ ] Cache normalized results for performance
- [ ] Create `NetInfo` value objects with complete classification
- [ ] 95%+ test coverage with all edge cases
- [ ] Correctly normalize all nets from sample CDL file

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F01 split |
