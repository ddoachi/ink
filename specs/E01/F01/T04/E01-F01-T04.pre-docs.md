# Pre-Implementation Documentation: E01-F01-T04 - Net Name Normalization

## Overview

### Problem Context
CDL netlists use various naming conventions for nets that need normalization for consistent connectivity matching:

**Bus Notation**: `data<7>` vs `data[7]` vs `data_7`
**Power/Ground Variants**: VDD, VDD!, VDDA, VCC, VSS, GND, GNDA
**Special Characters**: Trailing `!` or `?`, escaped names with backslashes

Without normalization:
- Bus bits won't match across instances (e.g., `data<7>` != `data[7]`)
- Power/ground nets won't be identified for special rendering
- Connectivity graph will have duplicate nets for same logical net

This component provides a central normalization service used by instance parser and graph builder.

### Goals
Build a fast, cached normalizer that converts raw CDL net names to canonical form and classifies nets by type (signal, power, ground) for downstream use.

---

## Implementation Approach

### High-Level Strategy

**Architecture Pattern**: Service with memoization cache

**Key Components**:
1. `NetInfo` value object - Normalized net metadata
2. `NetType` enum - Classification (signal, power, ground)
3. `NetNormalizer` - Stateful service with cache
4. Regex-based pattern matching for classification

**Processing Flow**:
```
Raw Net Name → Check Cache → Normalize → Classify → Cache → Return NetInfo
```

### Algorithm Design

**Normalization Pipeline**:
```
Input: "data<7>!"
Steps:
1. Strip trailing special chars (!, ?) → "data<7>"
2. Check bus pattern with regex → Match: base="data", index=7
3. Convert to bracket notation → "data[7]"
4. Classify type → NetType.SIGNAL
5. Create NetInfo(original="data<7>!", normalized="data[7]",
                  type=SIGNAL, is_bus=True, bus_index=7)
6. Cache result
```

**Classification Algorithm**:
```python
def _classify_type(net_name: str) -> NetType:
    # Check power patterns (case-insensitive)
    for pattern in POWER_PATTERNS:
        if re.match(pattern, net_name, re.IGNORECASE):
            return NetType.POWER

    # Check ground patterns
    for pattern in GROUND_PATTERNS:
        if re.match(pattern, net_name, re.IGNORECASE):
            return NetType.GROUND

    # Default: signal
    return NetType.SIGNAL
```

### Data Structures

```python
class NetType(Enum):
    SIGNAL = "signal"
    POWER = "power"
    GROUND = "ground"
    CLOCK = "clock"  # Future use

@dataclass(frozen=True)
class NetInfo:
    original_name: str         # Raw name from CDL
    normalized_name: str       # Canonical form
    net_type: NetType          # Classification
    is_bus: bool              # Part of bus?
    bus_index: Optional[int]  # Bit index if bus

class NetNormalizer:
    _net_cache: Dict[str, NetInfo]  # Memoization cache

    # Regex patterns
    BUS_PATTERN = re.compile(r'^(.+)<(\d+)(?::(\d+))?>$')
    POWER_PATTERNS = [r'^VDD[A-Z]*$', r'^VCC[A-Z]*$', r'^VPWR$']
    GROUND_PATTERNS = [r'^VSS[A-Z]*$', r'^GND[A-Z]*$', r'^VGND$']
```

---

## Key Design Decisions

### Decision 1: Bus Notation Format

**Options**:
- A) Convert `<N>` to `[N]` (Verilog style)
- B) Convert `<N>` to `_N` (flat naming)
- C) Keep original format, normalize only case/special chars

**Recommendation**: Option A (Bracket notation)

**Rationale**:
- Consistent with Verilog and most EDA tools
- Clearly distinguishes buses from flat names
- Easier to parse for UI display (e.g., hierarchy grouping)
- Future-proof for bus range expansion

**Edge Case**: Bus ranges like `data<7:0>` - For MVP, treat as single net with special handling flag (future expansion)

### Decision 2: Power/Ground Pattern Matching

**Options**:
- A) Hardcoded set of exact names
- B) Regex patterns with wildcards
- C) User-configurable pattern file

**Recommendation**: Option B (Regex patterns)

**Rationale**:
- Covers common variations (VDDA, VDDIO, etc.) with simple patterns
- Maintainable (add new patterns easily)
- Fast with compiled regex
- Option C adds unnecessary complexity for MVP

**Pattern Design**:
```python
POWER_PATTERNS = {
    r'^VDD[A-Z]*$',    # VDD, VDDA, VDDIO, VDDCORE
    r'^VCC[A-Z]*$',    # VCC, VCCA
    r'^VPWR$',         # Common in PDKs
}

GROUND_PATTERNS = {
    r'^VSS[A-Z]*$',    # VSS, VSSA, VSSIO
    r'^GND[A-Z]*$',    # GND, GNDA, GNDIO
    r'^VGND$',         # Common in PDKs
}
```

### Decision 3: Case Sensitivity

**Options**:
- A) Case-sensitive (VDD != vdd)
- B) Case-insensitive for power/ground only
- C) Fully case-insensitive

**Recommendation**: Option B (Partial case-insensitive)

**Rationale**:
- Signal nets should preserve case (may be meaningful)
- Power/ground typically uppercase but tools vary
- `re.IGNORECASE` flag for power/ground patterns only

**Normalized Storage**: Store power/ground as uppercase canonical form

### Decision 4: Caching Strategy

**Options**:
- A) No caching (recompute every time)
- B) Simple dict cache (unbounded)
- C) LRU cache with size limit

**Recommendation**: Option B (Simple dict cache)

**Rationale**:
- Net names repeat frequently in large designs (e.g., VDD, VSS on every cell)
- Cache hit rate will be very high (>90%)
- Memory usage acceptable (10K unique nets ≈ 1MB cache)
- No eviction needed for single-file parsing session

**Cache Key**: Original net name (raw string)

### Decision 5: Special Character Handling

**Options**:
- A) Strip all non-alphanumeric except brackets
- B) Strip only trailing `!` and `?`
- C) Keep all characters, rely on CDL to escape properly

**Recommendation**: Option B (Strip trailing only)

**Rationale**:
- `!` and `?` commonly added by tools to indicate net properties
- Underscores, slashes, brackets are meaningful
- Minimal transformation reduces risk of breaking valid names

**Implementation**:
```python
cleaned = net_name.rstrip('!?')
```

---

## Dependencies and Integration Points

### Upstream Dependencies
**None** - Pure string processing, no external dependencies

**Required Libraries**:
- Standard library `re` (regex)
- Standard library `dataclasses`

### Downstream Consumers

**E01-F01-T03 (Instance Parser)**:
- Normalizes connection net names before storing
- Uses classification to identify power/ground for validation

**E01-F01-T05 (Parser Integration)**:
- Builds net dictionary from all instances
- Uses normalization to deduplicate nets

**E01-F03 (Graph Construction)**:
- Uses normalized names as graph node IDs
- Uses `NetType` for rendering (power/ground displayed differently)

### Interface Contract

**Input**: `str` (raw net name)
**Output**: `NetInfo` (immutable value object)

**Guarantees**:
- Idempotent (same input → same output)
- Thread-safe (cache access is read-heavy, no mutation after cache insert)
- Fast (O(1) cache lookup, O(n) regex on cache miss where n = name length)

**Performance Target**: <1μs per lookup (cached), <10μs (uncached)

---

## Testing Strategy

### Unit Test Coverage

**Bus Normalization**:
1. `test_normalize_bus_single_bit` - `data<7>` → `data[7]`
2. `test_normalize_bus_range` - `data<7:0>` → Special handling
3. `test_normalize_non_bus` - `net1` → `net1` (unchanged)
4. `test_bus_index_extraction` - Verify `bus_index` field

**Power Net Classification**:
5. `test_classify_vdd_variants` - VDD, VDDA, VDDIO, VDDCORE
6. `test_classify_vcc_variants` - VCC, VCCA
7. `test_classify_vpwr` - VPWR

**Ground Net Classification**:
8. `test_classify_vss_variants` - VSS, VSSA, VSSIO
9. `test_classify_gnd_variants` - GND, GNDA
10. `test_classify_vgnd` - VGND

**Special Character Handling**:
11. `test_strip_trailing_exclamation` - `VDD!` → `VDD`
12. `test_strip_trailing_question` - `net?` → `net`
13. `test_preserve_internal_special_chars` - `net_1` → `net_1`

**Case Sensitivity**:
14. `test_power_case_insensitive` - `vdd`, `Vdd`, `VDD` all → POWER
15. `test_signal_case_preserved` - `NetA` != `neta`

**Caching**:
16. `test_cache_hit` - Verify same object returned
17. `test_cache_performance` - 10K lookups <10ms

**Edge Cases**:
18. `test_empty_net_name` - Graceful handling
19. `test_very_long_net_name` - 256+ characters
20. `test_numeric_only_net` - `123` → SIGNAL
21. `test_special_only_net` - `!!!` → ???

### Test Data Strategy

**Parametrized Tests**:
```python
@pytest.mark.parametrize("raw,expected_normalized,expected_type", [
    ("data<7>", "data[7]", NetType.SIGNAL),
    ("VDD!", "VDD", NetType.POWER),
    ("VSS", "VSS", NetType.GROUND),
    ("clk", "clk", NetType.SIGNAL),
    ("VDDA", "VDDA", NetType.POWER),
    ("net_1?", "net_1", NetType.SIGNAL),
])
def test_normalize_variations(raw, expected_normalized, expected_type):
    normalizer = NetNormalizer()
    info = normalizer.normalize(raw)
    assert info.normalized_name == expected_normalized
    assert info.net_type == expected_type
```

**Fixtures**:
- `common_net_names.txt` - 100 real-world net names for integration test
- `power_ground_variants.json` - Comprehensive list of known patterns

### Performance Testing

**Benchmark**: 1M normalizations <100ms

```python
def test_normalization_performance(benchmark):
    normalizer = NetNormalizer()

    # Mixed workload (90% cache hits, 10% new)
    net_names = ["VDD"] * 900 + [f"net_{i}" for i in range(100)]

    def normalize_batch():
        for name in net_names:
            normalizer.normalize(name)

    result = benchmark(normalize_batch)
    # Should be <100μs for 1000 normalizations
```

---

## Risks and Considerations

### Risk 1: Regex Performance
**Likelihood**: Low
**Impact**: Low

**Description**: Many regex patterns could slow down classification

**Mitigation**:
- Compile patterns once at class level
- Cache results aggressively
- Pattern list is small (<10 patterns)
- Early exit on first match

**Benchmark**: Test with 10K unique net names

### Risk 2: Bus Range Expansion
**Likelihood**: Medium
**Impact**: Medium

**Description**: Bus ranges like `data<7:0>` need special handling (expand to 8 nets?)

**Mitigation**:
- For MVP: Treat as single net, flag `is_bus=True`
- Future: Add `bus_range` field and expansion method
- Document current limitation

### Risk 3: Naming Collisions
**Likelihood**: Low
**Impact**: Medium

**Description**: Normalization could create collisions (e.g., `net!` and `net?` → `net`)

**Mitigation**:
- Very rare in practice (CDL tools avoid this)
- Log warning if normalized name collision detected
- Preserve original name for debugging

### Risk 4: Power/Ground False Positives
**Likelihood**: Low
**Impact**: Low

**Description**: Signal net named `VDD_enable` could match `^VDD.*` pattern

**Mitigation**:
- Use `$` anchor in regex (exact suffix match)
- Pattern: `^VDD[A-Z]*$` matches `VDD`, `VDDA` but not `VDD_enable`
- Document pattern rules

### Risk 5: Thread Safety
**Likelihood**: Low
**Impact**: Medium

**Description**: Cache dict access from multiple threads could cause issues

**Mitigation**:
- For MVP: Single-threaded parsing (no issue)
- Future: Use `threading.Lock` for cache writes
- Or use `functools.lru_cache` (thread-safe)

### Implementation Complexity
**Overall**: Low

**Rationale**:
- Pure string processing
- Well-defined regex patterns
- Simple caching
- No external dependencies

### Integration Challenges
**Level**: Low

**Considerations**:
- No complex dependencies
- Clean interface (in: string, out: NetInfo)
- Can be unit tested in isolation

---

## Success Metrics

### Functional Requirements
- [ ] 95%+ code coverage
- [ ] All common power/ground patterns classified correctly
- [ ] Bus notation normalized to bracket format
- [ ] Cache hit rate >90% on realistic workloads

### Non-Functional Requirements
- [ ] Normalize 1M nets in <100ms (with caching)
- [ ] Memory usage <10MB for 100K unique nets
- [ ] Zero false negatives on power/ground classification

### Quality Gates
- [ ] All unit tests pass
- [ ] Mypy strict type checking passes
- [ ] Parametrized tests cover 20+ variations
- [ ] Performance benchmark meets target

---

## Implementation Checklist

### Phase 1: Domain Model (0.5 hour)
- [ ] Create `src/ink/domain/value_objects/net.py`
- [ ] Implement `NetType` enum
- [ ] Implement `NetInfo` dataclass
- [ ] Write domain model tests

### Phase 2: Normalizer Core (1-1.5 hours)
- [ ] Create `src/ink/infrastructure/parsing/net_normalizer.py`
- [ ] Define regex patterns (bus, power, ground)
- [ ] Implement `NetNormalizer.__init__`
- [ ] Implement `normalize` method with caching
- [ ] Implement `_classify_type` method
- [ ] Implement `_do_normalize` method

### Phase 3: Testing (1-1.5 hours)
- [ ] Write bus normalization tests
- [ ] Write power/ground classification tests
- [ ] Write special character tests
- [ ] Write cache tests
- [ ] Write edge case tests
- [ ] Parametrized test suite

### Phase 4: Validation (0.5 hour)
- [ ] Performance benchmark
- [ ] Type checking
- [ ] Linting
- [ ] Integration test with instance parser

**Total Estimated Time**: 3-4 hours (matches spec estimate)
