---
id: E01-F01-T05
title: CDL Parser Integration
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F01
created: 2025-12-26
estimated_hours: 5-6
actual_hours:
effort: Medium
tags:
  - parsing
  - infrastructure
  - integration
  - domain-model
clickup_task_id: '86evzm276'
---

# Spec: E01-F01-T05 - CDL Parser Integration

## 1. Overview

### 1.1 Problem Statement
The lexer, subcircuit parser, instance parser, and net normalizer components must be orchestrated into a unified `CDLParser` that produces a complete `Design` aggregate root. This integration layer handles the parsing workflow, error collection, progress reporting, and construction of the domain model.

### 1.2 Goals
- Integrate all parsing components into cohesive `CDLParser` class
- Construct `Design` aggregate root from parsed data
- Collect and report all errors and warnings with line numbers
- Support partial loading on recoverable errors
- Provide progress callbacks for large files
- Meet performance requirement: parse 100K cells in <5 seconds

---

## 2. Technical Requirements

### 2.1 Implementation Details

**Location**: `src/ink/infrastructure/parsing/cdl_parser.py`

**Domain Model** (update `src/ink/domain/model/design.py`):
```python
from dataclasses import dataclass, field
from typing import Dict, List, Set
from ..value_objects.subcircuit import SubcircuitDefinition
from ..value_objects.instance import CellInstance
from ..value_objects.net import NetInfo

@dataclass
class Design:
    """Root aggregate for a circuit design"""
    name: str                                      # Top-level design name
    subcircuit_defs: Dict[str, SubcircuitDefinition]  # Cell type definitions
    instances: Dict[str, CellInstance]             # Instance name -> Instance
    nets: Dict[str, NetInfo]                       # Net name -> NetInfo
    top_level_ports: List[str] = field(default_factory=list)  # Top-level I/O

    def add_instance(self, instance: CellInstance) -> None:
        """Add instance to design"""
        if instance.name in self.instances:
            raise ValueError(f"Duplicate instance name: {instance.name}")
        self.instances[instance.name] = instance

    def get_instance(self, name: str) -> Optional[CellInstance]:
        """Retrieve instance by name"""
        return self.instances.get(name)

    def get_instances_by_type(self, cell_type: str) -> List[CellInstance]:
        """Find all instances of a cell type"""
        return [inst for inst in self.instances.values()
                if inst.cell_type == cell_type]
```

**Main Parser Class**:
```python
from pathlib import Path
from typing import Callable, Optional, List
from dataclasses import dataclass
from .cdl_lexer import CDLLexer, LineType
from .subcircuit_parser import SubcircuitParser
from .instance_parser import InstanceParser
from .net_normalizer import NetNormalizer
from ..domain.model.design import Design

@dataclass
class ParsingError:
    """Parsing error with context"""
    line_num: int
    message: str
    severity: str  # "error" or "warning"

class CDLParser:
    """Main CDL parser integrating all components"""

    def __init__(self):
        self._errors: List[ParsingError] = []
        self._progress_callback: Optional[Callable[[int, int], None]] = None

    def parse_file(
        self,
        file_path: Path,
        progress_callback: Optional[Callable[[int, int], None]] = None
    ) -> Design:
        """Parse CDL file and return Design aggregate

        Args:
            file_path: Path to .ckt file
            progress_callback: Optional callback(current_line, total_lines)

        Returns:
            Design aggregate root

        Raises:
            ValueError: If file cannot be parsed (critical errors)
        """
        self._progress_callback = progress_callback
        self._errors.clear()

        # Initialize components
        lexer = CDLLexer(file_path)
        subcircuit_parser = SubcircuitParser()
        net_normalizer = NetNormalizer()

        # First pass: collect subcircuit definitions
        tokens = list(lexer.tokenize())
        total_lines = len(tokens)

        for i, token in enumerate(tokens):
            if self._progress_callback and i % 100 == 0:
                self._progress_callback(i, total_lines)

            try:
                if token.line_type == LineType.SUBCKT:
                    subcircuit_parser.parse_subckt_line(token)
                elif token.line_type == LineType.ENDS:
                    subcircuit_parser.parse_ends_line(token)
            except ValueError as e:
                self._add_error(token.line_num, str(e), "error")

        # Validate all blocks closed
        try:
            subcircuit_parser.validate_complete()
        except ValueError as e:
            self._add_error(-1, str(e), "error")

        # Second pass: parse instances
        instance_parser = InstanceParser(subcircuit_parser._definitions)
        instances = []

        for i, token in enumerate(tokens):
            if self._progress_callback and i % 100 == 0:
                self._progress_callback(i, total_lines)

            try:
                if token.line_type == LineType.INSTANCE:
                    instance = instance_parser.parse_instance_line(token)
                    instances.append(instance)
            except ValueError as e:
                self._add_error(token.line_num, str(e), "error")
                # Continue parsing (partial load)

        # Collect warnings
        for warning in instance_parser.get_warnings():
            self._add_error(-1, warning, "warning")

        # Build Design aggregate
        design = self._build_design(
            file_path.stem,
            subcircuit_parser._definitions,
            instances,
            net_normalizer
        )

        # Report errors if any
        if self._has_critical_errors():
            error_summary = self._format_errors()
            raise ValueError(f"Failed to parse {file_path}:\n{error_summary}")

        return design

    def _build_design(
        self,
        name: str,
        subcircuit_defs: Dict[str, SubcircuitDefinition],
        instances: List[CellInstance],
        net_normalizer: NetNormalizer
    ) -> Design:
        """Construct Design aggregate from parsed components"""
        # Collect all unique nets from instances
        nets = {}
        for instance in instances:
            for port, net_name in instance.connections.items():
                if net_name not in nets:
                    nets[net_name] = net_normalizer.normalize(net_name)

        # Build instance map
        instance_map = {inst.name: inst for inst in instances}

        # Create design
        design = Design(
            name=name,
            subcircuit_defs=subcircuit_defs,
            instances=instance_map,
            nets=nets
        )

        return design

    def _add_error(self, line_num: int, message: str, severity: str) -> None:
        """Record parsing error"""
        self._errors.append(ParsingError(line_num, message, severity))

    def _has_critical_errors(self) -> bool:
        """Check if any critical errors occurred"""
        return any(e.severity == "error" for e in self._errors)

    def _format_errors(self) -> str:
        """Format all errors for reporting"""
        lines = []
        for error in self._errors:
            if error.line_num > 0:
                lines.append(f"Line {error.line_num}: {error.message}")
            else:
                lines.append(error.message)
        return "\n".join(lines)

    def get_errors(self) -> List[ParsingError]:
        """Return all parsing errors and warnings"""
        return self._errors
```

### 2.2 API/Interface

**Public Interface**:
```python
# Basic usage
parser = CDLParser()
design = parser.parse_file(Path("design.ckt"))

print(f"Loaded design: {design.name}")
print(f"Subcircuits: {len(design.subcircuit_defs)}")
print(f"Instances: {len(design.instances)}")
print(f"Nets: {len(design.nets)}")

# With progress callback
def on_progress(current, total):
    print(f"Parsing: {current}/{total} lines ({100*current/total:.1f}%)")

design = parser.parse_file(Path("large_design.ckt"), on_progress)

# Error handling
try:
    design = parser.parse_file(Path("bad_design.ckt"))
except ValueError as e:
    print(f"Parse failed: {e}")
    for error in parser.get_errors():
        print(f"  {error.severity}: {error.message}")
```

### 2.3 Testing Requirements

**Integration Tests** (`tests/integration/infrastructure/parsing/test_cdl_parser.py`):
```python
def test_parse_simple_design(tmp_path):
    """Test parsing complete simple design"""
    cdl_content = """
* Simple inverter chain
.SUBCKT INV A Y VDD VSS
.ENDS INV

.SUBCKT TOP IN OUT VDD VSS
XI1 IN net1 VDD VSS INV
XI2 net1 OUT VDD VSS INV
.ENDS TOP
"""
    cdl_file = tmp_path / "simple.ckt"
    cdl_file.write_text(cdl_content)

    parser = CDLParser()
    design = parser.parse_file(cdl_file)

    assert design.name == "simple"
    assert "INV" in design.subcircuit_defs
    assert "TOP" in design.subcircuit_defs
    assert len(design.instances) == 2
    assert "XI1" in design.instances
    assert "XI2" in design.instances

def test_parse_with_bus_notation(tmp_path):
    """Test parsing with bus notation in net names"""
    cdl_content = """
.SUBCKT BUF A Y
.ENDS BUF

.SUBCKT TOP
XI0 data<0> out<0> BUF
XI1 data<1> out<1> BUF
.ENDS TOP
"""
    cdl_file = tmp_path / "bus.ckt"
    cdl_file.write_text(cdl_content)

    parser = CDLParser()
    design = parser.parse_file(cdl_file)

    # Check normalized net names
    assert "data[0]" in [n.normalized_name for n in design.nets.values()]
    assert "data[1]" in [n.normalized_name for n in design.nets.values()]

def test_parse_with_warnings(tmp_path):
    """Test partial parsing with warnings"""
    cdl_content = """
.SUBCKT INV A Y
.ENDS INV

.SUBCKT TOP
XI1 net1 net2 INV
XI2 net3 net4 UNKNOWN_CELL
.ENDS TOP
"""
    cdl_file = tmp_path / "warnings.ckt"
    cdl_file.write_text(cdl_content)

    parser = CDLParser()
    design = parser.parse_file(cdl_file)

    # Should succeed with warnings
    assert len(design.instances) == 2
    errors = parser.get_errors()
    warnings = [e for e in errors if e.severity == "warning"]
    assert len(warnings) > 0

def test_parse_with_errors(tmp_path):
    """Test parsing failure with critical errors"""
    cdl_content = """
.SUBCKT INV A Y
* Missing .ENDS!

.SUBCKT TOP
XI1 net1 net2 INV
.ENDS TOP
"""
    cdl_file = tmp_path / "errors.ckt"
    cdl_file.write_text(cdl_content)

    parser = CDLParser()
    with pytest.raises(ValueError, match="Failed to parse"):
        parser.parse_file(cdl_file)

def test_progress_callback(tmp_path):
    """Test progress reporting during parse"""
    # Generate large CDL file
    lines = [".SUBCKT INV A Y", ".ENDS INV", ""]
    for i in range(1000):
        lines.append(f"XI{i} net{i} net{i+1} INV")

    cdl_file = tmp_path / "large.ckt"
    cdl_file.write_text("\n".join(lines))

    progress_calls = []
    def track_progress(current, total):
        progress_calls.append((current, total))

    parser = CDLParser()
    design = parser.parse_file(cdl_file, track_progress)

    assert len(progress_calls) > 0
    assert progress_calls[-1][0] <= progress_calls[-1][1]

def test_performance_100k_cells(tmp_path, benchmark):
    """Test parsing performance on 100K cell design"""
    # Generate 100K instances
    lines = [".SUBCKT INV A Y", ".ENDS INV", ""]
    for i in range(100_000):
        lines.append(f"XI{i} net{i} net{i+1} INV")

    cdl_file = tmp_path / "large.ckt"
    cdl_file.write_text("\n".join(lines))

    parser = CDLParser()

    # Should complete in < 5 seconds
    import time
    start = time.time()
    design = parser.parse_file(cdl_file)
    elapsed = time.time() - start

    assert elapsed < 5.0
    assert len(design.instances) == 100_000
```

**Edge Cases**:
- Empty CDL file
- File with only comments
- Very large files (>1M lines)
- Deeply nested subcircuits
- Duplicate instance names
- Circular subcircuit references (if possible)

---

## 3. Dependencies
- **Upstream**:
  - E01-F01-T01 (Lexer) - tokenization
  - E01-F01-T02 (Subcircuit Parser) - subcircuit definitions
  - E01-F01-T03 (Instance Parser) - cell instances
  - E01-F01-T04 (Net Normalizer) - net classification
- **Downstream**:
  - E01-F03 (Graph Construction) - consumes Design aggregate

---

## 4. Acceptance Criteria
- [ ] Integrate all parsing components into `CDLParser` class
- [ ] Construct complete `Design` aggregate from parsed data
- [ ] Two-pass parsing: (1) subcircuit definitions, (2) instances
- [ ] Collect all errors and warnings with line numbers
- [ ] Support partial loading - continue after recoverable errors
- [ ] Provide progress callback for UI integration
- [ ] Meet performance requirement: parse 100K cells in <5 seconds
- [ ] Return structured errors for reporting
- [ ] 90%+ integration test coverage
- [ ] Successfully parse sample CDL from PRD Appendix A

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F01 split |
