# Spec: E01-F01-T02 - Subcircuit Definition Parser

## Metadata
- **ID**: E01-F01-T02
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E01-F01](../E01-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 3-4
- **Actual Hours**:
- **Effort**: Small
- **Tags**: [parsing, infrastructure, domain-model]

---

## 1. Overview

### 1.1 Problem Statement
CDL subcircuit definitions (`.SUBCKT` ... `.ENDS` blocks) declare cell types and their port interfaces. These definitions are essential for mapping instance connections to cell ports. The parser must extract cell type names, port lists, and validate proper block nesting.

### 1.2 Goals
- Parse `.SUBCKT` header lines to extract cell name and port list
- Match `.SUBCKT` / `.ENDS` pairs with nesting support
- Validate subcircuit block integrity
- Create domain model `SubcircuitDefinition` value objects
- Report errors for unmatched blocks

---

## 2. Technical Requirements

### 2.1 Implementation Details

**Location**: `src/ink/infrastructure/parsing/subcircuit_parser.py`

**Domain Model** (add to `src/ink/domain/value_objects/subcircuit.py`):
```python
from dataclasses import dataclass
from typing import List

@dataclass(frozen=True)
class SubcircuitDefinition:
    """Immutable subcircuit definition from CDL"""
    name: str              # Cell type name (e.g., "INV_X1")
    ports: List[str]       # Ordered port names (e.g., ["A", "Y", "VDD", "VSS"])

    def __post_init__(self):
        """Validate subcircuit definition"""
        if not self.name:
            raise ValueError("Subcircuit name cannot be empty")
        if not self.ports:
            raise ValueError(f"Subcircuit {self.name} must have at least one port")
        if len(self.ports) != len(set(self.ports)):
            raise ValueError(f"Subcircuit {self.name} has duplicate port names")
```

**Parser Class**:
```python
from typing import Dict, Optional
from ..domain.value_objects.subcircuit import SubcircuitDefinition
from .cdl_lexer import CDLToken, LineType

class SubcircuitParser:
    """Parser for .SUBCKT / .ENDS blocks"""

    def __init__(self):
        self._definitions: Dict[str, SubcircuitDefinition] = {}
        self._stack: List[str] = []  # Track nesting

    def parse_subckt_line(self, token: CDLToken) -> SubcircuitDefinition:
        """Parse .SUBCKT header line

        Format: .SUBCKT cell_name port1 port2 ... portN

        Args:
            token: SUBCKT token from lexer

        Returns:
            SubcircuitDefinition value object

        Raises:
            ValueError: If line format is invalid
        """
        pass

    def parse_ends_line(self, token: CDLToken) -> str:
        """Parse .ENDS line and validate matching

        Format: .ENDS [cell_name]

        Args:
            token: ENDS token from lexer

        Returns:
            Name of closed subcircuit

        Raises:
            ValueError: If .ENDS without matching .SUBCKT
        """
        pass

    def get_definition(self, cell_type: str) -> Optional[SubcircuitDefinition]:
        """Retrieve parsed subcircuit definition by name"""
        return self._definitions.get(cell_type)

    def validate_complete(self) -> None:
        """Ensure all .SUBCKT blocks are closed

        Raises:
            ValueError: If unclosed .SUBCKT blocks remain
        """
        if self._stack:
            raise ValueError(f"Unclosed .SUBCKT blocks: {', '.join(self._stack)}")
```

### 2.2 API/Interface

**Usage Example**:
```python
# In CDLParser main loop
subckt_parser = SubcircuitParser()

for token in lexer.tokenize():
    if token.line_type == LineType.SUBCKT:
        definition = subckt_parser.parse_subckt_line(token)
        # Store definition for later instance parsing
    elif token.line_type == LineType.ENDS:
        closed_name = subckt_parser.parse_ends_line(token)

# After parsing
subckt_parser.validate_complete()
```

### 2.3 Testing Requirements

**Unit Tests** (`tests/unit/infrastructure/parsing/test_subcircuit_parser.py`):
```python
def test_parse_simple_subcircuit():
    """Test basic .SUBCKT parsing"""
    token = CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A Y VDD VSS", "...")
    parser = SubcircuitParser()
    defn = parser.parse_subckt_line(token)
    assert defn.name == "INV"
    assert defn.ports == ["A", "Y", "VDD", "VSS"]

def test_parse_ends_with_name():
    """Test .ENDS with explicit cell name"""
    token_subckt = CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A Y", "...")
    token_ends = CDLToken(10, LineType.ENDS, ".ENDS INV", "...")
    parser = SubcircuitParser()
    parser.parse_subckt_line(token_subckt)
    closed = parser.parse_ends_line(token_ends)
    assert closed == "INV"

def test_parse_ends_without_name():
    """Test .ENDS without cell name (closes last opened)"""
    token_subckt = CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A Y", "...")
    token_ends = CDLToken(10, LineType.ENDS, ".ENDS", "...")
    parser = SubcircuitParser()
    parser.parse_subckt_line(token_subckt)
    closed = parser.parse_ends_line(token_ends)
    assert closed == "INV"

def test_nested_subcircuits():
    """Test nested .SUBCKT blocks"""
    # Create tokens for nested structure
    # Verify stack management and correct closing

def test_unmatched_ends_error():
    """Test error on .ENDS without .SUBCKT"""
    token = CDLToken(1, LineType.ENDS, ".ENDS INV", "...")
    parser = SubcircuitParser()
    with pytest.raises(ValueError, match="without matching .SUBCKT"):
        parser.parse_ends_line(token)

def test_unclosed_subcircuit_error():
    """Test validation error for unclosed blocks"""
    token = CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A Y", "...")
    parser = SubcircuitParser()
    parser.parse_subckt_line(token)
    with pytest.raises(ValueError, match="Unclosed .SUBCKT"):
        parser.validate_complete()

def test_duplicate_port_names():
    """Test error on duplicate port names"""
    token = CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A A VDD", "...")
    parser = SubcircuitParser()
    with pytest.raises(ValueError, match="duplicate port"):
        parser.parse_subckt_line(token)
```

**Edge Cases**:
- Empty port list
- Very long port lists (>100 ports)
- Port names with special characters
- Case sensitivity in cell names
- Nested subcircuit definitions
- `.ENDS` with wrong cell name

---

## 3. Dependencies
- **Upstream**:
  - E01-F01-T01 (Lexer) - provides SUBCKT/ENDS tokens
- **Downstream**:
  - E01-F01-T03 (Instance Parser) - uses definitions to map connections

---

## 4. Acceptance Criteria
- [ ] Correctly parse `.SUBCKT` lines to extract cell name and port list
- [ ] Handle `.ENDS` with and without explicit cell name
- [ ] Track nesting stack for nested subcircuit definitions
- [ ] Validate matching `.SUBCKT` / `.ENDS` pairs
- [ ] Create immutable `SubcircuitDefinition` value objects
- [ ] Report errors with line numbers for unmatched blocks
- [ ] Detect and reject duplicate port names
- [ ] 95%+ test coverage with all edge cases
- [ ] Successfully parse all subcircuit definitions from sample CDL file

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F01 split |
