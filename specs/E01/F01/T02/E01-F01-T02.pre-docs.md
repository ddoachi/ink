# Pre-Implementation Documentation: E01-F01-T02 - Subcircuit Definition Parser

## Overview

### Problem Context
CDL subcircuit definitions (`.SUBCKT` ... `.ENDS` blocks) declare cell types and their port interfaces. These definitions are essential for mapping instance connections to port names. Without parsing subcircuit definitions, the instance parser cannot create proper port-to-net mappings.

The parser must handle:
- Extraction of cell type names and port lists from `.SUBCKT` headers
- Matching `.SUBCKT`/`.ENDS` pairs with proper nesting
- Validation of block integrity
- Creation of immutable domain value objects

This component bridges the infrastructure layer (parsing) with the domain layer (value objects).

### Goals
Build a robust subcircuit definition parser that creates validated `SubcircuitDefinition` value objects and tracks nesting state for proper block matching.

---

## Implementation Approach

### High-Level Strategy

**Architecture Pattern**: Stateful parser with stack-based nesting tracking

**Key Components**:
1. `SubcircuitDefinition` value object - Immutable domain model
2. `SubcircuitParser` - Stateful parser with nesting stack
3. Stack-based nesting validation

**Processing Flow**:
```
SUBCKT Token → Parse Header → Create Definition → Push Stack
ENDS Token → Pop Stack → Validate Match → Return Name
```

### Algorithm Design

**Parsing `.SUBCKT` Line**:
```
Input: ".SUBCKT INV A Y VDD VSS"
Steps:
1. Split on whitespace
2. Extract tokens: [".SUBCKT", "INV", "A", "Y", "VDD", "VSS"]
3. Cell name = tokens[1]
4. Ports = tokens[2:]
5. Validate port list (no duplicates, not empty)
6. Create SubcircuitDefinition(name="INV", ports=["A", "Y", "VDD", "VSS"])
7. Push "INV" onto nesting stack
8. Store in definitions map
```

**Parsing `.ENDS` Line**:
```
Input: ".ENDS INV" or ".ENDS"
Steps:
1. Split on whitespace
2. If name provided, validate it matches stack top
3. If no name, use stack top
4. Pop stack
5. Return closed subcircuit name
```

**Nesting Stack Management**:
- Stack stores subcircuit names in order of opening
- `.SUBCKT` → push name
- `.ENDS` → pop and validate
- Final validation: stack must be empty

### Data Structures

```python
@dataclass(frozen=True)
class SubcircuitDefinition:
    name: str              # Cell type name
    ports: List[str]       # Ordered port names

    def __post_init__(self):
        # Validate name not empty
        # Validate ports not empty
        # Validate no duplicate port names

class SubcircuitParser:
    _definitions: Dict[str, SubcircuitDefinition]  # name -> definition
    _stack: List[str]                              # Nesting tracking
```

---

## Key Design Decisions

### Decision 1: Value Object Immutability

**Options**:
- A) Mutable class with setter methods
- B) Immutable dataclass with `frozen=True`
- C) Named tuple

**Recommendation**: Option B (Immutable dataclass)

**Rationale**:
- Domain-Driven Design principle: Value objects should be immutable
- Thread-safe for concurrent access
- Clearer semantics (subcircuit definition doesn't change after parsing)
- Dataclass provides validation in `__post_init__`

**Implementation**:
```python
@dataclass(frozen=True)
class SubcircuitDefinition:
    name: str
    ports: List[str]  # Will be converted to tuple in __post_init__

    def __post_init__(self):
        # Validate and freeze ports list
        object.__setattr__(self, 'ports', tuple(self.ports))
```

### Decision 2: Duplicate Port Name Handling

**Options**:
- A) Raise error immediately
- B) Deduplicate silently
- C) Rename duplicates (e.g., `A`, `A_1`, `A_2`)

**Recommendation**: Option A (Raise error)

**Rationale**:
- Indicates CDL file error or corruption
- User should fix source file
- Consistent with strict validation approach

**Error Message**:
```python
raise ValueError(
    f"Subcircuit {self.name} has duplicate port names: {duplicates}"
)
```

### Decision 3: Nesting Stack Implementation

**Options**:
- A) Use simple Python list as stack
- B) Use deque for better performance
- C) Custom Stack class with validation

**Recommendation**: Option A (Python list)

**Rationale**:
- Stack depth is shallow (typically 1-3 levels max)
- List append/pop is O(1) amortized
- Simpler, more readable code
- No performance benefit from deque at this scale

### Decision 4: `.ENDS` Name Matching

**Options**:
- A) Require explicit name in `.ENDS`, error if missing
- B) Allow omitted name, use stack top
- C) Allow omitted name, but warn if stack has multiple levels

**Recommendation**: Option B (Allow omitted name)

**Rationale**:
- Common CDL convention to omit name
- Stack top uniquely identifies which block to close
- Matches behavior of real CDL parsers

**Enhancement**: Option C for better error messages (future)

### Decision 5: Definition Storage

**Options**:
- A) Store in parser instance (`_definitions` dict)
- B) Return list of definitions, caller stores
- C) Use repository pattern with in-memory store

**Recommendation**: Option A (Internal dict)

**Rationale**:
- Parser needs definitions available during parsing for validation
- Integration layer (E01-F01-T05) will extract and pass to Design aggregate
- Simple, no premature abstraction

**Interface**:
```python
def get_definition(self, cell_type: str) -> Optional[SubcircuitDefinition]:
    return self._definitions.get(cell_type)
```

---

## Dependencies and Integration Points

### Upstream Dependencies

**E01-F01-T01 (CDL Lexer)**:
- Requires `CDLToken` objects with `LineType.SUBCKT` and `LineType.ENDS`
- Depends on cleaned content (comments removed, continuation joined)
- Uses line numbers for error reporting

**Required Imports**:
```python
from .cdl_lexer import CDLToken, LineType
from ..domain.value_objects.subcircuit import SubcircuitDefinition
```

### Downstream Consumers

**E01-F01-T03 (Instance Parser)**:
- Uses subcircuit definitions to map instance connections to ports
- Calls `get_definition(cell_type)` for each instance
- Needs port list in correct order for positional mapping

**E01-F01-T05 (Parser Integration)**:
- Orchestrates parsing workflow
- Collects definitions from parser
- Validates all blocks closed via `validate_complete()`

### Interface Contract

**Input**: `CDLToken` with type `SUBCKT` or `ENDS`
**Output**: `SubcircuitDefinition` or `str` (closed name)

**Guarantees**:
- All returned definitions are valid (no empty names/ports, no duplicates)
- Nesting stack correctly maintained
- Line numbers preserved for error reporting

**Error Conditions**:
- Invalid `.SUBCKT` format → `ValueError` with line number
- Duplicate port names → `ValueError` with details
- `.ENDS` without matching `.SUBCKT` → `ValueError`
- Unclosed blocks at end → `ValueError` from `validate_complete()`

---

## Testing Strategy

### Unit Test Coverage

**Core Functionality**:
1. `test_parse_simple_subcircuit` - Basic `.SUBCKT` parsing
2. `test_parse_many_ports` - Subcircuit with 20+ ports
3. `test_parse_minimal_ports` - Subcircuit with 1 port
4. `test_parse_ends_with_name` - Explicit cell name in `.ENDS`
5. `test_parse_ends_without_name` - Omitted cell name
6. `test_get_definition` - Retrieval by name

**Nesting**:
7. `test_nested_subcircuits` - Multiple levels of nesting
8. `test_nested_same_name` - Nested blocks with same cell name (valid)
9. `test_sequential_subcircuits` - Multiple top-level blocks

**Error Handling**:
10. `test_empty_subcircuit_name` - Error on missing name
11. `test_empty_port_list` - Error on no ports
12. `test_duplicate_port_names` - Error on duplicates
13. `test_unmatched_ends_error` - `.ENDS` without `.SUBCKT`
14. `test_wrong_ends_name` - `.ENDS` name doesn't match stack
15. `test_unclosed_subcircuit_error` - Missing `.ENDS`

**Edge Cases**:
16. `test_case_sensitivity` - Cell names preserve case
17. `test_port_name_special_chars` - Ports with underscores, numbers
18. `test_very_long_port_list` - 100+ ports (stress test)
19. `test_duplicate_definition_override` - Second definition replaces first

### Test Data Strategy

**Sample Token Sequences**:
```python
# Simple case
tokens = [
    CDLToken(1, LineType.SUBCKT, ".SUBCKT INV A Y", "..."),
    CDLToken(10, LineType.ENDS, ".ENDS INV", "...")
]

# Nested case
tokens = [
    CDLToken(1, LineType.SUBCKT, ".SUBCKT OUTER A B", "..."),
    CDLToken(5, LineType.SUBCKT, ".SUBCKT INNER X Y", "..."),
    CDLToken(10, LineType.ENDS, ".ENDS INNER", "..."),
    CDLToken(15, LineType.ENDS, ".ENDS OUTER", "...")
]
```

**Fixtures**:
- `simple_subckt_tokens` - Single block
- `nested_subckt_tokens` - Two-level nesting
- `complex_subckt_tokens` - Multiple definitions, various port counts

### Validation Testing

**Domain Model Validation**:
```python
def test_subcircuit_definition_validation():
    # Test __post_init__ validation
    with pytest.raises(ValueError, match="empty"):
        SubcircuitDefinition(name="", ports=["A"])

    with pytest.raises(ValueError, match="at least one port"):
        SubcircuitDefinition(name="INV", ports=[])

    with pytest.raises(ValueError, match="duplicate"):
        SubcircuitDefinition(name="INV", ports=["A", "A"])
```

---

## Risks and Considerations

### Risk 1: Nested Redefinition Ambiguity
**Likelihood**: Low
**Impact**: Medium

**Description**: If nested `.SUBCKT` blocks redefine the same cell name, which definition should be stored?

**Example**:
```
.SUBCKT INV A Y
  .SUBCKT INV X Z  # Inner redefinition
  .ENDS INV
.ENDS INV
```

**Mitigation**:
- Current approach: Last definition wins (overwrites in dict)
- **Better**: Raise error on duplicate definition
- Document expected CDL format (no redefinitions)

**Decision**: Raise warning but allow (for MVP flexibility)

### Risk 2: Large Port Lists Performance
**Likelihood**: Low
**Impact**: Low

**Description**: Some cells (e.g., register files) have 100+ ports

**Mitigation**:
- Tuple conversion in `__post_init__` is O(n)
- Duplicate check is O(n) with set conversion
- Acceptable for n < 1000

### Risk 3: Case Sensitivity
**Likelihood**: Medium
**Impact**: Low

**Description**: CDL files may use inconsistent casing (VDD vs vdd)

**Mitigation**:
- Store names exactly as provided in CDL
- Document that names are case-sensitive
- Instance parser will use exact string matching

**Future Enhancement**: Add case-insensitive lookup option

### Risk 4: Special Characters in Names
**Likelihood**: Low
**Impact**: Low

**Description**: Port/cell names with special chars (e.g., `VDD!`, `net<0>`)

**Mitigation**:
- No validation on allowed characters in MVP
- Rely on CDL generation tools to produce valid names
- Add character validation if issues arise

### Implementation Complexity
**Overall**: Low

**Rationale**:
- Well-defined parsing grammar
- Simple state management (stack)
- Clear domain model
- Good separation from lexer

### Integration Challenges
**Level**: Low

**Considerations**:
- Depends on stable lexer output (E01-F01-T01 must complete first)
- Instance parser needs access to definitions (simple dict lookup)
- Error reporting needs line numbers (provided by tokens)

---

## Success Metrics

### Functional Requirements
- [ ] 95%+ code coverage
- [ ] Parse all subcircuits from PRD sample file
- [ ] Correct nesting validation (detect unclosed/unmatched blocks)
- [ ] All port lists in correct order

### Non-Functional Requirements
- [ ] Parse 10K subcircuit definitions in <100ms
- [ ] Zero memory leaks (immutable value objects)
- [ ] Clear error messages with line numbers

### Quality Gates
- [ ] All unit tests pass
- [ ] Mypy strict type checking passes
- [ ] Immutability enforced (frozen dataclass)
- [ ] Documentation complete

---

## Implementation Checklist

### Phase 1: Domain Model (0.5-1 hour)
- [ ] Create `src/ink/domain/value_objects/subcircuit.py`
- [ ] Implement `SubcircuitDefinition` dataclass
- [ ] Add validation in `__post_init__`
- [ ] Write domain model unit tests

### Phase 2: Parser Core (1-1.5 hours)
- [ ] Create `src/ink/infrastructure/parsing/subcircuit_parser.py`
- [ ] Implement `SubcircuitParser.__init__`
- [ ] Implement `parse_subckt_line` method
- [ ] Implement `parse_ends_line` method
- [ ] Add `validate_complete` method

### Phase 3: Testing (1-1.5 hours)
- [ ] Write parsing tests (simple, nested, sequential)
- [ ] Write error handling tests
- [ ] Write edge case tests
- [ ] Create token fixtures

### Phase 4: Validation (0.5 hour)
- [ ] Run full test suite
- [ ] Type checking
- [ ] Linting
- [ ] Integration test with lexer output

**Total Estimated Time**: 3-4 hours (matches spec estimate)
