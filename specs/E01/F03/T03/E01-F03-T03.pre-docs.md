# E01-F03-T03: NetworkX Graph Builder - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F03-T03 - NetworkX Graph Builder
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5
- **Estimated Hours**: 8

---

## 1. Overview

### 1.1 Problem Context

The Design aggregate (T02) provides entity storage with efficient O(1) lookup, but schematic operations require graph-based connectivity queries. Questions like "what cells are in the fanout of XI1?" or "what is the path from input to output?" require graph traversal algorithms that are not naturally expressible with simple entity relationships.

We need to bridge the domain model (Cell, Pin, Net) with a graph representation that enables:
- Efficient fanin/fanout traversal
- Path finding between cells
- Connectivity analysis
- Subgraph extraction for incremental rendering

This task implements a **graph adapter** that translates the Design aggregate into a NetworkX MultiDiGraph, mapping domain semantics onto graph structure while maintaining clean architectural separation.

### 1.2 Goals

1. Build NetworkX `MultiDiGraph` from Design aggregate entities
2. Map domain entities (Cell, Pin, Net, Port) to graph nodes with attributes
3. Represent connectivity as directed edges following signal flow
4. Implement builder pattern for incremental graph construction
5. Design adapter interface for future migration to rustworkx
6. Achieve target performance: <100ms for 1000-cell design

### 1.3 Success Criteria

- Graph accurately represents Design connectivity
- All entity types mapped to nodes with appropriate attributes
- Edge directions follow signal flow (output→net→input)
- Builder pattern enables clean construction
- All acceptance criteria from spec are met
- Integration tests verify correctness with sample designs
- Performance benchmark: 1000-cell graph in <100ms

---

## 2. Implementation Approach

### 2.1 Architecture Alignment

**Layer**: Infrastructure Layer
**Pattern**: Adapter Pattern (wraps NetworkX)
**Future-Proofing**: Abstract interface enables rustworkx migration

**Key Architectural Decisions**:

1. **MultiDiGraph for Multiple Edges**:
   - Cells can have multiple pins connected to same net
   - MultiDiGraph allows multiple edges between same nodes
   - Example: Cell with two inputs both on same net

2. **Hybrid Node Model (Cell, Pin, Net, Port)**:
   - Cells are nodes (high-level connectivity)
   - Pins are nodes (fine-grained direction awareness)
   - Nets are nodes (connection points)
   - Ports are nodes (I/O boundaries)
   - Enables both coarse and fine-grained queries

3. **Edge Direction Follows Signal Flow**:
   ```
   Output Pin → Net → Input Pin
   Cell → Pin (contains)
   Port (input) → Net → Port (output)
   ```

4. **Entity References in Node Attributes**:
   - Store original domain entity in `entity` attribute
   - Enables easy retrieval of full entity details
   - No data duplication (graph stores reference, not copy)

### 2.2 Graph Structure Design

**Node Types and Attributes**:

| Node Type | Attributes | Example |
|-----------|-----------|---------|
| Cell | `node_type='cell'`, `name`, `cell_type`, `is_sequential`, `entity` | `{'node_type': 'cell', 'name': 'XI1', 'cell_type': 'INV_X1', 'is_sequential': False, 'entity': <Cell>}` |
| Pin | `node_type='pin'`, `name`, `direction`, `net_id`, `entity` | `{'node_type': 'pin', 'name': 'A', 'direction': PinDirection.INPUT, 'entity': <Pin>}` |
| Net | `node_type='net'`, `name`, `pin_count`, `entity` | `{'node_type': 'net', 'name': 'net1', 'pin_count': 3, 'entity': <Net>}` |
| Port | `node_type='port'`, `name`, `direction`, `net_id`, `entity` | `{'node_type': 'port', 'name': 'data_in', 'direction': PinDirection.INPUT, 'entity': <Port>}` |

**Edge Types and Directions**:

| Edge | Direction | Type | Meaning |
|------|-----------|------|---------|
| Cell → Pin | Outgoing | `contains_pin` | Cell owns this pin |
| Output Pin → Net | Outgoing | `drives` | Pin drives signal onto net |
| Net → Input Pin | Outgoing | `drives` | Net drives signal into pin |
| Input Port → Net | Outgoing | `drives` | Port drives internal net |
| Net → Output Port | Outgoing | `drives` | Net drives output port |

**Why This Structure?**

- **Explicit Pin Nodes**: Enables pin-level queries (fanout from specific pin)
- **Net as Connection Hub**: Natural representation of multi-fanout
- **Direction Semantics**: Edge direction = signal flow direction
- **Type Attributes**: Easy filtering (get all cell nodes, all sequential cells)

### 2.3 Implementation Strategy

**Phase 1: Core Builder Class** (2 hours)
1. Create `src/ink/infrastructure/graph/networkx_adapter.py`
2. Implement `NetworkXGraphBuilder` class with `MultiDiGraph` storage
3. Implement `build_from_design(design: Design)` entry point
4. Clear existing graph on rebuild

**Phase 2: Node Creation** (2 hours)
1. Implement `_add_cell_nodes()` - iterate cells, create nodes with attributes
2. Implement `_add_pin_nodes()` - iterate pins, create nodes with attributes
3. Implement `_add_net_nodes()` - iterate nets, create nodes with attributes
4. Implement `_add_port_nodes()` - iterate ports, create nodes with attributes
5. Use entity IDs as node IDs for consistent references

**Phase 3: Edge Creation** (2 hours)
1. Implement `_add_cell_pin_edges()` - Cell → Pin edges for containment
2. Implement `_add_pin_net_edges()` - Pin ↔ Net edges based on pin direction
3. Implement `_add_port_net_edges()` - Port ↔ Net edges based on port direction
4. Handle edge direction logic (output→net, net→input)

**Phase 4: Utility Methods** (1 hour)
1. Implement `get_node_entity()` - retrieve domain entity from node
2. Implement `get_node_type()` - retrieve node type
3. Implement statistics: `node_count()`, `edge_count()`, `cell_node_count()`
4. Implement `get_graph()` - return constructed graph

**Phase 5: Testing** (3 hours)
1. Unit tests for node creation
2. Unit tests for edge creation
3. Integration tests with sample designs
4. Performance benchmarks
5. Validation tests (verify graph structure)

---

## 3. Key Design Decisions

### Decision 1: Node ID Strategy

**Options**:
1. Use entity IDs directly as node IDs
2. Generate sequential integer IDs
3. Use UUIDs

**Decision**: Use entity IDs directly (CellId, PinId, NetId, PortId as strings)

**Rationale**:
- Semantic meaning (can identify node from ID)
- Easy mapping back to Design entities
- NetworkX supports string IDs efficiently (dict-based)
- Debugging-friendly (see `"XI1"` instead of `42`)

**Example**:
```python
graph.add_node(cell.id, node_type='cell', entity=cell)
# Node ID: "XI1" (directly from CellId)
```

### Decision 2: Edge Direction Convention

**Question**: How to represent connectivity in edge direction?

**Options**:
1. All edges bidirectional (undirected graph)
2. Arbitrary direction (doesn't matter)
3. Direction follows signal flow

**Decision**: Direction follows signal flow (output→net→input)

**Rationale**:
- Semantic meaning (edges show data flow)
- Enables directed queries (fanout follows edge direction)
- Matches electrical intuition (driver→load)
- Simplifies fanin/fanout logic in T04

**Edge Direction Rules**:
```python
# Output pins drive nets
if pin.direction.is_output():
    graph.add_edge(pin.id, pin.net_id, edge_type='drives')

# Input pins are driven by nets
else:  # is_input()
    graph.add_edge(pin.net_id, pin.id, edge_type='drives')
```

### Decision 3: MultiGraph vs DiGraph

**Options**:
1. `DiGraph` - one edge per node pair
2. `MultiDiGraph` - multiple edges per node pair
3. `Graph` - undirected

**Decision**: `MultiDiGraph`

**Rationale**:
- Real netlists have multiple pins connecting same cell to same net
- Example: AND2 with both inputs tied to same net
- MultiDiGraph allows multiple edges without loss of information
- Slightly more memory, but more accurate representation

**Trade-off**: ~10% more memory, but prevents information loss.

### Decision 4: Store Entity References in Nodes?

**Question**: Should graph nodes store reference to domain entities?

**Decision**: Yes, store `entity` reference in node attributes

**Rationale**:
- Enables easy entity retrieval (no separate lookup in Design)
- Application layer can get full entity details from graph node
- Small memory cost (pointer to existing object, not copy)
- Simplifies query implementations in T04

**Example**:
```python
graph.add_node(cell.id, node_type='cell', entity=cell)
# Later:
cell_entity = graph.nodes[cell_id]['entity']
```

**Alternative Considered**: Store only IDs, require Design lookup
- Pros: Less coupling, slightly less memory
- Cons: Requires passing Design to all query methods, slower

### Decision 5: Builder Pattern vs Static Methods

**Question**: How should graph construction be initiated?

**Options**:
1. Static method: `NetworkXGraphBuilder.build(design)`
2. Instance method: `builder = NetworkXGraphBuilder(); builder.build(design)`
3. Factory function: `build_graph_from_design(design)`

**Decision**: Instance method with builder pattern

**Rationale**:
- Allows stateful building (can inspect intermediate state)
- Enables incremental construction if needed
- Can reuse builder instance for multiple designs
- Follows spec example code

**Usage**:
```python
builder = NetworkXGraphBuilder()
graph = builder.build_from_design(design)
```

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Direct Dependencies**:
- `E01-F03-T01` (Domain Entities): Cell, Pin, Net, Port types
- `E01-F03-T02` (Design Aggregate): Design aggregate to read from
- `networkx`: External graph library

**Import Structure**:
```python
import networkx as nx
from ...domain.model import Design, Cell, Pin, Net, Port
from ...domain.value_objects import CellId, NetId, PinId, PortId
```

### 4.2 Downstream Dependencies

**Consumed By**:

1. **E01-F03-T04 (Graph Query Interface)**:
   - Will use `NetworkXGraphBuilder` to create graph
   - Will query graph for fanin/fanout traversal
   - Will access node attributes for entity details

2. **E02 (Schematic Rendering)**:
   - Will use graph for layout computation
   - Will read node positions from graph
   - Will use edges for net routing

3. **E03 (Incremental Expansion)**:
   - Will query graph for expansion candidates
   - Will extract subgraphs for visible cells
   - Will use sequential cell markers

4. **E05 (Search and Navigation)**:
   - Will search graph nodes by attributes
   - Will use path finding on graph
   - Will highlight paths in graph

### 4.3 Integration Patterns

**Construction Pattern**:
```python
# Infrastructure layer creates graph from domain
design = design_repository.get_current_design()
builder = NetworkXGraphBuilder()
graph = builder.build_from_design(design)

# Application layer uses graph for queries
traverser = NetworkXGraphTraverser(graph, design)
fanout = traverser.get_fanout_cells(cell_id, hops=2)
```

**Query Pattern**:
```python
# Access entity from graph node
node_data = graph.nodes[cell_id]
cell_entity = node_data['entity']
cell_type = node_data['cell_type']
```

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Coverage Target**: 90%+

**Test Structure**:
```
tests/unit/infrastructure/graph/
└── test_networkx_adapter.py
```

### 5.2 Test Cases

**Builder Initialization**:
```python
def test_builder_creates_empty_graph():
    """Should initialize with empty MultiDiGraph"""
    builder = NetworkXGraphBuilder()

    assert isinstance(builder.graph, nx.MultiDiGraph)
    assert builder.node_count() == 0
    assert builder.edge_count() == 0

def test_builder_clears_graph_on_rebuild():
    """Should clear existing graph when building from new design"""
    builder = NetworkXGraphBuilder()
    design1 = create_simple_design()  # Helper fixture
    builder.build_from_design(design1)
    count1 = builder.node_count()

    design2 = Design(name="empty")
    builder.build_from_design(design2)

    assert builder.node_count() == 0  # Previous nodes cleared
```

**Node Creation**:
```python
def test_add_cell_nodes_creates_nodes_with_attributes():
    """Should create cell nodes with correct attributes"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", is_sequential=False)
    design.add_cell(cell)

    builder.build_from_design(design)

    assert "XI1" in builder.graph.nodes
    node_data = builder.graph.nodes["XI1"]
    assert node_data['node_type'] == 'cell'
    assert node_data['name'] == "XI1"
    assert node_data['cell_type'] == "INV_X1"
    assert node_data['is_sequential'] is False
    assert node_data['entity'] == cell

def test_add_pin_nodes_creates_nodes_with_attributes():
    """Should create pin nodes with correct attributes"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")
    pin = Pin(id=PinId("p1"), name="A", direction=PinDirection.INPUT, net_id=NetId("net1"))
    design.add_pin(pin)

    builder.build_from_design(design)

    assert "p1" in builder.graph.nodes
    node_data = builder.graph.nodes["p1"]
    assert node_data['node_type'] == 'pin'
    assert node_data['direction'] == PinDirection.INPUT
```

**Edge Creation**:
```python
def test_add_cell_pin_edges_creates_containment_edges():
    """Should create Cell→Pin edges with contains_pin type"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")

    pin = Pin(id=PinId("XI1.A"), name="A", direction=PinDirection.INPUT, net_id=None)
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", pin_ids=[PinId("XI1.A")])

    design.add_pin(pin)
    design.add_cell(cell)

    builder.build_from_design(design)

    assert builder.graph.has_edge("XI1", "XI1.A")
    edge_data = builder.graph.edges["XI1", "XI1.A", 0]  # MultiDiGraph key
    assert edge_data['edge_type'] == 'contains_pin'

def test_output_pin_drives_net():
    """Should create Output Pin→Net edge"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")

    net = Net(id=NetId("net1"), name="net1")
    pin = Pin(id=PinId("p1"), name="Y", direction=PinDirection.OUTPUT, net_id=NetId("net1"))

    design.add_net(net)
    design.add_pin(pin)

    builder.build_from_design(design)

    assert builder.graph.has_edge("p1", "net1")
    edge_data = builder.graph.edges["p1", "net1", 0]
    assert edge_data['edge_type'] == 'drives'

def test_net_drives_input_pin():
    """Should create Net→Input Pin edge"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")

    net = Net(id=NetId("net1"), name="net1")
    pin = Pin(id=PinId("p1"), name="A", direction=PinDirection.INPUT, net_id=NetId("net1"))

    design.add_net(net)
    design.add_pin(pin)

    builder.build_from_design(design)

    assert builder.graph.has_edge("net1", "p1")
    edge_data = builder.graph.edges["net1", "p1", 0]
    assert edge_data['edge_type'] == 'drives'

def test_inout_pin_creates_bidirectional_edges():
    """Should create both Pin→Net and Net→Pin for INOUT pins"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")

    net = Net(id=NetId("net1"), name="net1")
    pin = Pin(id=PinId("p1"), name="IO", direction=PinDirection.INOUT, net_id=NetId("net1"))

    design.add_net(net)
    design.add_pin(pin)

    builder.build_from_design(design)

    # INOUT pins are both input and output, so both edges should exist
    assert builder.graph.has_edge("p1", "net1")  # Output direction
    assert builder.graph.has_edge("net1", "p1")  # Input direction
```

**Utility Methods**:
```python
def test_get_node_entity_returns_entity():
    """Should retrieve domain entity from graph node"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
    design.add_cell(cell)
    builder.build_from_design(design)

    entity = builder.get_node_entity("XI1")

    assert entity == cell

def test_get_node_type_returns_type():
    """Should retrieve node type"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
    design.add_cell(cell)
    builder.build_from_design(design)

    node_type = builder.get_node_type("XI1")

    assert node_type == 'cell'

def test_cell_node_count_returns_correct_count():
    """Should count only cell nodes"""
    builder = NetworkXGraphBuilder()
    design = Design(name="test")
    design.add_cell(Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1"))
    design.add_cell(Cell(id=CellId("XI2"), name="XI2", cell_type="INV_X1"))
    design.add_net(Net(id=NetId("net1"), name="net1"))
    builder.build_from_design(design)

    assert builder.cell_node_count() == 2
    assert builder.net_node_count() == 1
```

### 5.3 Integration Tests

```python
def test_build_inverter_chain_graph():
    """Should build complete graph for 3-inverter chain"""
    # Setup: Create design with 3 inverters in chain
    design = Design(name="inverter_chain")

    # Nets: in → net1 → net2 → out
    design.add_net(Net(id=NetId("in"), name="in", connected_pin_ids=[PinId("XI1.A")]))
    design.add_net(Net(id=NetId("net1"), name="net1", connected_pin_ids=[PinId("XI1.Y"), PinId("XI2.A")]))
    design.add_net(Net(id=NetId("net2"), name="net2", connected_pin_ids=[PinId("XI2.Y"), PinId("XI3.A")]))
    design.add_net(Net(id=NetId("out"), name="out", connected_pin_ids=[PinId("XI3.Y")]))

    # Cells and Pins
    for i in range(1, 4):
        cell_id = CellId(f"XI{i}")
        pin_a_id = PinId(f"XI{i}.A")
        pin_y_id = PinId(f"XI{i}.Y")

        design.add_pin(Pin(id=pin_a_id, name="A", direction=PinDirection.INPUT, net_id=NetId(...)))
        design.add_pin(Pin(id=pin_y_id, name="Y", direction=PinDirection.OUTPUT, net_id=NetId(...)))
        design.add_cell(Cell(id=cell_id, name=f"XI{i}", cell_type="INV_X1", pin_ids=[pin_a_id, pin_y_id]))

    # Build graph
    builder = NetworkXGraphBuilder()
    graph = builder.build_from_design(design)

    # Verify structure
    assert builder.cell_node_count() == 3
    assert builder.net_node_count() == 4

    # Verify connectivity: Should be able to traverse from XI1 to XI3
    # (This verifies edges are correctly directed)
    assert nx.has_path(graph, "XI1", "XI3")  # Path exists through net nodes
```

### 5.4 Performance Tests

```python
@pytest.mark.benchmark
def test_build_1000_cell_design_performance(benchmark):
    """Should build graph from 1000-cell design in <100ms"""
    design = generate_large_design(num_cells=1000)  # Helper to generate synthetic design

    builder = NetworkXGraphBuilder()

    result = benchmark(builder.build_from_design, design)

    assert benchmark.stats.mean < 0.1  # <100ms
    assert builder.cell_node_count() == 1000
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: NetworkX Performance on Large Graphs**

**Impact**: High (slow construction, poor UX)
**Probability**: Medium

**Description**: NetworkX is pure Python, may be slow for 100K+ nodes.

**Mitigation**:
- Benchmark early with 1K, 10K, 100K cell graphs
- Set performance SLA: <100ms for 1000 cells
- Design adapter interface from start (enables rustworkx swap)
- Optimize hot paths (batch node/edge additions)

**Contingency**:
- Migrate to rustworkx (Rust-based graph library)
- Use custom adjacency list representation
- Lazy graph construction (build on-demand)

**Risk 2: Memory Overhead from Graph Duplication**

**Impact**: Medium (high memory usage)
**Probability**: Medium

**Description**: Graph stores references to entities + node attributes, doubling memory footprint.

**Mitigation**:
- Store entity references, not copies (pointer overhead only)
- Use intern for common strings (cell types, pin names)
- Measure memory with `memory_profiler`
- Target: <10% memory overhead vs Design alone

**Contingency**:
- Don't store entity reference, query Design on-demand
- Store only minimal attributes in graph
- Implement graph compaction (remove unused attributes)

**Risk 3: MultiDiGraph Edge Key Management**

**Impact**: Low (edge key confusion)
**Probability**: Low

**Description**: MultiDiGraph edges have keys (0, 1, 2...), can be confusing.

**Mitigation**:
- Always access edges with explicit key: `graph.edges[u, v, 0]`
- Document edge key usage
- Provide helper methods that hide key complexity
- In queries (T04), iterate all edges between nodes

**Example**:
```python
# Get all edges between two nodes
for u, v, key, data in graph.edges(nbunch=[node_id], keys=True, data=True):
    print(f"Edge {u}→{v} (key={key}): {data}")
```

**Risk 4: INOUT Pin Edge Direction Ambiguity**

**Impact**: Medium (incorrect traversal)
**Probability**: Low

**Description**: INOUT pins are both input and output, need bidirectional edges.

**Mitigation**:
- Create both directions for INOUT pins
- Document this behavior clearly
- Test bidirectional traversal for INOUT pins
- Mark INOUT edges with special attribute if needed

**Implementation**:
```python
if pin.direction == PinDirection.INOUT:
    # INOUT pins need both directions
    graph.add_edge(pin.id, pin.net_id, edge_type='drives')
    graph.add_edge(pin.net_id, pin.id, edge_type='drives')
```

### 6.2 Design Risks

**Risk 5: Tight Coupling to NetworkX API**

**Impact**: High (hard to migrate)
**Probability**: High

**Description**: Direct NetworkX usage throughout codebase makes migration difficult.

**Mitigation**:
- Encapsulate NetworkX in `NetworkXGraphBuilder`
- T04 query interface abstracts graph operations
- Design for replaceability (clear adapter boundaries)
- Keep NetworkX imports localized to infrastructure layer

**Future Migration Path**:
```python
# Define abstract interface
class GraphBuilder(Protocol):
    def build_from_design(self, design: Design) -> Graph: ...

# Implement for NetworkX
class NetworkXGraphBuilder(GraphBuilder): ...

# Future: Implement for rustworkx
class RustworkxGraphBuilder(GraphBuilder): ...
```

**Risk 6: Graph Structure Assumptions in Downstream Code**

**Impact**: Medium (brittle queries)
**Probability**: Medium

**Description**: T04 queries might depend on specific graph structure.

**Mitigation**:
- Document graph structure clearly (this pre-docs)
- Provide examples of correct graph queries
- Write integration tests that verify structure
- Keep structure simple and consistent

### 6.3 Integration Risks

**Risk 7: Design-Graph Synchronization**

**Impact**: Medium (stale data)
**Probability**: Low

**Description**: If Design changes after graph built, graph becomes stale.

**Mitigation**:
- Graph is immutable once built (rebuild on changes)
- Design aggregate doesn't support removal (MVP)
- Document that graph is snapshot, not live view
- Can add incremental update in P1 if needed

**Risk 8: Node ID Collisions**

**Impact**: High (corrupted graph)
**Probability**: Very Low

**Description**: If entity IDs collide (cell and net with same ID), graph corrupts.

**Mitigation**:
- Trust Design aggregate to enforce unique IDs
- Design validation (T02) prevents duplicate IDs
- Entity IDs have type prefixes in practice (CellId, NetId are distinct types)
- Add assertion checks in debug mode

---

## 7. Open Questions and Decisions Needed

### Question 1: Should we support hierarchical graphs?

**Current Approach**: Flat graph (all entities at one level)

**Consideration**: Real netlists have subcircuit hierarchy

**Decision**: Flat graph for MVP
- Matches Design aggregate (flat)
- Hierarchy flattening happens in parser
- Can add hierarchy metadata to nodes later

### Question 2: Should edges store additional metadata?

**Current Approach**: Edge type only (`contains_pin`, `drives`)

**Potential Metadata**:
- Net name on connectivity edges
- Fanout count
- Timing criticality (future)

**Decision**: Minimal metadata for MVP
- Edge type sufficient for MVP queries
- Can add metadata later without breaking API
- Keep it simple (YAGNI)

### Question 3: Should we cache graph statistics?

**Current Approach**: Compute on-demand

**Alternative**: Cache node counts, edge counts

**Decision**: No caching for MVP
- Statistics calls are rare (mostly for debugging)
- NetworkX operations are fast enough
- Premature optimization

**Future**: Add caching if profiling shows bottleneck

### Question 4: How to handle disconnected subgraphs?

**Current Approach**: No special handling

**Consideration**: Some cells might not be connected (unused logic)

**Decision**: Include all entities in graph
- Graph will have disconnected components
- NetworkX handles this naturally
- Queries can check connectivity: `nx.is_connected(graph.to_undirected())`

---

## 8. Implementation Checklist

### Phase 1: Core Builder
- [ ] Create `src/ink/infrastructure/graph/` directory
- [ ] Create `networkx_adapter.py`
- [ ] Implement `NetworkXGraphBuilder` class with `MultiDiGraph`
- [ ] Implement `build_from_design(design: Design)` method
- [ ] Clear graph on rebuild

### Phase 2: Node Creation
- [ ] Implement `_add_cell_nodes()` - iterate design.get_all_cells()
- [ ] Implement `_add_pin_nodes()` - iterate design.get_all_pins()
- [ ] Implement `_add_net_nodes()` - iterate design.get_all_nets()
- [ ] Implement `_add_port_nodes()` - iterate design.get_all_ports()
- [ ] Store entity IDs as node IDs
- [ ] Add node attributes: type, name, entity reference

### Phase 3: Edge Creation
- [ ] Implement `_add_cell_pin_edges()` - Cell → Pin for each cell.pin_ids
- [ ] Implement `_add_pin_net_edges()` - Pin ↔ Net based on pin.direction
  - [ ] OUTPUT: Pin → Net
  - [ ] INPUT: Net → Pin
  - [ ] INOUT: Both directions
- [ ] Implement `_add_port_net_edges()` - Port ↔ Net based on port.direction
- [ ] Add edge attributes: edge_type

### Phase 4: Utility Methods
- [ ] Implement `get_graph()` - return self.graph
- [ ] Implement `get_node_entity(node_id)` - return node['entity']
- [ ] Implement `get_node_type(node_id)` - return node['node_type']
- [ ] Implement `node_count()` - return graph.number_of_nodes()
- [ ] Implement `edge_count()` - return graph.number_of_edges()
- [ ] Implement `cell_node_count()` - count nodes with type='cell'
- [ ] Implement `net_node_count()` - count nodes with type='net'

### Phase 5: Testing
- [ ] Test builder initialization
- [ ] Test graph clearing on rebuild
- [ ] Test cell node creation with attributes
- [ ] Test pin node creation with attributes
- [ ] Test net node creation with attributes
- [ ] Test port node creation with attributes
- [ ] Test cell→pin edges
- [ ] Test output pin→net edges
- [ ] Test net→input pin edges
- [ ] Test INOUT pin bidirectional edges
- [ ] Test input port→net edges
- [ ] Test net→output port edges
- [ ] Test utility methods (get_node_entity, etc.)
- [ ] Test statistics methods
- [ ] Integration test: 3-inverter chain
- [ ] Performance test: 1000-cell design <100ms
- [ ] Achieve 90%+ coverage

### Phase 6: Documentation
- [ ] Add class docstring to `NetworkXGraphBuilder`
- [ ] Document graph structure in module docstring
- [ ] Add docstrings to all public methods
- [ ] Add inline comments for edge direction logic
- [ ] Create `__init__.py` with exports

### Phase 7: Validation
- [ ] Run tests: `pytest tests/unit/infrastructure/graph/ -v`
- [ ] Run coverage: `pytest --cov=src/ink/infrastructure/graph`
- [ ] Run mypy: `mypy src/ink/infrastructure/graph/`
- [ ] Run ruff: `ruff check src/ink/infrastructure/graph/`
- [ ] Review against spec acceptance criteria
- [ ] Performance benchmark meets targets

---

## 9. Success Metrics

### Code Quality
- **Test Coverage**: 90%+ (unit + integration)
- **Type Coverage**: 100% of public APIs
- **Linting**: Zero warnings from ruff
- **Documentation**: All public methods documented

### Performance
- **Build Time**: <100ms for 1000-cell design
- **Memory Overhead**: <10% vs Design alone
- **Node Lookup**: O(1) (NetworkX dict-based)

### Functional
- **Graph Correctness**: All entities mapped to nodes
- **Edge Correctness**: All edges follow signal flow
- **Integration**: Works with sample designs from T02

---

## 10. Definition of Done

- [ ] All acceptance criteria from spec are met
- [ ] `NetworkXGraphBuilder` class implemented
- [ ] `build_from_design()` creates complete graph
- [ ] All node types created with correct attributes
- [ ] All edge types created with correct direction
- [ ] Entity references stored in node attributes
- [ ] Utility methods implemented
- [ ] 90%+ unit test coverage achieved
- [ ] Integration test with inverter chain passes
- [ ] Performance benchmark: 1000 cells <100ms
- [ ] `mypy --strict` passes with zero errors
- [ ] `ruff check` passes with zero warnings
- [ ] All docstrings written (Google style)
- [ ] Module exports configured
- [ ] Code reviewed

---

## Appendix A: Graph Structure Example

**Input Design** (3-inverter chain):
```
Cells: XI1, XI2, XI3 (all INV_X1)
Nets: in, net1, net2, out
Pins: XI1.A, XI1.Y, XI2.A, XI2.Y, XI3.A, XI3.Y
Connections:
  in → XI1.A
  XI1.Y → net1 → XI2.A
  XI2.Y → net2 → XI3.A
  XI3.Y → out
```

**Output Graph**:
```
Nodes:
  XI1: {type: 'cell', cell_type: 'INV_X1', entity: <Cell>}
  XI2: {type: 'cell', cell_type: 'INV_X1', entity: <Cell>}
  XI3: {type: 'cell', cell_type: 'INV_X1', entity: <Cell>}
  in: {type: 'net', name: 'in', entity: <Net>}
  net1: {type: 'net', name: 'net1', entity: <Net>}
  net2: {type: 'net', name: 'net2', entity: <Net>}
  out: {type: 'net', name: 'out', entity: <Net>}
  XI1.A: {type: 'pin', direction: INPUT, entity: <Pin>}
  XI1.Y: {type: 'pin', direction: OUTPUT, entity: <Pin>}
  ... (6 pin nodes total)

Edges:
  XI1 → XI1.A (contains_pin)
  XI1 → XI1.Y (contains_pin)
  in → XI1.A (drives)
  XI1.Y → net1 (drives)
  net1 → XI2.A (drives)
  ... (12 edges total)
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
