---
id: E01-F03-T03
title: NetworkX Graph Builder
type: Task
priority: P0 (MVP)
status: Completed
parent: E01-F03
created: 2025-12-26
completed: 2025-12-27
estimated_hours: 8
actual_hours: 4
effort: Medium
tags:
  - infrastructure
  - networkx
  - graph-builder
clickup_task_id: '86evzm2fq'
github_issue: 56
---

# Spec: E01-F03-T03 - NetworkX Graph Builder

## 1. Overview

### 1.1 Problem Statement
The Design aggregate provides entity storage, but schematic operations require efficient graph-based connectivity queries (fanin/fanout traversal). A NetworkX-based graph adapter is needed to translate the Design aggregate into a queryable graph structure.

### 1.2 Goals
- Build NetworkX MultiDiGraph from Design aggregate entities
- Map domain entities to graph nodes with appropriate attributes
- Represent connectivity as directed edges (Cell→Pin, Pin→Net)
- Provide builder pattern for incremental graph construction
- Design for future migration to rustworkx

---

## 2. Technical Requirements

### 2.1 File Structure

```
src/ink/infrastructure/
├── graph/
│   ├── __init__.py
│   └── networkx_adapter.py   # Graph builder and adapter
```

### 2.2 NetworkX Graph Builder

**File**: `src/ink/infrastructure/graph/networkx_adapter.py`

```python
import networkx as nx
from typing import Dict, Optional
from ...domain.model import Design, Cell, Pin, Net, Port
from ...domain.value_objects import CellId, NetId, PinId, PortId

class NetworkXGraphBuilder:
    """Builds NetworkX graph from Design aggregate"""

    def __init__(self):
        self.graph: nx.MultiDiGraph = nx.MultiDiGraph()
        self._design: Optional[Design] = None

    def build_from_design(self, design: Design) -> nx.MultiDiGraph:
        """Build graph from Design aggregate"""
        self._design = design
        self.graph.clear()

        # Add all nodes first
        self._add_cell_nodes()
        self._add_pin_nodes()
        self._add_net_nodes()
        self._add_port_nodes()

        # Then add edges
        self._add_cell_pin_edges()
        self._add_pin_net_edges()
        self._add_port_net_edges()

        return self.graph

    def _add_cell_nodes(self) -> None:
        """Add Cell nodes to graph"""
        for cell in self._design.get_all_cells():
            self.graph.add_node(
                cell.id,
                node_type='cell',
                name=cell.name,
                cell_type=cell.cell_type,
                is_sequential=cell.is_sequential,
                entity=cell  # Store reference for easy retrieval
            )

    def _add_pin_nodes(self) -> None:
        """Add Pin nodes to graph"""
        for pin in self._design.get_all_pins():
            self.graph.add_node(
                pin.id,
                node_type='pin',
                name=pin.name,
                direction=pin.direction,
                net_id=pin.net_id,
                entity=pin
            )

    def _add_net_nodes(self) -> None:
        """Add Net nodes to graph"""
        for net in self._design.get_all_nets():
            self.graph.add_node(
                net.id,
                node_type='net',
                name=net.name,
                pin_count=net.pin_count(),
                entity=net
            )

    def _add_port_nodes(self) -> None:
        """Add Port nodes to graph"""
        for port in self._design.get_all_ports():
            self.graph.add_node(
                port.id,
                node_type='port',
                name=port.name,
                direction=port.direction,
                net_id=port.net_id,
                entity=port
            )

    def _add_cell_pin_edges(self) -> None:
        """Add Cell→Pin edges for containment"""
        for cell in self._design.get_all_cells():
            for pin_id in cell.pin_ids:
                self.graph.add_edge(
                    cell.id,
                    pin_id,
                    edge_type='contains_pin'
                )

    def _add_pin_net_edges(self) -> None:
        """Add Pin→Net edges for connectivity"""
        for pin in self._design.get_all_pins():
            if pin.net_id:
                # Direction depends on pin direction
                if pin.direction.is_output():
                    # Output pins drive nets: Pin → Net
                    self.graph.add_edge(
                        pin.id,
                        pin.net_id,
                        edge_type='drives'
                    )
                else:
                    # Input pins are driven by nets: Net → Pin
                    self.graph.add_edge(
                        pin.net_id,
                        pin.id,
                        edge_type='drives'
                    )

    def _add_port_net_edges(self) -> None:
        """Add Port→Net edges for top-level connectivity"""
        for port in self._design.get_all_ports():
            if port.net_id:
                if port.direction.is_input():
                    # Input ports drive internal nets: Port → Net
                    self.graph.add_edge(
                        port.id,
                        port.net_id,
                        edge_type='drives'
                    )
                else:
                    # Output ports are driven by internal nets: Net → Port
                    self.graph.add_edge(
                        port.net_id,
                        port.id,
                        edge_type='drives'
                    )

    def get_graph(self) -> nx.MultiDiGraph:
        """Get the constructed graph"""
        return self.graph

    def get_node_entity(self, node_id: str):
        """Get the domain entity associated with a graph node"""
        return self.graph.nodes[node_id].get('entity')

    def get_node_type(self, node_id: str) -> str:
        """Get the type of a graph node"""
        return self.graph.nodes[node_id].get('node_type')

    # Graph statistics
    def node_count(self) -> int:
        """Get total number of nodes"""
        return self.graph.number_of_nodes()

    def edge_count(self) -> int:
        """Get total number of edges"""
        return self.graph.number_of_edges()

    def cell_node_count(self) -> int:
        """Get number of cell nodes"""
        return sum(1 for _, data in self.graph.nodes(data=True)
                   if data.get('node_type') == 'cell')

    def net_node_count(self) -> int:
        """Get number of net nodes"""
        return sum(1 for _, data in self.graph.nodes(data=True)
                   if data.get('node_type') == 'net')
```

### 2.3 Graph Structure

**Node Types**:
- **Cell nodes**: `node_type='cell'`, attributes: `name`, `cell_type`, `is_sequential`
- **Pin nodes**: `node_type='pin'`, attributes: `name`, `direction`, `net_id`
- **Net nodes**: `node_type='net'`, attributes: `name`, `pin_count`
- **Port nodes**: `node_type='port'`, attributes: `name`, `direction`, `net_id`

**Edge Types**:
- `Cell → Pin`: `edge_type='contains_pin'` (containment relationship)
- `Pin → Net`: `edge_type='drives'` (output pins drive nets)
- `Net → Pin`: `edge_type='drives'` (nets drive input pins)
- `Port → Net`: `edge_type='drives'` (input ports drive nets)
- `Net → Port`: `edge_type='drives'` (nets drive output ports)

**Edge Direction Rules**:
```
OUTPUT Pin → Net
Net → INPUT Pin
Net → INOUT Pin (bidirectional)
INPUT Port → Net
Net → OUTPUT Port
```

### 2.4 Module Exports

**File**: `src/ink/infrastructure/graph/__init__.py`

```python
from .networkx_adapter import NetworkXGraphBuilder

__all__ = [
    'NetworkXGraphBuilder',
]
```

---

## 3. Dependencies

- **Upstream**:
  - E01-F03-T01 (Domain Model Entities) - uses Cell, Pin, Net, Port
  - E01-F03-T02 (Design Aggregate) - reads Design aggregate
- **Downstream**:
  - E01-F03-T04 (Graph Query Interface) - uses graph for queries
- **External Libraries**:
  - `networkx` (already in tech stack)

---

## 4. Acceptance Criteria

- [x] `NetworkXGraphBuilder` class implemented
- [x] `build_from_design(design: Design)` method creates complete graph
- [x] Cell nodes added with attributes: `name`, `cell_type`, `is_sequential`, `entity`
- [x] Pin nodes added with attributes: `name`, `direction`, `net_id`, `entity`
- [x] Net nodes added with attributes: `name`, `pin_count`, `entity`
- [x] Port nodes added with attributes: `name`, `direction`, `net_id`, `entity`
- [x] Cell→Pin edges added with `edge_type='contains_pin'`
- [x] Pin→Net edges added with correct direction based on pin direction
- [x] Port→Net edges added with correct direction based on port direction
- [x] `get_node_entity()` retrieves original domain entity from graph node
- [x] `get_node_type()` retrieves node type classification
- [x] Graph statistics: `node_count()`, `edge_count()`, `cell_node_count()`, `net_node_count()`
- [x] Graph is MultiDiGraph to support multiple edges between nodes
- [x] Builder pattern allows incremental construction
- [x] Unit tests with 87%+ coverage (55 tests)
- [x] Integration tests with sample Design aggregates (10-100 cells) (13 tests)
- [x] Performance test: build graph from 1000-cell design in ~6ms (well under 100ms)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
| 2025-12-27 | 1.0 | Claude | Implementation complete with TDD workflow |
