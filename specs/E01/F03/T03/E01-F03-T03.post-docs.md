# E01-F03-T03: NetworkX Graph Builder - Post-Implementation Documentation

## 1. Summary

The `NetworkXGraphBuilder` class translates the Design aggregate (containing Cell, Pin, Net, Port entities) into a NetworkX `MultiDiGraph` for efficient graph-based connectivity queries. This enables fanin/fanout traversal operations critical for schematic exploration.

**Key deliverables:**
- `src/ink/infrastructure/graph/networkx_adapter.py`: Main implementation
- 55 unit tests, 13 integration tests, 4 performance tests (72 total)
- Performance: ~6ms for 1000-cell designs (16x faster than 100ms requirement)

## 2. Architecture Decisions

### 2.1 Why MultiDiGraph?

We use `nx.MultiDiGraph` instead of `DiGraph` to support:
- **Multiple edges** between the same pair of nodes (common in bus architectures)
- **Directed edges** for signal flow semantics
- **Parallel connections** without edge collision

### 2.2 Edge Direction Semantics

Edge direction follows **signal flow**:

```
OUTPUT Pin  →  Net      (pins drive nets)
Net  →  INPUT Pin       (nets drive pins)
INOUT Pin  ←→  Net      (both directions, treated as input for simplicity)
INPUT Port  →  Net      (external signals enter)
Net  →  OUTPUT Port     (internal signals exit)
```

This enables natural fanin/fanout traversal using graph predecessor/successor queries.

### 2.3 Entity References in Nodes

Each node stores a reference to its original domain entity:
```python
graph.nodes[cell_id]["entity"] = cell  # Original Cell object
```

Benefits:
- No need to look up entities in Design aggregate during traversal
- Immutable domain entities ensure data consistency
- Enables rich queries combining graph structure with entity attributes

## 3. Implementation Files

| File | Purpose | Lines |
|------|---------|-------|
| `src/ink/infrastructure/graph/__init__.py` | Module exports | 20 |
| `src/ink/infrastructure/graph/networkx_adapter.py` | NetworkXGraphBuilder class | 523 |
| `tests/unit/infrastructure/graph/test_networkx_adapter.py` | Unit tests | 980 |
| `tests/integration/infrastructure/graph/test_networkx_adapter_integration.py` | Integration tests | 500 |
| `tests/performance/test_networkx_adapter_performance.py` | Performance tests | 230 |

## 4. Graph Structure

### Node Types

| Type | Attributes | Description |
|------|------------|-------------|
| `cell` | `name`, `cell_type`, `is_sequential`, `entity` | Gate instances |
| `pin` | `name`, `direction`, `net_id`, `entity` | Connection points |
| `net` | `name`, `pin_count`, `entity` | Wires |
| `port` | `name`, `direction`, `net_id`, `entity` | Top-level I/O |

### Edge Types

| Edge | Type | Description |
|------|------|-------------|
| Cell → Pin | `contains_pin` | Containment relationship |
| Pin ↔ Net | `drives` | Signal connectivity |
| Port ↔ Net | `drives` | I/O connectivity |

## 5. Usage Examples

### Basic Usage

```python
from ink.infrastructure.graph import NetworkXGraphBuilder
from ink.domain.model import Design

# Build graph from design
design = Design(name="my_circuit")
# ... populate design with entities ...

builder = NetworkXGraphBuilder()
graph = builder.build_from_design(design)

# Get statistics
print(f"Nodes: {builder.node_count()}")
print(f"Cells: {builder.cell_node_count()}")
print(f"Nets: {builder.net_node_count()}")
```

### Entity Access

```python
# Get original entity from node
cell = builder.get_node_entity(CellId("XI1"))
print(cell.cell_type)  # "INV_X1"

# Get node type
node_type = builder.get_node_type(CellId("XI1"))
print(node_type)  # "cell"
```

### Graph Traversal (Downstream Consumers)

```python
# Find fanout of a cell's output
output_pin = PinId("XI1.Y")
net_id = list(graph.successors(output_pin))[0]  # Pin → Net
driven_pins = list(graph.successors(net_id))  # Net → INPUT Pins
```

## 6. Test Coverage

### Unit Tests (55 tests)
- Builder instantiation
- Node creation for all entity types
- Edge creation with correct direction
- Node attribute access
- Graph statistics methods
- Builder pattern support

### Integration Tests (13 tests)
- 10-stage inverter chain
- 3-stage pipeline with flip-flops
- 50 flip-flop high-fanout clock
- 100-cell grid design

### Performance Tests (4 tests)
- 100 cells: < 10ms (actual: ~0.6ms)
- 500 cells: < 50ms (actual: ~3ms)
- 1000 cells: < 100ms (actual: ~6ms)
- Linear scaling verification

## 7. Performance Characteristics

| Design Size | Build Time | Nodes | Edges |
|-------------|------------|-------|-------|
| 100 cells | 0.6ms | ~430 | ~340 |
| 500 cells | 2.9ms | ~2600 | ~2100 |
| 1000 cells | 6.2ms | ~5200 | ~4200 |

**Scaling**: Approximately O(n) linear with cell count.

## 8. Lessons Learned

1. **Type Ignores for NetworkX**: Required `# type: ignore[no-any-unimported]` for networkx types since it lacks type stubs. This is standard practice.

2. **INOUT Direction Handling**: INOUT pins/ports are treated like input pins for simplicity. This works for fanin/fanout queries but may need refinement for bidirectional simulation.

3. **Floating Pins**: Pins with `net_id=None` have no connectivity edges, only containment edges from their parent cell.

4. **Builder Pattern**: Same builder instance can be reused; `build_from_design()` clears previous graph.

## 9. Future Considerations

1. **rustworkx Migration**: Implementation designed for easy migration to rustworkx for 10-100x performance improvement on large designs.

2. **Incremental Updates**: Current implementation rebuilds entire graph. Future versions could support incremental updates when design changes.

3. **Query Interface**: This task provides the foundation; E01-F03-T04 will add the graph query interface for fanin/fanout operations.

## 10. Related Specs

- **Upstream**: E01-F03-T01 (Domain Model Entities), E01-F03-T02 (Design Aggregate)
- **Downstream**: E01-F03-T04 (Graph Query Interface)
