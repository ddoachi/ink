---
id: E01-F03-T02
title: Design Aggregate Root
type: Task
priority: P0 (MVP)
status: Complete
parent: E01-F03
created: 2025-12-26
completed: 2025-12-27
estimated_hours: 6
actual_hours: 4
effort: Medium
tags:
  - domain-model
  - aggregate
  - design
clickup_task_id: '86evzm2fn'
---

# Spec: E01-F03-T02 - Design Aggregate Root

## 1. Overview

### 1.1 Problem Statement
The graph construction system needs an aggregate root that manages the collection of all entities (cells, nets, pins, ports) and enforces domain invariants. The Design aggregate serves as the consistency boundary and entry point for all netlist data operations.

### 1.2 Goals
- Implement Design as an aggregate root following DDD principles
- Provide collections for cells, nets, pins, and ports with O(1) lookup
- Enforce domain invariants (e.g., no duplicate IDs, valid references)
- Provide factory methods for creating entities
- Support immutable access patterns for thread safety

---

## 2. Technical Requirements

### 2.1 File Structure

```
src/ink/domain/
├── model/
│   ├── design.py         # Design aggregate root
│   └── ...               # Other entities (from T01)
```

### 2.2 Design Aggregate

**File**: `src/ink/domain/model/design.py`

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional
from .cell import Cell
from .pin import Pin
from .net import Net
from .port import Port
from ..value_objects.identifiers import CellId, NetId, PinId, PortId

@dataclass
class Design:
    """Design aggregate root managing all netlist entities"""
    name: str                           # Design/subcircuit name
    _cells: Dict[CellId, Cell] = field(default_factory=dict, repr=False)
    _nets: Dict[NetId, Net] = field(default_factory=dict, repr=False)
    _pins: Dict[PinId, Pin] = field(default_factory=dict, repr=False)
    _ports: Dict[PortId, Port] = field(default_factory=dict, repr=False)

    # Indexes for efficient lookup
    _cell_name_index: Dict[str, CellId] = field(default_factory=dict, repr=False)
    _net_name_index: Dict[str, NetId] = field(default_factory=dict, repr=False)
    _port_name_index: Dict[str, PortId] = field(default_factory=dict, repr=False)

    def add_cell(self, cell: Cell) -> None:
        """Add a cell to the design"""
        if cell.id in self._cells:
            raise ValueError(f"Cell with id {cell.id} already exists")
        if cell.name in self._cell_name_index:
            raise ValueError(f"Cell with name {cell.name} already exists")

        self._cells[cell.id] = cell
        self._cell_name_index[cell.name] = cell.id

    def add_net(self, net: Net) -> None:
        """Add a net to the design"""
        if net.id in self._nets:
            raise ValueError(f"Net with id {net.id} already exists")
        if net.name in self._net_name_index:
            raise ValueError(f"Net with name {net.name} already exists")

        self._nets[net.id] = net
        self._net_name_index[net.name] = net.id

    def add_pin(self, pin: Pin) -> None:
        """Add a pin to the design"""
        if pin.id in self._pins:
            raise ValueError(f"Pin with id {pin.id} already exists")

        self._pins[pin.id] = pin

    def add_port(self, port: Port) -> None:
        """Add a port to the design"""
        if port.id in self._ports:
            raise ValueError(f"Port with id {port.id} already exists")
        if port.name in self._port_name_index:
            raise ValueError(f"Port with name {port.name} already exists")

        self._ports[port.id] = port
        self._port_name_index[port.name] = port.id

    # Getters by ID (O(1))
    def get_cell(self, cell_id: CellId) -> Optional[Cell]:
        """Get cell by ID"""
        return self._cells.get(cell_id)

    def get_net(self, net_id: NetId) -> Optional[Net]:
        """Get net by ID"""
        return self._nets.get(net_id)

    def get_pin(self, pin_id: PinId) -> Optional[Pin]:
        """Get pin by ID"""
        return self._pins.get(pin_id)

    def get_port(self, port_id: PortId) -> Optional[Port]:
        """Get port by ID"""
        return self._ports.get(port_id)

    # Getters by name (O(1) via index)
    def get_cell_by_name(self, name: str) -> Optional[Cell]:
        """Get cell by instance name"""
        cell_id = self._cell_name_index.get(name)
        return self._cells.get(cell_id) if cell_id else None

    def get_net_by_name(self, name: str) -> Optional[Net]:
        """Get net by name"""
        net_id = self._net_name_index.get(name)
        return self._nets.get(net_id) if net_id else None

    def get_port_by_name(self, name: str) -> Optional[Port]:
        """Get port by name"""
        port_id = self._port_name_index.get(name)
        return self._ports.get(port_id) if port_id else None

    # Collection accessors (return immutable views)
    def get_all_cells(self) -> List[Cell]:
        """Get all cells in the design"""
        return list(self._cells.values())

    def get_all_nets(self) -> List[Net]:
        """Get all nets in the design"""
        return list(self._nets.values())

    def get_all_pins(self) -> List[Pin]:
        """Get all pins in the design"""
        return list(self._pins.values())

    def get_all_ports(self) -> List[Port]:
        """Get all ports in the design"""
        return list(self._ports.values())

    # Statistics
    def cell_count(self) -> int:
        """Get total number of cells"""
        return len(self._cells)

    def net_count(self) -> int:
        """Get total number of nets"""
        return len(self._nets)

    def pin_count(self) -> int:
        """Get total number of pins"""
        return len(self._pins)

    def port_count(self) -> int:
        """Get total number of ports"""
        return len(self._ports)

    def sequential_cell_count(self) -> int:
        """Get number of sequential cells (latches/FFs)"""
        return sum(1 for cell in self._cells.values() if cell.is_sequential)

    # Validation
    def validate(self) -> List[str]:
        """Validate design integrity and return list of errors"""
        errors: List[str] = []

        # Check pin references
        for pin in self._pins.values():
            if pin.net_id and pin.net_id not in self._nets:
                errors.append(f"Pin {pin.id} references non-existent net {pin.net_id}")

        # Check cell pin references
        for cell in self._cells.values():
            for pin_id in cell.pin_ids:
                if pin_id not in self._pins:
                    errors.append(f"Cell {cell.id} references non-existent pin {pin_id}")

        # Check net pin references
        for net in self._nets.values():
            for pin_id in net.connected_pin_ids:
                if pin_id not in self._pins:
                    errors.append(f"Net {net.id} references non-existent pin {pin_id}")

        # Check port net references
        for port in self._ports.values():
            if port.net_id and port.net_id not in self._nets:
                errors.append(f"Port {port.id} references non-existent net {port.net_id}")

        return errors

    def __repr__(self) -> str:
        return (
            f"Design(name='{self.name}', "
            f"cells={self.cell_count()}, "
            f"nets={self.net_count()}, "
            f"pins={self.pin_count()}, "
            f"ports={self.port_count()})"
        )
```

### 2.3 Factory Methods (Optional Enhancement)

For more complex entity creation, consider adding factory methods:

```python
def create_cell(
    self,
    name: str,
    cell_type: str,
    is_sequential: bool = False
) -> Cell:
    """Factory method to create and add a cell"""
    cell_id = CellId(name)  # or use UUID generator
    cell = Cell(
        id=cell_id,
        name=name,
        cell_type=cell_type,
        is_sequential=is_sequential,
    )
    self.add_cell(cell)
    return cell
```

---

## 3. Dependencies

- **Upstream**:
  - E01-F03-T01 (Domain Model Entities) - uses Cell, Pin, Net, Port
- **Downstream**:
  - E01-F03-T03 (Graph Builder) - populates Design aggregate
  - E01-F03-T04 (Graph Query Interface) - queries Design data

---

## 4. Acceptance Criteria

- [x] `Design` class implemented as aggregate root
- [x] Collections for cells, nets, pins, ports with private storage
- [x] `add_cell()`, `add_net()`, `add_pin()`, `add_port()` methods with duplicate checking
- [x] ID-based getters: `get_cell()`, `get_net()`, `get_pin()`, `get_port()` (O(1))
- [x] Name-based getters: `get_cell_by_name()`, `get_net_by_name()`, `get_port_by_name()` (O(1))
- [x] Collection accessors: `get_all_cells()`, `get_all_nets()`, `get_all_pins()`, `get_all_ports()`
- [x] Statistics methods: `cell_count()`, `net_count()`, `pin_count()`, `port_count()`, `sequential_cell_count()`
- [x] `validate()` method to check referential integrity
- [x] ValueError raised for duplicate IDs or names
- [x] Name indexes maintained for O(1) lookup
- [x] Immutable collection views returned (not internal dicts)
- [x] Unit tests with 95%+ coverage (63 tests, all passing)
- [x] Test coverage includes: add operations, duplicate detection, getters, validation

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
| 2025-12-27 | 1.0 | Claude | Implementation complete, all acceptance criteria met |

## 5. Implementation Notes

### Files Changed

| File | Change Type | Description |
|------|-------------|-------------|
| `src/ink/domain/model/design.py` | Modified | Rewritten as domain aggregate with dual-index architecture |
| `src/ink/infrastructure/parsing/parsed_design.py` | Created | Infrastructure representation for CDL parser output |
| `src/ink/infrastructure/parsing/cdl_parser.py` | Modified | Updated to return `ParsedDesign` |
| `tests/unit/domain/model/test_design_aggregate.py` | Created | 63 comprehensive tests |

### Architecture Decision: Layer Separation

The implementation separates:
- **Domain layer** (`Design`): Works with domain entities (`Cell`, `Pin`, `Net`, `Port`)
- **Infrastructure layer** (`ParsedDesign`): Works with value objects (`CellInstance`, `NetInfo`, `SubcircuitDefinition`)

This follows DDD principles and allows the future Graph Builder (E01-F03-T03) to transform parsed data into domain entities.

### Documentation

- [Post-docs](./E01-F03-T02.post-docs.md) - Key learnings and decisions
- [Implementation Narrative](./E01-F03-T02-implementation-narrative.md) - Comprehensive implementation story
