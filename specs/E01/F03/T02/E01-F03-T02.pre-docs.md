# E01-F03-T02: Design Aggregate Root - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F03-T02 - Design Aggregate Root
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5
- **Estimated Hours**: 6

---

## 1. Overview

### 1.1 Problem Context

The domain entities (Cell, Pin, Net, Port) from T01 need a consistency boundary and lifecycle manager. In Domain-Driven Design, this role is fulfilled by an **Aggregate Root** - a central entity that enforces invariants and controls access to related entities.

The Design aggregate serves as the single entry point for all netlist data operations. It must:
- Manage collections of entities with O(1) lookup performance
- Enforce domain invariants (no duplicate IDs/names, valid references)
- Provide both ID-based and name-based lookup
- Support validation of referential integrity
- Enable efficient queries for statistics and bulk operations

Without this aggregate, entities would be scattered across the codebase with no central ownership, making it impossible to enforce consistency rules or optimize queries.

### 1.2 Goals

1. Implement Design as an aggregate root following DDD principles
2. Provide O(1) lookup for entities by ID and by name (using indexes)
3. Enforce domain invariants during entity addition
4. Support referential integrity validation
5. Enable efficient bulk queries (get all cells, count by type, etc.)
6. Maintain clean separation from infrastructure concerns

### 1.3 Success Criteria

- Design aggregate manages all four entity types (Cell, Pin, Net, Port)
- Add operations validate uniqueness and update indexes atomically
- Lookup operations achieve O(1) time complexity
- Validation method detects dangling references
- All acceptance criteria from spec are met
- Unit tests achieve 95%+ coverage

---

## 2. Implementation Approach

### 2.1 Architecture Alignment

**Layer**: Domain Layer (Pure)
**Bounded Context**: Netlist Context
**Pattern**: Aggregate Root + Repository Pattern

**Key Architectural Decisions**:

1. **Mutable Aggregate, Immutable Entities**:
   - Design is mutable (can add entities)
   - Entities (Cell, Pin, Net, Port) remain frozen/immutable
   - Once added to Design, entities should not be modified

2. **Dual Index Strategy**:
   - Primary storage: `Dict[EntityId, Entity]` for O(1) ID lookup
   - Secondary index: `Dict[str, EntityId]` for O(1) name lookup
   - Indexes updated atomically on `add_*()` operations

3. **Private Storage, Public Accessors**:
   - Entity dictionaries are private (`_cells`, `_nets`, etc.)
   - Access only via getter methods
   - Return immutable views (copies of lists, not internal dicts)

4. **Eager Validation at Add Time**:
   - Check for duplicates immediately when adding
   - Fail fast with clear error messages
   - Defer cross-entity validation to `validate()` method

### 2.2 Data Structure Design

**Storage Layout**:
```python
@dataclass
class Design:
    name: str  # Design/subcircuit name

    # Primary storage (O(1) by ID)
    _cells: Dict[CellId, Cell] = field(default_factory=dict, repr=False)
    _nets: Dict[NetId, Net] = field(default_factory=dict, repr=False)
    _pins: Dict[PinId, Pin] = field(default_factory=dict, repr=False)
    _ports: Dict[PortId, Port] = field(default_factory=dict, repr=False)

    # Secondary indexes (O(1) by name)
    _cell_name_index: Dict[str, CellId] = field(default_factory=dict, repr=False)
    _net_name_index: Dict[str, NetId] = field(default_factory=dict, repr=False)
    _port_name_index: Dict[str, PortId] = field(default_factory=dict, repr=False)
    # Note: Pins don't have name index (accessed via cell + pin name combination)
```

**Why These Data Structures?**:
- **Dict for primary storage**: O(1) lookup, insertion, deletion
- **Separate name indexes**: Enables fast name-based search without scanning
- **No pin name index**: Pin names only meaningful in cell context
- **`repr=False`**: Prevent huge dict dumps in string representation

### 2.3 Implementation Strategy

**Phase 1: Core Structure** (1 hour)
1. Create `src/ink/domain/model/design.py`
2. Define Design dataclass with storage dictionaries
3. Implement `add_*()` methods with duplicate checking
4. Update indexes atomically

**Phase 2: Getters** (1.5 hours)
1. Implement ID-based getters (`get_cell()`, `get_net()`, etc.)
2. Implement name-based getters (`get_cell_by_name()`, etc.)
3. Implement collection accessors (`get_all_cells()`, etc.)
4. Return immutable views (list copies, not dict references)

**Phase 3: Statistics & Validation** (1.5 hours)
1. Implement count methods (`cell_count()`, `net_count()`, etc.)
2. Implement `sequential_cell_count()`
3. Implement `validate()` method with referential integrity checks
4. Implement `__repr__()` for debugging

**Phase 4: Testing** (2 hours)
1. Unit tests for add operations
2. Unit tests for duplicate detection
3. Unit tests for getters (ID and name-based)
4. Unit tests for validation logic
5. Unit tests for statistics methods
6. Edge case tests (empty design, missing references)

---

## 3. Key Design Decisions

### Decision 1: Mutable vs Immutable Aggregate

**Options**:
1. Immutable Design (return new Design on each add)
2. Mutable Design (modify in place)
3. Event Sourcing (append-only event log)

**Decision**: Mutable Design with controlled mutation

**Rationale**:
- Practical for builder pattern (parser adds entities incrementally)
- Better performance (no copying entire design on each add)
- Simpler mental model (aggregate manages internal state)
- Mutation controlled via public API (can't modify internals directly)

**Trade-off Accepted**: Less functional purity, but significant ergonomic and performance benefits.

### Decision 2: Eager vs Lazy Validation

**Options**:
1. Eager: Validate on each `add_*()` call
2. Lazy: Defer all validation to explicit `validate()` call
3. Hybrid: Basic checks on add, deep checks on validate

**Decision**: Hybrid approach

**Eager Checks** (on `add_*()`):
- Duplicate ID detection
- Duplicate name detection
- Prevents corrupt state

**Lazy Checks** (in `validate()`):
- Referential integrity (pin references valid net)
- Cross-entity constraints
- Can run after bulk construction

**Rationale**:
- Fail fast on obvious errors (duplicates)
- Allow incremental construction (references may not exist yet)
- Explicit validation step before using design

### Decision 3: Return Copies vs Views

**Question**: Should `get_all_cells()` return a view or a copy?

**Options**:
1. Return internal dict: `return self._cells`
2. Return dict values view: `return self._cells.values()`
3. Return list copy: `return list(self._cells.values())`

**Decision**: Return list copy

**Rationale**:
- Prevents accidental mutation of internal state
- Clear ownership (caller owns the list)
- Performance impact negligible for MVP (< 100K cells)
- Pythonic (users expect lists from "get_all" methods)

**Future Optimization**: Can return iterator if performance becomes issue:
```python
def iter_cells(self) -> Iterator[Cell]:
    return iter(self._cells.values())
```

### Decision 4: Name Index Design

**Question**: Should we index all entities by name?

**Decision**: Index cells, nets, and ports by name, but NOT pins

**Rationale**:
- Cell names are unique and globally meaningful (`"XI1"`)
- Net names are unique and globally meaningful (`"net_123"`)
- Port names are unique and globally meaningful (`"data_in"`)
- Pin names are NOT unique globally (many cells have `"A"` pin)
- Pins looked up via `(cell_name, pin_name)` combination

**Implication**: No `get_pin_by_name()` method - doesn't make sense without cell context.

### Decision 5: Error Handling Strategy

**Question**: How to handle add errors?

**Options**:
1. Raise exceptions immediately
2. Return success/failure boolean
3. Collect errors and return list

**Decision**: Raise `ValueError` immediately

**Rationale**:
- Fail fast - corruption should never happen
- Clear error messages with context
- Pythonic (exceptions are normal control flow)
- Forces caller to handle error (can't ignore return value)

**Example**:
```python
def add_cell(self, cell: Cell) -> None:
    if cell.id in self._cells:
        raise ValueError(f"Cell with id {cell.id} already exists")
    if cell.name in self._cell_name_index:
        raise ValueError(f"Cell with name {cell.name} already exists")
    # ... add to storage
```

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Direct Dependencies**:
- `E01-F03-T01` (Domain Model Entities): Cell, Pin, Net, Port, ID types

**Import Structure**:
```python
from .cell import Cell
from .pin import Pin
from .net import Net
from .port import Port
from ..value_objects.identifiers import CellId, NetId, PinId, PortId
```

### 4.2 Downstream Dependencies

**Consumed By**:

1. **E01-F03-T03 (Graph Builder)**:
   - Will call `get_all_cells()`, `get_all_nets()`, etc. to iterate entities
   - Will use getters to resolve references during graph construction

2. **E01-F03-T04 (Graph Query Interface)**:
   - Will query Design for entity details
   - Will use `get_cell()`, `get_net()` for lookups

3. **Infrastructure Layer (Parsers)**:
   - CDL parser will construct Design and call `add_cell()`, `add_net()`, etc.
   - Parser will call `validate()` after construction

4. **Application Layer (Use Cases)**:
   - File loading service will create Design from parser output
   - Search service will query Design by name

### 4.3 Integration Patterns

**Construction Pattern** (from parser):
```python
# Parser builds Design incrementally
design = Design(name="top_module")

# Add entities as they're parsed
for cell_data in parsed_cells:
    cell = Cell(...)
    design.add_cell(cell)

for net_data in parsed_nets:
    net = Net(...)
    design.add_net(net)

# Validate after construction
errors = design.validate()
if errors:
    raise ValidationError(errors)
```

**Query Pattern** (from application layer):
```python
# Application layer queries Design
design = design_repository.get_current_design()
cell = design.get_cell_by_name("XI1")
if cell and cell.is_latch():
    # ... do something
```

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Coverage Target**: 95%+

**Test Structure**:
```
tests/unit/domain/model/
└── test_design.py
```

### 5.2 Test Cases

**Add Operations**:
```python
def test_add_cell_success():
    """Should add cell to design and indexes"""
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")

    design.add_cell(cell)

    assert design.cell_count() == 1
    assert design.get_cell(CellId("XI1")) == cell
    assert design.get_cell_by_name("XI1") == cell

def test_add_cell_duplicate_id_raises_error():
    """Should raise ValueError when adding cell with duplicate ID"""
    design = Design(name="test")
    cell1 = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
    cell2 = Cell(id=CellId("XI1"), name="XI2", cell_type="INV_X1")

    design.add_cell(cell1)

    with pytest.raises(ValueError, match="Cell with id .* already exists"):
        design.add_cell(cell2)

def test_add_cell_duplicate_name_raises_error():
    """Should raise ValueError when adding cell with duplicate name"""
    design = Design(name="test")
    cell1 = Cell(id=CellId("XI1"), name="XINV", cell_type="INV_X1")
    cell2 = Cell(id=CellId("XI2"), name="XINV", cell_type="INV_X1")

    design.add_cell(cell1)

    with pytest.raises(ValueError, match="Cell with name .* already exists"):
        design.add_cell(cell2)
```

**Getter Operations**:
```python
def test_get_cell_returns_cell_when_exists():
    """Should return cell when ID exists"""
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
    design.add_cell(cell)

    result = design.get_cell(CellId("XI1"))

    assert result == cell

def test_get_cell_returns_none_when_not_exists():
    """Should return None when ID does not exist"""
    design = Design(name="test")

    result = design.get_cell(CellId("nonexistent"))

    assert result is None

def test_get_cell_by_name_returns_cell_when_exists():
    """Should return cell when name exists"""
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XINV", cell_type="INV_X1")
    design.add_cell(cell)

    result = design.get_cell_by_name("XINV")

    assert result == cell

def test_get_all_cells_returns_list_copy():
    """Should return list copy, not internal dict"""
    design = Design(name="test")
    cell1 = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
    cell2 = Cell(id=CellId("XI2"), name="XI2", cell_type="INV_X1")
    design.add_cell(cell1)
    design.add_cell(cell2)

    result = design.get_all_cells()

    assert isinstance(result, list)
    assert len(result) == 2
    assert cell1 in result
    assert cell2 in result

    # Modify list should not affect design
    result.clear()
    assert design.cell_count() == 2
```

**Statistics**:
```python
def test_cell_count_returns_correct_count():
    """Should return number of cells in design"""
    design = Design(name="test")
    assert design.cell_count() == 0

    design.add_cell(Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1"))
    assert design.cell_count() == 1

    design.add_cell(Cell(id=CellId("XI2"), name="XI2", cell_type="INV_X1"))
    assert design.cell_count() == 2

def test_sequential_cell_count():
    """Should count only sequential cells"""
    design = Design(name="test")
    design.add_cell(Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", is_sequential=False))
    design.add_cell(Cell(id=CellId("XFF1"), name="XFF1", cell_type="DFF_X1", is_sequential=True))
    design.add_cell(Cell(id=CellId("XFF2"), name="XFF2", cell_type="DFF_X1", is_sequential=True))

    assert design.sequential_cell_count() == 2
```

**Validation**:
```python
def test_validate_detects_dangling_pin_reference():
    """Should detect when pin references non-existent net"""
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", pin_ids=[PinId("p1")])
    pin = Pin(id=PinId("p1"), name="A", direction=PinDirection.INPUT, net_id=NetId("nonexistent"))

    design.add_cell(cell)
    design.add_pin(pin)

    errors = design.validate()

    assert len(errors) == 1
    assert "Pin p1 references non-existent net" in errors[0]

def test_validate_detects_invalid_cell_pin_reference():
    """Should detect when cell references non-existent pin"""
    design = Design(name="test")
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", pin_ids=[PinId("nonexistent")])

    design.add_cell(cell)

    errors = design.validate()

    assert len(errors) == 1
    assert "Cell XI1 references non-existent pin" in errors[0]

def test_validate_returns_empty_list_when_valid():
    """Should return empty list when design is valid"""
    design = Design(name="test")

    # Create valid structure
    net = Net(id=NetId("net1"), name="net1", connected_pin_ids=[PinId("p1")])
    pin = Pin(id=PinId("p1"), name="A", direction=PinDirection.INPUT, net_id=NetId("net1"))
    cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1", pin_ids=[PinId("p1")])

    design.add_net(net)
    design.add_pin(pin)
    design.add_cell(cell)

    errors = design.validate()

    assert len(errors) == 0
```

**Repr**:
```python
def test_repr_shows_summary():
    """Should show design summary in repr"""
    design = Design(name="test_design")
    design.add_cell(Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1"))
    design.add_net(Net(id=NetId("net1"), name="net1"))

    result = repr(design)

    assert "test_design" in result
    assert "cells=1" in result
    assert "nets=1" in result
```

### 5.3 Edge Cases to Test

1. **Empty design**: All counts should be 0, validate should pass
2. **Missing references**: Pin → net, cell → pin, net → pin, port → net
3. **Circular references**: Not possible with current model, but test anyway
4. **Large design**: 1000+ entities to verify performance doesn't degrade
5. **Unicode names**: Cells/nets with unicode characters in names

### 5.4 Integration Tests

```python
# Test full construction pipeline
def test_build_simple_inverter_design():
    """Should build complete design with cell, pins, net"""
    design = Design(name="inverter")

    # Create net
    net_in = Net(id=NetId("in"), name="in", connected_pin_ids=[PinId("XI1.A")])
    net_out = Net(id=NetId("out"), name="out", connected_pin_ids=[PinId("XI1.Y")])
    design.add_net(net_in)
    design.add_net(net_out)

    # Create pins
    pin_a = Pin(id=PinId("XI1.A"), name="A", direction=PinDirection.INPUT, net_id=NetId("in"))
    pin_y = Pin(id=PinId("XI1.Y"), name="Y", direction=PinDirection.OUTPUT, net_id=NetId("out"))
    design.add_pin(pin_a)
    design.add_pin(pin_y)

    # Create cell
    cell = Cell(
        id=CellId("XI1"),
        name="XI1",
        cell_type="INV_X1",
        pin_ids=[PinId("XI1.A"), PinId("XI1.Y")]
    )
    design.add_cell(cell)

    # Create ports
    port_in = Port(id=PortId("in"), name="in", direction=PinDirection.INPUT, net_id=NetId("in"))
    port_out = Port(id=PortId("out"), name="out", direction=PinDirection.OUTPUT, net_id=NetId("out"))
    design.add_port(port_in)
    design.add_port(port_out)

    # Validate
    errors = design.validate()
    assert len(errors) == 0

    # Verify structure
    assert design.cell_count() == 1
    assert design.net_count() == 2
    assert design.pin_count() == 2
    assert design.port_count() == 2
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: Memory Overhead from Dual Indexing**

**Impact**: Medium (memory usage)
**Probability**: Low

**Description**: Storing both ID→Entity dict and Name→ID dict increases memory.

**Mitigation**:
- Name index only stores string→ID mapping (small overhead)
- For 100K cells: ~100K strings × 50 bytes ≈ 5MB (negligible)
- Measure actual memory footprint in T03 integration tests

**Contingency**: If memory becomes issue, remove name indexes and scan dict values for name lookups (O(n) instead of O(1)).

**Risk 2: Validation Performance on Large Designs**

**Impact**: Medium (slow validation)
**Probability**: Medium

**Description**: `validate()` checks all references, could be slow for 100K+ entities.

**Mitigation**:
- Validation is optional (only run when needed)
- Can parallelize validation checks (check pins in parallel)
- Use early termination (stop after N errors)
- Limit: Validate only after full construction, not incrementally

**Contingency**: Add `validate(quick=True)` option for basic checks only.

**Risk 3: Thread Safety**

**Impact**: Low (MVP is single-threaded)
**Probability**: Low

**Description**: Design is mutable, concurrent access could corrupt state.

**Mitigation**:
- MVP is single-threaded (no concurrency)
- Document that Design is not thread-safe
- If needed later, add locking or make Design immutable with copy-on-write

**Risk 4: Large Design Repr Performance**

**Impact**: Low (debugging only)
**Probability**: High

**Description**: `repr()` on 100K cell design could be slow or huge.

**Mitigation**:
- Use `repr=False` on all storage dicts (already in spec)
- `__repr__()` only shows summary stats, not entity details
- Custom repr shows: `Design(name='top', cells=100000, nets=150000, ...)`

### 6.2 Design Risks

**Risk 5: API Stability**

**Impact**: Medium (breaking changes)
**Probability**: Medium

**Description**: Design API might need changes as requirements evolve.

**Mitigation**:
- Keep API minimal for MVP (only methods in spec)
- Follow semantic versioning (breaking changes = major version bump)
- Use deprecation warnings before removing methods
- Extensive tests will catch API changes

**Risk 6: Validation Incompleteness**

**Impact**: Medium (undetected corruption)
**Probability**: Medium

**Description**: `validate()` might not catch all invalid states.

**Mitigation**:
- Start with basic checks (references exist)
- Add more checks as bugs are discovered
- Accept that validation is best-effort, not proof of correctness
- Trust parser to generate valid structures

**Validation Checks for MVP**:
- ✓ Pin references valid net
- ✓ Cell references valid pins
- ✓ Net references valid pins
- ✓ Port references valid net
- ✗ No orphaned entities (unreachable from ports) - defer to P1
- ✗ No combinational loops - defer to P1
- ✗ No conflicting drivers - defer to P1

---

## 7. Open Questions and Decisions Needed

### Question 1: Should Design support entity removal?

**Current Approach**: No removal methods in spec

**Consideration**: What if parser needs to remove/replace entities?

**Decision**: No removal for MVP
- YAGNI - not needed for initial use cases
- Removal complicates index maintenance
- Removal requires cascade (delete cell → delete pins?)
- Can add in P1 if needed

**Workaround**: Build new Design if changes needed.

### Question 2: Should we support hierarchical designs?

**Current Approach**: Flat design (all cells at one level)

**Consideration**: Real netlists have subcircuit hierarchy

**Decision**: Flat design for MVP
- Matches spec (no hierarchy mentioned)
- Graph construction (T03) will flatten hierarchy
- Can add hierarchy in P1 with subcircuit references

**Implication**: Parser will need to flatten hierarchy before creating Design.

### Question 3: Factory methods vs direct construction?

**Spec includes factory method example**:
```python
def create_cell(self, name: str, cell_type: str, ...) -> Cell:
    cell_id = CellId(name)
    cell = Cell(id=cell_id, ...)
    self.add_cell(cell)
    return cell
```

**Decision**: No factory methods for MVP
- YAGNI - not clearly needed
- Parser can construct entities directly
- Factory methods duplicate logic (ID generation)
- Can add later if usage patterns emerge

**Prefer**: Direct construction by caller:
```python
cell = Cell(id=CellId("XI1"), ...)
design.add_cell(cell)
```

### Question 4: Should indexes be rebuilt on demand?

**Current Approach**: Indexes updated incrementally on add

**Alternative**: Rebuild all indexes on `get_*()` call

**Decision**: Incremental index updates
- Better performance (no rebuild overhead)
- Simpler invariants (indexes always in sync)
- Small cost on add (one extra dict insert)

---

## 8. Implementation Checklist

### Phase 1: Core Structure
- [ ] Create `src/ink/domain/model/design.py`
- [ ] Define Design dataclass with storage dicts and indexes
- [ ] Implement `add_cell()` with duplicate checking
- [ ] Implement `add_net()` with duplicate checking
- [ ] Implement `add_pin()` with duplicate checking
- [ ] Implement `add_port()` with duplicate checking
- [ ] Verify indexes updated atomically

### Phase 2: Getters
- [ ] Implement `get_cell(cell_id)` - O(1) ID lookup
- [ ] Implement `get_net(net_id)` - O(1) ID lookup
- [ ] Implement `get_pin(pin_id)` - O(1) ID lookup
- [ ] Implement `get_port(port_id)` - O(1) ID lookup
- [ ] Implement `get_cell_by_name(name)` - O(1) name lookup
- [ ] Implement `get_net_by_name(name)` - O(1) name lookup
- [ ] Implement `get_port_by_name(name)` - O(1) name lookup
- [ ] Implement `get_all_cells()` - returns list copy
- [ ] Implement `get_all_nets()` - returns list copy
- [ ] Implement `get_all_pins()` - returns list copy
- [ ] Implement `get_all_ports()` - returns list copy

### Phase 3: Statistics & Validation
- [ ] Implement `cell_count()` - returns len(_cells)
- [ ] Implement `net_count()` - returns len(_nets)
- [ ] Implement `pin_count()` - returns len(_pins)
- [ ] Implement `port_count()` - returns len(_ports)
- [ ] Implement `sequential_cell_count()` - count cells with is_sequential=True
- [ ] Implement `validate()` - check all references
  - [ ] Check pin → net references
  - [ ] Check cell → pin references
  - [ ] Check net → pin references
  - [ ] Check port → net references
- [ ] Implement `__repr__()` - show design summary

### Phase 4: Testing
- [ ] Test add_cell with valid input
- [ ] Test add_cell with duplicate ID
- [ ] Test add_cell with duplicate name
- [ ] Test add_net with valid input
- [ ] Test add_net with duplicate ID
- [ ] Test add_net with duplicate name
- [ ] Test add_pin with valid input
- [ ] Test add_pin with duplicate ID
- [ ] Test add_port with valid input
- [ ] Test add_port with duplicate ID
- [ ] Test add_port with duplicate name
- [ ] Test all getters return correct entities
- [ ] Test all getters return None for missing entities
- [ ] Test get_all_* returns list copies
- [ ] Test count methods return correct values
- [ ] Test sequential_cell_count counts only sequential cells
- [ ] Test validate detects all reference errors
- [ ] Test validate returns empty list for valid design
- [ ] Test repr shows summary
- [ ] Integration test: build complete inverter design
- [ ] Achieve 95%+ test coverage

### Phase 5: Documentation
- [ ] Add class-level docstring to Design
- [ ] Add docstrings to all add methods
- [ ] Add docstrings to all getter methods
- [ ] Add docstrings to statistics methods
- [ ] Add docstring to validate method
- [ ] Add usage examples in module docstring
- [ ] Update `src/ink/domain/model/__init__.py` to export Design

### Phase 6: Validation
- [ ] Run tests: `pytest tests/unit/domain/model/test_design.py -v`
- [ ] Run coverage: `pytest tests/unit/domain/model/test_design.py --cov`
- [ ] Run mypy: `mypy src/ink/domain/model/design.py`
- [ ] Run ruff: `ruff check src/ink/domain/model/design.py`
- [ ] Review against spec acceptance criteria

---

## 9. Success Metrics

### Code Quality
- **Test Coverage**: 95%+ (all methods tested)
- **Type Coverage**: 100% (all public APIs have type hints)
- **Linting**: Zero warnings from ruff
- **Documentation**: All public methods have docstrings

### Performance
- **Add Operation**: O(1) time complexity (measured)
- **Lookup by ID**: O(1) time complexity (measured)
- **Lookup by Name**: O(1) time complexity (measured)
- **Validation**: O(n) where n = total entities (acceptable)

### Functional
- **Duplicate Detection**: 100% - all duplicates caught
- **Index Consistency**: 100% - indexes always match storage
- **Validation Accuracy**: Detects all specified reference errors

---

## 10. Definition of Done

- [ ] All acceptance criteria from spec are met
- [ ] Design aggregate implemented with all methods
- [ ] Dual indexing (ID and name) working correctly
- [ ] Duplicate detection working for IDs and names
- [ ] Validation detects all reference errors
- [ ] 95%+ unit test coverage achieved
- [ ] `mypy --strict` passes with zero errors
- [ ] `ruff check` passes with zero warnings
- [ ] All docstrings written (Google style)
- [ ] Design exported from `src/ink/domain/model/__init__.py`
- [ ] Integration test builds complete design successfully
- [ ] Code reviewed (self-review checklist completed)

---

## Appendix A: API Reference

```python
class Design:
    """Aggregate root managing all netlist entities.

    Design is the central entry point for all netlist operations. It manages
    collections of cells, nets, pins, and ports, enforcing consistency rules
    and providing efficient lookup operations.

    Attributes:
        name: Design or subcircuit name

    Examples:
        >>> design = Design(name="top_module")
        >>> cell = Cell(id=CellId("XI1"), name="XI1", cell_type="INV_X1")
        >>> design.add_cell(cell)
        >>> design.cell_count()
        1
        >>> design.get_cell_by_name("XI1")
        Cell(id=CellId('XI1'), ...)
    """

    # Entity Management
    def add_cell(self, cell: Cell) -> None: ...
    def add_net(self, net: Net) -> None: ...
    def add_pin(self, pin: Pin) -> None: ...
    def add_port(self, port: Port) -> None: ...

    # Getters by ID (O(1))
    def get_cell(self, cell_id: CellId) -> Optional[Cell]: ...
    def get_net(self, net_id: NetId) -> Optional[Net]: ...
    def get_pin(self, pin_id: PinId) -> Optional[Pin]: ...
    def get_port(self, port_id: PortId) -> Optional[Port]: ...

    # Getters by Name (O(1))
    def get_cell_by_name(self, name: str) -> Optional[Cell]: ...
    def get_net_by_name(self, name: str) -> Optional[Net]: ...
    def get_port_by_name(self, name: str) -> Optional[Port]: ...

    # Collection Accessors (return copies)
    def get_all_cells(self) -> List[Cell]: ...
    def get_all_nets(self) -> List[Net]: ...
    def get_all_pins(self) -> List[Pin]: ...
    def get_all_ports(self) -> List[Port]: ...

    # Statistics
    def cell_count(self) -> int: ...
    def net_count(self) -> int: ...
    def pin_count(self) -> int: ...
    def port_count(self) -> int: ...
    def sequential_cell_count(self) -> int: ...

    # Validation
    def validate(self) -> List[str]: ...
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
