# E01-F03-T02: Design Aggregate Root - Post-Implementation Documentation

## Overview

This document captures the key learnings, design decisions, and implementation details from implementing the Design aggregate root for managing domain entities (`Cell`, `Pin`, `Net`, `Port`) in the Ink schematic viewer.

**Spec**: [E01-F03-T02.spec.md](./E01-F03-T02.spec.md)
**Status**: Complete
**Duration**: Single implementation session using TDD

## Implementation Summary

### What Was Built

1. **Domain Design Aggregate** (`src/ink/domain/model/design.py`)
   - Mutable aggregate root for managing immutable domain entities
   - Dual-index architecture for O(1) lookup by ID and name
   - Referential integrity validation
   - 63 comprehensive unit tests

2. **Infrastructure ParsedDesign** (`src/ink/infrastructure/parsing/parsed_design.py`)
   - Separation of concerns: infrastructure parsing output vs domain model
   - Maintains backward compatibility with CDL parser

### Key Metrics

| Metric | Value |
|--------|-------|
| Lines of Production Code | ~575 (Design) + ~230 (ParsedDesign) |
| Lines of Test Code | ~850 |
| Test Count | 63 (Design aggregate) + 18 (CDL parser integration) |
| Test Pass Rate | 100% (1422 total project tests) |
| Code Coverage | High (all public methods tested) |

## Architecture Decisions

### 1. Dual-Index Strategy

**Decision**: Use both ID-based and name-based indexes for efficient lookups.

**Rationale**:
- Graph traversal requires O(1) ID lookups for connectivity queries
- User interactions (search, property panel) need O(1) name lookups
- Dual indexes add minimal memory overhead (name strings already exist)

**Implementation**:
```python
@dataclass
class Design:
    _cells: dict[CellId, Cell]          # Primary: ID -> Entity
    _cell_name_index: dict[str, CellId]  # Secondary: Name -> ID
```

### 2. Mutable Aggregate, Immutable Entities

**Decision**: Design aggregate is mutable; contained entities are immutable (frozen dataclasses).

**Rationale**:
- Parsing builds design incrementally (can't pre-create all entities)
- Entities are shared across collections (immutability prevents aliasing bugs)
- Domain invariants enforced at aggregate level, not entity level

**Trade-offs**:
- (+) Natural incremental construction during parsing
- (+) Safe sharing of entity references
- (-) No transactional "commit" for bulk operations
- (-) Must return defensive copies from `get_all_*()` methods

### 3. Lazy vs Eager Validation

**Decision**: Use hybrid validation - eager for duplicates, lazy for referential integrity.

**Rationale**:
- Duplicate detection fails fast (prevents corrupt state)
- Referential integrity checked after full construction (entities may arrive out of order during parsing)

**Implementation**:
```python
# Eager: Immediate failure on duplicate
def add_cell(self, cell: Cell) -> None:
    if cell.id in self._cells:
        raise ValueError(f"Cell with id {cell.id} already exists")

# Lazy: Called after construction complete
def validate(self) -> list[str]:
    # Check all cross-references
```

### 4. Separation of ParsedDesign and Design

**Decision**: Create separate `ParsedDesign` class for CDL parser output.

**Rationale**:
- Infrastructure layer produces raw parsed data (CellInstance, NetInfo, SubcircuitDefinition)
- Domain layer works with domain entities (Cell, Pin, Net, Port)
- Future Graph Builder (E01-F03-T03) will transform ParsedDesign → Design

**Layer Separation**:
```
Infrastructure (ParsedDesign) → Application (Builder) → Domain (Design)
```

## Key Patterns Used

### 1. Aggregate Root Pattern (DDD)

The Design class acts as the single entry point for all entity operations:
- External code cannot directly modify internal collections
- All mutations go through aggregate methods (`add_cell()`, `add_net()`, etc.)
- Invariants enforced at the aggregate boundary

### 2. Factory Helpers in Tests

Test file uses factory functions for clean, readable tests:
```python
def create_test_cell(
    cell_id: str = "XI1",
    name: str | None = None,
    cell_type: str = "INV_X1",
    ...
) -> Cell:
    """Factory helper to create test cells with sensible defaults."""
```

### 3. Immutable Value Objects for IDs

Using `NewType` for typed IDs provides:
- Static type checking without runtime overhead
- Clear semantic distinction between ID types
- Simple serialization (just strings)

```python
CellId = NewType("CellId", str)
NetId = NewType("NetId", str)
```

## Lessons Learned

### 1. TDD Catches API Design Issues Early

Writing tests first revealed:
- Need for both ID and name-based lookups
- Importance of defensive copies for collection accessors
- Edge cases in duplicate detection (same ID vs same name)

### 2. Layer Separation Prevents Coupling

By creating `ParsedDesign`, we:
- Kept parser changes minimal (just rename import)
- Avoided mixing infrastructure and domain concerns
- Created clear transformation point for future builder

### 3. Comprehensive Docstrings Pay Off

Detailed docstrings with examples:
- Self-documenting code for future maintainers
- IDE autocompletion with context
- Living documentation that stays with the code

## Files Changed

| File | Change Type | Description |
|------|-------------|-------------|
| `src/ink/domain/model/design.py` | Modified | Completely rewritten as domain aggregate |
| `src/ink/infrastructure/parsing/parsed_design.py` | Created | New infrastructure class for parser output |
| `src/ink/infrastructure/parsing/cdl_parser.py` | Modified | Updated to return ParsedDesign |
| `src/ink/infrastructure/parsing/__init__.py` | Modified | Export ParsedDesign |
| `tests/unit/domain/model/test_design_aggregate.py` | Created | 63 comprehensive tests |
| `tests/unit/domain/model/test_design.py` | Deleted | Obsolete tests for old Design |
| `tests/integration/infrastructure/parsing/test_cdl_parser.py` | Modified | Updated docstring |

## API Reference

### Design Aggregate

```python
# Construction
design = Design(name="top_module")

# Add entities
design.add_cell(cell)      # Raises ValueError on duplicate ID/name
design.add_net(net)
design.add_pin(pin)        # No name uniqueness (pins share names across cells)
design.add_port(port)

# Query by ID (O(1))
cell = design.get_cell(CellId("XI1"))
net = design.get_net(NetId("clk"))
pin = design.get_pin(PinId("XI1.A"))
port = design.get_port(PortId("IN"))

# Query by name (O(1) via index)
cell = design.get_cell_by_name("XI1")
net = design.get_net_by_name("clk")
port = design.get_port_by_name("IN")

# Get all (returns defensive copy)
cells = design.get_all_cells()
nets = design.get_all_nets()
pins = design.get_all_pins()
ports = design.get_all_ports()

# Statistics
design.cell_count()           # Total cells
design.sequential_cell_count() # Flip-flops/latches only
design.net_count()
design.pin_count()
design.port_count()

# Validation
errors = design.validate()  # Returns list of error messages
```

## Integration Points

| Component | Interaction | Status |
|-----------|-------------|--------|
| CDL Parser | Produces ParsedDesign | Complete (updated) |
| Graph Builder | Transforms ParsedDesign → Design | Future (E01-F03-T03) |
| Expansion Service | Queries Design for connectivity | Future |
| Search Service | Uses name-based lookups | Future |

## Next Steps

1. **E01-F03-T03: Graph Builder** - Transform ParsedDesign to Design with proper Pin/Net relationships
2. **E01-F04: Graph Service** - Build NetworkX graph from Design for traversal
3. **Integration Tests** - End-to-end tests with real CDL files

## References

- [E01-F03-T02 Spec](./E01-F03-T02.spec.md)
- [E01-F03-T02 Pre-docs](./E01-F03-T02.pre-docs.md)
- [Architecture Documentation](../../../../docs/architecture/README.md)
- [DDD Architecture](../../../../docs/architecture/ddd-architecture.md)
