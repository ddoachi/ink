# Spec: E01-F03-T04 - Graph Query Interface

## Metadata
- **ID**: E01-F03-T04
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E01-F03](../E01-F03.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 8
- **Actual Hours**:
- **Effort**: Medium
- **Tags**: [domain-services, graph-queries, protocols]

---

## 1. Overview

### 1.1 Problem Statement
The schematic exploration features (incremental expansion, selection, search) require efficient graph traversal operations. A domain service interface (GraphTraverser protocol) is needed to abstract graph queries from the underlying NetworkX implementation, enabling testability and future library migration.

### 1.2 Goals
- Define GraphTraverser protocol in domain layer (interface)
- Implement NetworkXGraphTraverser in infrastructure layer
- Provide fanin/fanout queries with configurable hop count
- Support cell connectivity queries (connected nets, pins)
- Enable net-based cell lookups for selection operations
- Design for O(1) or O(k) query performance where k is result size

---

## 2. Technical Requirements

### 2.1 File Structure

```
src/ink/domain/
├── services/
│   ├── __init__.py
│   └── graph_traverser.py    # GraphTraverser Protocol

src/ink/infrastructure/
├── graph/
│   ├── __init__.py
│   ├── networkx_adapter.py   # (from T03)
│   └── networkx_traverser.py # NetworkXGraphTraverser implementation
```

### 2.2 Domain Service Protocol

**File**: `src/ink/domain/services/graph_traverser.py`

```python
from typing import Protocol, List, Set
from ..model import Cell, Pin, Net
from ..value_objects import CellId, PinId, NetId

class GraphTraverser(Protocol):
    """Domain service protocol for graph traversal operations"""

    def get_connected_cells(self, net_id: NetId) -> List[Cell]:
        """
        Get all cells connected to a net.

        Returns cells that have pins connected to the specified net.
        """
        ...

    def get_cell_pins(self, cell_id: CellId) -> List[Pin]:
        """
        Get all pins of a cell.

        Returns pins in the order they were added to the cell.
        """
        ...

    def get_pin_net(self, pin_id: PinId) -> Net | None:
        """
        Get the net connected to a pin.

        Returns None if pin is floating (not connected).
        """
        ...

    def get_fanout_cells(
        self,
        cell_id: CellId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """
        Get fanout cells (downstream) from a cell.

        Args:
            cell_id: Starting cell
            hops: Number of hops to traverse (1 = immediate fanout)
            stop_at_sequential: Stop traversal at sequential cells (latches/FFs)

        Returns:
            List of cells reachable within specified hops
        """
        ...

    def get_fanin_cells(
        self,
        cell_id: CellId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """
        Get fanin cells (upstream) to a cell.

        Args:
            cell_id: Starting cell
            hops: Number of hops to traverse (1 = immediate fanin)
            stop_at_sequential: Stop traversal at sequential cells (latches/FFs)

        Returns:
            List of cells reachable within specified hops
        """
        ...

    def get_fanout_from_pin(
        self,
        pin_id: PinId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """
        Get fanout cells from a specific pin.

        More precise than cell-based fanout - starts from a specific pin.
        """
        ...

    def get_fanin_to_pin(
        self,
        pin_id: PinId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """
        Get fanin cells to a specific pin.

        More precise than cell-based fanin - targets a specific pin.
        """
        ...

    def find_path(
        self,
        from_cell_id: CellId,
        to_cell_id: CellId,
        max_hops: int = 10
    ) -> List[Cell] | None:
        """
        Find shortest path between two cells.

        Returns None if no path exists within max_hops.
        Returns path as list of cells including start and end.
        """
        ...
```

### 2.3 NetworkX Implementation

**File**: `src/ink/infrastructure/graph/networkx_traverser.py`

```python
import networkx as nx
from typing import List, Set, Optional
from ...domain.model import Design, Cell, Pin, Net
from ...domain.value_objects import CellId, PinId, NetId
from ...domain.services.graph_traverser import GraphTraverser

class NetworkXGraphTraverser:
    """NetworkX-based implementation of GraphTraverser protocol"""

    def __init__(self, graph: nx.MultiDiGraph, design: Design):
        self.graph = graph
        self.design = design

    def get_connected_cells(self, net_id: NetId) -> List[Cell]:
        """Get all cells connected to a net via pins"""
        cells: List[Cell] = []
        seen_cell_ids: Set[CellId] = set()

        # Get all pins connected to this net
        # Net → Pin edges (for input pins)
        for _, pin_id, edge_data in self.graph.out_edges(net_id, data=True):
            if edge_data.get('edge_type') == 'drives':
                cell_ids = self._get_cells_for_pin(pin_id)
                for cell_id in cell_ids:
                    if cell_id not in seen_cell_ids:
                        cell = self.design.get_cell(cell_id)
                        if cell:
                            cells.append(cell)
                            seen_cell_ids.add(cell_id)

        # Pin → Net edges (for output pins)
        for pin_id, _, edge_data in self.graph.in_edges(net_id, data=True):
            if edge_data.get('edge_type') == 'drives':
                cell_ids = self._get_cells_for_pin(pin_id)
                for cell_id in cell_ids:
                    if cell_id not in seen_cell_ids:
                        cell = self.design.get_cell(cell_id)
                        if cell:
                            cells.append(cell)
                            seen_cell_ids.add(cell_id)

        return cells

    def _get_cells_for_pin(self, pin_id: PinId) -> List[CellId]:
        """Get cells that contain a pin"""
        cell_ids: List[CellId] = []
        # Cell → Pin edges
        for cell_id, _, edge_data in self.graph.in_edges(pin_id, data=True):
            if edge_data.get('edge_type') == 'contains_pin':
                cell_ids.append(CellId(cell_id))
        return cell_ids

    def get_cell_pins(self, cell_id: CellId) -> List[Pin]:
        """Get all pins of a cell"""
        pins: List[Pin] = []
        # Cell → Pin edges
        for _, pin_id, edge_data in self.graph.out_edges(cell_id, data=True):
            if edge_data.get('edge_type') == 'contains_pin':
                pin = self.design.get_pin(PinId(pin_id))
                if pin:
                    pins.append(pin)
        return pins

    def get_pin_net(self, pin_id: PinId) -> Optional[Net]:
        """Get the net connected to a pin"""
        pin = self.design.get_pin(pin_id)
        if not pin or not pin.net_id:
            return None
        return self.design.get_net(pin.net_id)

    def get_fanout_cells(
        self,
        cell_id: CellId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """Get fanout cells (downstream) from a cell"""
        visited_cells: Set[CellId] = set()
        current_level = {cell_id}

        for _ in range(hops):
            if not current_level:
                break

            next_level: Set[CellId] = set()

            for current_cell_id in current_level:
                visited_cells.add(current_cell_id)

                # Get output pins of current cell
                pins = self.get_cell_pins(current_cell_id)
                for pin in pins:
                    if not pin.direction.is_output():
                        continue

                    # Get net connected to output pin
                    if not pin.net_id:
                        continue

                    # Get cells driven by this net
                    connected_cells = self.get_connected_cells(pin.net_id)
                    for connected_cell in connected_cells:
                        if connected_cell.id == current_cell_id:
                            continue  # Skip self
                        if connected_cell.id in visited_cells:
                            continue  # Skip already visited

                        # Check sequential boundary
                        if stop_at_sequential and connected_cell.is_sequential:
                            continue

                        next_level.add(connected_cell.id)

            current_level = next_level

        # Convert visited_cells to list of Cell objects (excluding starting cell)
        result: List[Cell] = []
        for visited_cell_id in visited_cells:
            if visited_cell_id == cell_id:
                continue  # Exclude starting cell
            cell = self.design.get_cell(visited_cell_id)
            if cell:
                result.append(cell)

        return result

    def get_fanin_cells(
        self,
        cell_id: CellId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """Get fanin cells (upstream) to a cell"""
        visited_cells: Set[CellId] = set()
        current_level = {cell_id}

        for _ in range(hops):
            if not current_level:
                break

            next_level: Set[CellId] = set()

            for current_cell_id in current_level:
                visited_cells.add(current_cell_id)

                # Get input pins of current cell
                pins = self.get_cell_pins(current_cell_id)
                for pin in pins:
                    if not pin.direction.is_input():
                        continue

                    # Get net connected to input pin
                    if not pin.net_id:
                        continue

                    # Get cells driving this net
                    connected_cells = self.get_connected_cells(pin.net_id)
                    for connected_cell in connected_cells:
                        if connected_cell.id == current_cell_id:
                            continue  # Skip self
                        if connected_cell.id in visited_cells:
                            continue  # Skip already visited

                        # Check sequential boundary
                        if stop_at_sequential and connected_cell.is_sequential:
                            continue

                        next_level.add(connected_cell.id)

            current_level = next_level

        # Convert visited_cells to list of Cell objects (excluding starting cell)
        result: List[Cell] = []
        for visited_cell_id in visited_cells:
            if visited_cell_id == cell_id:
                continue  # Exclude starting cell
            cell = self.design.get_cell(visited_cell_id)
            if cell:
                result.append(cell)

        return result

    def get_fanout_from_pin(
        self,
        pin_id: PinId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """Get fanout cells from a specific pin"""
        # Get the cell containing this pin as starting point
        cell_ids = self._get_cells_for_pin(pin_id)
        if not cell_ids:
            return []

        # Use pin-specific traversal logic
        # (For MVP, can delegate to cell-based fanout)
        return self.get_fanout_cells(cell_ids[0], hops, stop_at_sequential)

    def get_fanin_to_pin(
        self,
        pin_id: PinId,
        hops: int = 1,
        stop_at_sequential: bool = False
    ) -> List[Cell]:
        """Get fanin cells to a specific pin"""
        # Get the cell containing this pin as starting point
        cell_ids = self._get_cells_for_pin(pin_id)
        if not cell_ids:
            return []

        # Use pin-specific traversal logic
        # (For MVP, can delegate to cell-based fanin)
        return self.get_fanin_cells(cell_ids[0], hops, stop_at_sequential)

    def find_path(
        self,
        from_cell_id: CellId,
        to_cell_id: CellId,
        max_hops: int = 10
    ) -> Optional[List[Cell]]:
        """Find shortest path between two cells"""
        try:
            # Use NetworkX shortest path algorithm
            path_ids = nx.shortest_path(
                self.graph,
                source=from_cell_id,
                target=to_cell_id,
                weight=None  # Unweighted
            )

            if len(path_ids) - 1 > max_hops:
                return None  # Path too long

            # Convert node IDs to Cell objects
            path_cells: List[Cell] = []
            for node_id in path_ids:
                node_type = self.graph.nodes[node_id].get('node_type')
                if node_type == 'cell':
                    cell = self.design.get_cell(CellId(node_id))
                    if cell:
                        path_cells.append(cell)

            return path_cells if path_cells else None

        except nx.NetworkXNoPath:
            return None
```

### 2.4 Module Exports

**File**: `src/ink/domain/services/__init__.py`

```python
from .graph_traverser import GraphTraverser

__all__ = [
    'GraphTraverser',
]
```

**File**: `src/ink/infrastructure/graph/__init__.py`

```python
from .networkx_adapter import NetworkXGraphBuilder
from .networkx_traverser import NetworkXGraphTraverser

__all__ = [
    'NetworkXGraphBuilder',
    'NetworkXGraphTraverser',
]
```

---

## 3. Dependencies

- **Upstream**:
  - E01-F03-T01 (Domain Model Entities) - uses Cell, Pin, Net
  - E01-F03-T02 (Design Aggregate) - queries Design
  - E01-F03-T03 (Graph Builder) - uses NetworkX graph
- **Downstream**:
  - E03 (Incremental Expansion) - uses fanin/fanout queries
  - E04 (Object Interaction) - uses connectivity queries
  - E05 (Search) - uses path finding

---

## 4. Acceptance Criteria

- [ ] `GraphTraverser` protocol defined in domain layer
- [ ] Protocol methods: `get_connected_cells()`, `get_cell_pins()`, `get_pin_net()`
- [ ] Protocol methods: `get_fanout_cells()`, `get_fanin_cells()`
- [ ] Protocol methods: `get_fanout_from_pin()`, `get_fanin_to_pin()`, `find_path()`
- [ ] `NetworkXGraphTraverser` implements GraphTraverser protocol
- [ ] `get_connected_cells()` returns all cells connected to a net
- [ ] `get_cell_pins()` returns all pins of a cell
- [ ] `get_fanout_cells()` traverses downstream cells with configurable hops
- [ ] `get_fanin_cells()` traverses upstream cells with configurable hops
- [ ] `stop_at_sequential` parameter stops traversal at latches/FFs
- [ ] `find_path()` returns shortest path between cells or None
- [ ] Query performance: < 10ms for single-hop fanout on 100K cell graph
- [ ] Query performance: < 50ms for 3-hop fanout on 100K cell graph
- [ ] Unit tests with mock graphs (95%+ coverage)
- [ ] Integration tests with real NetworkX graphs
- [ ] Performance benchmarks documented

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation |
