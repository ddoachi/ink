# E01-F03-T04: Graph Query Interface - Post-Implementation Documentation

## 1. Summary

The Graph Query Interface provides domain-level traversal operations for fanin/fanout queries, path finding, and connectivity lookups. The implementation uses the Protocol pattern for dependency inversion, enabling infrastructure implementations to be swapped without affecting domain code.

**Key deliverables:**
- `src/ink/domain/services/graph_traverser.py`: GraphTraverser protocol definition
- `src/ink/infrastructure/graph/networkx_traverser.py`: NetworkXGraphTraverser implementation
- 52 unit tests covering all query methods and edge cases
- BFS-based traversal with hop limits and sequential boundary support

## 2. Architecture Decisions

### 2.1 Why Protocol over ABC?

We use `typing.Protocol` instead of `abc.ABC` for:
- **Structural typing**: Implementations don't need explicit inheritance
- **Runtime checkable**: Supports `isinstance()` at runtime with `@runtime_checkable`
- **Type hints friendly**: Works naturally with modern Python typing

```python
@runtime_checkable
class GraphTraverser(Protocol):
    def get_connected_cells(self, net_id: NetId) -> list[Cell]: ...
```

### 2.2 Domain Layer Protocol, Infrastructure Implementation

Following Clean Architecture's dependency inversion principle:
- **Protocol in domain layer**: Defines the contract application services need
- **Implementation in infrastructure**: Uses NetworkX for actual graph operations
- **No domain dependency on infrastructure**: Application services depend only on protocol

### 2.3 BFS for Hop-Limited Traversal

Breadth-first search provides natural hop-counting:
- Level 0: Starting cell
- Level 1: Immediate neighbors (1-hop)
- Level N: Cells N hops away

This matches user expectations for schematic exploration.

## 3. Implementation Files

| File | Purpose | Lines |
|------|---------|-------|
| `src/ink/domain/services/graph_traverser.py` | GraphTraverser protocol | 304 |
| `src/ink/infrastructure/graph/networkx_traverser.py` | NetworkXGraphTraverser | 566 |
| `tests/unit/domain/services/test_graph_traverser.py` | Protocol tests | 102 |
| `tests/unit/infrastructure/graph/test_networkx_traverser.py` | Implementation tests | 896 |

## 4. Protocol Methods

| Method | Purpose | Returns |
|--------|---------|---------|
| `get_connected_cells(net_id)` | Cells on a net | `list[Cell]` |
| `get_cell_pins(cell_id)` | Pins of a cell | `list[Pin]` |
| `get_pin_net(pin_id)` | Net connected to pin | `Net \| None` |
| `get_fanout_cells(cell_id, hops, stop_at_sequential)` | Downstream cells | `list[Cell]` |
| `get_fanin_cells(cell_id, hops, stop_at_sequential)` | Upstream cells | `list[Cell]` |
| `get_fanout_from_pin(pin_id, hops, stop_at_sequential)` | Fanout from pin | `list[Cell]` |
| `get_fanin_to_pin(pin_id, hops, stop_at_sequential)` | Fanin to pin | `list[Cell]` |
| `find_path(from_cell_id, to_cell_id, max_hops)` | Shortest path | `list[Cell] \| None` |

## 5. Usage Examples

### Basic Usage

```python
from ink.infrastructure.graph import NetworkXGraphBuilder, NetworkXGraphTraverser
from ink.domain.model import Design

# Build graph and traverser
builder = NetworkXGraphBuilder()
graph = builder.build_from_design(design)
traverser = NetworkXGraphTraverser(graph, design)

# Query fanout
fanout = traverser.get_fanout_cells(CellId("XI1"), hops=2)
for cell in fanout:
    print(f"Reachable: {cell.name}")
```

### Sequential Boundary

```python
# Stop at flip-flops for combinational cone analysis
fanout = traverser.get_fanout_cells(
    CellId("XI1"),
    hops=10,
    stop_at_sequential=True  # Don't traverse past FFs
)
```

### Path Finding

```python
# Find shortest path between cells
path = traverser.find_path(
    CellId("XINPUT"),
    CellId("XOUTPUT"),
    max_hops=20
)
if path:
    print(" -> ".join(cell.name for cell in path))
```

## 6. Test Coverage

### Protocol Tests (11 tests)
- Protocol importability
- Protocol type verification (is Protocol)
- Runtime checkable support
- Method existence checks

### Implementation Tests (41 tests)

| Category | Tests | Coverage |
|----------|-------|----------|
| Instantiation | 3 | Import, creation, protocol compliance |
| get_connected_cells | 4 | Basic, fanout net, types, nonexistent |
| get_cell_pins | 4 | Basic, types, nonexistent, multi-pin |
| get_pin_net | 3 | Connected, floating, nonexistent |
| get_fanout_cells | 8 | Single/multi hop, excludes self, fanout, sequential, cycles |
| get_fanin_cells | 6 | Single/multi hop, excludes self, sequential |
| get_fanout_from_pin | 2 | Basic, nonexistent |
| get_fanin_to_pin | 2 | Basic, nonexistent |
| find_path | 6 | Shortest, no path, max_hops, includes ends |
| Edge Cases | 3 | Zero hops, negative hops, large hop count |

## 7. Key Design Patterns

### 7.1 Refactored Traversal Logic

To reduce code complexity (ruff PLR0912), common traversal logic was extracted:

```python
def get_fanout_cells(self, cell_id, hops, stop_at_sequential):
    return self._traverse_cells(cell_id, hops, stop_at_sequential, is_fanout=True)

def get_fanin_cells(self, cell_id, hops, stop_at_sequential):
    return self._traverse_cells(cell_id, hops, stop_at_sequential, is_fanout=False)

def _traverse_cells(self, cell_id, hops, stop_at_sequential, is_fanout):
    # Common BFS logic with direction parameter
```

### 7.2 Cycle Detection

BFS naturally handles cycles through visited tracking:

```python
visited_cells: set[CellId] = set()
# ...
if connected_cell.id in visited_cells:
    continue  # Skip already visited
```

### 7.3 Sequential Boundary

Sequential cells are included but not expanded from:

```python
if stop_at_sequential and connected_cell.is_sequential:
    visited_cells.add(connected_cell.id)  # Include in results
    continue  # Don't add to next_level for expansion
```

## 8. Lessons Learned

1. **Protocol over ABC**: Python's Protocol provides structural typing that matches duck typing philosophy while adding type safety.

2. **BFS for Hop Counting**: Level-based BFS provides natural hop counting without additional state.

3. **Helper Method Extraction**: Ruff's branch limit (12) encourages cleaner code organization.

4. **Visited Set Critical**: Cycle detection prevents infinite loops in feedback designs.

5. **Entity Resolution**: Returning domain entities (not graph IDs) maintains clean layer separation.

## 9. Performance Characteristics

| Operation | Complexity | Notes |
|-----------|------------|-------|
| get_connected_cells | O(k) | k = pins on net |
| get_cell_pins | O(k) | k = pins on cell |
| get_fanout/fanin | O(n) | n = cells visited |
| find_path | O(V + E) | NetworkX shortest_path |

## 10. Related Specs

- **Upstream**:
  - E01-F03-T01 (Domain Model Entities)
  - E01-F03-T02 (Design Aggregate)
  - E01-F03-T03 (NetworkX Graph Builder)
- **Downstream**:
  - E01-F04 (Cell Expansion) - will use fanout/fanin queries
  - E01-F05 (Schematic Layout) - will use path finding
