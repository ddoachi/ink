# E01-F03-T04: Graph Query Interface - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F03-T04 - Graph Query Interface
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5
- **Estimated Hours**: 8

---

## 1. Overview

### 1.1 Problem Context

The NetworkX graph built in T03 provides the data structure, but application features (incremental expansion, selection, search) need high-level query operations. Questions like:

- "What cells are in the fanout of this cell within 2 hops?"
- "What cells are in the fanin to this pin, stopping at sequential boundaries?"
- "What is the shortest path between these two cells?"

These queries require graph traversal algorithms combined with domain logic (pin directions, sequential boundaries, hop counting). We need a clean interface that:
1. Abstracts graph library implementation details
2. Returns domain entities (not raw graph nodes)
3. Respects domain semantics (pin directions, sequential boundaries)
4. Enables efficient multi-hop traversal

This task defines a **domain service protocol** (GraphTraverser) in the domain layer and implements it using NetworkX in the infrastructure layer, following the Dependency Inversion Principle.

### 1.2 Goals

1. Define `GraphTraverser` protocol in domain layer (pure interface)
2. Implement `NetworkXGraphTraverser` in infrastructure layer
3. Provide fanin/fanout queries with configurable hop count
4. Support sequential boundary stopping (for semantic expansion)
5. Enable pin-level and cell-level queries
6. Implement path finding between cells
7. Achieve target performance: <10ms for single-hop query on 1000-cell graph

### 1.3 Success Criteria

- Protocol defines all query methods with type hints
- Implementation returns domain entities, not graph nodes
- Fanin/fanout queries respect pin directions
- Sequential boundary logic works correctly
- Path finding returns shortest path or None
- All acceptance criteria from spec are met
- Performance benchmarks meet targets
- Unit tests achieve 95%+ coverage

---

## 2. Implementation Approach

### 2.1 Architecture Alignment

**Layer Split**:
- **Domain Layer**: `GraphTraverser` protocol (interface only, no implementation)
- **Infrastructure Layer**: `NetworkXGraphTraverser` (concrete implementation)

**Pattern**: Dependency Inversion (domain defines interface, infrastructure implements)

**Key Architectural Decisions**:

1. **Protocol in Domain Layer**:
   - Application layer depends on `GraphTraverser` protocol
   - Infrastructure provides implementation
   - Enables testing with mock implementations
   - No NetworkX leakage into domain

2. **Return Domain Entities, Not Graph Nodes**:
   - Query methods return `List[Cell]`, `Net`, etc.
   - Application layer never sees NetworkX types
   - Clean separation of concerns

3. **Multi-Hop BFS Traversal**:
   - Implement breadth-first search for hop-counted queries
   - Track visited nodes to avoid cycles
   - Stop at sequential boundaries when requested

4. **Leverage NetworkX for Path Finding**:
   - Use `nx.shortest_path()` for path queries
   - Filter path to return only Cell nodes

### 2.2 Query Design Patterns

**Fanout Query Logic**:
```
Starting from cell:
  1. Get output pins of cell
  2. For each output pin:
     a. Get connected net
     b. Get cells connected to that net (excluding self)
     c. Check sequential boundary condition
     d. Add to result set
  3. Repeat for N hops (BFS)
```

**Fanin Query Logic**:
```
Starting from cell:
  1. Get input pins of cell
  2. For each input pin:
     a. Get connected net
     b. Get cells connected to that net (excluding self)
     c. Check sequential boundary condition
     d. Add to result set
  3. Repeat for N hops (BFS)
```

**Sequential Boundary Logic**:
```
if stop_at_sequential and cell.is_sequential:
    # Don't traverse through this cell
    continue
```

### 2.3 Implementation Strategy

**Phase 1: Domain Protocol** (1 hour)
1. Create `src/ink/domain/services/graph_traverser.py`
2. Define `GraphTraverser` protocol with all method signatures
3. Add comprehensive docstrings with parameter descriptions
4. Add type hints for all parameters and return types

**Phase 2: Basic Queries** (2 hours)
1. Create `src/ink/infrastructure/graph/networkx_traverser.py`
2. Implement `NetworkXGraphTraverser` class
3. Implement `get_connected_cells(net_id)` - cells on a net
4. Implement `get_cell_pins(cell_id)` - pins of a cell
5. Implement `get_pin_net(pin_id)` - net connected to pin
6. Implement helper `_get_cells_for_pin()` - resolve pin to cells

**Phase 3: Fanout/Fanin Traversal** (3 hours)
1. Implement `get_fanout_cells()` with BFS traversal
2. Implement `get_fanin_cells()` with BFS traversal
3. Add hop counting logic
4. Add sequential boundary checking
5. Implement `get_fanout_from_pin()` (delegate to cell fanout for MVP)
6. Implement `get_fanin_to_pin()` (delegate to cell fanin for MVP)

**Phase 4: Path Finding** (1 hour)
1. Implement `find_path()` using `nx.shortest_path()`
2. Filter path to extract only Cell nodes
3. Handle `NetworkXNoPath` exception
4. Respect max_hops limit

**Phase 5: Testing** (3 hours)
1. Unit tests with mock graphs
2. Integration tests with real NetworkX graphs
3. Edge case tests (cycles, disconnected graphs, sequential boundaries)
4. Performance benchmarks

---

## 3. Key Design Decisions

### Decision 1: Protocol vs Abstract Base Class

**Options**:
1. `Protocol` (structural typing, Python 3.8+)
2. `ABC` (abstract base class, inheritance)
3. Interface module (no enforcement)

**Decision**: Use `Protocol`

**Rationale**:
- No inheritance required (more flexible)
- Structural typing (duck typing with type checking)
- Pythonic (matches PEP 544)
- Easier to mock in tests
- Follows spec example

**Example**:
```python
from typing import Protocol

class GraphTraverser(Protocol):
    def get_fanout_cells(self, cell_id: CellId, ...) -> List[Cell]:
        ...
```

### Decision 2: Return Lists vs Iterators

**Question**: Should queries return `List[Cell]` or `Iterator[Cell]`?

**Options**:
1. `List[Cell]` - eager evaluation, all results in memory
2. `Iterator[Cell]` - lazy evaluation, memory efficient
3. Both - `get_fanout_cells()` returns list, `iter_fanout_cells()` returns iterator

**Decision**: Return `List[Cell]` for MVP

**Rationale**:
- Simpler API (no generator complexity)
- Fanout typically small (< 1000 cells)
- Easier to debug (can inspect full list)
- Can add iterator version later if needed

**Trade-off**: Slightly more memory for large fanouts, but acceptable for MVP.

### Decision 3: BFS vs DFS for Traversal

**Options**:
1. Breadth-First Search (BFS) - level by level
2. Depth-First Search (DFS) - dive deep first

**Decision**: BFS

**Rationale**:
- Hop count naturally maps to BFS levels
- Finds all cells at distance N before N+1
- More intuitive for "2-hop fanout" queries
- Aligns with expansion UX (expand outward in layers)

**Example**:
```
Hop 1: [Cell1, Cell2, Cell3]
Hop 2: [Cell4, Cell5, Cell6, Cell7]
Hop 3: [Cell8, Cell9]
```

### Decision 4: Include Starting Cell in Results?

**Question**: Should fanout query include the starting cell?

**Options**:
1. Include starting cell in results
2. Exclude starting cell (only downstream/upstream cells)
3. Make it configurable

**Decision**: Exclude starting cell

**Rationale**:
- Matches user expectation ("fanout FROM cell" = other cells)
- Cleaner UX (don't render starting cell twice)
- Follows spec example (excludes starting cell)
- Simplifies graph rendering logic

**Implementation**:
```python
# Exclude starting cell from results
for visited_cell_id in visited_cells:
    if visited_cell_id == cell_id:
        continue  # Skip starting cell
    result.append(self.design.get_cell(visited_cell_id))
```

### Decision 5: Sequential Boundary Semantics

**Question**: When `stop_at_sequential=True`, should we include the sequential cell or stop before it?

**Options**:
1. Include sequential cell, don't traverse through it
2. Exclude sequential cell entirely

**Decision**: Exclude sequential cell (don't include it in results)

**Rationale**:
- Cleaner semantic boundary (sequential cells are boundaries)
- Matches expansion UX (latches define boundaries)
- More consistent behavior (boundary cells excluded)

**Example**:
```
Cell1 → Cell2 (latch) → Cell3

get_fanout(Cell1, hops=2, stop_at_sequential=True)
  → Returns [Cell2] but NOT Cell3 (stopped at latch)
  → Actually, should return [] to Cell2 (latch stops traversal BEFORE)

Revised: Return cells UP TO boundary, excluding boundary itself
  → Returns [] (Cell2 is boundary, excluded)

Wait, spec says "stop_at_sequential" which implies stop when encountering.
Let's check spec again...

Spec says: "stop_at_sequential: Stop traversal at sequential cells (latches/FFs)"

Interpretation: When we encounter a sequential cell, we stop expanding from it.
  - If fanout includes a latch, we add the latch to results
  - But we DON'T expand fanout from that latch
```

**Clarified Decision**: Include sequential cell in results, but don't traverse through it.

### Decision 6: Pin-Level vs Cell-Level Queries

**Question**: For MVP, should pin-level queries be fully implemented or delegated to cell-level?

**Spec Methods**:
- `get_fanout_from_pin(pin_id, ...)`
- `get_fanin_to_pin(pin_id, ...)`

**Decision**: Delegate to cell-level for MVP

**Rationale**:
- Cell-level queries sufficient for most use cases
- Pin-level queries more complex (need to track which pin)
- Can implement properly in P1
- Spec example shows delegation approach

**Implementation**:
```python
def get_fanout_from_pin(self, pin_id: PinId, ...) -> List[Cell]:
    """Get fanout cells from a specific pin"""
    cell_ids = self._get_cells_for_pin(pin_id)
    if not cell_ids:
        return []
    # For MVP, delegate to cell-based fanout
    return self.get_fanout_cells(cell_ids[0], hops, stop_at_sequential)
```

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Domain Layer Dependencies**:
- `E01-F03-T01` (Domain Entities): Cell, Pin, Net types
- `E01-F03-T02` (Design Aggregate): Design aggregate for entity lookup

**Infrastructure Layer Dependencies**:
- `E01-F03-T03` (Graph Builder): NetworkX graph structure
- `networkx`: Graph library for traversal algorithms

**Import Structure (Domain)**:
```python
# src/ink/domain/services/graph_traverser.py
from typing import Protocol, List, Optional
from ..model import Cell, Pin, Net
from ..value_objects import CellId, PinId, NetId
```

**Import Structure (Infrastructure)**:
```python
# src/ink/infrastructure/graph/networkx_traverser.py
import networkx as nx
from ...domain.model import Design, Cell, Pin, Net
from ...domain.value_objects import CellId, PinId, NetId
from ...domain.services.graph_traverser import GraphTraverser
```

### 4.2 Downstream Dependencies

**Consumed By**:

1. **E03 (Incremental Expansion)**:
   - Will use `get_fanout_cells()` for expansion queries
   - Will use `stop_at_sequential=True` for semantic boundaries
   - Will use hop count to limit expansion scope

2. **E04 (Object Interaction)**:
   - Will use `get_connected_cells()` for net-based selection
   - Will use `get_cell_pins()` for pin highlighting
   - Will use `get_pin_net()` for property display

3. **E05 (Search and Navigation)**:
   - Will use `find_path()` for path highlighting
   - Will use fanin/fanout for navigation features
   - Will use connectivity queries for related objects

4. **Application Services**:
   - Expansion service depends on `GraphTraverser` protocol
   - Selection service depends on connectivity queries
   - Search service depends on path finding

### 4.3 Integration Patterns

**Application Layer Usage** (Dependency Injection):
```python
# Application service receives traverser via constructor
class ExpansionService:
    def __init__(self, graph_traverser: GraphTraverser):
        self.traverser = graph_traverser

    def expand_fanout(self, cell_id: CellId, hops: int) -> List[Cell]:
        return self.traverser.get_fanout_cells(
            cell_id,
            hops=hops,
            stop_at_sequential=True
        )
```

**Infrastructure Layer Instantiation**:
```python
# Infrastructure layer creates concrete implementation
design = design_repository.get_current_design()
builder = NetworkXGraphBuilder()
graph = builder.build_from_design(design)
traverser = NetworkXGraphTraverser(graph, design)

# Inject into application service
expansion_service = ExpansionService(graph_traverser=traverser)
```

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Coverage Target**: 95%+

**Test Structure**:
```
tests/unit/domain/services/
└── test_graph_traverser.py  # Protocol tests (type checking)

tests/unit/infrastructure/graph/
└── test_networkx_traverser.py  # Implementation tests
```

### 5.2 Test Cases

**Basic Queries**:
```python
def test_get_connected_cells_returns_cells_on_net():
    """Should return all cells connected to a net"""
    # Setup: Create design with net connecting 3 cells
    design, graph = create_test_design_with_net()
    traverser = NetworkXGraphTraverser(graph, design)

    cells = traverser.get_connected_cells(NetId("net1"))

    assert len(cells) == 3
    assert all(isinstance(cell, Cell) for cell in cells)

def test_get_cell_pins_returns_pins_of_cell():
    """Should return all pins of a cell"""
    design, graph = create_test_design()
    traverser = NetworkXGraphTraverser(graph, design)

    pins = traverser.get_cell_pins(CellId("XI1"))

    assert len(pins) == 2  # A and Y pins for inverter
    assert all(isinstance(pin, Pin) for pin in pins)

def test_get_pin_net_returns_connected_net():
    """Should return net connected to pin"""
    design, graph = create_test_design()
    traverser = NetworkXGraphTraverser(graph, design)

    net = traverser.get_pin_net(PinId("XI1.A"))

    assert net is not None
    assert isinstance(net, Net)
```

**Fanout Traversal**:
```python
def test_get_fanout_cells_single_hop():
    """Should return immediate fanout (1 hop)"""
    # Setup: XI1 → XI2 → XI3 (chain)
    design, graph = create_inverter_chain()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(CellId("XI1"), hops=1)

    assert len(fanout) == 1
    assert fanout[0].name == "XI2"

def test_get_fanout_cells_multi_hop():
    """Should return fanout within 2 hops"""
    design, graph = create_inverter_chain()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(CellId("XI1"), hops=2)

    assert len(fanout) == 2
    assert set(cell.name for cell in fanout) == {"XI2", "XI3"}

def test_get_fanout_cells_excludes_starting_cell():
    """Should not include starting cell in results"""
    design, graph = create_inverter_chain()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(CellId("XI1"), hops=1)

    assert not any(cell.name == "XI1" for cell in fanout)

def test_get_fanout_cells_stops_at_sequential():
    """Should stop at sequential cells when stop_at_sequential=True"""
    # Setup: XI1 → XFF (latch) → XI2
    design, graph = create_design_with_latch()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(
        CellId("XI1"),
        hops=2,
        stop_at_sequential=True
    )

    # Should reach latch but not beyond
    assert len(fanout) == 1
    assert fanout[0].name == "XFF"
    assert not any(cell.name == "XI2" for cell in fanout)

def test_get_fanout_cells_traverses_through_sequential_when_false():
    """Should traverse through sequential cells when stop_at_sequential=False"""
    design, graph = create_design_with_latch()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(
        CellId("XI1"),
        hops=2,
        stop_at_sequential=False
    )

    # Should reach both latch and beyond
    assert len(fanout) == 2
    assert set(cell.name for cell in fanout) == {"XFF", "XI2"}
```

**Fanin Traversal**:
```python
def test_get_fanin_cells_single_hop():
    """Should return immediate fanin (1 hop)"""
    design, graph = create_inverter_chain()
    traverser = NetworkXGraphTraverser(graph, design)

    fanin = traverser.get_fanin_cells(CellId("XI3"), hops=1)

    assert len(fanin) == 1
    assert fanin[0].name == "XI2"

def test_get_fanin_cells_multi_hop():
    """Should return fanin within 2 hops"""
    design, graph = create_inverter_chain()
    traverser = NetworkXGraphTraverser(graph, design)

    fanin = traverser.get_fanin_cells(CellId("XI3"), hops=2)

    assert len(fanin) == 2
    assert set(cell.name for cell in fanin) == {"XI2", "XI1"}
```

**Path Finding**:
```python
def test_find_path_returns_shortest_path():
    """Should return shortest path between cells"""
    design, graph = create_inverter_chain()  # XI1 → XI2 → XI3
    traverser = NetworkXGraphTraverser(graph, design)

    path = traverser.find_path(CellId("XI1"), CellId("XI3"), max_hops=10)

    assert path is not None
    assert len(path) == 3
    assert [cell.name for cell in path] == ["XI1", "XI2", "XI3"]

def test_find_path_returns_none_when_no_path():
    """Should return None when no path exists"""
    design, graph = create_disconnected_design()
    traverser = NetworkXGraphTraverser(graph, design)

    path = traverser.find_path(CellId("XI1"), CellId("XI_isolated"), max_hops=10)

    assert path is None

def test_find_path_returns_none_when_exceeds_max_hops():
    """Should return None when path longer than max_hops"""
    design, graph = create_long_chain()  # 20 cells in chain
    traverser = NetworkXGraphTraverser(graph, design)

    path = traverser.find_path(CellId("XI1"), CellId("XI20"), max_hops=5)

    assert path is None  # Path is 20 hops, exceeds limit
```

**Edge Cases**:
```python
def test_get_fanout_cells_returns_empty_for_nonexistent_cell():
    """Should return empty list for non-existent cell"""
    design, graph = create_simple_design()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(CellId("nonexistent"), hops=1)

    assert fanout == []

def test_get_fanout_cells_handles_cycles():
    """Should handle circular connectivity without infinite loop"""
    design, graph = create_design_with_cycle()
    traverser = NetworkXGraphTraverser(graph, design)

    # Should not hang or crash
    fanout = traverser.get_fanout_cells(CellId("XI1"), hops=3)

    assert len(fanout) > 0  # Returns reachable cells
```

### 5.3 Integration Tests

```python
def test_integration_fanout_with_complex_design():
    """Integration test with realistic design structure"""
    # Create design with:
    # - 10 cells
    # - Mix of sequential and combinational
    # - Multiple fanout paths
    # - Some disconnected components
    design, graph = create_complex_test_design()
    traverser = NetworkXGraphTraverser(graph, design)

    fanout = traverser.get_fanout_cells(
        CellId("start_cell"),
        hops=3,
        stop_at_sequential=True
    )

    # Verify fanout is correct
    assert len(fanout) > 0
    # Verify no sequential cells in deep fanout
    deep_fanout = traverser.get_fanout_cells(CellId("start_cell"), hops=10, stop_at_sequential=True)
    # Should not include cells beyond sequential boundaries
```

### 5.4 Performance Tests

```python
@pytest.mark.benchmark
def test_single_hop_fanout_performance(benchmark):
    """Should perform single-hop fanout in <10ms"""
    design, graph = generate_large_design(num_cells=1000)
    traverser = NetworkXGraphTraverser(graph, design)

    result = benchmark(
        traverser.get_fanout_cells,
        CellId("XI_500"),  # Cell in middle
        hops=1
    )

    assert benchmark.stats.mean < 0.01  # <10ms

@pytest.mark.benchmark
def test_multi_hop_fanout_performance(benchmark):
    """Should perform 3-hop fanout in <50ms"""
    design, graph = generate_large_design(num_cells=1000)
    traverser = NetworkXGraphTraverser(graph, design)

    result = benchmark(
        traverser.get_fanout_cells,
        CellId("XI_500"),
        hops=3
    )

    assert benchmark.stats.mean < 0.05  # <50ms
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: BFS Performance on Large Fanouts**

**Impact**: High (slow queries, poor UX)
**Probability**: Medium

**Description**: High-fanout nets (clock, reset) could have thousands of cells, making BFS slow.

**Mitigation**:
- Set reasonable default hop limit (e.g., 3 hops)
- Add early termination (max result count)
- Optimize BFS with visited set (avoid revisits)
- Benchmark with real netlists (clock trees)

**Contingency**:
- Cache fanout results for common queries
- Use incremental BFS (lazy evaluation)
- Implement fanout sampling (return subset for preview)

**Risk 2: Cycle Handling in Traversal**

**Impact**: High (infinite loop, application hang)
**Probability**: Low (combinational loops rare)

**Description**: If design has combinational loops, BFS could cycle indefinitely.

**Mitigation**:
- Track visited nodes in set (prevents revisiting)
- Add iteration limit (safety check)
- Log warning if iteration limit hit
- Design validation (T02) should detect loops

**Implementation**:
```python
visited_cells: Set[CellId] = set()
iteration_count = 0
max_iterations = 100000  # Safety limit

for _ in range(hops):
    iteration_count += len(current_level)
    if iteration_count > max_iterations:
        raise RuntimeError("Traversal iteration limit exceeded (possible cycle)")
```

**Risk 3: Pin Direction Edge Cases**

**Impact**: Medium (incorrect traversal)
**Probability**: Low

**Description**: INOUT pins, tri-state buffers could confuse direction logic.

**Mitigation**:
- INOUT pins treated as both input and output
- Test with bidirectional nets
- Document edge case behavior
- Defer complex pin logic to P1

**Risk 4: Path Finding Performance**

**Impact**: Medium (slow path queries)
**Probability**: Low

**Description**: `nx.shortest_path()` could be slow for large graphs.

**Mitigation**:
- Use max_hops to limit search space
- NetworkX uses efficient Dijkstra/BFS algorithms
- Cache common paths (input to output)
- Benchmark with 1000-cell designs

**Contingency**:
- Implement custom bidirectional BFS (faster for large graphs)
- Use A* with heuristic (estimate remaining distance)

### 6.2 Design Risks

**Risk 5: Protocol Completeness**

**Impact**: Medium (missing methods, breaking changes)
**Probability**: Low

**Description**: Protocol might not include all needed methods for future features.

**Mitigation**:
- Design protocol based on known use cases (E03, E04, E05)
- Can extend protocol later (add new methods)
- Python protocols are extensible (no breaking changes)
- Document protocol version

**Risk 6: Traverser-Graph Coupling**

**Impact**: Medium (tight coupling)
**Probability**: Medium

**Description**: `NetworkXGraphTraverser` tightly coupled to specific graph structure.

**Mitigation**:
- Use graph accessors (node attributes, edge attributes)
- Don't rely on NetworkX internals
- Abstract graph operations behind helper methods
- Design for rustworkx migration

### 6.3 Integration Risks

**Risk 7: Design-Graph Synchronization**

**Impact**: Medium (stale results)
**Probability**: Low

**Description**: If Design changes, queries on old graph return stale data.

**Mitigation**:
- Design is immutable after construction (MVP)
- Graph rebuilt on Design change
- Document that traverser is snapshot
- Can add change detection in P1

**Risk 8: Large Result Sets**

**Impact**: Low (memory usage)
**Probability**: Low

**Description**: Fanout query could return 10K+ cells, consuming memory.

**Mitigation**:
- Queries return lists (acceptable for MVP)
- Can add result limiting in future
- Application layer can paginate results
- Typical fanout << 1000 cells

---

## 7. Open Questions and Decisions Needed

### Question 1: Should we cache query results?

**Current Approach**: No caching, compute on-demand

**Consideration**: Same query might be repeated (e.g., fanout of popular cell)

**Decision**: No caching for MVP
- YAGNI - optimize only if profiling shows need
- Cache invalidation complex (graph changes)
- Memory overhead for cache storage
- Can add LRU cache in P1 if needed

### Question 2: How to handle multi-driver nets?

**Current Approach**: All drivers contribute to fanout

**Consideration**: Net with multiple output pins (multiple drivers)

**Decision**: Include all drivers in fanin results
- Real scenario (buffers, bus drivers)
- Graph structure supports this (multiple edges to net)
- Application layer can filter if needed

### Question 3: Should path finding skip non-Cell nodes?

**Current Approach**: Path includes Net and Pin nodes, then filtered to Cells only

**Alternative**: Find path through Cells only (skip intermediate nodes)

**Decision**: Filter path to Cells only in result
- Application layer wants Cell path (for rendering)
- Internal path may include Nets/Pins (for accuracy)
- Filter at return boundary

**Implementation**:
```python
raw_path = nx.shortest_path(graph, from_cell, to_cell)
# Filter to Cell nodes only
cell_path = [
    self.design.get_cell(CellId(node_id))
    for node_id in raw_path
    if graph.nodes[node_id]['node_type'] == 'cell'
]
```

### Question 4: Should we support reverse path finding (from output to input)?

**Current Approach**: Path finding is directional (follows edge direction)

**Consideration**: User might want to trace backward (from output to input)

**Decision**: Bidirectional path finding (ignore edge direction)
- Use `nx.shortest_path()` which works on directed graphs
- Path might include backward traversal
- More intuitive for users (find any path)

**Alternative**: Use `graph.to_undirected()` for path finding
- Simpler implementation
- Loses directionality information
- Acceptable for MVP

---

## 8. Implementation Checklist

### Phase 1: Domain Protocol
- [ ] Create `src/ink/domain/services/` directory
- [ ] Create `graph_traverser.py`
- [ ] Define `GraphTraverser` protocol with all method signatures
- [ ] Add comprehensive docstrings to all methods
- [ ] Add type hints to all parameters and return types
- [ ] Create `__init__.py` with exports

### Phase 2: Basic Queries
- [ ] Create `src/ink/infrastructure/graph/networkx_traverser.py`
- [ ] Implement `NetworkXGraphTraverser` class with graph and design storage
- [ ] Implement `get_connected_cells(net_id)` - query graph for connected cells
- [ ] Implement `get_cell_pins(cell_id)` - query graph for cell's pins
- [ ] Implement `get_pin_net(pin_id)` - look up net from pin
- [ ] Implement helper `_get_cells_for_pin(pin_id)` - find cells containing pin

### Phase 3: Fanout/Fanin Traversal
- [ ] Implement `get_fanout_cells()` with BFS algorithm
  - [ ] Get output pins of starting cell
  - [ ] For each output pin, get connected net
  - [ ] Get cells connected to net (via get_connected_cells)
  - [ ] Track visited cells to avoid cycles
  - [ ] Implement hop counting with BFS levels
  - [ ] Check sequential boundary condition
  - [ ] Exclude starting cell from results
- [ ] Implement `get_fanin_cells()` with BFS algorithm
  - [ ] Get input pins of starting cell
  - [ ] For each input pin, get connected net
  - [ ] Get cells connected to net
  - [ ] Track visited cells
  - [ ] Implement hop counting
  - [ ] Check sequential boundary condition
  - [ ] Exclude starting cell from results
- [ ] Implement `get_fanout_from_pin()` - delegate to get_fanout_cells for MVP
- [ ] Implement `get_fanin_to_pin()` - delegate to get_fanin_cells for MVP

### Phase 4: Path Finding
- [ ] Implement `find_path()` using `nx.shortest_path()`
- [ ] Catch `nx.NetworkXNoPath` exception and return None
- [ ] Check path length against max_hops
- [ ] Filter path to extract Cell nodes only
- [ ] Return None if no Cell path exists

### Phase 5: Testing
- [ ] Test get_connected_cells returns all cells on net
- [ ] Test get_cell_pins returns all pins of cell
- [ ] Test get_pin_net returns connected net or None
- [ ] Test get_fanout_cells single hop
- [ ] Test get_fanout_cells multi hop
- [ ] Test get_fanout_cells excludes starting cell
- [ ] Test get_fanout_cells stops at sequential boundaries
- [ ] Test get_fanout_cells traverses through sequential when flag is false
- [ ] Test get_fanin_cells single hop
- [ ] Test get_fanin_cells multi hop
- [ ] Test find_path returns shortest path
- [ ] Test find_path returns None when no path
- [ ] Test find_path returns None when exceeds max_hops
- [ ] Test edge cases: nonexistent cells, cycles, disconnected components
- [ ] Integration test with complex design
- [ ] Performance benchmark: single-hop <10ms
- [ ] Performance benchmark: 3-hop <50ms
- [ ] Achieve 95%+ coverage

### Phase 6: Documentation
- [ ] Add class docstring to `NetworkXGraphTraverser`
- [ ] Add docstrings to all public methods
- [ ] Document BFS algorithm in comments
- [ ] Add usage examples in docstrings
- [ ] Update `__init__.py` exports for both domain and infrastructure

### Phase 7: Validation
- [ ] Run tests: `pytest tests/unit/infrastructure/graph/ -v`
- [ ] Run coverage: `pytest --cov=src/ink/infrastructure/graph`
- [ ] Run mypy: `mypy src/ink/domain/services/ src/ink/infrastructure/graph/`
- [ ] Run ruff: `ruff check src/ink/`
- [ ] Review against spec acceptance criteria
- [ ] Performance benchmarks meet targets

---

## 9. Success Metrics

### Code Quality
- **Test Coverage**: 95%+ (protocol + implementation)
- **Type Coverage**: 100% of protocol methods
- **Linting**: Zero warnings from ruff
- **Documentation**: All protocol methods documented

### Performance
- **Single-Hop Query**: <10ms for 1000-cell graph
- **Multi-Hop Query**: <50ms for 3-hop on 1000-cell graph
- **Path Finding**: <100ms for typical paths

### Functional
- **Protocol Completeness**: All methods in spec defined
- **Traversal Correctness**: BFS returns correct cells
- **Boundary Respect**: Sequential boundaries honored
- **Path Accuracy**: Shortest path returned

---

## 10. Definition of Done

- [ ] All acceptance criteria from spec are met
- [ ] `GraphTraverser` protocol defined in domain layer
- [ ] `NetworkXGraphTraverser` implements protocol
- [ ] All query methods implemented and tested
- [ ] Fanout/fanin traversal with hop counting works
- [ ] Sequential boundary logic works correctly
- [ ] Path finding returns shortest path or None
- [ ] 95%+ unit test coverage achieved
- [ ] Integration tests pass with complex designs
- [ ] Performance benchmarks meet targets
- [ ] `mypy --strict` passes with zero errors
- [ ] `ruff check` passes with zero warnings
- [ ] All docstrings written (Google style)
- [ ] Module exports configured
- [ ] Code reviewed

---

## Appendix A: Query Examples

**Example 1: Fanout Query**
```python
traverser = NetworkXGraphTraverser(graph, design)

# Get 2-hop fanout from inverter
fanout = traverser.get_fanout_cells(
    cell_id=CellId("XI1"),
    hops=2,
    stop_at_sequential=False
)

# Result: [Cell(XI2), Cell(XI3), Cell(XI4), ...]
```

**Example 2: Sequential Boundary**
```python
# Get fanout but stop at latches
fanout = traverser.get_fanout_cells(
    cell_id=CellId("XINPUT_BUF"),
    hops=10,
    stop_at_sequential=True  # Stop at flip-flops
)

# Result: All combinational logic in fanout, no logic beyond FFs
```

**Example 3: Path Finding**
```python
# Find path from input to output
path = traverser.find_path(
    from_cell_id=CellId("XINPUT"),
    to_cell_id=CellId("XOUTPUT"),
    max_hops=20
)

if path:
    print(f"Path: {' → '.join(cell.name for cell in path)}")
else:
    print("No path found within 20 hops")
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
