# E01-F03-T01: Domain Model Entities - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F03-T01 - Domain Model Entities
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5
- **Estimated Hours**: 4

---

## 1. Overview

### 1.1 Problem Context

The graph construction feature requires a solid foundation of domain entities that represent the core concepts of a gate-level netlist. These entities must be designed following Domain-Driven Design (DDD) principles, residing in the domain layer with zero external dependencies. The entities must be type-safe, immutable where appropriate, and provide clear semantics for the ubiquitous language of the application.

The challenge is to create a clean separation between the domain model (what we're building here) and infrastructure concerns (graph libraries, parsers, persistence). This separation enables testability, maintainability, and the ability to swap infrastructure implementations without affecting core business logic.

### 1.2 Goals

1. Define core domain entities (`Cell`, `Pin`, `Net`, `Port`) as frozen dataclasses
2. Create value objects for strong typing (`CellId`, `NetId`, `PinId`, `PortId`, `PinDirection`)
3. Ensure zero external dependencies in the domain layer (pure Python only)
4. Provide immutability for thread safety and functional programming patterns
5. Enable type-safe programming with comprehensive type hints
6. Define helper methods that encode domain logic (e.g., `is_connected()`, `is_latch()`)

### 1.3 Success Criteria

- All entities are frozen dataclasses with full type hints
- No imports from infrastructure, application, or presentation layers
- Helper methods provide meaningful domain operations
- Module exports are clean and well-organized
- Unit tests achieve 95%+ coverage
- All acceptance criteria from spec are met

---

## 2. Implementation Approach

### 2.1 Architecture Alignment

**Layer**: Domain Layer (Pure)
**Bounded Context**: Netlist Context
**Aggregate**: These entities will be managed by the Design aggregate (T02)

**Key Architectural Decisions**:

1. **Use `NewType` for ID aliases**: Provides compile-time type safety without runtime overhead
   - `CellId`, `NetId`, `PinId`, `PortId` are distinct types
   - Prevents accidental mixing (e.g., passing `NetId` where `CellId` expected)

2. **Frozen dataclasses for immutability**:
   - Most entities are immutable after construction
   - Thread-safe by default
   - Easier to reason about (no hidden state changes)
   - Exception: Lists in `Net.connected_pin_ids` use `field(default_factory=list)`

3. **String-based enum for `PinDirection`**:
   - Serializes naturally to JSON/string formats
   - Provides type safety through enum
   - Helper methods (`is_input()`, `is_output()`) encode domain logic

### 2.2 Data Model Design

**Entity Relationships**:
```
Design (Aggregate Root, in T02)
  ├── Cell*
  │   └── pin_ids: List[PinId]
  ├── Pin*
  │   ├── direction: PinDirection
  │   └── net_id: Optional[NetId]
  ├── Net*
  │   └── connected_pin_ids: List[PinId]
  └── Port*
      ├── direction: PinDirection
      └── net_id: Optional[NetId]
```

**Value Objects**:
- **Identifiers**: `CellId`, `NetId`, `PinId`, `PortId` - NewType wrappers around `str`
- **PinDirection**: Enum with `INPUT`, `OUTPUT`, `INOUT` values

**Why Lists Instead of References?**
- Entities store IDs, not object references
- Avoids circular dependencies during construction
- Enables lazy loading and efficient serialization
- Design aggregate will resolve IDs to objects when needed

### 2.3 Implementation Strategy

**Phase 1: Value Objects** (30 minutes)
1. Create `src/ink/domain/value_objects/` directory structure
2. Implement `identifiers.py` with `NewType` definitions
3. Implement `pin_direction.py` with enum and helper methods
4. Create `__init__.py` with exports

**Phase 2: Domain Entities** (2 hours)
1. Create `src/ink/domain/model/` directory structure
2. Implement entities in dependency order:
   - `Pin` (no dependencies)
   - `Net` (no dependencies)
   - `Port` (no dependencies)
   - `Cell` (no dependencies)
3. Add helper methods for each entity
4. Create `__init__.py` with exports

**Phase 3: Testing** (1.5 hours)
1. Unit tests for value objects
2. Unit tests for each entity
3. Test immutability constraints
4. Test helper method logic
5. Test edge cases (empty lists, None values)

**Phase 4: Documentation** (30 minutes)
1. Add docstrings to all public classes and methods
2. Add type hints to all fields and methods
3. Create usage examples in docstrings

---

## 3. Key Design Decisions

### Decision 1: NewType vs Classes for IDs

**Options**:
1. `NewType('CellId', str)` - Type alias with zero runtime cost
2. `@dataclass(frozen=True) class CellId` - Full class with validation
3. `UUID` - Universally unique identifiers

**Decision**: Use `NewType`

**Rationale**:
- Compile-time type safety (mypy will catch type errors)
- Zero runtime overhead (compiles to plain strings)
- Sufficient for MVP - IDs are just string names from CDL
- Can migrate to classes later if validation needed
- Simpler serialization (no special handling needed)

### Decision 2: Frozen vs Mutable Dataclasses

**Options**:
1. All frozen - Maximum immutability
2. All mutable - Maximum flexibility
3. Hybrid - Freeze entities, allow mutable lists inside

**Decision**: Frozen dataclasses with `field(default_factory=list)` for collections

**Rationale**:
- Entities themselves are immutable (can't reassign fields)
- Collections are mutable (can add pins to net during construction)
- Practical balance for builder pattern in T03
- Immutability prevents accidental bugs (e.g., reassigning `cell.id`)

**Impact**:
- Need to use `field(default_factory=list)` for list fields
- Can't use frozen dataclasses if we need to mutate lists after construction
- Actually, **revise**: `Net.connected_pin_ids` should be `List[PinId]` with default factory, and `frozen=True` means the field can't be reassigned, but list contents can change

**Final Decision**: Keep frozen, use mutable lists inside where needed

### Decision 3: Pin Direction Representation

**Options**:
1. String literals: `"INPUT"`, `"OUTPUT"`, `"INOUT"`
2. Integer constants: `0`, `1`, `2`
3. Enum (str): `class PinDirection(str, Enum)`
4. Enum (int): `class PinDirection(int, Enum)`

**Decision**: `class PinDirection(str, Enum)`

**Rationale**:
- Type safety (IDE autocomplete, mypy checking)
- Serializes as strings (JSON-friendly)
- Inherits from `str` so can use in f-strings naturally
- Helper methods (`is_input()`, `is_output()`) encode domain logic
- Explicit is better than implicit (Pythonic)

### Decision 4: Optional vs Required Net References

**Question**: Should `Pin.net_id` and `Port.net_id` be optional?

**Decision**: Yes, use `Optional[NetId]`

**Rationale**:
- Pins can be floating (not connected to any net) in malformed netlists
- Ports might not be connected (unused I/O)
- Explicit `None` better than empty string or sentinel value
- Enables `is_connected()` helper method
- Mirrors real-world CDL where connections may be missing

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**None** - This is pure domain layer with zero external dependencies.

- Only imports: `dataclasses`, `typing`, `enum` (all Python stdlib)
- No infrastructure, application, or presentation imports
- No external library dependencies (NetworkX, PySide6, etc.)

### 4.2 Downstream Dependencies

**These entities will be consumed by**:

1. **E01-F03-T02 (Design Aggregate)**:
   - Design aggregate will manage collections of these entities
   - Will use IDs to create references between entities
   - Will provide factory methods for creating entities

2. **E01-F03-T03 (Graph Builder)**:
   - Will map domain entities to NetworkX graph nodes
   - Will use entity attributes as node attributes
   - Will traverse entity relationships to create edges

3. **E01-F03-T04 (Graph Query Interface)**:
   - Will return lists of these entities from queries
   - Will use helper methods (`is_sequential`, `is_connected`)

4. **Future Features**:
   - Rendering (E02): Will read cell types, pin names for visualization
   - Expansion (E03): Will use `is_sequential` for boundary detection
   - Search (E05): Will search cell names, net names

### 4.3 Integration Patterns

**Entity Construction**:
```python
# Entities will be constructed by parsers (T03) via Design aggregate (T02)
pin = Pin(
    id=PinId("XI1.A"),
    name="A",
    direction=PinDirection.INPUT,
    net_id=NetId("net_123")
)
```

**Entity Access**:
```python
# Application layer will access via Design aggregate
design = Design(name="top")
cell = design.get_cell(CellId("XI1"))
if cell and cell.is_latch():
    print(f"Sequential cell: {cell.name}")
```

---

## 5. Testing Strategy

### 5.1 Unit Testing Approach

**Coverage Target**: 95%+

**Test Structure**:
```
tests/unit/domain/
├── value_objects/
│   ├── test_identifiers.py
│   └── test_pin_direction.py
└── model/
    ├── test_cell.py
    ├── test_pin.py
    ├── test_net.py
    └── test_port.py
```

### 5.2 Test Cases

**Value Objects**:
```python
# test_pin_direction.py
def test_pin_direction_enum_values():
    """Verify enum has INPUT, OUTPUT, INOUT"""
    assert PinDirection.INPUT == "INPUT"
    assert PinDirection.OUTPUT == "OUTPUT"
    assert PinDirection.INOUT == "INOUT"

def test_is_input_method():
    """INPUT and INOUT should return True for is_input()"""
    assert PinDirection.INPUT.is_input() is True
    assert PinDirection.INOUT.is_input() is True
    assert PinDirection.OUTPUT.is_input() is False

def test_is_output_method():
    """OUTPUT and INOUT should return True for is_output()"""
    assert PinDirection.OUTPUT.is_output() is True
    assert PinDirection.INOUT.is_output() is True
    assert PinDirection.INPUT.is_output() is False
```

**Entities**:
```python
# test_pin.py
def test_pin_creation():
    """Create Pin with all fields"""
    pin = Pin(
        id=PinId("test_pin"),
        name="A",
        direction=PinDirection.INPUT,
        net_id=NetId("net1")
    )
    assert pin.id == PinId("test_pin")
    assert pin.name == "A"
    assert pin.direction == PinDirection.INPUT
    assert pin.net_id == NetId("net1")

def test_pin_is_connected_when_net_id_present():
    """is_connected() returns True when net_id is set"""
    pin = Pin(
        id=PinId("p1"),
        name="Y",
        direction=PinDirection.OUTPUT,
        net_id=NetId("net1")
    )
    assert pin.is_connected() is True

def test_pin_is_connected_when_net_id_none():
    """is_connected() returns False when net_id is None"""
    pin = Pin(
        id=PinId("p1"),
        name="Y",
        direction=PinDirection.OUTPUT,
        net_id=None
    )
    assert pin.is_connected() is False

def test_pin_immutability():
    """Pin is frozen, cannot reassign fields"""
    pin = Pin(
        id=PinId("p1"),
        name="A",
        direction=PinDirection.INPUT,
        net_id=None
    )
    with pytest.raises(FrozenInstanceError):
        pin.id = PinId("p2")
```

```python
# test_cell.py
def test_cell_creation_with_defaults():
    """Create Cell with minimal fields"""
    cell = Cell(
        id=CellId("XI1"),
        name="XI1",
        cell_type="INV_X1"
    )
    assert cell.id == CellId("XI1")
    assert cell.name == "XI1"
    assert cell.cell_type == "INV_X1"
    assert cell.pin_ids == []
    assert cell.is_sequential is False

def test_cell_creation_with_pins():
    """Create Cell with pin_ids"""
    cell = Cell(
        id=CellId("XI1"),
        name="XI1",
        cell_type="INV_X1",
        pin_ids=[PinId("XI1.A"), PinId("XI1.Y")]
    )
    assert len(cell.pin_ids) == 2

def test_cell_is_latch_when_sequential():
    """is_latch() returns True when is_sequential is True"""
    cell = Cell(
        id=CellId("XFF1"),
        name="XFF1",
        cell_type="DFF_X1",
        is_sequential=True
    )
    assert cell.is_latch() is True

def test_cell_is_latch_when_combinational():
    """is_latch() returns False when is_sequential is False"""
    cell = Cell(
        id=CellId("XI1"),
        name="XI1",
        cell_type="INV_X1",
        is_sequential=False
    )
    assert cell.is_latch() is False
```

```python
# test_net.py
def test_net_creation_with_defaults():
    """Create Net with minimal fields"""
    net = Net(
        id=NetId("net1"),
        name="net1"
    )
    assert net.id == NetId("net1")
    assert net.name == "net1"
    assert net.connected_pin_ids == []

def test_net_is_multi_fanout():
    """is_multi_fanout() returns True when >1 pins"""
    net = Net(
        id=NetId("net1"),
        name="net1",
        connected_pin_ids=[PinId("p1"), PinId("p2")]
    )
    assert net.is_multi_fanout() is True

def test_net_pin_count():
    """pin_count() returns correct count"""
    net = Net(
        id=NetId("net1"),
        name="net1",
        connected_pin_ids=[PinId("p1"), PinId("p2"), PinId("p3")]
    )
    assert net.pin_count() == 3
```

### 5.3 Edge Cases to Test

1. **Empty collections**: Cell with no pins, Net with no connected pins
2. **None values**: Pin with `net_id=None`, Port with `net_id=None`
3. **Immutability**: Attempting to reassign frozen fields should raise error
4. **Type safety**: Using wrong ID type should be caught by mypy (tested via type checking)

### 5.4 Test Execution

```bash
# Run unit tests for domain layer
pytest tests/unit/domain/ -v

# Run with coverage
pytest tests/unit/domain/ --cov=src/ink/domain/model --cov=src/ink/domain/value_objects --cov-report=term-missing

# Type checking
mypy src/ink/domain/
```

---

## 6. Risks and Considerations

### 6.1 Technical Risks

**Risk 1: Circular Import Issues**

**Impact**: Medium
**Probability**: Low

**Description**: Domain entities importing each other could create circular dependencies.

**Mitigation**:
- Use forward references in type hints: `from __future__ import annotations`
- Keep imports minimal (only from same layer)
- Use `TYPE_CHECKING` flag for type-only imports

**Example**:
```python
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .cell import Cell
```

**Risk 2: Dataclass Default Mutable Arguments**

**Impact**: High (subtle bugs)
**Probability**: Medium

**Description**: Using `pin_ids: List[PinId] = []` creates shared default across instances.

**Mitigation**:
- Always use `field(default_factory=list)` for mutable defaults
- Enable `mypy` plugin for dataclasses
- Add test cases that create multiple instances and verify independence

**Example**:
```python
# WRONG
@dataclass
class Cell:
    pin_ids: List[PinId] = []  # DANGEROUS! Shared across instances

# CORRECT
@dataclass
class Cell:
    pin_ids: List[PinId] = field(default_factory=list)
```

**Risk 3: Type Hint Complexity**

**Impact**: Low
**Probability**: Medium

**Description**: Complex type hints might confuse developers or break IDE support.

**Mitigation**:
- Keep type hints simple and Pythonic
- Use `Optional[X]` instead of `X | None` for Python 3.10 compatibility
- Test with mypy to ensure correctness
- Document complex types in docstrings

### 6.2 Design Risks

**Risk 4: Over-Engineering**

**Impact**: Medium (wasted effort)
**Probability**: Medium

**Description**: Adding too many helper methods or validation logic to domain entities.

**Mitigation**:
- Follow YAGNI (You Aren't Gonna Need It) principle
- Only add helper methods that are clearly needed (from spec requirements)
- Defer advanced validation to aggregate root (T02)
- Keep entities focused on data representation

**Risk 5: Under-Specification of IDs**

**Impact**: Low
**Probability**: High

**Description**: Using simple `NewType` for IDs means no validation (could pass empty string).

**Mitigation**:
- Accept this trade-off for MVP (simplicity over validation)
- Validation will happen at aggregate root level (T02)
- Can migrate to validated classes later if needed
- Document assumption that IDs are validated upstream

**Contingency**: If validation becomes critical, create wrapper classes:
```python
@dataclass(frozen=True)
class CellId:
    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("CellId cannot be empty")
```

### 6.3 Integration Risks

**Risk 6: Mismatch with Graph Builder Expectations**

**Impact**: Medium
**Probability**: Low

**Description**: T03 (Graph Builder) might need entity fields we didn't include.

**Mitigation**:
- Review T03 spec before finalizing T01 implementation
- Use test-driven development: write tests for expected usage from T03
- Keep entities extensible (can add fields in future)
- Frozen dataclasses can use `__post_init__` for computed fields

**Risk 7: Performance Overhead of Immutability**

**Impact**: Low
**Probability**: Low

**Description**: Creating many immutable objects might be slower than mutable ones.

**Mitigation**:
- Dataclasses are optimized for performance
- Frozen dataclasses can be cached/interned
- Measure performance only if it becomes a problem (premature optimization)
- For MVP, correctness > performance

---

## 7. Open Questions and Decisions Needed

### Question 1: Should IDs be auto-generated or externally provided?

**Current Approach**: IDs are externally provided (from CDL parser)

**Alternatives**:
- Auto-generate UUIDs internally
- Use sequential integers

**Decision**: Keep external IDs for MVP
- IDs come from CDL file (instance names, net names)
- Preserves semantic meaning (better for debugging)
- Can add auto-generation later if needed

### Question 2: Should we use slots for memory optimization?

**Current Approach**: No `__slots__` in spec

**Trade-offs**:
- Pros: 30-40% memory savings, slight performance gain
- Cons: Less flexible (can't add attributes dynamically), inheritance complications

**Decision**: Add `slots=True` to dataclasses for memory optimization
```python
@dataclass(frozen=True, slots=True)
class Pin:
    ...
```

**Rationale**: Large netlists (100K+ cells) will benefit significantly from memory savings, and we don't need dynamic attributes in domain entities.

### Question 3: How to handle future schema evolution?

**Current Approach**: No versioning or migration strategy

**Consideration**: If we add new fields later, how to handle old serialized data?

**Decision**: Defer to persistence layer (out of scope for T01)
- Domain entities should be version-agnostic
- Serialization/deserialization will handle migrations
- Use default values for new fields to maintain backward compatibility

---

## 8. Implementation Checklist

### Phase 1: Setup
- [ ] Create directory structure: `src/ink/domain/value_objects/` and `src/ink/domain/model/`
- [ ] Create `__init__.py` files for both directories
- [ ] Set up test directories: `tests/unit/domain/value_objects/` and `tests/unit/domain/model/`

### Phase 2: Value Objects
- [ ] Implement `src/ink/domain/value_objects/identifiers.py`
  - [ ] Define `CellId = NewType('CellId', str)`
  - [ ] Define `NetId = NewType('NetId', str)`
  - [ ] Define `PinId = NewType('PinId', str)`
  - [ ] Define `PortId = NewType('PortId', str)`
- [ ] Implement `src/ink/domain/value_objects/pin_direction.py`
  - [ ] Define `PinDirection(str, Enum)` with INPUT, OUTPUT, INOUT
  - [ ] Implement `is_input()` method
  - [ ] Implement `is_output()` method
- [ ] Create exports in `src/ink/domain/value_objects/__init__.py`

### Phase 3: Domain Entities
- [ ] Implement `src/ink/domain/model/pin.py`
  - [ ] Define `Pin` frozen dataclass with id, name, direction, net_id
  - [ ] Implement `is_connected()` helper method
- [ ] Implement `src/ink/domain/model/net.py`
  - [ ] Define `Net` frozen dataclass with id, name, connected_pin_ids
  - [ ] Implement `is_multi_fanout()` helper method
  - [ ] Implement `pin_count()` helper method
- [ ] Implement `src/ink/domain/model/port.py`
  - [ ] Define `Port` frozen dataclass with id, name, direction, net_id
  - [ ] Implement `is_input_port()` helper method
  - [ ] Implement `is_output_port()` helper method
- [ ] Implement `src/ink/domain/model/cell.py`
  - [ ] Define `Cell` frozen dataclass with id, name, cell_type, pin_ids, is_sequential
  - [ ] Implement `is_latch()` helper method
- [ ] Create exports in `src/ink/domain/model/__init__.py`

### Phase 4: Testing
- [ ] Write unit tests for `PinDirection` enum
- [ ] Write unit tests for `Pin` entity
- [ ] Write unit tests for `Net` entity
- [ ] Write unit tests for `Port` entity
- [ ] Write unit tests for `Cell` entity
- [ ] Verify immutability with tests
- [ ] Achieve 95%+ test coverage

### Phase 5: Documentation
- [ ] Add docstrings to all classes (Google style)
- [ ] Add docstrings to all methods
- [ ] Add type hints to all fields and methods
- [ ] Add usage examples in module docstrings
- [ ] Run `mypy` with `--strict` mode and fix all issues

### Phase 6: Validation
- [ ] Review against spec acceptance criteria
- [ ] Run full test suite: `pytest tests/unit/domain/ -v`
- [ ] Run coverage report: `pytest tests/unit/domain/ --cov --cov-report=html`
- [ ] Run type checker: `mypy src/ink/domain/`
- [ ] Run linter: `ruff check src/ink/domain/`

---

## 9. Success Metrics

### Code Quality Metrics
- **Test Coverage**: 95%+ (measured by pytest-cov)
- **Type Coverage**: 100% of public APIs have type hints (verified by mypy)
- **Linting**: Zero warnings from ruff
- **Documentation**: All public classes and methods have docstrings

### Functional Metrics
- **All entities are immutable**: Frozen dataclasses pass immutability tests
- **Helper methods work correctly**: All helper methods return expected values
- **Module exports are clean**: Can import all entities from `src.ink.domain.model`
- **Zero external dependencies**: No imports outside Python stdlib

### Performance Metrics
- **Entity creation time**: <1μs per entity (dataclass creation is fast)
- **Memory footprint**: <200 bytes per entity (measured with `sys.getsizeof`)

---

## 10. Definition of Done

- [ ] All acceptance criteria from spec are met
- [ ] All entities implemented as frozen dataclasses with type hints
- [ ] All helper methods implemented and tested
- [ ] 95%+ unit test coverage achieved
- [ ] `mypy --strict` passes with zero errors
- [ ] `ruff check` passes with zero warnings
- [ ] All docstrings written (Google style)
- [ ] Module exports configured in `__init__.py` files
- [ ] Code reviewed (self-review checklist completed)
- [ ] Integration with T02 verified (can construct entities from test data)

---

## Appendix A: Code Templates

### Template: Entity with Helper Method
```python
from dataclasses import dataclass
from typing import Optional
from ..value_objects.identifiers import PinId, NetId
from ..value_objects.pin_direction import PinDirection

@dataclass(frozen=True, slots=True)
class Pin:
    """Pin entity representing a connection point on a cell.

    Pins are the fundamental connection points in a netlist. Each pin
    has a direction (INPUT, OUTPUT, or INOUT) and may be connected to
    a net. Floating pins (not connected) have net_id=None.

    Attributes:
        id: Unique identifier for this pin
        name: Pin name (e.g., "A", "Y", "CLK")
        direction: Pin direction (INPUT, OUTPUT, INOUT)
        net_id: Connected net ID, or None if floating

    Examples:
        >>> pin = Pin(
        ...     id=PinId("XI1.A"),
        ...     name="A",
        ...     direction=PinDirection.INPUT,
        ...     net_id=NetId("net_123")
        ... )
        >>> pin.is_connected()
        True
    """
    id: PinId
    name: str
    direction: PinDirection
    net_id: Optional[NetId]

    def is_connected(self) -> bool:
        """Check if pin is connected to a net.

        Returns:
            True if net_id is not None, False otherwise
        """
        return self.net_id is not None
```

### Template: Test Case
```python
import pytest
from dataclasses import FrozenInstanceError
from src.ink.domain.model.pin import Pin
from src.ink.domain.value_objects.identifiers import PinId, NetId
from src.ink.domain.value_objects.pin_direction import PinDirection

class TestPin:
    """Test suite for Pin entity"""

    def test_pin_creation_with_all_fields(self):
        """Should create Pin with all fields specified"""
        # Arrange & Act
        pin = Pin(
            id=PinId("test_pin"),
            name="A",
            direction=PinDirection.INPUT,
            net_id=NetId("net1")
        )

        # Assert
        assert pin.id == PinId("test_pin")
        assert pin.name == "A"
        assert pin.direction == PinDirection.INPUT
        assert pin.net_id == NetId("net1")

    def test_pin_is_connected_returns_true_when_net_id_present(self):
        """Should return True from is_connected() when net_id is set"""
        # Arrange
        pin = Pin(
            id=PinId("p1"),
            name="Y",
            direction=PinDirection.OUTPUT,
            net_id=NetId("net1")
        )

        # Act & Assert
        assert pin.is_connected() is True

    def test_pin_is_immutable(self):
        """Should raise error when trying to modify frozen Pin"""
        # Arrange
        pin = Pin(
            id=PinId("p1"),
            name="A",
            direction=PinDirection.INPUT,
            net_id=None
        )

        # Act & Assert
        with pytest.raises(FrozenInstanceError):
            pin.id = PinId("p2")
```

---

## Appendix B: Dependencies Graph

```
┌─────────────────────────────────────────────────────────────┐
│                     Domain Layer (Pure)                      │
│                                                              │
│  ┌──────────────────┐         ┌────────────────────────┐    │
│  │  value_objects/  │────────>│       model/           │    │
│  │                  │         │                        │    │
│  │  - identifiers   │         │  - Cell   ─┐           │    │
│  │  - pin_direction │         │  - Pin     │           │    │
│  └──────────────────┘         │  - Net     │ All use   │    │
│                               │  - Port   ─┘ IDs       │    │
│                               └────────────────────────┘    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ Used by (T02)
                           ▼
                  ┌────────────────┐
                  │ Design         │
                  │ Aggregate Root │
                  └────────────────┘
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
