# E01: Input Parsing & Data Model - Pre-Implementation Documentation

## Document Metadata
- **Epic**: E01 - Input Parsing & Data Model
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Opus 4.5

---

## 1. Overview

### 1.1 Epic Summary

E01 establishes the foundational data layer for Ink - parsing gate-level CDL netlists and constructing an efficient graph representation that enables incremental schematic exploration. This epic is the bedrock upon which all other features (rendering, expansion, search) depend.

### 1.2 Core Objectives

1. **Netlist Parsing**: Robust CDL (`.ckt`) and pin direction (`.pindir`) parsers that handle SPICE-like syntax variations
2. **Data Model**: Strongly-typed Python dataclasses representing cells, pins, nets, and ports
3. **Graph Construction**: NetworkX-based directed graph with efficient indexing for traversal queries
4. **Latch Identification**: Pattern-based detection of sequential elements for semantic boundary recognition
5. **Performance Foundation**: Memory-efficient representation supporting 100K+ cell netlists

### 1.3 Success Metrics

- Parse 100K cell netlist in <5 seconds
- Memory footprint <2GB for 100K cell design
- Single cell/net lookup <10ms (O(1) or O(log n))
- 90%+ test coverage on core modules
- Zero data loss during parse (all cells, nets, pins preserved)

---

## 2. Architecture Decisions

### 2.1 Parser Architecture

**Decision**: Use custom parser with tokenizer + recursive descent approach

**Alternatives Considered**:
1. **PLY (Python Lex-Yacc)**: More formal grammar definition
   - Pros: Industry standard, well-tested
   - Cons: Overkill for simple CDL syntax, slower performance, steeper learning curve

2. **Regex-only parser**: Simple pattern matching per line
   - Pros: Minimal dependencies, easy to understand
   - Cons: Fragile with syntax variations, poor error messages, hard to maintain

3. **ANTLR + Python target**: Full lexer/parser generator
   - Pros: Production-grade, excellent error recovery
   - Cons: External tool dependency, generated code complexity

**Rationale**: Custom parser gives best balance of performance, maintainability, and error handling for our specific CDL syntax. We can optimize hot paths and provide domain-specific error messages.

**Implementation Approach**:
```python
# src/ink/core/parser/cdl_parser.py
class CDLTokenizer:
    """Converts CDL text into token stream"""

class CDLParser:
    """Recursive descent parser for CDL syntax"""
    def parse_file(self, path: str) -> Netlist
    def _parse_subckt(self) -> Subcircuit
    def _parse_instance(self) -> Cell
```

### 2.2 Data Model Design

**Decision**: Use Python dataclasses with bidirectional references

**Key Design Choices**:

1. **Bidirectional References**: `Pin` → `Net`, `Net` → `List[Pin]`
   - Enables O(1) traversal in both directions
   - Requires careful initialization to avoid circular reference issues
   - Use factory pattern or builder for construction

2. **Immutability**: Make core objects frozen after construction
   - Prevents accidental mutations during graph traversal
   - Thread-safe for future parallelization
   - Use `frozen=True` on dataclasses where possible

3. **Type Safety**: Leverage Python 3.10+ type hints and Pydantic validation
   - Catch errors at parse time, not runtime
   - Enable IDE autocomplete and static analysis
   - Document expected data structures

**Schema**:
```python
@dataclass(frozen=True)
class Cell:
    name: str
    cell_type: str
    pins: Tuple[Pin, ...]  # Immutable
    is_sequential: bool = False
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass(frozen=True)
class Pin:
    name: str
    direction: PinDirection
    cell: Cell
    net: Optional[Net] = None

@dataclass
class Net:  # Mutable during construction only
    name: str
    connected_pins: List[Pin] = field(default_factory=list)

@dataclass(frozen=True)
class Port:
    name: str
    direction: PinDirection
    net: Net
```

### 2.3 Graph Representation

**Decision**: Start with NetworkX, design for rustworkx migration

**Graph Structure**:
- **Nodes**: Hybrid model with both Cell and Pin nodes
  - Cell nodes: High-level connectivity queries
  - Pin nodes: Fine-grained direction-aware traversal
- **Edges**: Directed edges from driver pins to sink pins
  - Weight: Net name (for routing)
  - Attributes: Fanout count, criticality (future)

**Node Attributes**:
```python
# Cell node
{
    'type': 'cell',
    'cell_type': 'INV_X1',
    'is_sequential': False,
    'pins': {...}
}

# Pin node
{
    'type': 'pin',
    'direction': PinDirection.OUTPUT,
    'net': 'net_123',
    'cell': 'XI1'
}
```

**Indexing Strategy**:
1. **Primary Index**: Hash map `cell_name → Cell` (O(1) lookup)
2. **Net Index**: Hash map `net_name → Net` (O(1) lookup)
3. **Pin Index**: Hash map `(cell_name, pin_name) → Pin` (O(1) lookup)
4. **Sequential Index**: Set of sequential cell names (O(1) membership test)

**Migration Path to rustworkx**:
- Encapsulate all NetworkX calls behind abstract `GraphBackend` interface
- Implement `NetworkXBackend` and `RustworkxBackend` with same API
- Swap implementation via configuration flag
- Expected performance gain: 5-10x for large graphs

### 2.4 Pin Direction Resolution

**Decision**: Global pin direction mapping with cell-type override capability

**Approach**:
1. **Default**: Load `.pindir` file with global `pin_name → direction` mapping
2. **Override**: Support cell-type-specific mappings for special cases
3. **Fallback**: Default to `INOUT` with warning for unknown pins

**Example**:
```python
# Global pindir
pin_directions = {
    'A': PinDirection.INPUT,
    'B': PinDirection.INPUT,
    'Y': PinDirection.OUTPUT,
    'Q': PinDirection.OUTPUT,
    'D': PinDirection.INPUT,
}

# Cell-type override (future)
cell_specific_pins = {
    'TRI_X1': {
        'Y': PinDirection.OUTPUT,
        'OE': PinDirection.INPUT  # Output enable
    }
}
```

### 2.5 Latch Identification

**Decision**: Pattern-based identification with configurable rules

**Strategy**:
1. **Naming Patterns**: Match cell types against regex patterns
   - Default: `.*LATCH.*`, `.*_FF$`, `.*_DFF$`, `.*_SDFF.*`
2. **Configuration**: User-editable JSON config file
3. **Explicit Marking**: Support manual override via metadata

**Configuration File** (`src/ink/config/sequential_patterns.json`):
```json
{
  "patterns": [
    ".*LATCH.*",
    ".*_FF$",
    ".*_DFF$",
    ".*SDFF.*",
    ".*DLATCH.*"
  ],
  "explicit_types": [
    "LATCH_X1",
    "DFF_X1"
  ]
}
```

---

## 3. Implementation Strategy

### 3.1 Development Phases

#### Phase 1: Core Parser (Week 1)
**Goal**: Functional CDL parser with basic validation

**Deliverables**:
- `CDLTokenizer` class with line-by-line tokenization
- `CDLParser` class parsing `.SUBCKT`, `.ENDS`, `X` instances
- Unit tests for sample CDL files
- Error handling for malformed syntax

**Success Criteria**:
- Parse 3 sample CDL files from examples/
- Extract all subcircuits, cells, nets
- Generate meaningful error messages with line numbers

#### Phase 2: Data Model & Graph Construction (Week 1-2)
**Goal**: Build graph representation from parsed data

**Deliverables**:
- `Cell`, `Pin`, `Net`, `Port` dataclasses
- `NetlistGraph` class wrapping NetworkX
- Builder pattern for safe object construction
- Bidirectional reference resolution

**Success Criteria**:
- Construct graph from parsed CDL
- Validate graph connectivity (no dangling nets)
- Memory profiling shows <2GB for 100K cells

#### Phase 3: Pin Direction Parsing (Week 2)
**Goal**: Add pin direction awareness

**Deliverables**:
- `.pindir` file parser
- Pin direction resolution logic
- Integration with graph construction
- Warning system for missing directions

**Success Criteria**:
- All pins have direction assigned (default INOUT if missing)
- Direction propagates to graph node attributes
- Warnings logged for unknown pins

#### Phase 4: Latch Identification (Week 2)
**Goal**: Detect sequential elements

**Deliverables**:
- Sequential pattern configuration loader
- Cell-type matching engine
- `is_sequential` flag in Cell model
- Sequential cell index for fast queries

**Success Criteria**:
- 100% accuracy on known latch/FF patterns
- Configurable patterns work correctly
- Performance: <1ms to check if cell is sequential

#### Phase 5: Query API & Optimization (Week 3)
**Goal**: Efficient graph query interface

**Deliverables**:
- `get_fanin(cell, hops)` method
- `get_fanout(cell, hops)` method
- `get_connected_cells(net)` method
- Benchmark suite and performance profiling

**Success Criteria**:
- Single-hop query <10ms
- Multi-hop query scales linearly
- 90%+ test coverage

### 3.2 File Organization

```
src/ink/core/
├── __init__.py
├── parser/
│   ├── __init__.py
│   ├── cdl_parser.py       # CDL file parser
│   ├── pindir_parser.py    # Pin direction parser
│   ├── tokenizer.py        # Shared tokenization logic
│   └── exceptions.py       # Parse error types
├── graph/
│   ├── __init__.py
│   ├── netlist_graph.py    # Main graph class
│   ├── backend.py          # Abstract graph backend
│   ├── networkx_backend.py # NetworkX implementation
│   └── queries.py          # Graph query methods
├── models/
│   ├── __init__.py
│   ├── cell.py             # Cell dataclass
│   ├── pin.py              # Pin dataclass
│   ├── net.py              # Net dataclass
│   ├── port.py             # Port dataclass
│   └── enums.py            # PinDirection enum
└── config/
    ├── __init__.py
    ├── sequential_patterns.json
    └── config_loader.py

tests/core/
├── parser/
│   ├── test_cdl_parser.py
│   ├── test_pindir_parser.py
│   └── test_tokenizer.py
├── graph/
│   ├── test_netlist_graph.py
│   ├── test_queries.py
│   └── test_backends.py
└── models/
    └── test_models.py

examples/
├── simple_inverter.ckt
├── simple_inverter.pindir
├── counter_8bit.ckt
└── alu_32bit.ckt
```

### 3.3 Integration Points

**With E02 (Rendering)**:
- Graph provides node positions for layout algorithm
- Edge data includes net names for routing
- Sequential cells marked for visual differentiation

**With E03 (Expansion)**:
- Fanin/fanout queries drive incremental expansion
- Sequential cell detection defines semantic boundaries
- Graph supports efficient subgraph extraction

**With E04 (Interaction)**:
- Selection queries map UI coordinates to graph nodes
- Property panel reads node attributes
- Collapse operations modify graph visibility flags

**With E05 (Search)**:
- Net name index enables fast text search
- Cell type index supports wildcard queries
- Path traversal builds on fanin/fanout queries

---

## 4. Technical Deep Dive

### 4.1 CDL Syntax Handling

**Supported Syntax**:
```cdl
* Comment line
.SUBCKT inverter A Y VDD VSS
XI1 A Y VDD VSS INV_X1
.ENDS inverter

.SUBCKT top_module in out VDD VSS
XINV1 in net1 VDD VSS inverter
XBUF1 net1 out VDD VSS buffer
.ENDS top_module
```

**Edge Cases**:
1. **Line Continuation**: `+` at start of next line
   ```cdl
   X1 very_long_net_name_1 very_long_net_name_2
   + very_long_net_name_3 CELL_TYPE
   ```

2. **Bus Notation**: Angle brackets for bit indices
   ```cdl
   X1 data<7> data<6> data<5> data<4> CELL_TYPE
   ```

3. **Escaped Names**: Backslash escaping for special characters
   ```cdl
   X1 net\.with\.dots signal\[0\] CELL_TYPE
   ```

4. **Case Sensitivity**: Preserve case but match case-insensitively for keywords
   ```cdl
   .subckt MyCell A Y    # Valid (keywords case-insensitive)
   XI1 ... MyCell        # Matches above definition
   ```

**Parser State Machine**:
```
IDLE → .SUBCKT → IN_SUBCKT → (.ENDS → IDLE)
                           → (X instance → IN_SUBCKT)
```

### 4.2 Graph Construction Algorithm

**Step 1: Parse All Subcircuits**
```python
subcircuits = {}
for subckt in cdl_parser.parse_subcircuits():
    subcircuits[subckt.name] = subckt
```

**Step 2: Build Cell Objects**
```python
cells = []
for instance in top_subckt.instances:
    pins = []
    for pin_name, net_name in zip(instance.pins, instance.nets):
        direction = pin_directions.get(pin_name, PinDirection.INOUT)
        pin = Pin(name=pin_name, direction=direction, net_name=net_name)
        pins.append(pin)

    cell = Cell(
        name=instance.name,
        cell_type=instance.cell_type,
        pins=tuple(pins),
        is_sequential=is_sequential(instance.cell_type)
    )
    cells.append(cell)
```

**Step 3: Resolve Nets**
```python
nets = defaultdict(list)
for cell in cells:
    for pin in cell.pins:
        nets[pin.net_name].append(pin)

# Create Net objects with bidirectional links
net_objects = {}
for net_name, pins in nets.items():
    net = Net(name=net_name, connected_pins=pins)
    net_objects[net_name] = net

    # Update pin references
    for pin in pins:
        pin.net = net  # If not frozen
```

**Step 4: Build Graph**
```python
graph = nx.DiGraph()

# Add nodes
for cell in cells:
    graph.add_node(cell.name, type='cell', cell=cell)
    for pin in cell.pins:
        pin_id = f"{cell.name}.{pin.name}"
        graph.add_node(pin_id, type='pin', pin=pin)

# Add edges (driver → sink)
for net in net_objects.values():
    drivers = [p for p in net.connected_pins if p.direction == PinDirection.OUTPUT]
    sinks = [p for p in net.connected_pins if p.direction == PinDirection.INPUT]

    for driver in drivers:
        for sink in sinks:
            driver_id = f"{driver.cell.name}.{driver.name}"
            sink_id = f"{sink.cell.name}.{sink.name}"
            graph.add_edge(driver_id, sink_id, net=net.name)
```

### 4.3 Memory Optimization Techniques

**Problem**: 100K cells × 4 pins avg × 100 bytes/pin = 40MB (pins alone)
- Add cell objects, net objects, graph overhead → easily 500MB+
- NetworkX has high memory overhead per node/edge

**Optimizations**:

1. **Interning Strings**: Reuse cell type names, common pin names
   ```python
   cell_type = sys.intern(cell_type_str)  # Saves ~30% on strings
   ```

2. **Frozen Dataclasses**: Reduce per-instance memory (no `__dict__`)
   ```python
   @dataclass(frozen=True, slots=True)
   class Pin:
       ...
   ```

3. **Tuple Instead of List**: Immutable pin lists save memory
   ```python
   pins: Tuple[Pin, ...] = field(default_factory=tuple)
   ```

4. **Lazy Net Resolution**: Don't store full pin lists in memory
   ```python
   class Net:
       def get_connected_pins(self):
           # Query graph on-demand instead of storing list
           return self._graph.query_pins_on_net(self.name)
   ```

5. **Graph Attribute Compression**: Use integer IDs instead of full objects
   ```python
   # Bad: Store full object reference
   graph.nodes[node_id]['cell'] = cell_object

   # Good: Store ID and use index
   graph.nodes[node_id]['cell_id'] = cell_id
   cell_map[cell_id] = cell_object
   ```

### 4.4 Error Handling Strategy

**Error Categories**:

1. **Syntax Errors**: Malformed CDL syntax
   - Line number + column position
   - Suggestion for fix
   - Continue parsing if possible

2. **Semantic Errors**: Valid syntax but invalid structure
   - Undefined cell type reference
   - Dangling net (no driver or sink)
   - Port count mismatch

3. **Warning-Level Issues**: Non-critical problems
   - Missing pin direction (defaults to INOUT)
   - Unused nets
   - Unconnected pins

**Error Reporting Format**:
```
ERROR [cdl_parser.py:142] Syntax error in file 'design.ckt' at line 47:
  X1 net1 net2 net3
     ^~~~
  Expected cell type after net list

WARNING [graph.py:89] Pin direction unknown for 'CUSTOM_PIN'
  Cell: XI_123, Pin: CUSTOM_PIN
  Defaulting to INOUT direction
```

---

## 5. Risk Analysis

### 5.1 Technical Risks

#### Risk 1: Memory Exhaustion on Large Netlists
**Impact**: High (application crash, unusable for target use case)
**Probability**: Medium (100K cells is achievable, but 500K+ may hit limits)

**Mitigation**:
- Implement memory profiling early (Phase 2)
- Use `memory_profiler` and `tracemalloc` to track allocations
- Set hard limit: 2GB for 100K cells → 20GB max for 1M cells
- If exceeded, implement streaming parser or database backend

**Contingency**:
- Switch to SQLite backend for graph storage
- Lazy-load cell details on-demand
- Implement LRU cache for frequently accessed cells

#### Risk 2: CDL Syntax Variations
**Impact**: Medium (parser fails on real-world files)
**Probability**: High (CDL has no strict standard, vendor variations exist)

**Mitigation**:
- Build parser with error recovery (skip malformed lines, continue parsing)
- Collect sample CDL files from multiple sources during development
- Implement plugin system for vendor-specific syntax handlers
- Extensive logging to identify patterns in parse failures

**Contingency**:
- Provide "strict" vs "permissive" parse modes
- Allow user to provide custom parsing rules via config
- Fall back to regex-based parsing for problematic sections

#### Risk 3: NetworkX Performance Bottleneck
**Impact**: Medium (slow queries, poor user experience)
**Probability**: Medium (NetworkX is Python, not optimized for large graphs)

**Mitigation**:
- Design abstraction layer from day 1
- Benchmark NetworkX early (Phase 5)
- Set performance SLA: 10ms for single-hop fanout with 1000 fanout pins
- Plan rustworkx migration if benchmarks fail

**Contingency**:
- Implement custom adjacency list representation
- Use NumPy arrays for graph storage (integer IDs only)
- Pre-compute common queries (e.g., all latches, all I/O ports)

### 5.2 Integration Risks

#### Risk 4: Pin Direction Ambiguity
**Impact**: Medium (incorrect fanin/fanout direction, wrong expansion)
**Probability**: Medium (some cells have bidirectional pins, three-state buffers)

**Mitigation**:
- Default to INOUT for ambiguous pins
- Emit warnings for all INOUT pins (user should review)
- Support cell-type-specific pin direction overrides
- Validate with electrical rule checking (ERC) - future feature

**Contingency**:
- Allow users to manually annotate pin directions in UI
- Provide pin direction editor dialog
- Save overrides to separate `.pindir.local` file

#### Risk 5: Latch Detection False Positives/Negatives
**Impact**: Low (incorrect semantic boundaries, suboptimal expansion)
**Probability**: Medium (naming conventions vary across libraries)

**Mitigation**:
- Make patterns configurable, not hardcoded
- Provide UI to review detected sequential cells
- Support manual override (mark cell as sequential/combinational)
- Test against multiple standard cell libraries (FreePDK, SkyWater)

**Contingency**:
- Add "semantic boundary preview" mode to visualize expansion
- Allow users to define custom boundary rules (not just sequential)
- Fall back to hop-based expansion if semantic detection unreliable

### 5.3 Schedule Risks

#### Risk 6: Underestimated Parser Complexity
**Impact**: Low (delays other epics)
**Probability**: Medium (CDL edge cases may be more complex than expected)

**Mitigation**:
- Start with simple parser for well-formed CDL (80% case)
- Iterate on error handling and edge cases in parallel with other epics
- Use TDD to catch regressions early
- Timebox edge case handling (don't gold-plate)

**Contingency**:
- Ship MVP with "strict" parser, add permissive mode in P1
- Crowdsource CDL samples from users for testing
- Prioritize most common syntax variants first

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Coverage Target**: 90%+ for core modules

**Test Structure**:
```python
# tests/core/parser/test_cdl_parser.py
class TestCDLParser:
    def test_parse_simple_subcircuit(self):
        """Parse basic .SUBCKT with single instance"""

    def test_parse_nested_hierarchy(self):
        """Parse multiple subcircuit levels"""

    def test_parse_bus_notation(self):
        """Handle data<7:0> syntax"""

    def test_parse_line_continuation(self):
        """Handle + continuation"""

    def test_error_recovery_malformed_line(self):
        """Continue parsing after syntax error"""

    def test_preserves_case_sensitivity(self):
        """Net names are case-sensitive"""
```

**Fixtures**:
- `simple_inverter.ckt`: 1 subcircuit, 1 instance
- `nested_gates.ckt`: 3 levels of hierarchy
- `complex_alu.ckt`: 1000 instances, realistic structure
- `malformed.ckt`: Various syntax errors for error handling

### 6.2 Integration Testing

**Graph Construction Pipeline**:
```python
# tests/integration/test_parse_to_graph.py
def test_end_to_end_graph_construction():
    """Parse CDL + pindir, build graph, verify connectivity"""
    parser = CDLParser()
    netlist = parser.parse_file("examples/counter_8bit.ckt")

    pindir_parser = PinDirParser()
    pin_directions = pindir_parser.parse_file("examples/counter_8bit.pindir")

    graph = NetlistGraph.from_netlist(netlist, pin_directions)

    # Verify graph integrity
    assert graph.num_cells() == 247
    assert graph.num_nets() == 356
    assert all(cell.has_valid_pins() for cell in graph.cells())

    # Verify connectivity
    cell = graph.get_cell("XINV_0")
    fanout = graph.get_fanout(cell, hops=1)
    assert len(fanout) == 2
```

### 6.3 Performance Testing

**Benchmark Suite**:
```python
# tests/benchmarks/test_performance.py
@pytest.mark.benchmark
def test_parse_large_netlist(benchmark):
    """Parse 100K cell netlist"""
    result = benchmark(CDLParser().parse_file, "examples/large_design.ckt")
    assert benchmark.stats.mean < 5.0  # <5 seconds

@pytest.mark.benchmark
def test_single_cell_lookup(benchmark, large_graph):
    """O(1) cell lookup"""
    result = benchmark(large_graph.get_cell, "XINV_50000")
    assert benchmark.stats.mean < 0.01  # <10ms

@pytest.mark.benchmark
def test_fanout_query_1000_pins(benchmark, large_graph):
    """Fanout from high-fanout net"""
    clock_buffer = large_graph.get_cell("XCLK_BUF")
    result = benchmark(large_graph.get_fanout, clock_buffer, hops=1)
    assert benchmark.stats.mean < 0.05  # <50ms
```

**Memory Profiling**:
```python
from memory_profiler import profile

@profile
def test_memory_footprint():
    """Measure memory usage for 100K cells"""
    parser = CDLParser()
    netlist = parser.parse_file("examples/large_design.ckt")
    graph = NetlistGraph.from_netlist(netlist)

    # Should be <2GB
    assert get_object_size(graph) < 2 * 1024**3
```

### 6.4 Validation Testing

**Netlist Integrity Checks**:
```python
class NetlistValidator:
    def validate_no_dangling_nets(self, graph):
        """Every net has at least one driver and one sink"""
        for net in graph.nets():
            drivers = [p for p in net.pins if p.direction == OUTPUT]
            sinks = [p for p in net.pins if p.direction == INPUT]
            assert len(drivers) >= 1, f"Net {net.name} has no driver"
            assert len(sinks) >= 1, f"Net {net.name} has no sink"

    def validate_cell_pin_consistency(self, graph):
        """Cell pin count matches cell type definition"""
        for cell in graph.cells():
            expected_pins = get_cell_definition(cell.cell_type).pins
            assert len(cell.pins) == len(expected_pins)

    def validate_graph_connectivity(self, graph):
        """All nodes reachable from I/O ports"""
        inputs = graph.get_input_ports()
        reachable = set()
        for port in inputs:
            reachable.update(nx.descendants(graph.nx_graph, port))

        unreachable = set(graph.cells()) - reachable
        assert len(unreachable) == 0, f"Unreachable cells: {unreachable}"
```

### 6.5 Test Data Strategy

**Example Files**:
1. **simple_inverter.ckt**: Minimal test case (1 cell)
2. **counter_8bit.ckt**: Small realistic design (247 cells)
3. **alu_32bit.ckt**: Medium design (5000 cells)
4. **large_design.ckt**: Stress test (100K cells, generated)

**Generation Script**:
```python
# tests/data/generate_large_netlist.py
def generate_large_cdl(num_cells: int, output_path: str):
    """Generate synthetic CDL for stress testing"""
    with open(output_path, 'w') as f:
        f.write(".SUBCKT large_design in out VDD VSS\n")

        for i in range(num_cells):
            cell_type = random.choice(['INV_X1', 'NAND2_X1', 'NOR2_X1'])
            # Generate instance line...

        f.write(".ENDS large_design\n")
```

---

## 7. Definition of Done

### 7.1 Feature Completeness

- [ ] CDL parser handles all syntax variants in PRD Appendix A
- [ ] Pin direction parser loads `.pindir` files successfully
- [ ] Graph construction creates bidirectional Cell-Pin-Net model
- [ ] Latch identification correctly marks sequential cells
- [ ] All 4 user stories have passing acceptance criteria

### 7.2 Code Quality

- [ ] 90%+ test coverage on `src/ink/core/` modules
- [ ] All unit tests pass with 0 failures
- [ ] Type hints on 100% of public APIs
- [ ] Docstrings on all public classes and methods (Google style)
- [ ] `mypy` static analysis passes with `--strict` mode
- [ ] `ruff` linting passes with zero warnings

### 7.3 Performance

- [ ] Parse 100K cell netlist in <5 seconds
- [ ] Memory footprint <2GB for 100K cells (measured with `memory_profiler`)
- [ ] Single cell/net lookup <10ms (99th percentile)
- [ ] 1-hop fanout query <50ms for 1000-pin net
- [ ] Benchmark suite runs in CI pipeline

### 7.4 Documentation

- [ ] API reference documentation generated (Sphinx)
- [ ] Architecture decision records (ADRs) for key choices
- [ ] Example code snippets in docstrings
- [ ] User-facing error messages are clear and actionable
- [ ] `README.md` in `src/ink/core/` explaining module structure

### 7.5 Integration Readiness

- [ ] Graph API stable and versioned (v1.0.0)
- [ ] Breaking changes documented in CHANGELOG.md
- [ ] Integration tests pass with mock E02 (Rendering) consumer
- [ ] Memory profiling shows headroom for 200K+ cells
- [ ] Sequential cell detection tested against 3+ standard cell libraries

### 7.6 Acceptance Sign-Off

**Demo Requirements**:
1. Load `examples/alu_32bit.ckt` in <1 second
2. Query fanout of `XALU_ADD_0` and display in <100ms
3. Show all identified latches in design
4. Demonstrate error recovery on malformed CDL file
5. Show memory usage dashboard (example: 150MB for 5000 cells)

**Stakeholder Approval**:
- [ ] Technical lead reviews architecture decisions
- [ ] Performance benchmarks meet targets
- [ ] Integration points validated by E02/E03 teams
- [ ] Codebase ready for external contributors (clean, documented)

---

## 8. Next Steps

### 8.1 Immediate Actions

1. **Create Feature Specs**: Run `/spec_work E01 --split features` to generate F01-F04 specs
2. **Set Up Development Environment**: Configure `uv`, install dependencies, verify tooling
3. **Create Test Data**: Generate or source sample CDL files for all test scenarios
4. **Implement Phase 1**: Begin CDL tokenizer and parser implementation

### 8.2 Open Questions

1. **Hierarchical Netlists**: Should we flatten hierarchy or preserve subcircuit structure?
   - Impact on expansion, rendering, memory usage
   - Recommendation: Flatten for MVP, preserve hierarchy in P1

2. **Power/Ground Nets**: How to handle VDD/VSS in graph?
   - Option A: Ignore (not interesting for logic tracing)
   - Option B: Include but mark as special
   - Recommendation: Include with `is_power_net` flag

3. **Transistor-Level CDL**: Should parser handle `M` prefix transistor instances?
   - PRD says "gate-level" but some files mix gate + transistor
   - Recommendation: Skip for MVP, warn user

4. **Graph Versioning**: How to handle graph schema evolution?
   - If we add new node attributes, how to migrate?
   - Recommendation: Semantic versioning on graph serialization format

### 8.3 Dependencies to Resolve

- [ ] Obtain sample CDL files from multiple vendors (Synopsys, Cadence, Mentor)
- [ ] Confirm standard cell library for latch pattern testing
- [ ] Identify performance benchmarking infrastructure (CI machine specs)
- [ ] Decide on graph serialization format (Pickle, JSON, Protocol Buffers)

---

## Appendix A: API Reference Preview

```python
# High-level API that other epics will consume

class NetlistGraph:
    """Main entry point for netlist graph operations"""

    @classmethod
    def from_files(cls, cdl_path: str, pindir_path: str) -> NetlistGraph:
        """Load netlist from CDL and pin direction files"""

    def get_cell(self, name: str) -> Cell:
        """O(1) lookup of cell by name"""

    def get_net(self, name: str) -> Net:
        """O(1) lookup of net by name"""

    def get_fanout(self, cell: Cell, hops: int = 1) -> List[Cell]:
        """Get all cells in fanout cone within N hops"""

    def get_fanin(self, cell: Cell, hops: int = 1) -> List[Cell]:
        """Get all cells in fanin cone within N hops"""

    def get_sequential_cells(self) -> Set[Cell]:
        """Get all latches and flip-flops"""

    def get_input_ports(self) -> List[Port]:
        """Get all top-level input ports"""

    def get_output_ports(self) -> List[Port]:
        """Get all top-level output ports"""

    def validate(self) -> ValidationReport:
        """Run integrity checks on graph"""
```

---

## Appendix B: Sample CDL Parsing

**Input** (`examples/simple_inverter.ckt`):
```cdl
* Simple inverter chain example
.SUBCKT inverter_chain in out VDD VSS
XINV1 in net1 VDD VSS INV_X1
XINV2 net1 net2 VDD VSS INV_X1
XINV3 net2 out VDD VSS INV_X1
.ENDS inverter_chain
```

**Parsed Output** (internal representation):
```python
Subcircuit(
    name='inverter_chain',
    ports=['in', 'out', 'VDD', 'VSS'],
    instances=[
        Instance(name='XINV1', nets=['in', 'net1', 'VDD', 'VSS'], cell_type='INV_X1'),
        Instance(name='XINV2', nets=['net1', 'net2', 'VDD', 'VSS'], cell_type='INV_X1'),
        Instance(name='XINV3', nets=['net2', 'out', 'VDD', 'VSS'], cell_type='INV_X1'),
    ]
)
```

**Graph Representation**:
```
Nodes:
  XINV1 (cell, type=INV_X1, sequential=False)
  XINV2 (cell, type=INV_X1, sequential=False)
  XINV3 (cell, type=INV_X1, sequential=False)
  in (port, direction=INPUT)
  out (port, direction=OUTPUT)

Edges:
  in → XINV1.A (net=in)
  XINV1.Y → XINV2.A (net=net1)
  XINV2.Y → XINV3.A (net=net2)
  XINV3.Y → out (net=out)
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Opus 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
