---
id: E01-F04-T02
title: Latch Detector Service
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F04
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - domain-service
  - pattern-matching
---

# Spec: E01-F04-T02 - Latch Detector Service

## 1. Overview

### 1.1 Problem Statement
The system needs a domain service to identify sequential elements (latches, flip-flops) based on cell type names. This service must perform efficient pattern matching against configurable patterns and provide a clean interface for use by graph construction and query logic.

### 1.2 Goals
- Define `LatchIdentifier` protocol (domain service interface)
- Implement `PatternBasedLatchIdentifier` in infrastructure layer
- Support glob-style wildcard pattern matching
- Provide case-insensitive matching
- Enable runtime pattern reconfiguration
- Optimize for repeated queries during graph construction

---

## 2. Technical Requirements

### 2.1 Domain Service Protocol

**Location**: `src/ink/domain/services/latch_identifier.py`

```python
from typing import Protocol, List

class LatchIdentifier(Protocol):
    """Domain service for identifying sequential elements (latches/flip-flops)"""

    def is_sequential(self, cell_type: str) -> bool:
        """
        Check if a cell type represents a sequential element.

        Args:
            cell_type: Cell type name (e.g., "DFFR_X1", "LATCH_X1")

        Returns:
            True if cell type matches sequential patterns, False otherwise
        """
        ...

    def configure_patterns(self, patterns: List[str]) -> None:
        """
        Update cell type patterns for sequential detection.

        Args:
            patterns: List of glob-style patterns (e.g., ["*DFF*", "*LATCH*"])
        """
        ...

    def get_patterns(self) -> List[str]:
        """
        Get current configured patterns.

        Returns:
            List of glob patterns currently in use
        """
        ...
```

### 2.2 Infrastructure Implementation

**Location**: `src/ink/infrastructure/identification/pattern_latch_identifier.py`

```python
from typing import List
import fnmatch

DEFAULT_SEQUENTIAL_PATTERNS = [
    "*DFF*",      # D flip-flops
    "*LATCH*",    # D latches
    "*FF*",       # Generic flip-flops
]

class PatternBasedLatchIdentifier:
    """Pattern-based latch/flip-flop identification using glob matching"""

    def __init__(self, patterns: List[str] | None = None, case_sensitive: bool = False):
        """
        Initialize latch identifier with patterns.

        Args:
            patterns: List of glob patterns (defaults to DEFAULT_SEQUENTIAL_PATTERNS)
            case_sensitive: Whether pattern matching is case-sensitive
        """
        self._patterns = patterns if patterns is not None else list(DEFAULT_SEQUENTIAL_PATTERNS)
        self._case_sensitive = case_sensitive

    def is_sequential(self, cell_type: str) -> bool:
        """
        Check if cell type matches sequential patterns.

        Args:
            cell_type: Cell type name (e.g., "DFFR_X1")

        Returns:
            True if cell type matches any configured pattern
        """
        if not cell_type:
            return False

        # Normalize case if case-insensitive
        test_type = cell_type if self._case_sensitive else cell_type.upper()

        for pattern in self._patterns:
            pattern_test = pattern if self._case_sensitive else pattern.upper()
            if fnmatch.fnmatch(test_type, pattern_test):
                return True

        return False

    def configure_patterns(self, patterns: List[str]) -> None:
        """Update patterns (validates non-empty)"""
        if not patterns:
            raise ValueError("Patterns list cannot be empty")
        self._patterns = list(patterns)

    def get_patterns(self) -> List[str]:
        """Get current patterns (returns copy)"""
        return list(self._patterns)
```

### 2.3 Pattern Matching Logic

**Glob Pattern Support** (via `fnmatch`):
- `*` matches zero or more characters
- `?` matches exactly one character
- `[seq]` matches any character in seq
- `[!seq]` matches any character not in seq

**Examples**:
```python
identifier = PatternBasedLatchIdentifier()

# Positive matches
assert identifier.is_sequential("DFFR_X1") == True      # Matches *DFF*
assert identifier.is_sequential("SDFFR_X2") == True     # Matches *DFF*
assert identifier.is_sequential("LATCH_X1") == True     # Matches *LATCH*
assert identifier.is_sequential("dlatch_x1") == True    # Case-insensitive
assert identifier.is_sequential("FF_POS") == True       # Matches *FF*

# Negative matches
assert identifier.is_sequential("AND2_X1") == False
assert identifier.is_sequential("NAND3_X2") == False
assert identifier.is_sequential("INV_X1") == False
assert identifier.is_sequential("") == False
assert identifier.is_sequential("DFA_X1") == False      # Not DFF
```

### 2.4 Performance Considerations

**Optimization Strategy**:
1. **Compile patterns once**: Store normalized patterns during `configure_patterns()`
2. **Early termination**: Return `True` on first match
3. **Pattern ordering**: Place most common patterns first (e.g., `*DFF*` before `*FF*`)

**Expected Performance**:
- **Graph Construction**: O(1) per cell (amortized), called once per cell during parsing
- **Query**: O(p) where p = number of patterns (typically 3-5)
- **Memory**: O(p) for pattern storage

**Benchmark Target** (for 100K cell design):
- Sequential identification should add < 100ms to graph construction time

---

## 3. Dependencies

- **Upstream**:
  - E01-F04-T01 (Pattern Configuration) - provides configuration data structure
- **Downstream**:
  - E01-F04-T03 (Cell Tagging) - uses this service to tag cells
  - E01-F03 (Graph Construction) - integrates detector during graph building

---

## 4. Acceptance Criteria

- [ ] `LatchIdentifier` protocol defined in `domain/services/latch_identifier.py`
- [ ] `PatternBasedLatchIdentifier` implements protocol in `infrastructure/identification/`
- [ ] `is_sequential()` returns `True` for cells matching any pattern
- [ ] `is_sequential()` returns `False` for non-matching cells and empty strings
- [ ] Case-insensitive matching by default
- [ ] `configure_patterns()` updates patterns and raises `ValueError` for empty list
- [ ] `get_patterns()` returns copy of current patterns (not reference)
- [ ] Default patterns (`*DFF*`, `*LATCH*`, `*FF*`) defined as constant
- [ ] Glob patterns support `*`, `?`, `[seq]`, `[!seq]` wildcards
- [ ] Unit tests cover all matching logic with positive/negative cases
- [ ] Performance test validates < 100ms overhead for 100K cells
- [ ] 100% test coverage on implementation

---

## 5. Implementation Notes

### 5.1 File Structure
```
src/ink/
├── domain/services/
│   ├── __init__.py
│   └── latch_identifier.py           # Protocol definition
└── infrastructure/identification/
    ├── __init__.py
    └── pattern_latch_identifier.py   # Implementation

tests/
├── unit/domain/services/
│   └── test_latch_identifier.py      # Protocol tests (if needed)
└── unit/infrastructure/identification/
    └── test_pattern_latch_identifier.py  # Implementation tests
```

### 5.2 Test Cases

**Unit Tests** (`test_pattern_latch_identifier.py`):
```python
def test_default_patterns_match_dff():
    """Test DFF patterns match standard flip-flops"""

def test_default_patterns_match_latch():
    """Test LATCH patterns match latches"""

def test_case_insensitive_matching():
    """Test case-insensitive matching works"""

def test_empty_string_returns_false():
    """Test empty cell type returns False"""

def test_configure_patterns_updates():
    """Test pattern reconfiguration"""

def test_configure_empty_patterns_raises_error():
    """Test empty pattern list raises ValueError"""

def test_get_patterns_returns_copy():
    """Test get_patterns returns copy not reference"""

def test_non_matching_combinational_cells():
    """Test AND, NAND, INV gates return False"""

def test_performance_100k_cells(benchmark):
    """Benchmark identification for 100K cells"""
```

### 5.3 Integration with Configuration

```python
from ink.infrastructure.config.latch_config import LatchIdentificationConfig
from ink.infrastructure.identification.pattern_latch_identifier import PatternBasedLatchIdentifier

# Load configuration
config = LatchIdentificationConfig.load_from_yaml("config/latch_patterns.yaml")

# Create identifier with config
identifier = PatternBasedLatchIdentifier(
    patterns=config.patterns,
    case_sensitive=config.case_sensitive
)
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task spec creation |
