---
id: E01-F04-T02
title: Latch Detector Service
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F04
created: 2025-12-26
estimated_hours: 10
actual_hours:
effort: High
tags:
  - domain-service
  - topology-analysis
  - circuit-detection
clickup_task_id: '86evzm2g9'
---

# Spec: E01-F04-T02 - Latch Detector Service

## 1. Overview

### 1.1 Problem Statement
The system needs a domain service to identify sequential elements (latches, flip-flops) based on **circuit topology** rather than naming conventions. Name-based approaches are insufficient because:
- **Cell type names** vary across vendors and libraries (e.g., `DFF_X1` vs `MYFF_CUSTOM`)
- **Pin names** are also non-standard (e.g., `CLK` vs `CK` vs `PHI` vs `CP1`)
- Custom or renamed cells may not follow any standard naming convention
- Name-based detection produces false positives/negatives

Topology-based detection analyzes the **structural characteristics** of cells—specifically **feedback loops**—to reliably identify sequential elements regardless of any naming conventions.

### 1.2 Goals
- Define `LatchIdentifier` protocol (domain service interface)
- Implement `TopologyBasedLatchIdentifier` in infrastructure layer
- Support **feedback loop detection** as primary detection method (naming-independent)
- Support **pin signature analysis** as secondary heuristic
- Provide **explicit annotation** for user-defined sequential cells
- Provide fallback to pattern-based matching for edge cases
- Enable runtime configuration of detection strategies
- Optimize with caching for repeated queries during graph construction

### 1.3 Detection Strategies (Priority Order)

| Priority | Strategy | Description | Reliability |
|----------|----------|-------------|-------------|
| 1 | **Feedback Loop** | Detect cross-coupled gates via cycle detection in internal topology | **Highest** - naming independent |
| 2 | **Explicit Annotation** | User-provided list of sequential cell types | **High** - explicit configuration |
| 3 | **Pin Signature** | Detect by characteristic pins (CLK, D, Q patterns) | **Medium** - relies on pin naming |
| 4 | **Pattern Matching** | Fallback using glob patterns on cell type names | **Low** - relies on cell naming |

### 1.4 Key Insight: Feedback Loops

The **defining characteristic** of a sequential element is the presence of a **feedback loop** in its internal topology. Common implementations include:

| Latch Type | Topology | Feedback Structure |
|------------|----------|-------------------|
| **SR Latch** | Cross-coupled NAND/NOR gates | Gate outputs cross-connected to inputs |
| **Transmission Gate Latch** | TG + inverter + feedback inverter | Inverter output feeds back through TG |
| **Tristate Latch** | Tristate inverter + feedback inverter | Inverter loop with enable control |
| **D Flip-Flop** | Master + Slave latches | Two feedback loops in series |

```
┌─────────────────────────────────────────────────────────────┐
│  Transmission Gate Latch (Common CMOS Implementation)       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│              TG1                    TG2 (feedback)          │
│            ┌─────┐                 ┌─────┐                  │
│  D ────────┤ TG  ├───●─────────────┤ TG  ├──────┐           │
│            └──┬──┘   │             └──┬──┘      │           │
│               │      │                │         │           │
│  CLK ─────────┘      │   ┌───────┐   CLK'       │           │
│                      └──>│  INV  │──────────> Q │           │
│                          └───────┘              │           │
│                               │                 │           │
│                               │   ┌───────┐    │           │
│                               └──>│  INV  │────┘           │
│                                   └───────┘                 │
│                                   (feedback)                │
│                                                             │
│  Feedback: INV1.out → INV2.in → INV2.out → TG2 → INV1.in    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│  Tristate Inverter Latch (Compact CMOS)                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│            Tristate INV                                     │
│            ┌───────┐                                        │
│  D ────────┤ TINV  ├───●───────────────────> Q              │
│            └───┬───┘   │                                    │
│                │       │                                    │
│  CLK ──────────┘       │   ┌───────┐                        │
│                        └──>│ TINV  │────┐                   │
│                   CLK' ────┤       │    │                   │
│                            └───────┘    │                   │
│                            (feedback)   │                   │
│                                ↑        │                   │
│                                └────────┘                   │
│                                                             │
│  Feedback: Output → Tristate INV → Input node               │
└─────────────────────────────────────────────────────────────┘
```

This structural property is **independent of naming** and provides the most reliable detection.

---

## 2. Technical Requirements

### 2.1 Domain Service Protocol

**Location**: `src/ink/domain/services/latch_identifier.py`

```python
from typing import Protocol, Set
from dataclasses import dataclass
from enum.enum import Enum

class DetectionStrategy(Enum):
    """Strategy used to detect sequential elements (ordered by reliability)"""
    FEEDBACK_LOOP = "feedback_loop"      # Detected by internal feedback (most reliable)
    EXPLICIT = "explicit"                # Explicitly annotated by user
    PIN_SIGNATURE = "pin_signature"      # Detected by pin characteristics
    PATTERN_MATCH = "pattern_match"      # Detected by name pattern (least reliable)
    UNKNOWN = "unknown"                  # Could not determine

@dataclass(frozen=True)
class SequentialDetectionResult:
    """Result of sequential element detection with reasoning"""
    is_sequential: bool
    strategy: DetectionStrategy
    confidence: float  # 0.0 to 1.0
    reason: str        # Human-readable explanation

class LatchIdentifier(Protocol):
    """Domain service for identifying sequential elements by topology"""

    def is_sequential(self, cell_type: str, pin_names: Set[str] | None = None) -> bool:
        """
        Check if a cell type represents a sequential element.

        Detection priority:
        1. Feedback loop in registered topology (highest reliability)
        2. Explicit annotation
        3. Pin signature analysis (if pin_names provided)
        4. Pattern matching on cell_type (lowest reliability)

        Args:
            cell_type: Cell type name (e.g., "DFFR_X1", "MY_CUSTOM_FF")
            pin_names: Optional set of pin names for signature analysis

        Returns:
            True if cell is detected as sequential, False otherwise
        """
        ...

    def detect_with_reason(
        self, cell_type: str, pin_names: Set[str] | None = None
    ) -> SequentialDetectionResult:
        """
        Detect sequential element with detailed reasoning.

        Args:
            cell_type: Cell type name
            pin_names: Optional set of pin names for signature analysis

        Returns:
            SequentialDetectionResult with detection details
        """
        ...

    def register_subcircuit_topology(
        self, cell_type: str, internal_connections: list[tuple[str, str]]
    ) -> None:
        """
        Register internal topology of a subcircuit for feedback detection.
        This is the PRIMARY detection method - naming independent.

        Args:
            cell_type: Cell type name
            internal_connections: List of (from_node, to_node) internal wire connections
        """
        ...

    def register_sequential_cells(self, cell_types: Set[str]) -> None:
        """
        Explicitly register cell types as sequential (user annotation).
        Use when topology cannot be analyzed or as override.

        Args:
            cell_types: Set of cell type names to mark as sequential
        """
        ...
```

### 2.2 Infrastructure Implementation

**Location**: `src/ink/infrastructure/identification/topology_latch_identifier.py`

```python
from typing import Set
from dataclasses import dataclass
import fnmatch

# Pin signature patterns for sequential detection (used as heuristic fallback)
CLOCK_PIN_PATTERNS = {"CLK", "CK", "CP", "CLOCK", "GCLK", "CLKB", "CKB", "PHI", "PHI1", "PHI2"}
DATA_INPUT_PATTERNS = {"D", "DI", "DATA", "SI", "SE", "SN", "SD"}
DATA_OUTPUT_PATTERNS = {"Q", "QN", "QB", "QI", "DO", "QO"}
SET_RESET_PATTERNS = {"SET", "SETB", "RST", "RSTB", "RESET", "RESETB", "RN", "SN", "CDN", "SDN", "CLR", "PRE"}
ENABLE_PATTERNS = {"EN", "ENB", "ENABLE", "TE", "TI", "G", "GN", "GATE"}

# Fallback name patterns (lowest priority - least reliable)
FALLBACK_NAME_PATTERNS = ["*DFF*", "*LATCH*", "*FF*", "*FLOP*", "*REG*"]

@dataclass
class PinSignature:
    """Analyzed pin signature of a cell"""
    has_clock: bool
    has_data_input: bool
    has_data_output: bool
    has_set_reset: bool
    has_enable: bool
    clock_pins: set[str]
    data_pins: set[str]

class TopologyBasedLatchIdentifier:
    """Topology-based latch/flip-flop identification.

    Detection Priority (highest to lowest reliability):
    1. Feedback loop in registered subcircuit topology (naming-independent)
    2. Explicit annotation via register_sequential_cells()
    3. Pin signature analysis (relies on standard pin naming)
    4. Pattern matching on cell type name (least reliable)
    """

    def __init__(
        self,
        enable_feedback_detection: bool = True,
        enable_pin_signature: bool = True,
        enable_pattern_fallback: bool = True,
        fallback_patterns: list[str] | None = None,
        case_sensitive: bool = False,
    ):
        """
        Initialize topology-based latch identifier.

        Args:
            enable_feedback_detection: Enable feedback loop detection (PRIMARY)
            enable_pin_signature: Enable pin-based detection (SECONDARY)
            enable_pattern_fallback: Enable name pattern fallback (LOWEST)
            fallback_patterns: Custom fallback patterns
            case_sensitive: Case sensitivity for pattern matching
        """
        self._enable_feedback = enable_feedback_detection
        self._enable_pin_signature = enable_pin_signature
        self._enable_fallback = enable_pattern_fallback
        self._fallback_patterns = fallback_patterns or list(FALLBACK_NAME_PATTERNS)
        self._case_sensitive = case_sensitive

        # Cache for subcircuit topologies (cell_type -> has_feedback)
        self._topology_cache: dict[str, bool] = {}

        # Explicit annotations (cell_type -> True)
        self._explicit_sequential: set[str] = set()

        # Cache for detection results (cache_key -> result)
        self._detection_cache: dict[str, SequentialDetectionResult] = {}

    def is_sequential(self, cell_type: str, pin_names: Set[str] | None = None) -> bool:
        """Check if cell is sequential using topology analysis."""
        result = self.detect_with_reason(cell_type, pin_names)
        return result.is_sequential

    def detect_with_reason(
        self, cell_type: str, pin_names: Set[str] | None = None
    ) -> SequentialDetectionResult:
        """Detect with detailed reasoning, using priority-based strategies."""
        pin_names = pin_names or set()

        # Check cache first
        cache_key = f"{cell_type}:{','.join(sorted(pin_names))}"
        if cache_key in self._detection_cache:
            return self._detection_cache[cache_key]

        result = self._detect_impl(cell_type, pin_names)
        self._detection_cache[cache_key] = result
        return result

    def _detect_impl(
        self, cell_type: str, pin_names: Set[str]
    ) -> SequentialDetectionResult:
        """Internal detection implementation with strategy priority."""

        # Strategy 1: Feedback Loop Detection (HIGHEST PRIORITY - naming independent)
        if self._enable_feedback and cell_type in self._topology_cache:
            has_feedback = self._topology_cache[cell_type]
            if has_feedback:
                return SequentialDetectionResult(
                    is_sequential=True,
                    strategy=DetectionStrategy.FEEDBACK_LOOP,
                    confidence=0.99,  # Highest confidence - structural proof
                    reason=f"Detected feedback loop in subcircuit '{cell_type}' internal topology"
                )

        # Strategy 2: Explicit Annotation
        normalized_type = cell_type if self._case_sensitive else cell_type.upper()
        if normalized_type in self._explicit_sequential:
            return SequentialDetectionResult(
                is_sequential=True,
                strategy=DetectionStrategy.EXPLICIT,
                confidence=0.95,  # High confidence - user explicitly marked
                reason=f"Cell type '{cell_type}' explicitly registered as sequential"
            )

        # Strategy 3: Pin Signature Analysis (if pins provided)
        if self._enable_pin_signature and pin_names:
            signature = self._analyze_pin_signature(pin_names)
            if signature.has_clock and signature.has_data_output:
                confidence = 0.80 if signature.has_data_input else 0.70
                return SequentialDetectionResult(
                    is_sequential=True,
                    strategy=DetectionStrategy.PIN_SIGNATURE,
                    confidence=confidence,
                    reason=f"Detected clock pin(s): {signature.clock_pins}, "
                           f"data output(s): {signature.data_pins}"
                )

        # Strategy 4: Pattern Fallback (LOWEST priority)
        if self._enable_fallback:
            test_type = cell_type if self._case_sensitive else cell_type.upper()
            for pattern in self._fallback_patterns:
                test_pattern = pattern if self._case_sensitive else pattern.upper()
                if fnmatch.fnmatch(test_type, test_pattern):
                    return SequentialDetectionResult(
                        is_sequential=True,
                        strategy=DetectionStrategy.PATTERN_MATCH,
                        confidence=0.50,  # Low confidence - just name matching
                        reason=f"Cell type '{cell_type}' matches pattern '{pattern}' (name-based)"
                    )

        # No detection - combinational cell
        return SequentialDetectionResult(
            is_sequential=False,
            strategy=DetectionStrategy.UNKNOWN,
            confidence=0.80,
            reason=f"No sequential characteristics detected in '{cell_type}'"
        )

    def _analyze_pin_signature(self, pin_names: Set[str]) -> PinSignature:
        """Analyze pin names to identify sequential characteristics."""
        normalized = {p.upper() for p in pin_names}

        clock_pins = normalized & CLOCK_PIN_PATTERNS
        data_input_pins = normalized & DATA_INPUT_PATTERNS
        data_output_pins = normalized & DATA_OUTPUT_PATTERNS
        set_reset_pins = normalized & SET_RESET_PATTERNS
        enable_pins = normalized & ENABLE_PATTERNS

        return PinSignature(
            has_clock=bool(clock_pins),
            has_data_input=bool(data_input_pins),
            has_data_output=bool(data_output_pins),
            has_set_reset=bool(set_reset_pins),
            has_enable=bool(enable_pins),
            clock_pins=clock_pins,
            data_pins=data_input_pins | data_output_pins,
        )

    def register_subcircuit_topology(
        self, cell_type: str, internal_connections: list[tuple[str, str]]
    ) -> None:
        """Register subcircuit topology for feedback detection (PRIMARY method)."""
        has_feedback = self._detect_feedback_loop(internal_connections)
        self._topology_cache[cell_type] = has_feedback
        # Invalidate detection cache for this cell type
        self._invalidate_cache_for_type(cell_type)

    def register_sequential_cells(self, cell_types: Set[str]) -> None:
        """Explicitly register cell types as sequential (user annotation)."""
        for cell_type in cell_types:
            normalized = cell_type if self._case_sensitive else cell_type.upper()
            self._explicit_sequential.add(normalized)
            self._invalidate_cache_for_type(cell_type)

    def _invalidate_cache_for_type(self, cell_type: str) -> None:
        """Invalidate detection cache entries for a cell type."""
        to_remove = [k for k in self._detection_cache if k.startswith(f"{cell_type}:")]
        for key in to_remove:
            del self._detection_cache[key]

    def _detect_feedback_loop(
        self, connections: list[tuple[str, str]]
    ) -> bool:
        """Detect feedback loops using DFS cycle detection.

        This is the core algorithm for naming-independent sequential detection.
        A feedback loop indicates bistable storage (latch/flip-flop).
        """
        if not connections:
            return False

        # Build adjacency list
        graph: dict[str, list[str]] = {}
        for src, dst in connections:
            if src not in graph:
                graph[src] = []
            graph[src].append(dst)

        # DFS cycle detection (standard algorithm)
        visited: set[str] = set()
        rec_stack: set[str] = set()

        def has_cycle(node: str) -> bool:
            visited.add(node)
            rec_stack.add(node)

            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True  # Back edge found = cycle

            rec_stack.remove(node)
            return False

        for node in graph:
            if node not in visited:
                if has_cycle(node):
                    return True

        return False

    def clear_cache(self) -> None:
        """Clear all caches."""
        self._detection_cache.clear()
        self._topology_cache.clear()
        self._explicit_sequential.clear()
```

### 2.3 Detection Logic

**Detection Priority and Confidence**:

| Priority | Strategy | Condition | Confidence |
|----------|----------|-----------|------------|
| 1 | **Feedback Loop** | Cycle detected in internal topology | **99%** |
| 2 | **Explicit Annotation** | User-registered cell type | **95%** |
| 3 | **Pin Signature** | CLK + D + Q pins detected | 80% |
| 3 | **Pin Signature** | CLK + Q pins (no D) | 70% |
| 4 | **Pattern Match** | Name matches `*DFF*`, `*LATCH*`, etc. | 50% |
| - | **Unknown** | No indicators found | 80% (combinational) |

**Feedback Loop Detection** (PRIMARY - Naming Independent):
```
┌─────────────────────────────────────────────────────────┐
│           SR Latch Feedback Topology                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   S ───>│\        ┌────────────────>│\                  │
│         │ NAND──Q─┘            R ───>│ NAND──QN         │
│     ┌──>│/                       ┌──>│/                 │
│     │                            │                      │
│     └────────────────────────────┘                      │
│                  ↑                                      │
│            FEEDBACK LOOP                                │
│                                                         │
│   Detected by: Cycle in internal connection graph       │
│   Works regardless of cell name or pin names!           │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│           D Flip-Flop Feedback Topology                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│           ┌──────────────────────────────┐              │
│           │      MASTER LATCH            │              │
│   D ──────┼──>│\      ┌────────>│\       │              │
│           │   │ ──────┘    ┌───>│ ──────┼───> Q        │
│   CLK ────┼──>│/           │    │/      │              │
│           │       ┌────────┘            │              │
│           │       │     SLAVE LATCH     │              │
│           └───────┴─────────────────────┘              │
│                                                         │
│   Two latches with feedback = D Flip-Flop               │
│   Detected by: Multiple cycles in topology              │
└─────────────────────────────────────────────────────────┘
```

**Pin Signature Analysis** (Secondary Heuristic):
```
┌─────────────────────────────────────────────────────────┐
│              Standard D Flip-Flop Pins                  │
├─────────────────────────────────────────────────────────┤
│   CLK/CK/CP/PHI ───┐                                    │
│                    │   ┌─────────┐                      │
│   D/DI/DATA ───────┼──>│   ???   │──> Q/QN/QB           │
│                    │   │         │                      │
│   RST/SET/CLR ─────┘   └─────────┘                      │
│                                                         │
│   Detected by: Clock-like + Data-like pin names         │
│   ⚠️  Relies on pin naming conventions                  │
└─────────────────────────────────────────────────────────┘
```

### 2.4 Examples

```python
identifier = TopologyBasedLatchIdentifier()

# ═══════════════════════════════════════════════════════════════════════════
# EXAMPLE 1: Feedback Loop Detection (HIGHEST PRIORITY - naming independent)
# ═══════════════════════════════════════════════════════════════════════════

# Register subcircuit with cross-coupled gates (SR latch topology)
# Cell name is arbitrary, pin names are arbitrary - doesn't matter!
identifier.register_subcircuit_topology(
    "WEIRD_CELL_XYZ",  # Non-standard name
    [
        ("gate1.out", "gate2.in1"),  # Cross-coupling
        ("gate2.out", "gate1.in2"),  # Creates feedback loop
    ]
)

result = identifier.detect_with_reason(
    "WEIRD_CELL_XYZ",
    {"A1", "B2", "OUT1", "OUT2"}  # Completely non-standard pin names
)
assert result.is_sequential == True
assert result.strategy == DetectionStrategy.FEEDBACK_LOOP
assert result.confidence == 0.99  # Highest confidence
# Works because we detected structural feedback, not names!

# Transmission gate latch (TG + inverter + feedback)
identifier.register_subcircuit_topology(
    "TG_LATCH_CUSTOM",
    [
        ("D", "tg1.in"),
        ("tg1.out", "inv1.in"),
        ("inv1.out", "Q"),           # Data path
        ("inv1.out", "inv2.in"),
        ("inv2.out", "tg2.in"),
        ("tg2.out", "inv1.in"),      # Feedback loop!
    ]
)
result = identifier.detect_with_reason("TG_LATCH_CUSTOM", {"D", "CLK", "Q"})
assert result.is_sequential == True
assert result.strategy == DetectionStrategy.FEEDBACK_LOOP

# ═══════════════════════════════════════════════════════════════════════════
# EXAMPLE 2: Explicit Annotation (for black-box cells without internal topology)
# ═══════════════════════════════════════════════════════════════════════════

# User knows these are sequential cells, but can't analyze internals
identifier.register_sequential_cells({
    "VENDOR_SPECIAL_FF",
    "ENCRYPTED_LATCH_IP",
    "HARDMACRO_REG"
})

result = identifier.detect_with_reason(
    "VENDOR_SPECIAL_FF",
    {"X", "Y", "Z"}  # Unknown pins
)
assert result.is_sequential == True
assert result.strategy == DetectionStrategy.EXPLICIT
assert result.confidence == 0.95

# ═══════════════════════════════════════════════════════════════════════════
# EXAMPLE 3: Pin Signature Detection (when standard pin names are used)
# ═══════════════════════════════════════════════════════════════════════════

result = identifier.detect_with_reason(
    "CUSTOM_STORAGE_ELEMENT",  # Non-standard cell name
    {"CLK", "D", "Q", "QN"}    # But standard pin names
)
assert result.is_sequential == True
assert result.strategy == DetectionStrategy.PIN_SIGNATURE
assert result.confidence == 0.80

# ═══════════════════════════════════════════════════════════════════════════
# EXAMPLE 4: Pattern Match Fallback (lowest reliability)
# ═══════════════════════════════════════════════════════════════════════════

result = identifier.detect_with_reason(
    "SDFFRX2_TSMC",  # Name contains "FF"
    {"A", "B", "Y"}  # Non-standard pins, no topology registered
)
assert result.is_sequential == True
assert result.strategy == DetectionStrategy.PATTERN_MATCH
assert result.confidence == 0.50  # Lowest confidence

# ═══════════════════════════════════════════════════════════════════════════
# EXAMPLE 5: Combinational Cell (correctly identified as non-sequential)
# ═══════════════════════════════════════════════════════════════════════════

# Register combinational cell topology (no feedback)
identifier.register_subcircuit_topology(
    "AND2_X1",
    [("A", "gate.in1"), ("B", "gate.in2"), ("gate.out", "Y")]  # No cycles
)

result = identifier.detect_with_reason("AND2_X1", {"A", "B", "Y"})
assert result.is_sequential == False
assert result.strategy == DetectionStrategy.UNKNOWN
```

### 2.5 Performance Considerations

**Optimization Strategy**:
1. **Result caching**: Cache detection results per `(cell_type, pin_signature)` pair
2. **Topology caching**: Cache feedback analysis per subcircuit type
3. **Lazy analysis**: Only analyze subcircuit internals when registered
4. **Set operations**: Use set intersection for O(1) pin matching

**Expected Performance**:
- **Pin signature check**: O(p) where p = number of pins (typically 5-10)
- **Cached detection**: O(1) after first query per cell type
- **Feedback detection**: O(V + E) per subcircuit (one-time analysis)
- **Memory**: O(c) for c unique cell types

**Benchmark Target** (for 100K cell design):
- Sequential identification should add < 200ms to graph construction time
- Pin signature analysis: < 1μs per cell (after cache warm-up)

---

## 3. Dependencies

- **Upstream**:
  - E01-F04-T01 (Pattern Configuration) - provides configuration data structure
  - E01-F03-T01 (Domain Model Entities) - provides Cell, Pin entities
  - **E01-F04-T04 (Transistor Topology Analyzer)** - extracts `internal_connections` from transistor-level subcircuits
- **Downstream**:
  - E01-F04-T03 (Cell Tagging) - uses this service to tag cells
  - E01-F03 (Graph Construction) - integrates detector during graph building

### 3.1 Integration with Transistor Topology Analyzer (E01-F04-T04)

This task (E01-F04-T02) provides the **detection algorithm**. The connection graph comes from E01-F04-T04:

```
┌──────────────────┐     ┌──────────────────┐     ┌──────────────────┐
│   CDL Parser     │     │  E01-F04-T04     │     │  E01-F04-T02     │
│   (E01-F02)      │     │  Transistor      │     │  Latch           │
│                  │     │  Analyzer        │     │  Identifier      │
├──────────────────┤     ├──────────────────┤     ├──────────────────┤
│                  │     │                  │     │                  │
│  .SUBCKT DFF ... │────>│  Analyze         │────>│  Detect          │
│  M1 n1 D VDD ... │     │  transistor      │     │  feedback        │
│  M2 n1 D VSS ... │     │  patterns        │     │  loops           │
│  ...             │     │                  │     │                  │
│  .ENDS           │     │  Extract signal  │     │  Return          │
│                  │     │  flow graph      │     │  is_sequential   │
│                  │     │                  │     │                  │
└──────────────────┘     └──────────────────┘     └──────────────────┘
     SubcircuitDef           [(from, to), ...]        True/False
```

**Separation of Concerns**:
- **E01-F04-T04**: Understands transistor patterns (inverter, TG, NAND, NOR)
- **E01-F04-T02**: Understands graph theory (cycle detection)

---

## 4. Acceptance Criteria

### 4.1 Core Functionality
- [ ] `LatchIdentifier` protocol defined in `domain/services/latch_identifier.py`
- [ ] `TopologyBasedLatchIdentifier` implements protocol in `infrastructure/identification/`
- [ ] `DetectionStrategy` enum defined with FEEDBACK_LOOP, EXPLICIT, PIN_SIGNATURE, PATTERN_MATCH, UNKNOWN
- [ ] `SequentialDetectionResult` dataclass with is_sequential, strategy, confidence, reason

### 4.2 Feedback Loop Detection (PRIMARY - Naming Independent)
- [ ] `register_subcircuit_topology()` accepts internal connections as `list[tuple[str, str]]`
- [ ] Detects cycles in connection graph using DFS algorithm
- [ ] Returns confidence = 0.99 for feedback-detected elements (highest)
- [ ] Works regardless of cell type name or pin names
- [ ] Correctly identifies cross-coupled NAND/NOR as sequential
- [ ] Correctly identifies no-feedback cells as combinational

### 4.3 Explicit Annotation
- [ ] `register_sequential_cells()` accepts set of cell type names
- [ ] Returns confidence = 0.95 for explicitly annotated cells
- [ ] Case-insensitive matching by default
- [ ] Supports runtime addition of annotations

### 4.4 Pin Signature Detection (Heuristic)
- [ ] Detects flip-flops by CLK + D + Q pin combination (confidence = 0.80)
- [ ] Detects latches by CLK + Q (no D) combination (confidence = 0.70)
- [ ] Identifies clock pins: CLK, CK, CP, CLOCK, GCLK, PHI (and variants)
- [ ] Identifies data pins: D, Q, QN, DI, DO (and variants)
- [ ] Identifies control pins: SET, RST, EN, G (and variants)
- [ ] Case-insensitive pin name matching by default
- [ ] Pin signature detection is optional (can be disabled)

### 4.5 Pattern Fallback (Lowest Priority)
- [ ] Falls back to pattern matching when topology/annotation/pins inconclusive
- [ ] Default patterns: `*DFF*`, `*LATCH*`, `*FF*`, `*FLOP*`, `*REG*`
- [ ] Pattern fallback has lowest confidence (0.50)
- [ ] Pattern matching can be disabled via configuration

### 4.6 Performance
- [ ] Result caching reduces repeated queries to O(1)
- [ ] Cache key includes both cell_type and pin_names
- [ ] Performance test validates < 200ms overhead for 100K cells
- [ ] Cache can be cleared via `clear_cache()` method
- [ ] Cache invalidation when topology/annotation is registered

### 4.7 Testing
- [ ] Unit tests for feedback loop detection (positive/negative cases)
- [ ] Unit tests for explicit annotation
- [ ] Unit tests for pin signature detection
- [ ] Unit tests for pattern fallback
- [ ] Unit tests for detection priority order
- [ ] Unit tests for caching behavior
- [ ] Unit tests for cache invalidation
- [ ] Integration test showing naming-independent detection
- [ ] 100% test coverage on implementation

---

## 5. Implementation Notes

### 5.1 File Structure
```
src/ink/
├── domain/services/
│   ├── __init__.py
│   └── latch_identifier.py           # Protocol + result types
└── infrastructure/identification/
    ├── __init__.py
    ├── topology_latch_identifier.py  # Main implementation
    └── pin_signatures.py             # Pin pattern constants

tests/
├── unit/domain/services/
│   └── test_latch_identifier.py      # Protocol tests
└── unit/infrastructure/identification/
    ├── test_topology_latch_identifier.py  # Implementation tests
    └── test_pin_signatures.py             # Pin pattern tests
```

### 5.2 Test Cases

**Unit Tests** (`test_topology_latch_identifier.py`):
```python
# ═══════════════════════════════════════════════════════════════════════════
# FEEDBACK LOOP DETECTION (Primary - Naming Independent)
# ═══════════════════════════════════════════════════════════════════════════

def test_detects_cross_coupled_nand_as_sequential():
    """Cross-coupled NANDs detected as sequential via feedback"""

def test_detects_cross_coupled_nor_as_sequential():
    """Cross-coupled NORs detected as sequential via feedback"""

def test_detects_transmission_gate_latch():
    """Transmission gate + inverter feedback detected as sequential"""

def test_detects_tristate_inverter_latch():
    """Tristate inverter feedback loop detected as sequential"""

def test_no_feedback_in_combinational_chain():
    """Linear gate chain has no feedback - detected as combinational"""

def test_feedback_detection_ignores_cell_name():
    """Feedback detection works regardless of cell type name"""

def test_feedback_detection_ignores_pin_names():
    """Feedback detection works regardless of pin names"""

def test_feedback_detection_highest_confidence():
    """Feedback detection returns confidence 0.99"""

# ═══════════════════════════════════════════════════════════════════════════
# EXPLICIT ANNOTATION
# ═══════════════════════════════════════════════════════════════════════════

def test_explicit_annotation_marks_as_sequential():
    """Explicitly registered cells detected as sequential"""

def test_explicit_annotation_case_insensitive():
    """Explicit annotation matching is case-insensitive"""

def test_explicit_annotation_confidence():
    """Explicit annotation returns confidence 0.95"""

def test_multiple_explicit_annotations():
    """Can register multiple cell types as sequential"""

# ═══════════════════════════════════════════════════════════════════════════
# PIN SIGNATURE DETECTION (Heuristic)
# ═══════════════════════════════════════════════════════════════════════════

def test_detects_dff_by_clk_d_q_pins():
    """D flip-flop detected by CLK, D, Q pins"""

def test_detects_latch_by_clk_q_pins():
    """Latch detected by CLK, Q pins (no D)"""

def test_case_insensitive_pin_matching():
    """Pin matching is case-insensitive by default"""

def test_pin_signature_lower_confidence_than_feedback():
    """Pin signature confidence < feedback confidence"""

def test_disable_pin_signature_detection():
    """Pin signature detection can be disabled"""

# ═══════════════════════════════════════════════════════════════════════════
# PATTERN FALLBACK (Lowest Priority)
# ═══════════════════════════════════════════════════════════════════════════

def test_pattern_fallback_when_no_other_detection():
    """Falls back to pattern when other methods don't match"""

def test_pattern_fallback_lowest_confidence():
    """Pattern-based detection has confidence 0.50"""

def test_disable_pattern_fallback():
    """Pattern fallback can be disabled"""

# ═══════════════════════════════════════════════════════════════════════════
# DETECTION PRIORITY ORDER
# ═══════════════════════════════════════════════════════════════════════════

def test_feedback_takes_priority_over_explicit():
    """Feedback detection has higher priority than explicit annotation"""

def test_explicit_takes_priority_over_pin_signature():
    """Explicit annotation has higher priority than pin signature"""

def test_pin_signature_takes_priority_over_pattern():
    """Pin signature has higher priority than pattern matching"""

# ═══════════════════════════════════════════════════════════════════════════
# CACHING
# ═══════════════════════════════════════════════════════════════════════════

def test_caches_detection_results():
    """Results are cached for repeated queries"""

def test_cache_key_includes_cell_type_and_pins():
    """Cache key includes both cell_type and pin_names"""

def test_cache_invalidation_on_topology_registration():
    """Cache is invalidated when topology is registered"""

def test_cache_invalidation_on_explicit_annotation():
    """Cache is invalidated when explicit annotation is added"""

# ═══════════════════════════════════════════════════════════════════════════
# EDGE CASES
# ═══════════════════════════════════════════════════════════════════════════

def test_empty_pins_no_crash():
    """Empty pin set doesn't cause crash"""

def test_empty_topology_no_feedback():
    """Empty topology list returns no feedback"""

def test_combinational_cell_detection():
    """AND, NAND, INV correctly identified as combinational"""

# ═══════════════════════════════════════════════════════════════════════════
# PERFORMANCE
# ═══════════════════════════════════════════════════════════════════════════

def test_performance_100k_cells(benchmark):
    """Benchmark detection for 100K cells < 200ms"""

def test_cached_lookups_are_fast(benchmark):
    """Cached lookups are O(1)"""
```

### 5.3 Integration with Graph Construction

```python
from ink.infrastructure.identification.topology_latch_identifier import (
    TopologyBasedLatchIdentifier
)
from ink.domain.model.cell import Cell

# During CDL parsing
identifier = TopologyBasedLatchIdentifier()

# When creating Cell entities
def create_cell(instance_name: str, cell_type: str, pin_names: set[str]) -> Cell:
    is_seq = identifier.is_sequential(cell_type, pin_names)
    return Cell(
        id=CellId(instance_name),
        name=instance_name,
        cell_type=cell_type,
        pin_ids=[...],
        is_sequential=is_seq,
    )
```

### 5.4 Configuration Integration

```python
from ink.infrastructure.config.latch_config import LatchIdentificationConfig
from ink.infrastructure.identification.topology_latch_identifier import (
    TopologyBasedLatchIdentifier
)

# Load configuration
config = LatchIdentificationConfig.load_from_yaml("config/latch_detection.yaml")

# Create identifier with config
identifier = TopologyBasedLatchIdentifier(
    enable_pin_signature=config.enable_pin_signature,
    enable_feedback_detection=config.enable_feedback_detection,
    enable_pattern_fallback=config.enable_pattern_fallback,
    fallback_patterns=config.fallback_patterns,
    case_sensitive=config.case_sensitive,
)
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task spec creation (name-based) |
| 2025-12-27 | 0.2 | Claude | Major revision: Changed to topology-based detection |
| 2025-12-27 | 0.3 | Claude | Clarified scope: Algorithm-focused (cycle detection). Transistor pattern recognition moved to E01-F04-T04 |
