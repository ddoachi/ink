# Pre-Docs: E01-F04-T01 - Pattern Configuration for Sequential Cell Detection

## 1. Problem & Context

### Clear Problem Statement
Sequential elements (flip-flops, latches) in gate-level netlists have varying naming conventions across different cell libraries. Hard-coding detection patterns would make the system rigid and require code changes for each new library.

**Example Cell Names**:
- Standard Cell Library A: `DFFR_X1`, `DFFR_X2`, `SDFFR_X1`
- Standard Cell Library B: `DFF_1`, `DFF_2`, `SCAN_DFF_1`
- Latch Library: `LATCH_X1`, `DLATCH_X2`

### Business Impact
**Why This Matters**: Latch identification is the foundation for semantic expansion boundaries (P0 MVP feature). Without configurable patterns, the tool would only work with a single cell library, severely limiting adoption.

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| Hard-coded patterns | Tool breaks with new libraries | Every new project |
| Code modification required | Developer intervention needed | Per library change |
| No user customization | Cannot handle custom cell names | Common in ASIC flows |
| Pattern updates need rebuild | Deployment overhead | Every pattern change |

### Success Metrics
- ✅ Support 3+ cell library naming conventions without code changes
- ✅ Pattern updates via configuration file (no rebuild)
- ✅ Case-insensitive matching for robustness
- ✅ Default patterns work for 80%+ of standard libraries

---

## 2. Conceptual Solution

### Core Architecture

```
┌─────────────────────────────────────────────────┐
│         Application Configuration               │
│                                                  │
│  ┌──────────────────────────────────────────┐  │
│  │  config/latch_patterns.yaml              │  │
│  │                                           │  │
│  │  patterns:                                │  │
│  │    - "*DFF*"   ← User editable           │  │
│  │    - "*LATCH*"                            │  │
│  │    - "*FF*"                               │  │
│  └──────────────────────────────────────────┘  │
│                      ↓                           │
│  ┌──────────────────────────────────────────┐  │
│  │  LatchIdentificationConfig (dataclass)   │  │
│  │                                           │  │
│  │  • patterns: List[str]                    │  │
│  │  • case_sensitive: bool                   │  │
│  └──────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
                      ↓
        Used by Latch Detector Service (T02)
```

### Key Concepts Explained

#### Glob-Style Pattern Matching

**Think of it like file matching in a shell**:
- `ls *.txt` matches all text files
- `*DFF*` matches any cell type containing "DFF"

**Pattern Wildcards**:
```
Pattern: "*DFF*"
         ↑    ↑
    matches  matches
   anything anything
    before   after

Matches: DFFR_X1 ✅, SDFFR_X2 ✅, DFF_POS ✅, AND2_X1 ❌
```

**Why Glob Instead of Regex?**
| Aspect | Glob | Regex |
|--------|------|-------|
| User-friendliness | Easy for non-programmers | Complex syntax |
| Common use | File patterns (`*.txt`) | Text parsing |
| Error-prone | Low risk | High risk (syntax errors) |
| Performance | Fast | Slower (compilation) |

#### Configuration as Data, Not Code

**Before (Hard-coded)**:
```python
# Requires code change and rebuild
def is_sequential(cell_type):
    return "DFF" in cell_type or "LATCH" in cell_type
```

**After (Configurable)**:
```yaml
# Edit and reload, no rebuild
patterns:
  - "*DFF*"
  - "*LATCH*"
```

**Benefit**: Field engineers can adapt to new libraries without developer support.

### Component Interactions

```
Startup Sequence:
┌──────────────┐
│ Application  │
│   Starts     │
└──────┬───────┘
       ↓
┌──────────────────────────────┐
│ Load Configuration           │
│                              │
│ 1. Check config file exists  │
│ 2. Parse YAML                │
│ 3. Validate patterns         │
│ 4. Create config object      │
└──────┬───────────────────────┘
       ↓
┌──────────────────────────────┐
│ Inject into Services         │
│                              │
│ LatchDetector ← Config       │
└──────────────────────────────┘
```

**Error Recovery**:
```
File Loading:
  ┌─────────────┐
  │ Read YAML   │
  └──────┬──────┘
         ├─ Success → Use patterns
         ├─ Missing → Use defaults (log warning)
         └─ Invalid → Use defaults (log error)
```

---

## 3. Technical Approach

### Strategy: Layered Configuration

**Three-Tier Fallback**:
```
1. User-provided YAML file
   ↓ (if missing)
2. Default YAML in config/
   ↓ (if corrupted)
3. Hard-coded defaults in code
```

### Pseudocode

```
DEFINE default patterns:
  patterns = ["*DFF*", "*LATCH*", "*FF*"]

FUNCTION load_configuration(file_path):
  IF file does NOT exist:
    LOG warning: "Config file missing, using defaults"
    RETURN default_config()

  TRY:
    data = parse_yaml(file_path)
    patterns = extract(data, "latch_identification.patterns")
    case_sensitive = extract(data, "latch_identification.case_sensitive", default=False)

    IF patterns is EMPTY:
      LOG warning: "Empty patterns, using defaults"
      patterns = default_patterns

    RETURN new Config(patterns, case_sensitive)

  CATCH parse_error:
    LOG error: "Invalid YAML format, using defaults"
    RETURN default_config()
```

### Design Decisions

#### Decision 1: YAML vs JSON vs Python Config

| Format | Chosen | Why |
|--------|--------|-----|
| **YAML** | ✅ Yes | Human-readable, supports comments, standard in DevOps |
| JSON | ❌ No | No comments, harder to edit manually |
| Python (.py) | ❌ No | Security risk (arbitrary code execution) |

**Detailed Reasoning**:

YAML was chosen because field engineers and designers (non-programmers) frequently need to customize patterns for proprietary cell libraries. YAML's readability and comment support enable self-documenting configuration:

```yaml
# Standard DFF flip-flops (most common)
- "*DFF*"

# Latch elements (less common but critical)
- "*LATCH*"

# Generic fallback (may have false positives - use with care)
- "*FF*"
```

**Real-World Example**: An ASIC verification team discovered their library uses `REGF_X1` for flip-flops. They can simply add `- "*REGF*"` without needing developer support.

**Trade-offs**:
- **Gain**: Accessibility for non-programmers, inline documentation via comments
- **Lose**: Slightly slower parsing than JSON (negligible for small config)
- **Risk Mitigation**: YAML parsing errors fallback to defaults + clear error messages

**Alternatives Rejected**:
- **JSON**: No inline comments would force separate documentation. Editing JSON manually is error-prone (trailing commas, quote escaping).
- **Python Config**: Opens security vulnerability (arbitrary code execution if config file is compromised). Requires Python knowledge to modify.

#### Decision 2: Glob Patterns vs Regex

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Glob** | ✅ Yes | Familiar to users (`*.txt` file patterns) |
| Regex | ❌ No | Too complex for cell name matching |

**Detailed Reasoning**:

Glob patterns (`*DFF*`) are universally understood by anyone who has used a file manager or command line. Sequential cell naming follows simple conventions that don't require regex power:

**Problem vs Solution Example**:

```
Problem: Match all DFF variants
  DFFR_X1, SDFFR_X2, DFF_POS, DFFQ_X1

Glob Solution: *DFF*
  ↑ Simple, obvious, hard to get wrong

Regex Solution: .*DFF.*
  ↑ Same result but requires regex knowledge
```

**Concrete Scenario**: A hardware engineer (not a programmer) needs to add support for `JKFF_X1` (JK flip-flops). With glob, they instantly know to use `*JKFF*`. With regex, they might struggle with escaping or anchors.

**Trade-offs**:
- **Gain**: Zero learning curve, self-documenting patterns
- **Lose**: Cannot express complex patterns (e.g., "DFF at word boundary only")
- **Why This Is OK**: Cell library naming is simple and consistent. If complex patterns are ever needed (P1+), we can add regex as an opt-in advanced feature.

**Alternatives Rejected**:
- **Regex Only**: Overkill for the problem domain. Would require documentation and increase error rate.
- **Exact Matching**: Too rigid, would need hundreds of entries for library variants.

#### Decision 3: Case-Insensitive by Default

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Case-Insensitive** | ✅ Yes | Cell libraries are inconsistent with casing |
| Case-Sensitive | ❌ No | Would require duplicate patterns |

**Detailed Reasoning**:

Cell libraries exhibit inconsistent casing conventions:
- Vendor A: `DFFR_X1` (uppercase)
- Vendor B: `dffr_x1` (lowercase)
- Vendor C: `Dffr_X1` (mixed case)

Case-insensitive matching prevents pattern explosion:

**Before (Case-Sensitive)**:
```yaml
patterns:
  - "*DFF*"
  - "*dff*"
  - "*Dff*"
  - "*dFf*"  # Combinatorial explosion!
```

**After (Case-Insensitive)**:
```yaml
patterns:
  - "*DFF*"  # Matches all variants
```

**Real Example**: A design team imported a netlist with lowercase cell names (`dffr_x1`) from a third-party IP. Without case-insensitive matching, all latches would be missed, breaking semantic expansion.

**Trade-offs**:
- **Gain**: Robustness across vendor libraries, simpler configuration
- **Lose**: Cannot distinguish `DFF` from `dff` (not a real-world requirement)
- **Configurability**: `case_sensitive: true` flag available if needed (future edge case)

**Alternative Rejected**:
- **Case-Sensitive Default**: Would cause silent failures when netlists use different casing. Users would waste time debugging pattern mismatches.

#### Decision 4: Immutable Configuration Object

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Frozen Dataclass** | ✅ Yes | Prevents runtime modification bugs |
| Mutable Class | ❌ No | Allows accidental state changes |

**Detailed Reasoning**:

Configuration should be loaded once at startup and remain constant during operation. Using `@dataclass(frozen=True)` prevents accidental modification:

**Problem Prevented**:
```python
# Without frozen=True, this bug could happen:
config.patterns.append("*BUG*")  # Oops! Unintended side effect
```

**Solution Example**:
```python
@dataclass(frozen=True)
class LatchIdentificationConfig:
    patterns: List[str]  # Immutable reference
```

**Trade-offs**:
- **Gain**: Thread-safe, predictable behavior, easier testing
- **Lose**: Cannot hot-reload patterns without restarting (acceptable for MVP)
- **Future**: P1 feature could add explicit `reload_config()` method

**Alternative Rejected**:
- **Mutable Config**: Opens door to bugs where config state changes during graph construction, leading to inconsistent latch detection.

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Core Infrastructure (Day 1)
├─ Define LatchIdentificationConfig dataclass
├─ Implement load_from_yaml() with error handling
└─ Create default_config() factory

Phase 2: File Management (Day 1)
├─ Create config/latch_patterns.yaml template
├─ Add validation for empty/invalid patterns
└─ Implement fallback logic

Phase 3: Testing (Day 2)
├─ Unit tests for config loading
├─ Error handling tests (missing file, invalid YAML)
└─ Edge case tests (empty patterns, malformed data)

Phase 4: Integration (Day 2)
└─ Wire into application startup sequence
```

### Integration Points

```
Application Startup:
┌──────────────────┐
│  main.py         │
│                  │
│  config = load() │ ← Load once at startup
└────────┬─────────┘
         ↓
┌──────────────────────────────┐
│ Dependency Injection         │
│                              │
│ detector = LatchDetector(    │
│     config=config            │ ← Pass to services
│ )                            │
└──────────────────────────────┘
```

**File Locations**:
```
ink/
├── config/
│   └── latch_patterns.yaml        ← User-editable config
│
└── src/ink/infrastructure/config/
    └── latch_config.py             ← Loader implementation
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|--------|---------------------|
| Missing config file | Medium | Low | Fallback to defaults + warning log |
| Invalid YAML syntax | Medium | Low | Catch exception, use defaults + error log |
| Empty patterns list | Low | Medium | Validate and replace with defaults |
| Wrong file permissions | Low | Low | Clear error message with file path |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: Default Usage**
```
GIVEN fresh installation
WHEN application starts
THEN use default patterns (*DFF*, *LATCH*, *FF*)
```

**Story 2: Custom Library**
```
GIVEN engineer has custom library with REGF_X1 flip-flops
WHEN they edit config/latch_patterns.yaml to add "*REGF*"
AND restart application
THEN REGF_X1 cells are detected as sequential
```

**Story 3: Corrupted Config**
```
GIVEN config file has invalid YAML syntax
WHEN application loads
THEN log error message with file path
AND use default patterns (graceful degradation)
AND application continues running normally
```

### Edge Cases

| Case | Behavior |
|------|----------|
| Empty patterns list | Replace with defaults + warning |
| Patterns with only whitespace | Treat as empty, use defaults |
| Duplicate patterns | Keep duplicates (harmless, minor performance hit) |
| Config file is directory | Log error, use defaults |
| No read permissions | Log error with permissions hint, use defaults |

### Performance Expectations

**Config Loading Budget**:
```
Total Startup Overhead: < 10ms

├─ YAML File I/O:     ~5ms   (small file, OS cached)
├─ YAML Parsing:      ~3ms   (simple structure)
└─ Object Creation:   ~1ms   (dataclass instantiation)
```

**Memory Footprint**:
```
LatchIdentificationConfig:
  patterns: List[str]        ~100 bytes (3 patterns × ~30 chars)
  case_sensitive: bool       1 byte
  ──────────────────────────────────
  Total per instance:        ~101 bytes (negligible)
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
         /\
        /  \          E2E: Full app loads config
       /────\
      /      \        Integration: Config → Detector Service
     /────────\
    /          \      Unit: Config loading, error handling
   /────────────\
  /______________\
```

### Key Scenarios

**Happy Path Tests**:
- ✅ Load valid YAML file with patterns
- ✅ Create config from default factory
- ✅ Parse patterns with various wildcard formats
- ✅ Handle case-sensitive flag correctly

**Error Handling Tests**:
- ✅ Missing config file returns defaults + logs warning
- ✅ Invalid YAML syntax returns defaults + logs error
- ✅ Empty patterns list replaced with defaults
- ✅ File permission errors handled gracefully

**Edge Case Tests**:
- ✅ YAML with comments and whitespace
- ✅ Unicode characters in patterns (international libraries)
- ✅ Very long pattern strings (stress test)
- ✅ Config file path with spaces/special chars

### Validation Approach

**Conceptual Test Flow**:
```
1. Setup: Create temp config file
2. Act: Load configuration
3. Assert: Patterns match expected
4. Verify: Logging occurred (if error case)
5. Cleanup: Remove temp files
```

**Logging Verification**:
```
WHEN error occurs:
  CAPTURE log output
  ASSERT contains error message
  ASSERT contains file path
  ASSERT contains recommended action
```

---

## Summary

This configuration system provides a **simple, robust foundation** for latch detection:

- ✅ **User-Friendly**: Edit YAML file, no code changes
- ✅ **Safe**: Immutable config, error handling, defaults
- ✅ **Flexible**: Supports any cell library naming convention
- ✅ **Fast**: < 10ms startup overhead, negligible memory

**Next Step**: Use this configuration in the Latch Detector Service (T02) to perform pattern matching against cell types during graph construction.
