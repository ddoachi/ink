# Spec: E01-F04 - Latch Identification

## Metadata
- **ID**: E01-F04
- **Type**: Feature
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E01](../E01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**:
- **Actual Hours**:
- **Effort**:
- **Tags**: []

---

## 1. Overview

### 1.1 Problem Statement
During incremental schematic expansion, engineers need to stop at meaningful semantic boundaries rather than arbitrary hop counts. Sequential elements (latches, flip-flops) represent natural boundaries in circuit logic, separating combinational logic stages. Identifying these elements automatically enables semantic boundary-based expansion (P1 feature) and helps users understand circuit structure.

### 1.2 Goals
- Identify sequential elements (latches, flip-flops) based on configurable cell type naming patterns
- Tag sequential cells in the graph model for use by expansion logic
- Provide API to query if a cell is a sequential element
- Support configurable patterns to accommodate different cell libraries
- Enable future semantic boundary expansion features

---

## 2. User Stories

### US-E01-04: Identify Sequential Elements
**As a** circuit designer
**I want to** latches and flip-flops automatically identified
**So that** expansion can stop at sequential boundaries

**Acceptance Criteria:**
- [ ] Configurable naming patterns for latch detection (e.g., `*LATCH*`, `*DFF*`, `*FF*`)
- [ ] Sequential cells are tagged in the graph model
- [ ] API to query if a cell is a sequential element

---

## 3. Technical Requirements

### 3.1 Latch/Flip-Flop Definition

From PRD ยง3.3:

> A latch is a level-sensitive sequential storage element that captures and holds a logic value while an enable signal is asserted.

**Sequential Elements Include**:
- **D Flip-Flops** (DFF): Edge-triggered (rising/falling)
- **D Latches**: Level-sensitive
- **Scan Flip-Flops** (SDFF): Flip-flops with scan input
- **Other Sequential Cells**: JK flip-flops, T flip-flops, SR latches (less common)

### 3.2 Identification Strategy

**Pattern-Based Matching** on cell type names:

Default patterns:
```python
DEFAULT_SEQUENTIAL_PATTERNS = [
    "*DFF*",      # D flip-flops (DFFR_X1, SDFFR_X2, etc.)
    "*LATCH*",    # D latches (LATCH_X1, DLATCH_X2, etc.)
    "*FF*",       # Generic flip-flops (FF_X1, SRLATCH, etc.)
]
```

**Matching Logic**:
- Use glob-style wildcard matching (`fnmatch` or regex)
- Case-insensitive matching
- Match against `cell_type` field (e.g., "DFFR_X1")

### 3.3 Configuration

**Location**: Application configuration (e.g., `config.yaml` or settings dialog)

```yaml
latch_identification:
  patterns:
    - "*DFF*"
    - "*LATCH*"
    - "*FF*"
  case_sensitive: false
```

### 3.4 Architecture

**Location**: `src/ink/domain/services/latch_identifier.py`

**Domain Service Interface**:
```python
from typing import Protocol, List

class LatchIdentifier(Protocol):
    """Domain service for identifying sequential elements"""

    def is_sequential(self, cell_type: str) -> bool:
        """Check if cell type is a sequential element"""
        pass

    def configure_patterns(self, patterns: List[str]) -> None:
        """Configure cell type patterns for sequential detection"""
        pass
```

**Implementation** (Infrastructure Layer):
```python
class PatternBasedLatchIdentifier:
    """Pattern-based latch/FF identification"""

    def __init__(self, patterns: List[str] = None):
        self.patterns = patterns or DEFAULT_SEQUENTIAL_PATTERNS

    def is_sequential(self, cell_type: str) -> bool:
        """Match cell type against patterns"""
        for pattern in self.patterns:
            if fnmatch.fnmatch(cell_type.upper(), pattern.upper()):
                return True
        return False

    def configure_patterns(self, patterns: List[str]) -> None:
        """Update patterns"""
        self.patterns = patterns
```

### 3.5 Graph Integration

During graph construction (E01-F03), apply latch identification:

```python
def add_cell(self, cell: Cell) -> None:
    """Add cell node to graph"""
    # Identify if cell is sequential
    cell.is_sequential = self.latch_identifier.is_sequential(cell.cell_type)

    # Add to graph
    self.graph.add_node(cell.id, **cell.to_dict())
    self._cell_index[cell.name] = cell.id
```

### 3.6 Query API

**Cell Entity**:
```python
@dataclass
class Cell:
    name: str
    cell_type: str
    pins: List[Pin]
    is_sequential: bool  # Set by latch identifier
```

**Graph Query**:
```python
def is_sequential_cell(self, cell_id: CellId) -> bool:
    """Check if cell is a sequential element"""
    return self.graph.nodes[cell_id]['is_sequential']

def get_sequential_cells(self) -> List[Cell]:
    """Get all sequential cells in design"""
    return [
        self._get_cell(node_id)
        for node_id, data in self.graph.nodes(data=True)
        if data.get('is_sequential', False)
    ]
```

---

## 4. Dependencies

- **Upstream**:
  - E01-F01 (CDL Parser) - provides cell type names
  - E01-F03 (Graph Construction) - applies latch tags to cells
- **Downstream**:
  - E03 (Incremental Expansion) - uses `is_sequential` flag for semantic boundaries (P1)
  - E04 (Object Interaction) - may highlight sequential cells differently

---

## 5. Acceptance Criteria

- [ ] Configurable naming patterns for latch/FF detection (e.g., `*LATCH*`, `*DFF*`, `*FF*`)
- [ ] Pattern matching is case-insensitive
- [ ] Sequential cells are tagged with `is_sequential=True` in graph
- [ ] API to query if a cell is sequential by cell ID
- [ ] API to get all sequential cells in design
- [ ] Default patterns detect common cell types (DFFR_X1, LATCH_X1, SDFF_X2)
- [ ] User can configure patterns via settings (P1 feature dependency)
- [ ] Latch identification applied during graph construction
- [ ] 90%+ test coverage on latch identifier module

---

## 6. Child Specs

| ID | Task | Status |
|----|------|--------|
| [E01-F04-T01](T01/E01-F04-T01.spec.md) | Pattern Configuration for Sequential Cell Detection | Draft |
| [E01-F04-T02](T02/E01-F04-T02.spec.md) | Latch Detector Service | Draft |
| [E01-F04-T03](T03/E01-F04-T03.spec.md) | Cell Tagging with Sequential Flag | Draft |

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial feature creation from E01 split |
