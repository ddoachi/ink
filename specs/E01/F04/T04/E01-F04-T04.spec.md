---
id: E01-F04-T04
title: Transistor Topology Analyzer
type: Task
priority: P0 (MVP)
status: Completed
parent: E01-F04
created: 2025-12-27
completed: 2025-12-27
estimated_hours: 12
actual_hours: 4
effort: High
tags:
  - infrastructure
  - transistor-analysis
  - topology-extraction
clickup_task_id: '86evzv7ze'
---

# Spec: E01-F04-T04 - Transistor Topology Analyzer

## 1. Overview

### 1.1 Problem Statement
Gate-level CDL netlists contain standard cell definitions at the **transistor level**. To detect sequential elements (latches, flip-flops) by topology, we need to extract a **signal flow graph** from transistor-level subcircuit definitions.

This task bridges the gap between:
- **CDL Parser (E01-F02)**: Produces `SubcircuitDefinition` with transistor instances
- **Latch Identifier (E01-F04-T02)**: Consumes `internal_connections` for cycle detection

### 1.2 Goals
- Define `TopologyAnalyzer` protocol (infrastructure service interface)
- Implement `TransistorTopologyAnalyzer` that extracts signal flow from transistors
- Recognize common transistor patterns: inverter, transmission gate, NAND, NOR
- Handle both PMOS and NMOS transistors
- Extract directed connection graph for feedback detection
- Support hierarchical subcircuits (cells instantiating other cells)

### 1.3 Data Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           Pipeline                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  CDL File          CDL Parser         Topology Analyzer   Latch ID      │
│                    (E01-F02)          (E01-F04-T04)       (E01-F04-T02) │
│                                                                         │
│  .SUBCKT DFF  ───> SubcircuitDef ───> [(from, to), ...] ───> is_seq?   │
│  M1 n1 D ...       transistors[]      signal_flow_graph     True/False │
│  M2 n1 D ...       instances[]                                         │
│  .ENDS                                                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 2. Technical Requirements

### 2.1 Infrastructure Service Protocol

**Location**: `src/ink/infrastructure/analysis/topology_analyzer.py`

```python
from typing import Protocol
from dataclasses import dataclass

@dataclass
class TransistorInstance:
    """Represents a transistor in a subcircuit."""
    name: str           # Instance name (e.g., "M1")
    type: str           # "PMOS" or "NMOS"
    drain: str          # Drain node
    gate: str           # Gate node
    source: str         # Source node
    bulk: str           # Bulk/body node

@dataclass
class CellInstance:
    """Represents a subcircuit instance within another subcircuit."""
    name: str           # Instance name (e.g., "XI1")
    cell_type: str      # Subcircuit type (e.g., "INV_X1")
    connections: dict[str, str]  # pin_name -> net_name

@dataclass
class SubcircuitDefinition:
    """Parsed subcircuit from CDL."""
    name: str                           # Subcircuit name
    ports: list[str]                    # External ports (e.g., ["D", "Q", "CLK", "VDD", "VSS"])
    transistors: list[TransistorInstance]
    instances: list[CellInstance]       # Sub-cell instances (hierarchical)

@dataclass
class SignalFlowGraph:
    """Extracted signal flow from a subcircuit."""
    cell_type: str
    connections: list[tuple[str, str]]  # [(from_node, to_node), ...]
    identified_structures: list[str]    # ["inverter@n1->n2", "tgate@n3<->n4", ...]

class TopologyAnalyzer(Protocol):
    """Infrastructure service for extracting signal flow from subcircuits."""

    def analyze(self, subcircuit: SubcircuitDefinition) -> SignalFlowGraph:
        """
        Extract signal flow graph from subcircuit definition.

        Args:
            subcircuit: Parsed subcircuit with transistors and instances

        Returns:
            SignalFlowGraph with directed connections for cycle detection
        """
        ...

    def register_cell_pinout(self, cell_type: str, input_pins: set[str], output_pins: set[str]) -> None:
        """
        Register pin directions for a known cell type.
        Required for hierarchical analysis.

        Args:
            cell_type: Cell type name (e.g., "INV_X1")
            input_pins: Set of input pin names (e.g., {"A"})
            output_pins: Set of output pin names (e.g., {"Y"})
        """
        ...
```

### 2.2 Transistor Pattern Recognition

**Location**: `src/ink/infrastructure/analysis/transistor_patterns.py`

```python
from dataclasses import dataclass
from enum import Enum

class StructureType(Enum):
    """Types of recognized transistor structures."""
    INVERTER = "inverter"
    TRANSMISSION_GATE = "tgate"
    NAND = "nand"
    NOR = "nor"
    PASS_TRANSISTOR = "pass"
    UNKNOWN = "unknown"

@dataclass
class RecognizedStructure:
    """A recognized transistor pattern."""
    type: StructureType
    input_nodes: set[str]
    output_nodes: set[str]
    control_nodes: set[str]  # For TG: clock nodes
    transistors: list[str]   # Transistor names involved

class TransistorPatternRecognizer:
    """Recognizes common transistor patterns."""

    def find_inverters(
        self, transistors: list[TransistorInstance], vdd: str, vss: str
    ) -> list[RecognizedStructure]:
        """
        Find complementary PMOS/NMOS pairs forming inverters.

        Pattern:
        - PMOS: source=VDD, drain=output, gate=input
        - NMOS: source=VSS, drain=output, gate=input
        - Same gate (input) and same drain (output)
        """
        ...

    def find_transmission_gates(
        self, transistors: list[TransistorInstance]
    ) -> list[RecognizedStructure]:
        """
        Find PMOS/NMOS pairs forming transmission gates.

        Pattern:
        - PMOS and NMOS with same source and drain (bidirectional)
        - Gates are complementary clocks (CLK, CLK_B)
        """
        ...

    def find_nand_gates(
        self, transistors: list[TransistorInstance], vdd: str, vss: str
    ) -> list[RecognizedStructure]:
        """
        Find NAND gate structures.

        Pattern:
        - Parallel PMOS pull-up network
        - Series NMOS pull-down network
        """
        ...

    def find_nor_gates(
        self, transistors: list[TransistorInstance], vdd: str, vss: str
    ) -> list[RecognizedStructure]:
        """
        Find NOR gate structures.

        Pattern:
        - Series PMOS pull-up network
        - Parallel NMOS pull-down network
        """
        ...
```

### 2.3 Implementation

**Location**: `src/ink/infrastructure/analysis/transistor_topology_analyzer.py`

```python
class TransistorTopologyAnalyzer:
    """Extracts signal flow graph from transistor-level subcircuits."""

    def __init__(self, vdd_names: set[str] = None, vss_names: set[str] = None):
        """
        Initialize analyzer.

        Args:
            vdd_names: Power supply net names (default: {"VDD", "VDDX", "VCC"})
            vss_names: Ground net names (default: {"VSS", "VSSX", "GND"})
        """
        self._vdd_names = vdd_names or {"VDD", "VDDX", "VCC", "VPWR"}
        self._vss_names = vss_names or {"VSS", "VSSX", "GND", "VGND"}
        self._cell_pinouts: dict[str, tuple[set[str], set[str]]] = {}
        self._pattern_recognizer = TransistorPatternRecognizer()

    def analyze(self, subcircuit: SubcircuitDefinition) -> SignalFlowGraph:
        """Extract signal flow from subcircuit."""
        connections: list[tuple[str, str]] = []
        structures: list[str] = []

        # Identify power/ground nets
        vdd, vss = self._identify_power_nets(subcircuit)

        # Step 1: Find inverters
        inverters = self._pattern_recognizer.find_inverters(
            subcircuit.transistors, vdd, vss
        )
        for inv in inverters:
            for inp in inv.input_nodes:
                for out in inv.output_nodes:
                    connections.append((inp, out))
            structures.append(f"inverter@{inv.input_nodes}->{inv.output_nodes}")

        # Step 2: Find transmission gates
        tgates = self._pattern_recognizer.find_transmission_gates(subcircuit.transistors)
        for tg in tgates:
            # Bidirectional - add both directions
            nodes = list(tg.input_nodes | tg.output_nodes)
            if len(nodes) == 2:
                connections.append((nodes[0], nodes[1]))
                connections.append((nodes[1], nodes[0]))
            structures.append(f"tgate@{nodes}")

        # Step 3: Find NAND/NOR gates
        nands = self._pattern_recognizer.find_nand_gates(
            subcircuit.transistors, vdd, vss
        )
        for nand in nands:
            for inp in nand.input_nodes:
                for out in nand.output_nodes:
                    connections.append((inp, out))
            structures.append(f"nand@{nand.input_nodes}->{nand.output_nodes}")

        nors = self._pattern_recognizer.find_nor_gates(
            subcircuit.transistors, vdd, vss
        )
        for nor in nors:
            for inp in nor.input_nodes:
                for out in nor.output_nodes:
                    connections.append((inp, out))
            structures.append(f"nor@{nor.input_nodes}->{nor.output_nodes}")

        # Step 4: Handle hierarchical instances
        for instance in subcircuit.instances:
            inst_connections = self._analyze_instance(instance)
            connections.extend(inst_connections)

        return SignalFlowGraph(
            cell_type=subcircuit.name,
            connections=connections,
            identified_structures=structures,
        )

    def register_cell_pinout(
        self, cell_type: str, input_pins: set[str], output_pins: set[str]
    ) -> None:
        """Register known cell pinout for hierarchical analysis."""
        self._cell_pinouts[cell_type.upper()] = (input_pins, output_pins)

    def _analyze_instance(self, instance: CellInstance) -> list[tuple[str, str]]:
        """Extract connections from a subcircuit instance."""
        cell_key = instance.cell_type.upper()
        if cell_key not in self._cell_pinouts:
            return []  # Unknown cell - skip

        input_pins, output_pins = self._cell_pinouts[cell_key]
        connections = []

        # Map: input_net -> output_net
        input_nets = [instance.connections[p] for p in input_pins if p in instance.connections]
        output_nets = [instance.connections[p] for p in output_pins if p in instance.connections]

        for inp in input_nets:
            for out in output_nets:
                connections.append((inp, out))

        return connections

    def _identify_power_nets(self, subcircuit: SubcircuitDefinition) -> tuple[str, str]:
        """Identify VDD and VSS nets in subcircuit."""
        vdd = next((p for p in subcircuit.ports if p.upper() in self._vdd_names), "VDD")
        vss = next((p for p in subcircuit.ports if p.upper() in self._vss_names), "VSS")
        return vdd, vss
```

### 2.4 Transistor Pattern Details

**Inverter Recognition**:
```
┌─────────────────────────────────────────────────────────────────────────┐
│  CMOS Inverter Pattern                                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│         VDD                                                             │
│          │                                                              │
│     ┌────┴────┐                                                         │
│     │  PMOS   │  source=VDD, gate=A, drain=Y                            │
│     └────┬────┘                                                         │
│  A ──────┼───────> Y                                                    │
│     ┌────┴────┐                                                         │
│     │  NMOS   │  source=VSS, gate=A, drain=Y                            │
│     └────┬────┘                                                         │
│          │                                                              │
│         VSS                                                             │
│                                                                         │
│  Detection criteria:                                                    │
│  1. PMOS.source connects to VDD                                         │
│  2. NMOS.source connects to VSS                                         │
│  3. PMOS.gate == NMOS.gate (input)                                      │
│  4. PMOS.drain == NMOS.drain (output)                                   │
│                                                                         │
│  Signal flow: gate → drain (A → Y)                                      │
└─────────────────────────────────────────────────────────────────────────┘
```

**Transmission Gate Recognition**:
```
┌─────────────────────────────────────────────────────────────────────────┐
│  CMOS Transmission Gate Pattern                                         │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│          CLK                                                            │
│           │                                                             │
│     ┌─────┴─────┐                                                       │
│  A ─┤   NMOS    ├─ B    source/drain = A, B (interchangeable)           │
│     └───────────┘       gate = CLK                                      │
│     ┌───────────┐                                                       │
│  A ─┤   PMOS    ├─ B    source/drain = A, B (interchangeable)           │
│     └─────┬─────┘       gate = CLK_B                                    │
│           │                                                             │
│         CLK_B                                                           │
│                                                                         │
│  Detection criteria:                                                    │
│  1. PMOS and NMOS with same source/drain pair                           │
│  2. Gates are different (complementary clocks)                          │
│  3. Neither source/drain is VDD/VSS                                     │
│                                                                         │
│  Signal flow: Bidirectional (A ↔ B)                                     │
└─────────────────────────────────────────────────────────────────────────┘
```

**NAND2 Recognition**:
```
┌─────────────────────────────────────────────────────────────────────────┐
│  CMOS NAND2 Pattern                                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│         VDD ────┬────────┐                                              │
│                 │        │                                              │
│            ┌────┴────┐ ┌─┴──────┐                                       │
│      A ────┤  PMOS   │ │  PMOS  │──── B   (Parallel pull-up)            │
│            └────┬────┘ └────┬───┘                                       │
│                 └─────┬─────┘                                           │
│                       │                                                 │
│                       Y (output)                                        │
│                       │                                                 │
│                 ┌─────┴─────┐                                           │
│      A ────────>│   NMOS    │                 (Series pull-down)        │
│                 └─────┬─────┘                                           │
│                 ┌─────┴─────┐                                           │
│      B ────────>│   NMOS    │                                           │
│                 └─────┬─────┘                                           │
│                       │                                                 │
│                      VSS                                                │
│                                                                         │
│  Signal flow: A → Y, B → Y                                              │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.5 Examples

```python
analyzer = TransistorTopologyAnalyzer()

# Register known primitive cells for hierarchical analysis
analyzer.register_cell_pinout("INV_X1", input_pins={"A"}, output_pins={"Y"})
analyzer.register_cell_pinout("NAND2_X1", input_pins={"A", "B"}, output_pins={"Y"})

# Example: Analyze a D-latch subcircuit
subckt = SubcircuitDefinition(
    name="DLATCH_X1",
    ports=["D", "G", "Q", "QN", "VDD", "VSS"],
    transistors=[
        # Transmission gate (data input)
        TransistorInstance("M1", "NMOS", drain="n1", gate="G", source="D", bulk="VSS"),
        TransistorInstance("M2", "PMOS", drain="n1", gate="GN", source="D", bulk="VDD"),
        # Inverter 1
        TransistorInstance("M3", "PMOS", drain="Q", gate="n1", source="VDD", bulk="VDD"),
        TransistorInstance("M4", "NMOS", drain="Q", gate="n1", source="VSS", bulk="VSS"),
        # Inverter 2 (feedback)
        TransistorInstance("M5", "PMOS", drain="n2", gate="Q", source="VDD", bulk="VDD"),
        TransistorInstance("M6", "NMOS", drain="n2", gate="Q", source="VSS", bulk="VSS"),
        # Feedback transmission gate
        TransistorInstance("M7", "NMOS", drain="n1", gate="GN", source="n2", bulk="VSS"),
        TransistorInstance("M8", "PMOS", drain="n1", gate="G", source="n2", bulk="VDD"),
        # Output inverter for QN
        TransistorInstance("M9", "PMOS", drain="QN", gate="Q", source="VDD", bulk="VDD"),
        TransistorInstance("M10", "NMOS", drain="QN", gate="Q", source="VSS", bulk="VSS"),
    ],
    instances=[],
)

result = analyzer.analyze(subckt)

# Result:
# SignalFlowGraph(
#     cell_type="DLATCH_X1",
#     connections=[
#         ("D", "n1"), ("n1", "D"),     # TG1 (bidirectional)
#         ("n1", "Q"),                   # INV1
#         ("Q", "n2"),                   # INV2
#         ("n2", "n1"), ("n1", "n2"),   # TG2 (feedback, bidirectional)
#         ("Q", "QN"),                   # INV3
#     ],
#     identified_structures=[
#         "tgate@['D', 'n1']",
#         "inverter@{'n1'}->{'Q'}",
#         "inverter@{'Q'}->{'n2'}",
#         "tgate@['n2', 'n1']",
#         "inverter@{'Q'}->{'QN'}",
#     ]
# )

# Feed to Latch Identifier (E01-F04-T02)
from ink.infrastructure.identification.topology_latch_identifier import (
    TopologyBasedLatchIdentifier
)

identifier = TopologyBasedLatchIdentifier()
identifier.register_subcircuit_topology("DLATCH_X1", result.connections)

assert identifier.is_sequential("DLATCH_X1") == True  # Feedback detected!
```

### 2.6 Performance Considerations

**Optimization Strategy**:
1. **Pattern caching**: Cache recognized structures per subcircuit
2. **Lazy analysis**: Only analyze when `analyze()` is called
3. **Efficient matching**: Group transistors by gate/drain for O(n) pattern matching

**Expected Performance**:
- **Pattern recognition**: O(n²) worst case, O(n) typical for well-structured cells
- **Memory**: O(t) where t = number of transistors
- **Typical cell**: < 1ms for 20-50 transistor cells

---

## 3. Dependencies

- **Upstream**:
  - E01-F02 (CDL Parser) - provides `SubcircuitDefinition`
- **Downstream**:
  - E01-F04-T02 (Latch Identifier) - consumes `internal_connections`
  - E01-F03 (Graph Construction) - may use for cell classification

---

## 4. Acceptance Criteria

### 4.1 Core Functionality
- [x] `TopologyAnalyzer` protocol defined
- [x] `TransistorTopologyAnalyzer` implements protocol
- [x] `TransistorPatternRecognizer` identifies transistor structures
- [x] `SignalFlowGraph` dataclass with connections and identified structures

### 4.2 Inverter Recognition
- [x] Detects complementary PMOS/NMOS pairs as inverters
- [x] Correctly identifies input (gate) and output (drain) nodes
- [x] Handles different VDD/VSS naming conventions
- [x] Ignores transistors not forming valid inverter structure

### 4.3 Transmission Gate Recognition
- [x] Detects PMOS/NMOS pairs with shared source/drain
- [x] Marks signal flow as bidirectional
- [x] Identifies control nodes (CLK, CLK_B)
- [x] Distinguishes from inverters (no VDD/VSS connection)

### 4.4 NAND/NOR Recognition
- [x] Detects parallel PMOS + series NMOS as NAND
- [x] Detects series PMOS + parallel NMOS as NOR
- [x] Handles multi-input gates (NAND3, NOR4, etc.)
- [x] Correctly maps all inputs to output

### 4.5 Hierarchical Analysis
- [x] `register_cell_pinout()` accepts cell pin definitions
- [x] Analyzes subcircuit instances using registered pinouts
- [x] Gracefully handles unknown cell types (skip with warning)

### 4.6 Integration
- [x] Output format compatible with E01-F04-T02 `register_subcircuit_topology()`
- [x] Works with CDL Parser output format

### 4.7 Testing
- [x] Unit tests for inverter pattern recognition
- [x] Unit tests for transmission gate recognition
- [x] Unit tests for NAND/NOR recognition
- [x] Unit tests for D-latch analysis (SR latch structure)
- [x] Unit tests for D-FF analysis (master-slave structure)
- [x] Integration test with E01-F04-T02
- [x] 100% test coverage on implementation

---

## 5. Implementation Notes

### 5.1 File Structure
```
src/ink/
└── infrastructure/analysis/
    ├── __init__.py
    ├── topology_analyzer.py           # Protocol + data classes
    ├── transistor_patterns.py         # Pattern recognition
    └── transistor_topology_analyzer.py # Main implementation

tests/
└── unit/infrastructure/analysis/
    ├── test_transistor_patterns.py
    └── test_transistor_topology_analyzer.py
```

### 5.2 Test Cases

**Unit Tests** (`test_transistor_topology_analyzer.py`):
```python
# ═══════════════════════════════════════════════════════════════════════════
# INVERTER RECOGNITION
# ═══════════════════════════════════════════════════════════════════════════

def test_recognizes_simple_inverter():
    """Complementary PMOS/NMOS pair detected as inverter"""

def test_inverter_signal_flow_gate_to_drain():
    """Signal flows from gate (input) to drain (output)"""

def test_multiple_inverters_in_subcircuit():
    """Multiple inverter pairs correctly identified"""

def test_handles_different_vdd_names():
    """Works with VDD, VDDX, VCC, VPWR"""

# ═══════════════════════════════════════════════════════════════════════════
# TRANSMISSION GATE RECOGNITION
# ═══════════════════════════════════════════════════════════════════════════

def test_recognizes_transmission_gate():
    """PMOS/NMOS with shared source/drain detected as TG"""

def test_tgate_bidirectional_flow():
    """Signal flow marked as bidirectional"""

def test_distinguishes_tgate_from_inverter():
    """TG not confused with inverter (no VDD/VSS)"""

# ═══════════════════════════════════════════════════════════════════════════
# NAND/NOR RECOGNITION
# ═══════════════════════════════════════════════════════════════════════════

def test_recognizes_nand2():
    """Parallel PMOS + series NMOS = NAND2"""

def test_recognizes_nor2():
    """Series PMOS + parallel NMOS = NOR2"""

def test_recognizes_nand3():
    """3-input NAND correctly identified"""

# ═══════════════════════════════════════════════════════════════════════════
# LATCH/FF ANALYSIS
# ═══════════════════════════════════════════════════════════════════════════

def test_analyzes_sr_latch():
    """Cross-coupled NAND/NOR identified with feedback"""

def test_analyzes_d_latch():
    """D-latch with TG + inverter feedback analyzed"""

def test_analyzes_d_flipflop():
    """Master-slave D-FF with two feedback loops"""

# ═══════════════════════════════════════════════════════════════════════════
# HIERARCHICAL ANALYSIS
# ═══════════════════════════════════════════════════════════════════════════

def test_analyzes_cell_instances():
    """Subcircuit instances analyzed using registered pinouts"""

def test_unknown_cell_skipped():
    """Unknown cell types gracefully skipped"""

# ═══════════════════════════════════════════════════════════════════════════
# INTEGRATION
# ═══════════════════════════════════════════════════════════════════════════

def test_integration_with_latch_identifier():
    """Output feeds correctly into E01-F04-T02"""
```

---

## 6. Edge Cases and Limitations

### 6.1 Known Limitations
- **Complex logic**: May not recognize AOI/OAI (AND-OR-INVERT) structures
- **Analog circuits**: Not designed for analog/mixed-signal analysis
- **Non-standard structures**: Custom transistor arrangements may not be recognized

### 6.2 Edge Cases to Handle
- **Floating nodes**: Transistors with unconnected terminals
- **Multi-finger transistors**: Multiple transistors with same net connections
- **Dummy transistors**: Transistors for DRC fill (no electrical function)
- **Body ties**: Bulk connections to VDD/VSS

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-27 | 0.1 | Claude | Initial task spec creation |
