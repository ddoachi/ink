# Pre-Docs: E01-F04-T03 - Cell Tagging with Sequential Flag

## 1. Problem & Context

### Clear Problem Statement
Once sequential cells are identified by the latch detector service (T02), this information must be **persisted in the graph model** to avoid re-computing pattern matches during every expansion operation. Without cached tagging, each boundary query would trigger pattern matching overhead.

### Business Impact
**Why This Matters**: Semantic expansion (core MVP feature) needs **O(1) lookups** to check if a cell is sequential when deciding expansion boundaries. Re-running pattern matching during expansion would cause:
- **Slow expansion**: 100+ cells × 3 patterns = 300 unnecessary checks per expansion
- **Coupling**: Expansion logic would depend on pattern matching infrastructure
- **Inconsistency**: Same cell might be detected differently if patterns change mid-session

### Current Pain Points

| Issue | Impact | Frequency |
|-------|--------|-----------|
| No persistent sequential flag | Re-compute pattern matches on every query | Every expansion |
| Graph nodes lack metadata | Cannot distinguish sequential from combinational | Per-cell lookup |
| Expansion logic tightly coupled | Hard to test without full pattern infrastructure | Every test |
| Breaking change risk | Adding `Cell` field affects all instantiation sites | One-time migration |

### Success Metrics
- ✅ O(1) query time for `is_sequential_cell(name)`
- ✅ < 1MB memory overhead for 100K cell design
- ✅ 100% tagging accuracy (matches pattern detection)
- ✅ Backward compatible with existing tests

---

## 2. Conceptual Solution

### Core Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    GRAPH CONSTRUCTION                        │
│                                                               │
│  CDL Parser → Cell Objects → Latch Detector → Tagged Cells  │
│                                     ↓                         │
│                            ┌────────────────┐                │
│                            │ is_sequential? │                │
│                            └────────┬───────┘                │
│                                     ↓                         │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              Cell Entity (Domain Model)              │   │
│  │                                                       │   │
│  │  - name: str                                          │   │
│  │  - cell_type: str                                     │   │
│  │  - pins: List[Pin]                                    │   │
│  │  - is_sequential: bool  ← NEW FIELD                   │   │
│  └──────────────────────────────────────────────────────┘   │
│                            ↓                                  │
│  ┌──────────────────────────────────────────────────────┐   │
│  │           Graph Node (NetworkX Storage)              │   │
│  │                                                       │   │
│  │  node_id: "U123"                                      │   │
│  │  attributes:                                          │   │
│  │    - cell_type: "DFFR_X1"                             │   │
│  │    - is_sequential: True  ← CACHED FLAG               │   │
│  │    - pins: [...]                                      │   │
│  └──────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    EXPANSION QUERIES (Fast)                  │
│                                                               │
│  if graph.nodes[cell_id]['is_sequential']:                   │
│      # Stop expansion (boundary reached)                     │
│  else:                                                        │
│      # Continue expansion                                    │
└───────────────────────────────────────────────────────────────┘
```

### Key Concepts Explained

#### Cache vs Compute Trade-off

**Real-World Analogy**: Think of **employee badges with color coding**:

**Without Tagging (Compute Every Time)**:
```
Security: "Can this person enter restricted area?"
Guard: *checks employee database*
Guard: *looks up clearance level*
Guard: *verifies department*
Guard: "Yes, allowed."

Next person: *repeat entire process*
```

**With Tagging (Cache at Badge)**:
```
Security: "Can this person enter?"
Guard: *looks at badge color* (Red = restricted access)
Guard: "Yes, allowed."

Next person: *instant check via badge*
```

**Performance Impact**:
```
WITHOUT tagging (compute):
  Expansion query → Pattern match → 3 fnmatch calls → ~1.5μs
  100 cells/expansion × 1.5μs = 150μs per expansion

WITH tagging (cache):
  Expansion query → Attribute lookup → ~0.05μs
  100 cells/expansion × 0.05μs = 5μs per expansion

  Speedup: 30x faster! ✅
```

#### Domain Model vs Graph Storage

**Dual Storage Pattern**:

```
┌─────────────────────────────────────────────────────┐
│         DOMAIN MODEL (Business Logic)               │
│                                                      │
│  Cell: Python @dataclass                            │
│  - Strong typing                                     │
│  - Validation logic                                  │
│  - Domain methods                                    │
│  - Used in application/presentation layers          │
└─────────────────────────────────────────────────────┘
                      ↕ sync
┌─────────────────────────────────────────────────────┐
│       GRAPH STORAGE (Traversal/Query)               │
│                                                      │
│  NetworkX Node: Dictionary attributes               │
│  - Optimized for graph algorithms                   │
│  - Efficient neighbor queries                       │
│  - Used in infrastructure layer                     │
└─────────────────────────────────────────────────────┘
```

**Why Both?**
- **Domain Model**: Type-safe, testable, enforces business rules
- **Graph Storage**: Fast traversal, indexing, network algorithms
- **Sync Pattern**: Graph builder translates domain → graph on construction

### Component Interactions

#### Tagging During Graph Construction

```
┌─────────────────────────────────────────────────────────┐
│  Step 1: CDL Parser produces raw cell data              │
│    {name: "U123", cell_type: "DFFR_X1", pins: [...]}   │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  Step 2: Create Cell entity (domain model)              │
│    cell = Cell(name="U123", cell_type="DFFR_X1", ...)   │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  Step 3: Query latch detector                           │
│    is_seq = latch_identifier.is_sequential("DFFR_X1")   │
│    # Returns: True                                       │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  Step 4: Tag domain entity                              │
│    cell.is_sequential = True                            │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  Step 5: Add to graph with attribute                    │
│    graph.add_node("U123", cell_type="DFFR_X1",          │
│                   is_sequential=True, ...)              │
└─────────────────────────────────────────────────────────┘
```

#### Query During Expansion

```
┌─────────────────────────────────────────────────────────┐
│  User double-clicks cell "U100" (expands fanout)        │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  Expansion Service gets downstream cells:               │
│    neighbors = graph.successors("U100")                 │
│    # ["U200", "U201", "U202"]                           │
└────────┬────────────────────────────────────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│  For each neighbor, check boundary:                     │
│    FOR cell_id IN neighbors:                            │
│      is_seq = graph.nodes[cell_id]['is_sequential']     │
│                                                          │
│      IF is_seq:                                          │
│        STOP (boundary reached, don't expand latches)    │
│      ELSE:                                               │
│        INCLUDE in expansion (show combinational logic)  │
└─────────────────────────────────────────────────────────┘
```

---

## 3. Technical Approach

### Strategy: Augment Domain Model + Sync to Graph

**Three-Layer Update**:
1. **Domain Layer**: Add `is_sequential: bool` field to `Cell` dataclass
2. **Infrastructure Layer**: Tag cells during graph construction
3. **Application Layer**: Provide query methods for expansion logic

### Pseudocode

#### Domain Model Update

```python
@dataclass
CLASS Cell:
  name: string                      # Instance name (e.g., "U123")
  cell_type: string                 # Cell type (e.g., "DFFR_X1")
  pins: list of Pin                 # Connection points
  is_sequential: boolean = False    # NEW: Sequential flag

  METHOD validate():
    IF name is empty:
      RAISE ValueError("Cell name required")
    IF cell_type is empty:
      RAISE ValueError("Cell type required")
```

#### Graph Construction Integration

```
CLASS DesignGraphBuilder:
  PROPERTIES:
    latch_identifier: LatchIdentifier  # Injected service
    graph: NetworkX DiGraph
    cell_index: dictionary

  METHOD add_cell(cell: Cell):
    # Step 1: Identify if sequential
    is_seq = latch_identifier.is_sequential(cell.cell_type)

    # Step 2: Tag domain entity
    cell.is_sequential = is_seq

    # Step 3: Add to graph with cached flag
    graph.add_node(
      cell.name,
      cell_type=cell.cell_type,
      is_sequential=is_seq,      # CACHED ATTRIBUTE
      pins=serialize(cell.pins)
    )

    # Step 4: Index for fast lookup
    cell_index[cell.name] = cell.name
```

#### Query Methods

```
CLASS GraphQueryService:
  PROPERTIES:
    graph: NetworkX DiGraph

  METHOD is_sequential_cell(cell_name: string) → boolean:
    """O(1) lookup of cached flag"""
    IF cell_name NOT IN graph.nodes:
      RAISE KeyError(f"Cell {cell_name} not found")

    # Direct attribute access (no pattern matching)
    RETURN graph.nodes[cell_name].get('is_sequential', False)

  METHOD get_sequential_cells() → list of Cell:
    """Get all sequential cells"""
    sequential_cells = []

    FOR node_id, attributes IN graph.nodes:
      IF attributes.get('is_sequential', False):
        cell = reconstruct_cell(node_id, attributes)
        sequential_cells.append(cell)

    RETURN sequential_cells

  METHOD get_sequential_count() → integer:
    """Count sequential cells"""
    count = 0
    FOR _, attributes IN graph.nodes:
      IF attributes.get('is_sequential', False):
        count += 1
    RETURN count
```

### Design Decisions

#### Decision 1: Add Field to Cell vs Separate Lookup Table

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Cell Field** | ✅ Yes | Data locality, type safety, clear ownership |
| Separate Lookup | ❌ No | Indirection overhead, sync complexity |

**Detailed Reasoning**:

Adding `is_sequential` directly to the `Cell` entity makes it **first-class domain data**, not infrastructure metadata. This reflects that "whether a cell is sequential" is a core business concept.

**Problem with Lookup Table**:
```python
# Separate table approach
sequential_cells = {"U123", "U456", "U789"}  # Set lookup

def is_sequential(cell: Cell) -> bool:
    return cell.name in sequential_cells  # Indirection
```

**Issues**:
- Must keep lookup table in sync with graph
- No type hint connection to `Cell` entity
- Unclear ownership (who updates the table?)
- Extra memory allocation for separate data structure

**Solution with Field**:
```python
@dataclass
class Cell:
    is_sequential: bool  # Self-contained

# Usage
if cell.is_sequential:  # Direct, obvious, type-safe
    ...
```

**Trade-offs**:
- **Gain**: Cleaner domain model, no sync issues, better testability
- **Lose**: Breaks existing `Cell` instantiation (one-time migration cost)
- **Memory**: +1 byte per cell (negligible: 100K cells = 100KB)

**Alternative Rejected**:
- **Lookup Table**: Adds architectural complexity without benefits. The "is sequential" property is intrinsic to the cell, not a relationship.

#### Decision 2: Store in Graph Nodes vs Compute on Query

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Store in Graph** | ✅ Yes | O(1) query, no pattern matching overhead |
| Compute on Query | ❌ No | 30x slower, couples expansion to pattern matching |

**Detailed Reasoning**:

Expansion operations query hundreds of cells to determine boundaries. Re-running pattern matching would create unacceptable performance overhead:

**Performance Comparison**:
```
Scenario: Expand cell with 200 downstream neighbors

COMPUTE ON QUERY (re-run pattern matching):
  FOR 200 cells:
    is_seq = latch_identifier.is_sequential(cell_type)
    # 200 × 1.5μs = 300μs per expansion
    # Plus 200 function calls overhead

STORE IN GRAPH (attribute lookup):
  FOR 200 cells:
    is_seq = graph.nodes[cell_id]['is_sequential']
    # 200 × 0.05μs = 10μs per expansion
    # 30x faster! ✅
```

**Real-World Example**: User expands 10 cells in rapid succession while exploring a datapath:
```
Without cache: 10 × 300μs = 3ms (noticeable lag)
With cache:    10 × 10μs  = 0.1ms (instant)
```

**Trade-offs**:
- **Gain**: 30x faster queries, decouples expansion from pattern infrastructure
- **Lose**: +1 byte per graph node (100KB for 100K cells)
- **Consistency**: If patterns change mid-session, old tags persist (reload design to refresh)

**Alternative Rejected**:
- **Compute on Query**: Unacceptable performance penalty for interactive expansion. Memory overhead is trivial compared to graph structure itself (NetworkX uses ~KB per node).

#### Decision 3: Tag During Graph Construction vs Post-Processing

| Aspect | Chosen | Why |
|--------|--------|-----|
| **During Construction** | ✅ Yes | Single pass, no duplicate iteration |
| Post-Processing | ❌ No | Requires iterating all cells twice |

**Detailed Reasoning**:

Graph construction already iterates over every cell once to build the network. Tagging during this pass is "free" (no extra iteration):

**During Construction (Chosen)**:
```
FOR EACH cell IN parsed_cells:
  # Already iterating for graph construction
  is_seq = latch_identifier.is_sequential(cell.cell_type)
  cell.is_sequential = is_seq
  graph.add_node(cell.name, is_sequential=is_seq, ...)

# One pass through all cells ✅
```

**Post-Processing (Rejected)**:
```
# First pass: Build graph (without tagging)
FOR EACH cell IN parsed_cells:
  graph.add_node(cell.name, cell_type=cell.cell_type, ...)

# Second pass: Tag nodes (redundant iteration)
FOR node_id IN graph.nodes:
  cell_type = graph.nodes[node_id]['cell_type']
  is_seq = latch_identifier.is_sequential(cell_type)
  graph.nodes[node_id]['is_sequential'] = is_seq

# Two passes through all cells ❌
```

**Trade-offs**:
- **Gain**: 50% faster (one pass vs two), simpler code flow
- **Lose**: None (tagging is synchronous during construction)

**Alternative Rejected**:
- **Post-Processing**: Doubles iteration overhead for no benefit. Tagging is not a separate "phase"—it's part of graph construction.

#### Decision 4: Backward Compatibility with .get() Default

| Aspect | Chosen | Why |
|--------|--------|-----|
| **Default to False** | ✅ Yes | Safe fallback for old/missing attribute |
| Raise KeyError | ❌ No | Would break existing code/tests |

**Detailed Reasoning**:

Existing code or tests might have graph nodes without the `is_sequential` attribute. Using `.get('is_sequential', False)` provides graceful backward compatibility:

**Problem Without Default**:
```python
# Old graph node (before this feature)
graph.add_node("U123", cell_type="DFFR_X1")
# No 'is_sequential' attribute

# Query code
is_seq = graph.nodes["U123"]['is_sequential']  # KeyError! ❌
```

**Solution with Default**:
```python
# Query code (defensive)
is_seq = graph.nodes["U123"].get('is_sequential', False)
# Returns: False (safe default) ✅
```

**Trade-offs**:
- **Gain**: Backward compatible, tests don't break, graceful degradation
- **Lose**: Silent failure if attribute truly missing (acceptable for boolean flag)
- **Best Practice**: Standard Python pattern for optional dict keys

**Alternative Rejected**:
- **Raise KeyError**: Would force immediate migration of all tests/fixtures. Default of `False` is safe (assumes combinational unless proven sequential).

---

## 4. Implementation Strategy

### Development Phases

```
Phase 1: Domain Model Update (1 hour)
├─ Add is_sequential: bool field to Cell dataclass
├─ Update Cell.__post_init__() validation
└─ Update existing tests to provide is_sequential value

Phase 2: Graph Construction Integration (2 hours)
├─ Inject LatchIdentifier into DesignGraphBuilder
├─ Call latch_identifier.is_sequential() for each cell
├─ Tag Cell entity and graph node attributes
└─ Update graph builder tests

Phase 3: Query Methods (1.5 hours)
├─ Implement is_sequential_cell(cell_name)
├─ Implement get_sequential_cells()
├─ Implement get_sequential_count()
└─ Add query method tests

Phase 4: Integration Testing (1.5 hours)
├─ Create sample netlist with DFF + combinational cells
├─ Verify end-to-end tagging accuracy
├─ Test backward compatibility with old graphs
└─ Performance benchmark (100K cells)
```

### Integration Points

```
Application Startup & Graph Loading:

main.py:
  ┌──────────────────────────────────────────────┐
  │ 1. Load configuration                        │
  │    config = LatchIdentificationConfig.load() │
  └────────┬─────────────────────────────────────┘
           ↓
  ┌──────────────────────────────────────────────┐
  │ 2. Create latch detector                     │
  │    detector = PatternBasedLatchIdentifier(   │
  │        patterns=config.patterns              │
  │    )                                          │
  └────────┬─────────────────────────────────────┘
           ↓
  ┌──────────────────────────────────────────────┐
  │ 3. Create graph builder with detector        │
  │    builder = DesignGraphBuilder(             │
  │        latch_identifier=detector             │
  │    )                                          │
  └────────┬─────────────────────────────────────┘
           ↓
  ┌──────────────────────────────────────────────┐
  │ 4. Parse CDL and build graph                 │
  │    cells = cdl_parser.parse(file)            │
  │    FOR cell IN cells:                        │
  │        builder.add_cell(cell)  ← Tags here   │
  └────────┬─────────────────────────────────────┘
           ↓
  ┌──────────────────────────────────────────────┐
  │ 5. Graph ready with is_sequential tags       │
  │    graph.nodes["U123"]['is_sequential']      │
  └──────────────────────────────────────────────┘
```

**File Structure**:
```
src/ink/
├── domain/model/
│   └── cell.py                      ← Add is_sequential field
│
├── infrastructure/graph/
│   └── design_graph_builder.py      ← Tagging logic
│
└── application/services/
    └── graph_query_service.py       ← Query methods
```

### Risk Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|-------------|--------|---------------------|
| Breaking change to Cell | High | Medium | Update all Cell() calls in tests with is_sequential=False |
| Existing tests fail | High | Low | Use default value (False) for backward compatibility |
| Missing attribute in old graphs | Medium | Low | Use .get('is_sequential', False) in queries |
| Inconsistent tagging | Low | High | Unit test verifies latch_identifier called for each cell |

---

## 5. Expected Behavior & Scenarios

### User Stories

**Story 1: Accurate Tagging**
```
GIVEN a netlist with 2 DFF cells and 1 AND gate
WHEN graph is constructed
THEN DFF cells have is_sequential=True
AND AND gate has is_sequential=False
```

**Story 2: Fast Boundary Queries**
```
GIVEN a graph with 100K cells (80K sequential, 20K combinational)
WHEN expansion service queries is_sequential_cell() 1000 times
THEN total query time < 1ms (1μs per query)
```

**Story 3: Sequential Cell Filtering**
```
GIVEN a design with 5000 sequential cells
WHEN get_sequential_cells() is called
THEN returns list of 5000 Cell entities
AND all have is_sequential=True
AND get_sequential_count() returns 5000
```

**Story 4: Backward Compatibility**
```
GIVEN an old graph without is_sequential attribute
WHEN is_sequential_cell(cell_id) is queried
THEN returns False (safe default)
AND no exceptions raised
```

### Edge Cases

| Case | Input | Expected Output |
|------|-------|----------------|
| Query non-existent cell | `is_sequential_cell("INVALID")` | Raises `KeyError` |
| Cell with empty cell_type | `cell.cell_type = ""` | `is_sequential=False` |
| Graph node missing attribute | Old graph node | `.get()` returns `False` |
| Mixed case cell types | `"dffr_x1"` | Tagged as `True` (case-insensitive) |
| None cell_type | `cell.cell_type = None` | `is_sequential=False` |

### Performance Expectations

**Tagging Overhead (Graph Construction)**:
```
100,000 Cell Design:
├─ Latch identification calls: 100K × 0.65μs = 65ms
├─ Cell field assignment:      100K × 0.01μs = 1ms
├─ Graph attribute storage:    100K × 0.02μs = 2ms
   ───────────────────────────────────────────────
   Total overhead:                            ~68ms

Target: < 100ms ✅
```

**Query Performance**:
```
Single is_sequential_cell() call:
├─ Dict attribute lookup:    ~0.03μs
├─ .get() with default:      ~0.02μs
└─ Return value:             ~0.01μs
   ────────────────────────────────
   Total per query:          ~0.06μs (60 nanoseconds)

1000 queries: 1000 × 0.06μs = 60μs (0.06ms) ✅
```

**Memory Overhead**:
```
100,000 Cells:
├─ Cell.is_sequential field:  100K × 1 byte  = 100KB
├─ Graph node attribute:      100K × 1 byte  = 100KB
   ────────────────────────────────────────────────
   Total additional memory:                    200KB

Percentage of total graph: ~0.5% (negligible) ✅
```

---

## 6. Testing Strategy

### Coverage Pyramid

```
           /\
          /  \         E2E: Load netlist → Tagged graph → Query expansion
         /────\
        /      \       Integration: CDL Parser → Graph Builder → Tags
       /────────\
      /          \     Unit: Cell validation, query methods, edge cases
     /────────────\
    /______________\
```

### Key Scenarios

**Domain Model Tests**:
- ✅ Cell defaults is_sequential to False
- ✅ Cell accepts is_sequential=True
- ✅ Cell validation works with new field

**Graph Construction Tests**:
- ✅ DFF cells tagged as is_sequential=True
- ✅ Combinational cells tagged as is_sequential=False
- ✅ Latch detector called once per cell
- ✅ Graph nodes have is_sequential attribute

**Query Method Tests**:
- ✅ is_sequential_cell() returns correct value
- ✅ get_sequential_cells() filters correctly
- ✅ get_sequential_count() matches actual count
- ✅ Missing attribute returns False (backward compat)

**Integration Tests**:
- ✅ End-to-end: Parse netlist with mixed cell types
- ✅ Verify 100% tagging accuracy
- ✅ Custom patterns tag custom cells correctly
- ✅ Performance: 100K cells tagged in < 100ms

### Validation Approach

**Test Data** (Sample Netlist):
```
Sample netlist (sample_sequential.ckt):
  X_DFF1  (DFFR_X1)   ← Should be tagged True
  X_AND1  (AND2_X1)   ← Should be tagged False
  X_DFF2  (SDFFR_X2)  ← Should be tagged True
  X_NAND1 (NAND3_X2)  ← Should be tagged False
  X_LATCH (LATCH_X1)  ← Should be tagged True
```

**Assertion Pattern**:
```
TEST end_to_end_tagging:
  # Build graph from sample netlist
  graph = build_graph_from_file("sample_sequential.ckt")

  # Verify sequential cells
  ASSERT graph.nodes["X_DFF1"]['is_sequential'] == True
  ASSERT graph.nodes["X_DFF2"]['is_sequential'] == True
  ASSERT graph.nodes["X_LATCH"]['is_sequential'] == True

  # Verify combinational cells
  ASSERT graph.nodes["X_AND1"]['is_sequential'] == False
  ASSERT graph.nodes["X_NAND1"]['is_sequential'] == False

  # Query methods
  ASSERT get_sequential_count() == 3
  ASSERT len(get_sequential_cells()) == 3
```

**Mock Testing** (Domain Layer):
```
TEST graph_builder_calls_latch_identifier:
  # Create mock latch identifier
  mock_identifier = Mock(LatchIdentifier)
  mock_identifier.is_sequential.return_value = True

  # Inject into builder
  builder = DesignGraphBuilder(latch_identifier=mock_identifier)

  # Add cell
  cell = Cell(name="U1", cell_type="DFFR_X1")
  builder.add_cell(cell)

  # Verify detector was called
  mock_identifier.is_sequential.assert_called_once_with("DFFR_X1")

  # Verify cell was tagged
  ASSERT cell.is_sequential == True
```

---

## Summary

**Cell Tagging** completes the latch identification pipeline by **caching detection results** in the graph model:

- ✅ **O(1) Queries**: Expansion boundary checks are instant
- ✅ **Type-Safe Domain Model**: `is_sequential` is first-class `Cell` field
- ✅ **Backward Compatible**: Old graphs default to `False` gracefully
- ✅ **Minimal Overhead**: < 100ms tagging, 200KB memory for 100K cells
- ✅ **Testable**: Clean separation via dependency injection

**Data Flow Summary**:
```
Config (T01) → Detector (T02) → Cell Tagging (T03)
                                        ↓
                                Query Methods
                                        ↓
                                Expansion Logic ✅
```

**Integration Points**:
- **Upstream**: Latch Detector Service (T02) provides `is_sequential()` checks
- **Downstream**: Expansion Service queries `is_sequential_cell()` for boundaries
- **Side Effects**: Property panel can display "Sequential: Yes/No"

**Next Steps**:
1. Implement E01-F03 (Graph Construction) if not done—provides `DesignGraphBuilder`
2. Wire tagging into graph builder's `add_cell()` method
3. Use `is_sequential_cell()` queries in E03 (Expansion) for semantic boundaries
