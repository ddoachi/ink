---
id: E01-F04-T03
title: Cell Tagging with Sequential Flag
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F04
created: 2025-12-26
estimated_hours: 5
actual_hours:
effort: Small
tags:
  - domain-model
  - graph-construction
---

# Spec: E01-F04-T03 - Cell Tagging with Sequential Flag

## 1. Overview

### 1.1 Problem Statement
Once sequential cells are identified by the latch detector service, the graph model must store this information for efficient query during expansion operations. Adding an `is_sequential` flag to the `Cell` entity and graph nodes enables O(1) lookups without repeated pattern matching.

### 1.2 Goals
- Add `is_sequential` field to `Cell` entity (domain model)
- Tag cells during graph construction using `LatchIdentifier` service
- Store `is_sequential` flag in graph node attributes
- Provide query methods to retrieve sequential cells
- Enable efficient boundary detection for semantic expansion (future P1)

---

## 2. Technical Requirements

### 2.1 Domain Model Updates

**Location**: `src/ink/domain/model/cell.py`

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Cell:
    """Gate-level cell instance entity"""
    name: str                    # Instance name (e.g., "U123")
    cell_type: str               # Cell type (e.g., "DFFR_X1", "AND2_X1")
    pins: List[Pin] = field(default_factory=list)
    is_sequential: bool = False  # NEW: Sequential element flag

    def __post_init__(self):
        """Validate cell attributes"""
        if not self.name:
            raise ValueError("Cell name cannot be empty")
        if not self.cell_type:
            raise ValueError("Cell type cannot be empty")
```

**Breaking Change**: This adds a new field to `Cell`. Existing code creating `Cell` objects must be reviewed.

### 2.2 Graph Construction Integration

**Location**: `src/ink/infrastructure/graph/design_graph.py` (or equivalent)

**During Graph Building**:
```python
from ink.domain.services.latch_identifier import LatchIdentifier

class DesignGraphBuilder:
    """Builds design graph from parsed netlist data"""

    def __init__(self, latch_identifier: LatchIdentifier):
        """
        Args:
            latch_identifier: Service to identify sequential elements
        """
        self.latch_identifier = latch_identifier
        self.graph = nx.DiGraph()
        self._cell_index = {}

    def add_cell(self, cell: Cell) -> None:
        """
        Add cell to graph with sequential tagging.

        Args:
            cell: Cell entity to add
        """
        # Identify if cell is sequential
        cell.is_sequential = self.latch_identifier.is_sequential(cell.cell_type)

        # Add to graph with attributes
        self.graph.add_node(
            cell.name,
            cell_type=cell.cell_type,
            is_sequential=cell.is_sequential,
            pins=[p.to_dict() for p in cell.pins]
        )
        self._cell_index[cell.name] = cell.name
```

**Alternative**: Tag cells in `CDLParser` during parsing (less preferred due to layering).

### 2.3 Query Methods

**Location**: `src/ink/application/services/graph_query_service.py` (or equivalent)

```python
from typing import List
from ink.domain.model.cell import Cell

class GraphQueryService:
    """Service for querying design graph"""

    def is_sequential_cell(self, cell_name: str) -> bool:
        """
        Check if a cell is a sequential element.

        Args:
            cell_name: Cell instance name

        Returns:
            True if cell is sequential, False otherwise

        Raises:
            KeyError: If cell not found in graph
        """
        return self.graph.nodes[cell_name].get('is_sequential', False)

    def get_sequential_cells(self) -> List[Cell]:
        """
        Get all sequential cells in the design.

        Returns:
            List of Cell entities that are sequential elements
        """
        sequential_cells = []
        for node_id, data in self.graph.nodes(data=True):
            if data.get('is_sequential', False):
                cell = self._node_to_cell(node_id, data)
                sequential_cells.append(cell)
        return sequential_cells

    def get_sequential_count(self) -> int:
        """
        Count sequential elements in design.

        Returns:
            Number of sequential cells
        """
        return sum(
            1 for _, data in self.graph.nodes(data=True)
            if data.get('is_sequential', False)
        )
```

### 2.4 Graph Node Attributes

**Node Attribute Schema**:
```python
{
    "cell_type": "DFFR_X1",
    "is_sequential": True,          # NEW attribute
    "pins": [
        {"name": "D", "direction": "INPUT"},
        {"name": "Q", "direction": "OUTPUT"},
        {"name": "CK", "direction": "INPUT"}
    ]
}
```

### 2.5 Backward Compatibility

**Migration Strategy**:
- Existing graph construction code assumes `is_sequential=False` if attribute missing
- Use `data.get('is_sequential', False)` for safe queries
- Update all `Cell` instantiation sites to explicitly set `is_sequential`

---

## 3. Dependencies

- **Upstream**:
  - E01-F04-T02 (Latch Detector Service) - provides `LatchIdentifier` service
  - E01-F01 (CDL Parser) - provides cell type data
  - E01-F03 (Graph Construction) - integration point for tagging
- **Downstream**:
  - E03 (Incremental Expansion) - queries `is_sequential` for semantic boundaries
  - E04-F02 (Property Display) - may display sequential status
  - E06 (Search) - may filter by sequential cells

---

## 4. Acceptance Criteria

- [ ] `Cell` dataclass has `is_sequential: bool` field with default `False`
- [ ] Graph construction calls `latch_identifier.is_sequential()` for each cell
- [ ] `is_sequential` flag stored in graph node attributes
- [ ] `is_sequential_cell(cell_name)` query method implemented
- [ ] `get_sequential_cells()` returns list of sequential cells
- [ ] `get_sequential_count()` returns count of sequential cells
- [ ] Query methods handle missing `is_sequential` attribute gracefully (default `False`)
- [ ] Existing unit tests updated to handle new `Cell` field
- [ ] Integration test validates sequential cells tagged correctly from sample netlist
- [ ] 90%+ test coverage on query methods

---

## 5. Implementation Notes

### 5.1 File Locations

```
src/ink/
├── domain/model/
│   └── cell.py                         # Add is_sequential field
├── infrastructure/graph/
│   └── design_graph.py                 # Integration during graph build
└── application/services/
    └── graph_query_service.py          # Query methods

tests/
├── unit/domain/model/
│   └── test_cell.py                    # Test new field
├── integration/infrastructure/graph/
│   └── test_design_graph_builder.py    # Test tagging integration
└── unit/application/services/
    └── test_graph_query_service.py     # Test query methods
```

### 5.2 Test Cases

**Unit Tests** (`test_cell.py`):
```python
def test_cell_default_is_sequential_false():
    """Test Cell.is_sequential defaults to False"""

def test_cell_can_be_sequential():
    """Test Cell can be marked as sequential"""
```

**Integration Tests** (`test_design_graph_builder.py`):
```python
def test_dff_cells_tagged_as_sequential():
    """Test DFF cells tagged during graph construction"""

def test_combinational_cells_not_sequential():
    """Test AND/NAND gates not tagged as sequential"""

def test_sequential_tagging_with_custom_patterns():
    """Test custom patterns correctly tag cells"""
```

**Unit Tests** (`test_graph_query_service.py`):
```python
def test_is_sequential_cell_returns_true_for_dff():
    """Test query returns True for sequential cells"""

def test_get_sequential_cells_returns_only_sequential():
    """Test get_sequential_cells filters correctly"""

def test_get_sequential_count_accurate():
    """Test count matches number of sequential cells"""

def test_missing_is_sequential_attribute_defaults_false():
    """Test backward compatibility with old graphs"""
```

### 5.3 Sample Netlist Test Data

**Example**: `tests/fixtures/sample_sequential.ckt`
```spice
.SUBCKT test_circuit IN OUT VDD VSS
X_DFF1 IN DFF_Q DFFR_X1
X_AND1 DFF_Q IN AND_OUT AND2_X1
X_DFF2 AND_OUT OUT DFFR_X1
.ENDS
```

**Expected Results**:
- `X_DFF1`: `is_sequential=True` (matches `*DFF*`)
- `X_AND1`: `is_sequential=False` (no match)
- `X_DFF2`: `is_sequential=True` (matches `*DFF*`)
- `get_sequential_count()` → 2

### 5.4 Error Handling

**Edge Cases**:
- Empty cell type → `is_sequential=False`
- Unknown cell type → `is_sequential=False` (unless matches pattern)
- Graph node without `is_sequential` attribute → query returns `False`

---

## 6. Performance Impact

**Expected Overhead**:
- **Graph Construction**: +1 function call per cell (`is_sequential()` → O(p) patterns)
  - For 100K cell design: ~100ms additional time (target)
- **Query**: O(1) per cell (attribute lookup)
- **Memory**: +1 byte per cell (boolean flag)

**Optimization**: Cache pattern matching results if same cell type appears frequently (future).

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task spec creation |
