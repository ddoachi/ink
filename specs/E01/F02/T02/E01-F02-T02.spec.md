---
id: E01-F02-T02
title: Direction Lookup Service
type: Task
priority: P0 (MVP)
status: Draft
parent: E01-F02
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - domain
  - service
  - api
clickup_task_id: ''
---

# Spec: E01-F02-T02 - Direction Lookup Service

## 1. Overview

### 1.1 Problem Statement
After parsing the `.pindir` file, the application needs a clean API to query pin directions during graph construction and rendering. The lookup service should provide O(1) direction queries by pin name and handle the global pin matching strategy where pin names map to directions across all cells.

### 1.2 Goals
- Provide a domain service interface for pin direction queries
- Support O(1) lookup performance for pin direction by name
- Integrate with existing `PinDirectionMap` from parser
- Enable querying pin existence and direction mapping
- Support future enhancements (caching, statistics, etc.)

---

## 2. Technical Requirements

### 2.1 Domain Service Interface

**Location**: `src/ink/domain/services/pin_direction_service.py`

**Service Protocol**:
```python
from typing import Protocol, Optional
from ink.domain.value_objects.pin_direction import PinDirection


class PinDirectionService(Protocol):
    """
    Domain service for querying pin directions.

    Pin directions are applied globally by pin name:
    - Pin "A" is INPUT for all cells that have an "A" pin
    - Pin "Y" is OUTPUT for all cells that have a "Y" pin
    """

    def get_direction(self, pin_name: str) -> PinDirection:
        """
        Get direction for a pin name.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            PinDirection for the pin, or INOUT if not found (default)
        """
        ...

    def has_pin(self, pin_name: str) -> bool:
        """
        Check if pin name exists in the direction mapping.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            True if pin direction is defined, False otherwise
        """
        ...

    def get_all_pins(self) -> dict[str, PinDirection]:
        """
        Get all pin name to direction mappings.

        Returns:
            Dictionary mapping pin names to their directions
        """
        ...
```

### 2.2 Infrastructure Implementation

**Location**: `src/ink/infrastructure/services/pin_direction_service_impl.py`

**Implementation**:
```python
from dataclasses import dataclass
from typing import Dict
import logging

from ink.domain.value_objects.pin_direction import PinDirection
from ink.infrastructure.parsing.pindir_parser import PinDirectionMap


@dataclass
class PinDirectionServiceImpl:
    """
    Implementation of PinDirectionService using parsed pin direction data.

    Provides O(1) lookup for pin directions using in-memory dictionary.
    """
    _direction_map: PinDirectionMap
    _logger: logging.Logger = None

    def __post_init__(self):
        if self._logger is None:
            self._logger = logging.getLogger(__name__)

    def get_direction(self, pin_name: str) -> PinDirection:
        """
        Get direction for a pin name.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            PinDirection for the pin, or INOUT if not found (default)
        """
        direction = self._direction_map.get_direction(pin_name)

        # Log warning if pin not found (first time only to avoid spam)
        if not self.has_pin(pin_name):
            self._logger.debug(
                f"Pin '{pin_name}' not found in direction mapping. "
                f"Defaulting to INOUT."
            )

        return direction

    def has_pin(self, pin_name: str) -> bool:
        """
        Check if pin name exists in the direction mapping.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            True if pin direction is defined, False otherwise
        """
        return self._direction_map.has_pin(pin_name)

    def get_all_pins(self) -> Dict[str, PinDirection]:
        """
        Get all pin name to direction mappings.

        Returns:
            Dictionary mapping pin names to their directions
        """
        return self._direction_map.directions.copy()

    def get_pin_count(self) -> int:
        """
        Get total number of pins with defined directions.

        Returns:
            Number of pins in the mapping
        """
        return len(self._direction_map.directions)

    def get_pins_by_direction(self, direction: PinDirection) -> list[str]:
        """
        Get all pin names with a specific direction.

        Args:
            direction: Direction to filter by

        Returns:
            List of pin names with the specified direction
        """
        return [
            pin_name
            for pin_name, pin_dir in self._direction_map.directions.items()
            if pin_dir == direction
        ]
```

### 2.3 Application Layer Integration

**Location**: `src/ink/application/services/file_service.py` (enhancement)

**Usage Example**:
```python
from pathlib import Path
from ink.infrastructure.parsing.pindir_parser import PinDirectionParser
from ink.infrastructure.services.pin_direction_service_impl import PinDirectionServiceImpl


class FileService:
    """Application service for file operations"""

    def load_pin_directions(self, pindir_path: Path) -> PinDirectionServiceImpl:
        """
        Load pin directions from .pindir file.

        Args:
            pindir_path: Path to .pindir file

        Returns:
            PinDirectionService implementation

        Raises:
            FileNotFoundError: If file not found
            PinDirectionParseError: If parsing fails
        """
        parser = PinDirectionParser()
        direction_map = parser.parse_file(pindir_path)

        service = PinDirectionServiceImpl(_direction_map=direction_map)

        self.logger.info(
            f"Loaded {service.get_pin_count()} pin directions from {pindir_path}"
        )

        return service
```

### 2.4 API Design Rationale

**Why Protocol instead of ABC?**
- More flexible for testing (easy to create mock implementations)
- Supports structural typing (duck typing with type hints)
- Recommended pattern for domain service interfaces in DDD

**Why separate interface and implementation?**
- Domain layer defines interface (protocol)
- Infrastructure layer provides implementation
- Allows dependency inversion (domain doesn't depend on infrastructure)
- Easy to swap implementations (e.g., database-backed in future)

**Why include utility methods?**
- `get_all_pins()`: Useful for debugging and UI display
- `get_pin_count()`: Statistics and validation
- `get_pins_by_direction()`: Future filtering needs (e.g., show all inputs)

---

## 3. Dependencies

### 3.1 Upstream
- Task E01-F02-T01: `PinDirectionMap` and `PinDirectionParser`
- Domain value object: `PinDirection` enum

### 3.2 Downstream
- Task E01-F03 (Graph Construction): Uses service to set Pin entity directions
- Application layer: `FileService` orchestrates parsing and service creation
- Future: Schematic rendering, expansion logic

### 3.3 External Dependencies
- Python standard library: `typing`, `dataclasses`, `logging`
- No third-party dependencies

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `get_direction()` returns correct direction for known pins
- [ ] `get_direction()` returns INOUT for unknown pins (default behavior)
- [ ] `has_pin()` correctly identifies presence of pin in mapping
- [ ] `get_all_pins()` returns complete dictionary of all mappings
- [ ] `get_pin_count()` returns correct count of defined pins
- [ ] `get_pins_by_direction()` filters pins by direction correctly

### 4.2 Performance
- [ ] `get_direction()` is O(1) lookup (dictionary-backed)
- [ ] `has_pin()` is O(1) lookup
- [ ] `get_all_pins()` returns copy to prevent external mutation
- [ ] Service creation overhead < 1ms (simple dataclass initialization)

### 4.3 API Design
- [ ] Protocol interface defined in domain layer
- [ ] Implementation in infrastructure layer
- [ ] No circular dependencies between layers
- [ ] Type hints on all public methods
- [ ] Docstrings on all public methods

### 4.4 Testing
- [ ] Unit tests for each service method
- [ ] Test with empty direction map (no pins defined)
- [ ] Test with large direction map (1000+ pins)
- [ ] Test case-sensitivity of pin name lookup
- [ ] Test default INOUT behavior for unknown pins
- [ ] Mock-based tests for logging behavior
- [ ] 95%+ code coverage on service implementation

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why return copy in `get_all_pins()`?**
- Prevents external code from mutating internal state
- Preserves immutability of direction map
- Small performance cost acceptable for safety

**Why debug level for missing pin warnings?**
- Missing pins default to INOUT (valid behavior)
- Avoid log spam during normal operation
- Debug level allows troubleshooting when needed

**Why separate `has_pin()` from `get_direction()`?**
- Explicit check for pin existence vs. getting direction
- Allows client code to distinguish "not found" from "explicitly INOUT"
- Clearer API semantics

### 5.2 Future Enhancements

**Caching**:
- Current implementation already has O(1) lookup (no caching needed)
- Future: Cache negative lookups to avoid repeated debug logs

**Statistics**:
- Track most-queried pins
- Direction distribution metrics (% INPUT vs OUTPUT vs INOUT)
- Useful for debugging and optimization

**Validation**:
- Validate pin direction consistency across cell library
- Detect pins used with multiple directions (potential errors)

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/services/test_pin_direction_service.py`):
- Test service methods with known direction map
- Test edge cases (empty map, large map, unknown pins)
- Verify logging behavior with mock logger

**Integration Tests** (`tests/integration/infrastructure/test_pin_direction_integration.py`):
- Test full workflow: parse file → create service → query directions
- Use real `.pindir` files from `examples/` directory
- Verify end-to-end performance

---

## 6. Usage Examples

### 6.1 Basic Usage
```python
from pathlib import Path
from ink.infrastructure.parsing.pindir_parser import PinDirectionParser
from ink.infrastructure.services.pin_direction_service_impl import PinDirectionServiceImpl

# Parse pin direction file
parser = PinDirectionParser()
direction_map = parser.parse_file(Path("examples/standard_cells.pindir"))

# Create service
service = PinDirectionServiceImpl(_direction_map=direction_map)

# Query directions
a_direction = service.get_direction("A")  # Returns PinDirection.INPUT
y_direction = service.get_direction("Y")  # Returns PinDirection.OUTPUT
unknown = service.get_direction("UNKNOWN")  # Returns PinDirection.INOUT

# Check existence
has_a = service.has_pin("A")  # Returns True
has_unknown = service.has_pin("UNKNOWN")  # Returns False

# Get all pins
all_pins = service.get_all_pins()  # Dict[str, PinDirection]
print(f"Loaded {service.get_pin_count()} pin directions")
```

### 6.2 Integration with Graph Construction
```python
# During Pin entity creation
from ink.domain.model.pin import Pin

def create_pin(pin_name: str, pin_direction_service: PinDirectionService) -> Pin:
    """Create Pin entity with direction from service"""
    direction = pin_direction_service.get_direction(pin_name)
    return Pin(name=pin_name, direction=direction)
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F02 split |
