# E01-F02-T02: Direction Lookup Service - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F02-T02 - Direction Lookup Service
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Problem Context

After parsing the `.pindir` file (E01-F02-T01), the application needs a clean, domain-aligned API for querying pin directions. Direct access to `PinDirectionMap` from the infrastructure layer would violate the dependency inversion principle - the domain layer should not depend on infrastructure implementations.

This task creates the service layer bridge between domain and infrastructure:
- **Domain Layer**: Defines `PinDirectionService` protocol (interface)
- **Infrastructure Layer**: Implements service using parsed `PinDirectionMap`
- **Application Layer**: Orchestrates file loading and service creation

This follows the **Hexagonal Architecture** pattern where domain defines ports (interfaces) and infrastructure provides adapters (implementations).

### 1.2 Core Objectives

1. **Clean API**: Define domain service protocol with minimal, focused methods
2. **O(1) Performance**: Provide fast pin direction lookups using dictionary backing
3. **Dependency Inversion**: Domain defines interface, infrastructure implements
4. **Extensibility**: Support future enhancements (statistics, caching, validation)
5. **Testability**: Easy to mock for unit tests in consuming code

### 1.3 Success Metrics

- O(1) lookup performance for `get_direction()`
- Zero coupling from domain to infrastructure
- 100% protocol method coverage in tests
- Clean integration with graph construction (E01-F03)
- API usable without knowledge of parsing internals

---

## 2. Architecture Decisions

### 2.1 Protocol vs Abstract Base Class

**Decision**: Use `Protocol` from `typing` module for service interface

**Alternatives Considered**:

1. **Abstract Base Class (ABC)**: Traditional inheritance-based interface
   - Pros: Explicit inheritance, runtime checking with `abc.abstractmethod`
   - Cons: Tight coupling (requires `class Impl(ABC)`), less flexible

2. **Structural Subtyping (duck typing)**: No explicit interface
   - Pros: Maximum flexibility, no boilerplate
   - Cons: No type checking, poor IDE support, unclear contract

3. **Protocol with runtime_checkable**: Protocol + isinstance() support
   - Pros: Both static and runtime checking
   - Cons: Slightly more overhead, rarely needed

**Rationale**:
- **Protocol** provides structural typing (duck typing with type hints)
- Perfect for DDD service interfaces (no inheritance required)
- Better for testing (easy to create mock implementations inline)
- Pythonic and modern (Python 3.8+)
- Recommended pattern in clean architecture literature

**Implementation**:
```python
from typing import Protocol

class PinDirectionService(Protocol):
    """Domain service interface for pin direction queries"""

    def get_direction(self, pin_name: str) -> PinDirection:
        """Get direction for a pin name"""
        ...

    def has_pin(self, pin_name: str) -> bool:
        """Check if pin exists in mapping"""
        ...
```

### 2.2 Service Method Design

**Decision**: Minimal core API with optional utility methods

**Core Methods** (Protocol interface):
1. `get_direction(pin_name: str) -> PinDirection`: Primary query method
2. `has_pin(pin_name: str) -> bool`: Existence check
3. `get_all_pins() -> Dict[str, PinDirection]`: Bulk retrieval

**Utility Methods** (Implementation-specific):
4. `get_pin_count() -> int`: Statistics
5. `get_pins_by_direction(direction: PinDirection) -> List[str]`: Filtering

**Rationale**:
- Core methods are minimal and focused (single responsibility)
- `get_direction()` handles default behavior (returns INOUT if not found)
- `has_pin()` allows explicit existence checking
- `get_all_pins()` enables bulk operations and debugging
- Utility methods are conveniences, not required by protocol

**Alternative Considered**: Single method `lookup(pin_name: str) -> Optional[PinDirection]`
- Cons: Caller must handle `None` cases, no default behavior
- Cons: Requires separate existence check logic

### 2.3 Default Value Handling

**Decision**: `get_direction()` returns `INOUT` for missing pins (no exceptions)

**Alternatives Considered**:

1. **Raise KeyError**: Fail on missing pin
   - Pros: Explicit error handling, catches mistakes
   - Cons: Requires try/catch everywhere, verbose code

2. **Return Optional[PinDirection]**: Return None if not found
   - Pros: Type-safe, explicit missing case
   - Cons: Caller must handle None, no default behavior

3. **Return INOUT with warning**: Current approach
   - Pros: Always usable value, warnings for visibility
   - Cons: Could hide missing pin definitions

**Rationale**:
- **Robustness**: Netlist may have pins not in `.pindir` file (common case)
- **Usability**: Caller doesn't need error handling for normal operation
- **Visibility**: Debug logging + statistics (E01-F02-T03) provide feedback
- **Correctness**: INOUT is conservative (treats as bidirectional)

**Implementation**:
```python
def get_direction(self, pin_name: str) -> PinDirection:
    direction = self._direction_map.get_direction(pin_name)

    if not self.has_pin(pin_name):
        self._logger.debug(f"Pin '{pin_name}' not found, defaulting to INOUT")

    return direction
```

### 2.4 Immutability and Data Protection

**Decision**: Return copy of data in `get_all_pins()` to prevent mutation

**Rationale**:
- **Encapsulation**: Prevents external code from modifying internal state
- **Thread Safety**: Safe for concurrent reads
- **Predictability**: Service state never changes after creation

**Implementation**:
```python
def get_all_pins(self) -> Dict[str, PinDirection]:
    """Return defensive copy"""
    return self._direction_map.directions.copy()
```

**Trade-off**: Small performance cost (~O(n) copy), but n is typically small (<1000 pins).

---

## 3. Implementation Approach

### 3.1 File Structure

```
src/ink/
├── domain/
│   └── services/
│       └── pin_direction_service.py         # Protocol interface (NEW)
└── infrastructure/
    └── services/
        └── pin_direction_service_impl.py   # Implementation (NEW)

tests/
├── unit/
│   └── infrastructure/
│       └── services/
│           └── test_pin_direction_service.py  # Unit tests (NEW)
└── integration/
    └── infrastructure/
        └── test_pin_direction_integration.py  # Integration tests (NEW)
```

### 3.2 Development Phases

#### Phase 1: Protocol Definition (30 minutes)
**Goal**: Define domain service interface

**Deliverables**:
- `src/ink/domain/services/pin_direction_service.py`
- `PinDirectionService` protocol with 3 core methods
- Complete docstrings with Args, Returns documentation

**Success Criteria**:
- Protocol compiles without errors
- Type hints are correct and complete
- Docstrings follow Google style guide
- No dependencies on infrastructure layer

#### Phase 2: Service Implementation (1 hour)
**Goal**: Implement protocol using `PinDirectionMap`

**Deliverables**:
- `src/ink/infrastructure/services/pin_direction_service_impl.py`
- `PinDirectionServiceImpl` dataclass
- Implementation of all protocol methods
- Logging integration for debug warnings

**Success Criteria**:
- All protocol methods implemented correctly
- O(1) performance for `get_direction()` and `has_pin()`
- Logging works for missing pin warnings
- Type hints pass `mypy --strict` checks

#### Phase 3: Utility Methods (30 minutes)
**Goal**: Add convenience methods for statistics and filtering

**Deliverables**:
- `get_pin_count()` method
- `get_pins_by_direction()` method
- Unit tests for utility methods

**Success Criteria**:
- Methods provide correct results
- Performance is acceptable (O(n) for filtering)
- Methods are properly documented

#### Phase 4: Application Integration (1 hour)
**Goal**: Add service creation to application layer

**Deliverables**:
- Update `FileService` with `load_pin_directions()` method
- Example usage in docstrings
- Integration test demonstrating full workflow

**Success Criteria**:
- `FileService` can create service from `.pindir` file
- Error handling propagates correctly
- Integration test validates E2E flow

### 3.3 Testing Strategy

**Unit Tests** (`test_pin_direction_service.py`):
```python
class TestPinDirectionServiceImpl:
    @pytest.fixture
    def sample_direction_map(self):
        """Create sample direction map for testing"""
        directions = {
            'A': PinDirection.INPUT,
            'B': PinDirection.INPUT,
            'Y': PinDirection.OUTPUT,
        }
        return PinDirectionMap(directions=directions)

    @pytest.fixture
    def service(self, sample_direction_map):
        """Create service instance"""
        return PinDirectionServiceImpl(_direction_map=sample_direction_map)

    def test_get_direction_existing_pin(self, service):
        """Return correct direction for known pin"""
        assert service.get_direction('A') == PinDirection.INPUT
        assert service.get_direction('Y') == PinDirection.OUTPUT

    def test_get_direction_missing_pin_defaults_inout(self, service):
        """Return INOUT for unknown pin"""
        assert service.get_direction('UNKNOWN') == PinDirection.INOUT

    def test_get_direction_logs_missing_pin(self, service, caplog):
        """Log debug message for missing pin"""
        with caplog.at_level(logging.DEBUG):
            service.get_direction('UNKNOWN')
        assert 'not found' in caplog.text

    def test_has_pin_true_for_existing(self, service):
        """Return True for defined pins"""
        assert service.has_pin('A') is True
        assert service.has_pin('Y') is True

    def test_has_pin_false_for_missing(self, service):
        """Return False for undefined pins"""
        assert service.has_pin('UNKNOWN') is False

    def test_get_all_pins_returns_copy(self, service):
        """Returned dict is independent copy"""
        pins1 = service.get_all_pins()
        pins2 = service.get_all_pins()
        assert pins1 == pins2
        assert pins1 is not pins2  # Different objects

    def test_get_all_pins_modification_isolated(self, service):
        """Modifying returned dict doesn't affect service"""
        pins = service.get_all_pins()
        pins['NEW'] = PinDirection.INPUT
        assert not service.has_pin('NEW')

    def test_get_pin_count(self, service):
        """Return correct count of defined pins"""
        assert service.get_pin_count() == 3

    def test_get_pins_by_direction_input(self, service):
        """Filter pins by INPUT direction"""
        inputs = service.get_pins_by_direction(PinDirection.INPUT)
        assert set(inputs) == {'A', 'B'}

    def test_get_pins_by_direction_output(self, service):
        """Filter pins by OUTPUT direction"""
        outputs = service.get_pins_by_direction(PinDirection.OUTPUT)
        assert outputs == ['Y']

    def test_get_pins_by_direction_empty(self, service):
        """Return empty list if no pins match"""
        inouts = service.get_pins_by_direction(PinDirection.INOUT)
        assert inouts == []

    def test_empty_direction_map(self):
        """Handle empty direction mapping"""
        empty_map = PinDirectionMap(directions={})
        service = PinDirectionServiceImpl(_direction_map=empty_map)

        assert service.get_pin_count() == 0
        assert service.get_direction('A') == PinDirection.INOUT
        assert not service.has_pin('A')

    def test_large_direction_map_performance(self):
        """O(1) lookup with 1000+ pins"""
        # Create large direction map
        directions = {f'PIN_{i}': PinDirection.INPUT for i in range(1000)}
        large_map = PinDirectionMap(directions=directions)
        service = PinDirectionServiceImpl(_direction_map=large_map)

        # Benchmark lookup
        import time
        start = time.perf_counter()
        for _ in range(1000):
            service.get_direction('PIN_500')
        duration = time.perf_counter() - start

        # Should be <1ms for 1000 lookups (1μs per lookup)
        assert duration < 0.001
```

**Integration Tests** (`test_pin_direction_integration.py`):
```python
def test_full_workflow_parse_to_service(tmp_path):
    """Test complete workflow from file to service"""
    # Create sample .pindir file
    pindir_file = tmp_path / 'test.pindir'
    pindir_file.write_text("""
* Test pin directions
A  INPUT
B  INPUT
Y  OUTPUT
""")

    # Parse file
    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)

    # Create service
    service = PinDirectionServiceImpl(_direction_map=direction_map)

    # Verify end-to-end
    assert service.get_direction('A') == PinDirection.INPUT
    assert service.get_direction('B') == PinDirection.INPUT
    assert service.get_direction('Y') == PinDirection.OUTPUT
    assert service.get_pin_count() == 3

def test_file_service_integration(tmp_path):
    """Test FileService.load_pin_directions()"""
    pindir_file = tmp_path / 'design.pindir'
    pindir_file.write_text("A  INPUT\nY  OUTPUT\n")

    file_service = FileService()
    service = file_service.load_pin_directions(pindir_file)

    assert service.get_direction('A') == PinDirection.INPUT
    assert service.get_direction('Y') == PinDirection.OUTPUT
```

---

## 4. Key Design Decisions

### 4.1 Why Protocol Instead of ABC?

**Question**: Why use Protocol instead of traditional Abstract Base Class?

**Decision**: Protocol for structural typing and flexibility

**Rationale**:
- **DDD Alignment**: Protocols are perfect for domain service interfaces
- **Testing**: Easy to create inline mocks without inheritance
- **Flexibility**: Implementations don't need explicit inheritance
- **Modern Python**: Recommended pattern in Python 3.8+ codebases
- **Type Safety**: Full type checking without runtime overhead

**Example of Benefit**:
```python
# With Protocol - easy inline mock
class MockPinService:
    def get_direction(self, pin_name: str) -> PinDirection:
        return PinDirection.INPUT  # Simple mock

# Type checker accepts this as PinDirectionService
service: PinDirectionService = MockPinService()

# With ABC - requires inheritance
class MockPinService(PinDirectionServiceABC):
    def get_direction(self, pin_name: str) -> PinDirection:
        return PinDirection.INPUT
```

### 4.2 Why Separate Interface and Implementation?

**Question**: Why not just use `PinDirectionMap` directly?

**Decision**: Separate protocol (domain) from implementation (infrastructure)

**Rationale**:
- **Dependency Inversion**: Domain doesn't depend on infrastructure
- **Testability**: Domain code can use mock implementations
- **Flexibility**: Can swap implementations (e.g., database-backed in future)
- **Clean Architecture**: Follows port-adapter pattern
- **Evolution**: Can change implementation without affecting domain

**Future Scenarios This Enables**:
- Database-backed pin direction storage
- Remote pin direction service (API)
- Cached/optimized implementation
- Cell-type-specific override service

### 4.3 Why Include Utility Methods?

**Question**: Should utility methods be in protocol or just implementation?

**Decision**: Core methods in protocol, utilities in implementation

**Rationale**:
- **Protocol Stability**: Minimal protocol reduces breaking changes
- **Implementation Freedom**: Different implementations can have different utilities
- **Evolution**: Can add utilities without changing protocol
- **Clarity**: Core methods are required, utilities are optional

**Protocol (required)**:
- `get_direction()` - primary query
- `has_pin()` - existence check
- `get_all_pins()` - bulk retrieval

**Implementation (optional)**:
- `get_pin_count()` - convenience
- `get_pins_by_direction()` - filtering helper

### 4.4 Why Return Copy in get_all_pins()?

**Question**: Should `get_all_pins()` return reference or copy?

**Decision**: Return defensive copy

**Rationale**:
- **Immutability**: Prevents external mutation of service state
- **Safety**: No risk of concurrent modification
- **Predictability**: Service state is stable
- **Cost**: O(n) copy is acceptable for small pin counts (<1000)

**Trade-off**: Performance cost vs safety. Safety wins for MVP.

**Future Optimization**: If profiling shows this is bottleneck, can add read-only view.

---

## 5. Dependencies and Integration Points

### 5.1 Upstream Dependencies

**E01-F02-T01** (Pin Direction Parser):
- Provides `PinDirectionMap` data structure
- Service wraps this as data source

**Domain Layer**:
- Uses `PinDirection` enum (from E01-F02-T01)
- Defines `PinDirectionService` protocol (new)

### 5.2 Downstream Consumers

**E01-F03** (Graph Construction):
- Uses `PinDirectionService` to get pin directions
- Calls `get_direction()` when creating `Pin` entities

**Application Layer** (`FileService`):
- Orchestrates file loading and service creation
- Returns service to callers

**E01-F02-T03** (Default Direction Handling):
- Extends service with statistics tracking
- Uses same protocol interface

**Future Features**:
- Schematic rendering (direction affects symbol orientation)
- Expansion logic (direction determines fanin/fanout)
- Search/filter by pin direction

### 5.3 External Dependencies

**Python Standard Library**:
- `typing.Protocol`: Service interface definition
- `dataclasses`: Implementation structure
- `logging`: Debug warnings for missing pins
- `Dict`, `List`: Type hints

**No third-party dependencies** - Keeps service layer lightweight.

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: Performance Degradation with Large Pin Maps
**Impact**: Medium (slow queries affect responsiveness)
**Probability**: Low (typical designs have <1000 unique pins)

**Mitigation**:
- Use dictionary backing (O(1) lookup)
- Benchmark with 1000+ pins in tests
- Set SLA: <1μs per lookup

**Contingency**:
- If needed, add caching layer
- Use more efficient data structures (trie, perfect hash)

#### Risk 2: Memory Overhead from Defensive Copying
**Impact**: Low (minimal memory usage)
**Probability**: Low (copying is infrequent)

**Mitigation**:
- `get_all_pins()` is called rarely (mainly for debugging)
- Pin maps are small (<10KB typically)
- Modern Python dict copying is optimized

**Contingency**:
- Return read-only view instead of copy
- Document that returned dict must not be modified

### 6.2 Integration Risks

#### Risk 3: Protocol Mismatch Between Domain and Infrastructure
**Impact**: High (compilation errors, broken integration)
**Probability**: Low (type checking catches mismatches)

**Mitigation**:
- Use `mypy --strict` to verify protocol conformance
- Integration tests validate actual implementation
- Protocol is minimal (fewer methods = less to break)

**Contingency**:
- Add runtime protocol checking with `@runtime_checkable`
- Versioning on protocol if breaking changes needed

#### Risk 4: Logging Spam from Missing Pins
**Impact**: Medium (logs become unreadable)
**Probability**: Medium (designs may have many undefined pins)

**Mitigation**:
- Use DEBUG level (off by default in production)
- E01-F02-T03 adds statistics reporting (aggregated warnings)
- Log only first occurrence per pin

**Contingency**:
- Add rate limiting to logging
- Provide "quiet mode" configuration option

### 6.3 Design Risks

#### Risk 5: Protocol Too Minimal or Too Complex
**Impact**: Medium (future changes require protocol update)
**Probability**: Medium (predicting all future needs is hard)

**Mitigation**:
- Start minimal (3 core methods only)
- Add utilities to implementation (not protocol)
- Can extend protocol in future with backward compatibility

**Contingency**:
- Version protocol (PinDirectionServiceV1, V2)
- Use protocol composition for extensions

---

## 7. Testing and Validation

### 7.1 Test Coverage Goals

**Coverage Target**: 95%+ line coverage, 100% branch coverage

**Key Test Scenarios**:
1. Get direction for existing pin (happy path)
2. Get direction for missing pin (default behavior)
3. Check pin existence (true and false cases)
4. Get all pins (copy behavior)
5. Get pin count (empty and populated)
6. Filter pins by direction (each direction)
7. Logging behavior for missing pins
8. Large pin map performance
9. Empty pin map edge case
10. Defensive copy mutation isolation

### 7.2 Performance Validation

**Benchmark 1: Single Lookup**
- Operation: `get_direction('A')`
- Target: <1μs per call
- Method: 1000 lookups, measure average

**Benchmark 2: Existence Check**
- Operation: `has_pin('A')`
- Target: <1μs per call
- Method: 1000 checks, measure average

**Benchmark 3: Bulk Retrieval**
- Operation: `get_all_pins()` with 1000 pins
- Target: <1ms per call
- Method: 100 retrievals, measure average

**Measurement**:
```python
import timeit

def benchmark_get_direction():
    setup = """
from ink.infrastructure.services.pin_direction_service_impl import PinDirectionServiceImpl
from ink.infrastructure.parsing.pindir_parser import PinDirectionMap
from ink.domain.value_objects.pin_direction import PinDirection

directions = {f'PIN_{i}': PinDirection.INPUT for i in range(1000)}
direction_map = PinDirectionMap(directions=directions)
service = PinDirectionServiceImpl(_direction_map=direction_map)
"""
    stmt = "service.get_direction('PIN_500')"
    time = timeit.timeit(stmt, setup=setup, number=1000)
    print(f"Average lookup time: {time/1000*1000000:.2f}μs")
```

### 7.3 Integration Validation

**Validation 1: Parse → Service → Query**
```python
def test_end_to_end_workflow():
    # Parse .pindir file
    parser = PinDirectionParser()
    direction_map = parser.parse_file(Path("examples/standard_cells.pindir"))

    # Create service
    service = PinDirectionServiceImpl(_direction_map=direction_map)

    # Verify queries work
    assert service.get_direction('A') == PinDirection.INPUT
    assert service.has_pin('A')
    assert len(service.get_all_pins()) > 0
```

**Validation 2: FileService Integration**
```python
def test_file_service_creates_service():
    file_service = FileService()
    service = file_service.load_pin_directions(Path("examples/standard_cells.pindir"))

    assert isinstance(service, PinDirectionServiceImpl)
    assert service.get_pin_count() > 0
```

---

## 8. Definition of Done

### 8.1 Feature Completeness

- [ ] `PinDirectionService` protocol defined in domain layer
- [ ] Protocol has 3 core methods: `get_direction()`, `has_pin()`, `get_all_pins()`
- [ ] `PinDirectionServiceImpl` implements protocol in infrastructure layer
- [ ] Implementation includes utility methods: `get_pin_count()`, `get_pins_by_direction()`
- [ ] `FileService.load_pin_directions()` creates service from file

### 8.2 Behavior Requirements

- [ ] `get_direction()` returns correct direction for known pins
- [ ] `get_direction()` returns INOUT for unknown pins
- [ ] `get_direction()` logs debug message for missing pins
- [ ] `has_pin()` correctly identifies pin existence
- [ ] `get_all_pins()` returns defensive copy (modification isolated)
- [ ] `get_pin_count()` returns correct count
- [ ] `get_pins_by_direction()` filters correctly

### 8.3 Performance

- [ ] `get_direction()` is O(1) lookup (<1μs per call)
- [ ] `has_pin()` is O(1) lookup (<1μs per call)
- [ ] `get_all_pins()` copy overhead is acceptable (<1ms for 1000 pins)
- [ ] Service creation overhead is minimal (<1ms)
- [ ] Performance tests validate SLAs

### 8.4 Code Quality

- [ ] Protocol defined with complete type hints
- [ ] Implementation passes `mypy --strict` checks
- [ ] All public methods have docstrings (Google style)
- [ ] No circular dependencies between layers
- [ ] Code passes `ruff` linting
- [ ] 95%+ code coverage on implementation

### 8.5 Testing

- [ ] Unit tests for all protocol methods
- [ ] Unit tests for all utility methods
- [ ] Tests verify logging behavior
- [ ] Tests verify defensive copy behavior
- [ ] Integration test for parse → service workflow
- [ ] Integration test for FileService integration
- [ ] Performance benchmarks pass

### 8.6 Documentation

- [ ] Protocol docstring explains purpose and usage
- [ ] Method docstrings include Args, Returns sections
- [ ] Example usage code in module docstring
- [ ] Integration points documented
- [ ] Protocol versioning strategy documented

### 8.7 Integration Readiness

- [ ] Protocol API is stable and minimal
- [ ] Implementation ready for use in E01-F03
- [ ] FileService can create service from .pindir file
- [ ] Error handling propagates correctly
- [ ] No breaking changes to downstream consumers

---

## 9. Open Questions

### 9.1 Design Questions

**Q1: Should protocol include statistics methods?**
```python
def get_pin_count(self) -> int: ...
def get_pins_by_direction(self, direction: PinDirection) -> List[str]: ...
```

**Answer**: No, keep these in implementation only. Protocol should be minimal. Statistics are convenience methods, not core functionality.

**Q2: Should we support asynchronous queries?**
```python
async def get_direction_async(self, pin_name: str) -> PinDirection: ...
```

**Answer**: Not in MVP. Synchronous API is sufficient. Pin maps are in-memory, no I/O needed. Can add async variant in P1 if database backend is added.

**Q3: Should service be mutable (support adding pins at runtime)?**
```python
def add_pin(self, pin_name: str, direction: PinDirection) -> None: ...
```

**Answer**: No, immutable after creation. Simplifies reasoning and thread safety. If runtime modification needed, create new service instance.

### 9.2 Implementation Questions

**Q1: Should we cache negative lookups (missing pins)?**

**Answer**: Not in MVP. `get_direction()` is already O(1). Caching adds complexity for minimal benefit. E01-F02-T03 tracks missing pins for statistics.

**Q2: Should we validate pin names (format, length, characters)?**

**Answer**: Not in service. Parser handles format validation. Service is format-agnostic (accepts any string).

**Q3: Should we support case-insensitive pin lookups?**

**Answer**: No, pin names are case-sensitive (A vs a are different). Matches netlist behavior.

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Define protocol**: Create `PinDirectionService` in domain/services/
2. **Implement service**: Create `PinDirectionServiceImpl` in infrastructure/services/
3. **Write unit tests**: Cover all methods and edge cases
4. **Update FileService**: Add `load_pin_directions()` method
5. **Integration test**: Validate E2E workflow

### 10.2 Follow-up Tasks

- **E01-F02-T03**: Extend service with missing pin tracking
- **E01-F03**: Use service in graph construction for pin directions
- **Application layer**: Integrate service into design loading workflow

---

## Appendix A: Code Examples

### A.1 Protocol Definition

```python
# src/ink/domain/services/pin_direction_service.py
from typing import Protocol
from ink.domain.value_objects.pin_direction import PinDirection


class PinDirectionService(Protocol):
    """
    Domain service for querying pin directions.

    Pin directions are applied globally by pin name:
    - Pin "A" is INPUT for all cells that have an "A" pin
    - Pin "Y" is OUTPUT for all cells that have a "Y" pin

    This is a protocol (structural subtype) - implementations
    do not need to explicitly inherit from this class.
    """

    def get_direction(self, pin_name: str) -> PinDirection:
        """
        Get direction for a pin name.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            PinDirection for the pin, or INOUT if not found (default)
        """
        ...

    def has_pin(self, pin_name: str) -> bool:
        """
        Check if pin name exists in the direction mapping.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            True if pin direction is defined, False otherwise
        """
        ...

    def get_all_pins(self) -> dict[str, PinDirection]:
        """
        Get all pin name to direction mappings.

        Returns:
            Dictionary mapping pin names to their directions.
            Returned dictionary is a defensive copy - modifications
            will not affect the service's internal state.
        """
        ...
```

### A.2 Service Implementation

```python
# src/ink/infrastructure/services/pin_direction_service_impl.py
from dataclasses import dataclass, field
from typing import Dict, List
import logging

from ink.domain.value_objects.pin_direction import PinDirection
from ink.infrastructure.parsing.pindir_parser import PinDirectionMap


@dataclass
class PinDirectionServiceImpl:
    """
    Implementation of PinDirectionService using parsed pin direction data.

    Provides O(1) lookup for pin directions using in-memory dictionary.
    Conforms to PinDirectionService protocol via structural typing.

    Example:
        >>> parser = PinDirectionParser()
        >>> direction_map = parser.parse_file(Path("design.pindir"))
        >>> service = PinDirectionServiceImpl(_direction_map=direction_map)
        >>> service.get_direction("A")
        PinDirection.INPUT
    """

    _direction_map: PinDirectionMap
    _logger: logging.Logger = field(default_factory=lambda: logging.getLogger(__name__))

    def get_direction(self, pin_name: str) -> PinDirection:
        """Get direction for a pin name."""
        direction = self._direction_map.get_direction(pin_name)

        if not self.has_pin(pin_name):
            self._logger.debug(
                f"Pin '{pin_name}' not found in direction mapping. Defaulting to INOUT."
            )

        return direction

    def has_pin(self, pin_name: str) -> bool:
        """Check if pin name exists in the direction mapping."""
        return self._direction_map.has_pin(pin_name)

    def get_all_pins(self) -> Dict[str, PinDirection]:
        """Get all pin name to direction mappings (defensive copy)."""
        return self._direction_map.directions.copy()

    def get_pin_count(self) -> int:
        """
        Get total number of pins with defined directions.

        Returns:
            Number of pins in the mapping
        """
        return len(self._direction_map.directions)

    def get_pins_by_direction(self, direction: PinDirection) -> List[str]:
        """
        Get all pin names with a specific direction.

        Args:
            direction: Direction to filter by

        Returns:
            List of pin names with the specified direction
        """
        return [
            pin_name
            for pin_name, pin_dir in self._direction_map.directions.items()
            if pin_dir == direction
        ]
```

### A.3 FileService Integration

```python
# src/ink/application/services/file_service.py (enhancement)
from pathlib import Path
import logging

from ink.infrastructure.parsing.pindir_parser import PinDirectionParser
from ink.infrastructure.services.pin_direction_service_impl import PinDirectionServiceImpl


class FileService:
    """Application service for file operations"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def load_pin_directions(self, pindir_path: Path) -> PinDirectionServiceImpl:
        """
        Load pin directions from .pindir file.

        Args:
            pindir_path: Path to .pindir file

        Returns:
            PinDirectionService implementation

        Raises:
            FileNotFoundError: If file not found
            PinDirectionParseError: If parsing fails
        """
        parser = PinDirectionParser()
        direction_map = parser.parse_file(pindir_path)

        service = PinDirectionServiceImpl(_direction_map=direction_map)

        self.logger.info(
            f"Loaded {service.get_pin_count()} pin directions from {pindir_path}"
        )

        return service
```

### A.4 Usage Example

```python
# Example: Using service in graph construction
from pathlib import Path
from ink.application.services.file_service import FileService
from ink.domain.model.pin import Pin


def create_pin_with_direction(
    pin_name: str,
    file_service: FileService
) -> Pin:
    """Create Pin entity with direction from service"""
    # Load pin direction service
    service = file_service.load_pin_directions(Path("examples/standard_cells.pindir"))

    # Get direction
    direction = service.get_direction(pin_name)

    # Create pin entity
    pin = Pin(name=pin_name, direction=direction)

    return pin
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
