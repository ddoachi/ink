# E01-F02-T03: Default Direction Handling - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F02-T03 - Default Direction Handling
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Problem Context

Real-world netlists often contain pins that don't have explicit direction definitions in the `.pindir` file. This happens for several reasons:
1. **Incomplete pin files**: Users provide partial pin direction data
2. **Custom pins**: Design-specific pins not in standard cell library
3. **Power/ground pins**: VDD, VSS often omitted from pin direction files
4. **Tool variations**: Different EDA tools may use different pin names

The system must handle missing pin directions gracefully without:
- Failing to load the design
- Producing incorrect visualizations
- Hiding connectivity information
- Causing confusion for users

This task implements a comprehensive default handling strategy with visibility and feedback mechanisms.

### 1.2 Core Objectives

1. **Graceful Defaults**: Use INOUT for undefined pins (safe, conservative)
2. **Visibility**: Track and report which pins used defaults
3. **Statistics**: Provide pin direction coverage metrics
4. **User Feedback**: Warn users about missing pins without being noisy
5. **Configuration**: Design for future customization of default behavior

### 1.3 Success Metrics

- Zero design load failures due to missing pins
- 100% of queried pins return valid direction (default if needed)
- Missing pin statistics accurate and informative
- Warning messages clear and actionable
- <1% performance overhead for tracking

---

## 2. Architecture Decisions

### 2.1 Default Direction Strategy

**Decision**: Use `PinDirection.INOUT` as universal default

**Alternatives Considered**:

1. **Fail on missing pins**: Raise exception
   - Pros: Forces complete pin direction files
   - Cons: Blocks users with partial data, poor UX

2. **Infer from context**: Guess based on connected pins
   - Pros: Potentially more accurate
   - Cons: Complex, unreliable, confusing when wrong

3. **Prompt user**: Ask for direction interactively
   - Pros: Accurate, user-controlled
   - Cons: Breaks batch processing, poor for large pin counts

4. **Use INOUT (bidirectional)**: Current approach
   - Pros: Conservative, always safe, allows connectivity
   - Cons: May be less accurate than actual direction

**Rationale**:
- **Safety**: INOUT is most conservative (treats as both input and output)
- **Rendering**: Layout algorithms handle INOUT correctly (no special cases)
- **Expansion**: Fanin/fanout logic includes INOUT in both directions (no lost connectivity)
- **Usability**: Design loads successfully, user can fix later
- **Correctness**: Better to show too many connections than hide real ones

**Implementation**:
```python
def get_direction(self, pin_name: str) -> PinDirection:
    """Always returns valid direction, INOUT if not defined"""
    if pin_name not in self.directions:
        return PinDirection.INOUT  # Safe default
    return self.directions[pin_name]
```

### 2.2 Missing Pin Tracking Design

**Decision**: Track accessed missing pins in `Set` for statistics

**Why Track?**
- Identify incomplete `.pindir` files
- Calculate coverage metrics (defined / total)
- Generate "missing pins report" for user to populate
- Validate pin direction file quality

**Data Structure**:
```python
@dataclass
class PinDirectionMap:
    directions: Dict[str, PinDirection]
    _accessed_missing_pins: Set[str] = field(default_factory=set, init=False)
```

**Tracking Logic**:
```python
def get_direction(self, pin_name: str) -> PinDirection:
    if pin_name not in self.directions:
        # Track this missing pin
        self._accessed_missing_pins.add(pin_name)
        return PinDirection.INOUT
    return self.directions[pin_name]
```

**Performance**: `Set.add()` is O(1), minimal overhead.

### 2.3 Warning and Reporting Strategy

**Decision**: Debug-level per-pin warnings, info-level summary statistics

**Warning Levels**:

1. **Per-Pin Warnings** (DEBUG level):
   ```python
   logger.debug(f"Pin '{pin_name}' not found, defaulting to INOUT")
   ```
   - Disabled by default in production
   - Useful for development and troubleshooting
   - Prevents log spam with hundreds of missing pins

2. **Summary Statistics** (INFO level):
   ```python
   logger.info(f"Pin Direction Statistics:\n"
               f"  - Defined pins: 150\n"
               f"  - Missing pins accessed: 23\n"
               f"  - Total unique pins: 173")
   ```
   - Shown once after design load
   - Provides visibility into pin direction coverage
   - Actionable feedback for user

3. **Missing Pin List** (WARNING level):
   ```python
   logger.warning(f"Missing pins (defaulted to INOUT): A, B, C, ... (23 total)")
   ```
   - Shows sample of missing pins (first 10)
   - Indicates total count if more than sample
   - Helps user identify what to add to `.pindir` file

**Rationale**:
- **No log spam**: Debug level avoids console noise
- **Actionable summary**: Info/warning levels show aggregate view
- **User-friendly**: Clear what's missing, what to do about it

### 2.4 Statistics API Design

**Decision**: Provide programmatic access to statistics via methods

**Statistics Methods**:

1. **`get_missing_pin_stats() -> Dict[str, int]`**
   - Returns structured statistics dictionary
   - Keys: `defined_pins`, `missing_pins_accessed`, `total_unique_pins`
   - Use case: Programmatic validation, coverage calculation

2. **`get_missing_pins() -> Set[str]`**
   - Returns set of all missing pin names queried
   - Use case: Generate report, export to file for user editing

**Example Usage**:
```python
stats = direction_map.get_missing_pin_stats()
coverage = stats['defined_pins'] / stats['total_unique_pins'] * 100
print(f"Pin direction coverage: {coverage:.1f}%")

# Export missing pins for user to fill in
missing = direction_map.get_missing_pins()
with open("missing_pins.txt", "w") as f:
    for pin in sorted(missing):
        f.write(f"{pin}\tINOUT\n")
```

### 2.5 Future Configuration Design

**Decision**: Design for future `PinDirectionConfig` without implementing in MVP

**Planned Configuration Options** (P1 feature):
```python
@dataclass
class PinDirectionConfig:
    # Default direction for missing pins
    default_direction: PinDirection = PinDirection.INOUT

    # Warn on missing pins
    warn_on_missing: bool = True

    # Fail on missing pins instead of defaulting
    strict_mode: bool = False

    # Log level for missing pin warnings
    missing_pin_log_level: str = "DEBUG"

    # Heuristic inference rules
    infer_from_name: bool = False  # "CLK" → INPUT, "OUT" → OUTPUT
```

**MVP Implementation**: Hardcoded INOUT default, INFO-level statistics.

**Rationale**:
- Keep MVP simple and focused
- Design allows easy addition of config in P1
- Most users don't need customization initially
- Can gather user feedback before finalizing config options

---

## 3. Implementation Approach

### 3.1 File Structure

```
src/ink/
├── infrastructure/
│   ├── parsing/
│   │   └── pindir_parser.py           # Enhanced with tracking (MODIFIED)
│   └── services/
│       └── pin_direction_service_impl.py  # Uses tracking (MODIFIED)
└── application/
    └── services/
        └── file_service.py             # Adds statistics reporting (MODIFIED)

tests/
├── unit/
│   └── infrastructure/
│       └── parsing/
│           └── test_pin_direction_defaults.py  # Default behavior tests (NEW)
└── integration/
    └── infrastructure/
        └── test_pin_direction_reporting.py     # Statistics reporting tests (NEW)
```

### 3.2 Development Phases

#### Phase 1: Tracking Implementation (1 hour)
**Goal**: Add missing pin tracking to `PinDirectionMap`

**Deliverables**:
- Add `_accessed_missing_pins: Set[str]` field to `PinDirectionMap`
- Update `get_direction()` to track missing pins
- Implement `get_missing_pin_stats()` method
- Implement `get_missing_pins()` method

**Success Criteria**:
- Missing pins accumulated in set correctly
- Statistics calculation accurate
- Returned set is defensive copy (immutable)
- No performance degradation (<1% overhead)

#### Phase 2: Statistics Reporting (30 minutes)
**Goal**: Add summary reporting to application layer

**Deliverables**:
- `FileService._report_pin_direction_stats()` method
- Summary logging at INFO level
- Missing pin list logging at WARNING level
- Integration into design loading workflow

**Success Criteria**:
- Statistics logged after design load
- Missing pins shown with sample (max 10)
- Logging format is clear and readable
- No duplicate warnings (logged once)

#### Phase 3: Testing (30 minutes)
**Goal**: Comprehensive test coverage

**Deliverables**:
- Unit tests for tracking behavior
- Unit tests for statistics calculation
- Integration tests with partial `.pindir` files
- Tests verify logging output

**Success Criteria**:
- 95%+ code coverage on tracking code
- All edge cases covered (empty, all missing, all defined)
- Logging tests verify message content
- Performance tests show minimal overhead

### 3.3 Testing Strategy

**Unit Tests** (`test_pin_direction_defaults.py`):
```python
class TestPinDirectionDefaultHandling:
    def test_get_direction_missing_returns_inout(self):
        """Missing pin returns INOUT default"""
        direction_map = PinDirectionMap(directions={})
        assert direction_map.get_direction('UNKNOWN') == PinDirection.INOUT

    def test_missing_pin_tracked_on_access(self):
        """Missing pin added to tracking set"""
        direction_map = PinDirectionMap(directions={'A': PinDirection.INPUT})
        direction_map.get_direction('UNKNOWN')

        assert 'UNKNOWN' in direction_map.get_missing_pins()
        assert 'A' not in direction_map.get_missing_pins()

    def test_missing_pin_tracked_once(self):
        """Multiple accesses to same pin tracked once"""
        direction_map = PinDirectionMap(directions={})
        direction_map.get_direction('PIN_A')
        direction_map.get_direction('PIN_A')
        direction_map.get_direction('PIN_A')

        assert len(direction_map.get_missing_pins()) == 1

    def test_get_missing_pin_stats_empty(self):
        """Statistics correct for empty map"""
        direction_map = PinDirectionMap(directions={})
        stats = direction_map.get_missing_pin_stats()

        assert stats['defined_pins'] == 0
        assert stats['missing_pins_accessed'] == 0
        assert stats['total_unique_pins'] == 0

    def test_get_missing_pin_stats_all_defined(self):
        """Statistics correct when all pins defined"""
        direction_map = PinDirectionMap(directions={
            'A': PinDirection.INPUT,
            'B': PinDirection.OUTPUT,
        })
        direction_map.get_direction('A')
        direction_map.get_direction('B')
        stats = direction_map.get_missing_pin_stats()

        assert stats['defined_pins'] == 2
        assert stats['missing_pins_accessed'] == 0
        assert stats['total_unique_pins'] == 2

    def test_get_missing_pin_stats_mixed(self):
        """Statistics correct with mix of defined and missing"""
        direction_map = PinDirectionMap(directions={
            'A': PinDirection.INPUT,
            'B': PinDirection.OUTPUT,
        })
        direction_map.get_direction('A')      # Defined
        direction_map.get_direction('B')      # Defined
        direction_map.get_direction('C')      # Missing
        direction_map.get_direction('D')      # Missing
        stats = direction_map.get_missing_pin_stats()

        assert stats['defined_pins'] == 2
        assert stats['missing_pins_accessed'] == 2
        assert stats['total_unique_pins'] == 4

    def test_get_missing_pins_returns_copy(self):
        """Returned set is defensive copy"""
        direction_map = PinDirectionMap(directions={})
        direction_map.get_direction('A')

        pins1 = direction_map.get_missing_pins()
        pins2 = direction_map.get_missing_pins()

        assert pins1 == pins2
        assert pins1 is not pins2  # Different objects

    def test_get_missing_pins_modification_isolated(self):
        """Modifying returned set doesn't affect tracking"""
        direction_map = PinDirectionMap(directions={})
        direction_map.get_direction('A')

        pins = direction_map.get_missing_pins()
        pins.add('B')  # Modify copy

        # Original tracking unchanged
        assert 'B' not in direction_map.get_missing_pins()
```

**Integration Tests** (`test_pin_direction_reporting.py`):
```python
def test_statistics_reporting_logged(tmp_path, caplog):
    """Statistics logged after design load"""
    # Create partial .pindir file
    pindir_file = tmp_path / 'partial.pindir'
    pindir_file.write_text("A  INPUT\nB  OUTPUT\n")

    # Parse and create service
    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)
    service = PinDirectionServiceImpl(_direction_map=direction_map)

    # Access some missing pins
    service.get_direction('A')  # Defined
    service.get_direction('C')  # Missing
    service.get_direction('D')  # Missing

    # Report statistics
    file_service = FileService()
    with caplog.at_level(logging.INFO):
        file_service._report_pin_direction_stats(service)

    # Verify logging
    assert 'Defined pins: 2' in caplog.text
    assert 'Missing pins accessed: 2' in caplog.text
    assert 'Total unique pins: 4' in caplog.text

def test_missing_pins_warning_logged(tmp_path, caplog):
    """Missing pins listed in warning"""
    pindir_file = tmp_path / 'partial.pindir'
    pindir_file.write_text("A  INPUT\n")

    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)
    service = PinDirectionServiceImpl(_direction_map=direction_map)

    # Access missing pins
    for pin in ['B', 'C', 'D', 'E', 'F']:
        service.get_direction(pin)

    # Report
    file_service = FileService()
    with caplog.at_level(logging.WARNING):
        file_service._report_pin_direction_stats(service)

    # Verify warning message
    assert 'not found in direction file' in caplog.text
    assert 'B' in caplog.text  # Sample pins shown

def test_missing_pins_sample_limit(tmp_path, caplog):
    """Only first 10 missing pins shown"""
    pindir_file = tmp_path / 'empty.pindir'
    pindir_file.write_text("* Empty\n")

    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)
    service = PinDirectionServiceImpl(_direction_map=direction_map)

    # Access 20 missing pins
    for i in range(20):
        service.get_direction(f'PIN_{i}')

    # Report
    file_service = FileService()
    with caplog.at_level(logging.WARNING):
        file_service._report_pin_direction_stats(service)

    # Verify "and 10 more" message
    assert 'and 10 more' in caplog.text

def test_large_design_performance(tmp_path):
    """Tracking overhead minimal for large designs"""
    import time

    # Create .pindir with 500 pins
    pindir_file = tmp_path / 'large.pindir'
    with open(pindir_file, 'w') as f:
        for i in range(500):
            f.write(f"DEFINED_{i}  INPUT\n")

    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)

    # Access 500 defined + 500 missing pins
    start = time.perf_counter()
    for i in range(500):
        direction_map.get_direction(f'DEFINED_{i}')
    for i in range(500):
        direction_map.get_direction(f'MISSING_{i}')
    duration = time.perf_counter() - start

    # Should be <10ms total (tracking overhead ~1%)
    assert duration < 0.01

    # Verify tracking
    stats = direction_map.get_missing_pin_stats()
    assert stats['defined_pins'] == 500
    assert stats['missing_pins_accessed'] == 500
    assert stats['total_unique_pins'] == 1000
```

---

## 4. Key Design Decisions

### 4.1 Why Track Missing Pins at All?

**Question**: Why not just return INOUT and ignore tracking?

**Decision**: Track for visibility and data quality feedback

**Rationale**:
- **User Awareness**: Users should know their `.pindir` file is incomplete
- **Data Quality**: Helps identify issues with pin direction files
- **Actionable**: User can export missing pins and populate them
- **Coverage Metrics**: Quantifies how complete the pin data is

**Cost**: Minimal - `Set.add()` is O(1), memory is ~100 bytes per pin name

**Benefit**: Much better user experience, actionable feedback

### 4.2 Why Default to INOUT Instead of INPUT or OUTPUT?

**Question**: Why not guess INPUT vs OUTPUT from context?

**Decision**: Always use INOUT (bidirectional)

**Rationale**:
- **Conservative**: Treats pin as both input and output
- **Safe for Rendering**: Layout algorithms handle INOUT correctly
- **Safe for Expansion**: Fanin/fanout includes pin in both directions
- **No Hidden Connections**: Better to show too many than miss real ones
- **Predictable**: User always knows what default means

**Alternative Rejected**: Heuristic-based inference (e.g., "CLK" → INPUT)
- Pros: Potentially more accurate
- Cons: Unreliable, confusing when wrong, hard to maintain rules
- Conclusion: Explicit is better than implicit (Zen of Python)

### 4.3 Why Use Set for Tracking Instead of List?

**Question**: Why `Set[str]` instead of `List[str]`?

**Decision**: Set for automatic deduplication and O(1) operations

**Rationale**:
- **Deduplication**: Same pin accessed multiple times tracked once
- **Performance**: `add()` is O(1), `in` check is O(1)
- **Memory**: No duplicates, minimal overhead
- **Order**: Don't care about access order, just unique pins

**Alternative**: List with manual deduplication
- Cons: O(n) membership check, duplicates need manual filtering
- Conclusion: Set is correct data structure for this use case

### 4.4 Why DEBUG Level for Per-Pin Warnings?

**Question**: Should missing pin warnings be INFO, WARNING, or DEBUG?

**Decision**: DEBUG level for per-pin, WARNING for summary

**Rationale**:
- **Per-Pin DEBUG**: Avoids log spam (could be hundreds of missing pins)
- **Summary WARNING**: Shows aggregate issue, actionable feedback
- **Production**: DEBUG disabled by default, WARNING visible
- **Development**: Can enable DEBUG to see all missing pins

**Example Scenario**: Design with 1000 pins, 200 missing
- DEBUG: Would generate 200 warning lines (log spam)
- WARNING: Single warning with summary and sample (clean)

---

## 5. Dependencies and Integration Points

### 5.1 Upstream Dependencies

**E01-F02-T01** (Pin Direction Parser):
- Provides `PinDirectionMap` class (to be extended)
- Default behavior already implemented

**E01-F02-T02** (Direction Lookup Service):
- Uses `PinDirectionMap` with tracking
- Service logging calls tracking methods

### 5.2 Downstream Consumers

**E01-F03** (Graph Construction):
- Relies on default behavior working correctly
- Uses statistics to validate pin direction coverage

**Application Layer** (`FileService`):
- Calls `_report_pin_direction_stats()` after design load
- Displays statistics to user

**Future UI**:
- May show coverage % in status bar
- Could highlight pins using defaults in property panel
- Export missing pins feature

### 5.3 External Dependencies

**Python Standard Library**:
- `typing.Set`: Type hint for missing pins
- `dataclasses.field`: Default factory for set
- `logging`: Statistics reporting

**No third-party dependencies** - Keeps implementation lightweight.

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: Tracking Memory Overhead
**Impact**: Low (memory usage increases)
**Probability**: Low (typical designs have <1000 unique pins)

**Mitigation**:
- Set stores only pin names (strings), ~100 bytes each
- 1000 missing pins = ~100KB overhead (negligible)
- Memory test validates overhead acceptable

**Contingency**:
- If memory is concern, make tracking optional
- Add configuration flag to disable tracking

#### Risk 2: Performance Impact on Hot Path
**Impact**: Low (get_direction called frequently)
**Probability**: Low (Set.add is O(1))

**Mitigation**:
- Benchmark with tracking vs without
- Target: <1% performance overhead
- Set operations are highly optimized in Python

**Contingency**:
- Lazy tracking (only track if statistics requested)
- Cache missing pin lookups to avoid repeated Set.add

### 6.2 Usability Risks

#### Risk 3: Warning Fatigue
**Impact**: Medium (users ignore important warnings)
**Probability**: Medium (if too many warnings)

**Mitigation**:
- Use DEBUG for per-pin (off by default)
- Summary WARNING shown once (not per pin)
- Sample limit (10 pins) prevents long warning messages

**Contingency**:
- Add "quiet mode" configuration option
- Allow users to suppress warnings for known-incomplete files

#### Risk 4: Confusing Coverage Metrics
**Impact**: Low (users misinterpret statistics)
**Probability**: Medium (coverage % might be unclear)

**Mitigation**:
- Clear metric names: `defined_pins`, `missing_pins_accessed`
- Documentation explains what metrics mean
- Example interpretations in docstring

**Example**:
```
Pin Direction Statistics:
  - Defined pins: 150       (pins in .pindir file)
  - Missing pins accessed: 23  (pins in netlist but not in .pindir)
  - Total unique pins: 173  (all pins in netlist)
Coverage: 86.7% (150/173)
```

### 6.3 Design Risks

#### Risk 5: Future Configuration Compatibility
**Impact**: Medium (config changes break API)
**Probability**: Low (MVP design allows clean extension)

**Mitigation**:
- Design MVP with future config in mind
- Keep config separate from core logic
- Use dependency injection for config

**Contingency**:
- Version configuration schema
- Deprecate old config gracefully

---

## 7. Testing and Validation

### 7.1 Test Coverage Goals

**Coverage Target**: 95%+ line coverage, 100% branch coverage

**Key Test Scenarios**:
1. Missing pin returns INOUT (default behavior)
2. Missing pin tracked in set
3. Multiple accesses tracked once (deduplication)
4. Statistics calculation correct (all cases)
5. Empty pin map statistics
6. All pins defined statistics
7. Mixed defined/missing statistics
8. Defensive copy for get_missing_pins()
9. Logging output verification
10. Performance overhead validation

### 7.2 Edge Case Testing

**Edge Case 1: No .pindir File (All Pins Missing)**
```python
def test_no_pindir_file_all_default():
    # Empty direction map
    direction_map = PinDirectionMap(directions={})

    # All queries return INOUT
    for pin in ['A', 'B', 'C', 'D']:
        assert direction_map.get_direction(pin) == PinDirection.INOUT

    # Statistics show 0% coverage
    stats = direction_map.get_missing_pin_stats()
    assert stats['defined_pins'] == 0
    assert stats['missing_pins_accessed'] == 4
```

**Edge Case 2: Complete .pindir File (No Missing Pins)**
```python
def test_complete_pindir_no_missing():
    # All pins defined
    direction_map = PinDirectionMap(directions={
        'A': PinDirection.INPUT,
        'B': PinDirection.OUTPUT,
    })

    # Query only defined pins
    direction_map.get_direction('A')
    direction_map.get_direction('B')

    # Statistics show 100% coverage
    stats = direction_map.get_missing_pin_stats()
    assert stats['defined_pins'] == 2
    assert stats['missing_pins_accessed'] == 0
```

**Edge Case 3: Partial .pindir File (50% Coverage)**
```python
def test_partial_pindir_file():
    # Half pins defined
    direction_map = PinDirectionMap(directions={
        'A': PinDirection.INPUT,
        'B': PinDirection.OUTPUT,
    })

    # Query mixed
    direction_map.get_direction('A')  # Defined
    direction_map.get_direction('C')  # Missing
    direction_map.get_direction('D')  # Missing

    # Statistics show 50% coverage (2/4)
    stats = direction_map.get_missing_pin_stats()
    assert stats['defined_pins'] == 2
    assert stats['missing_pins_accessed'] == 2
    assert stats['total_unique_pins'] == 4
```

### 7.3 Performance Validation

**Benchmark: Tracking Overhead**
```python
import time

def benchmark_tracking_overhead():
    # Setup
    direction_map = PinDirectionMap(directions={})

    # Measure with tracking
    start = time.perf_counter()
    for i in range(1000):
        direction_map.get_direction(f'PIN_{i}')
    duration = time.perf_counter() - start

    # Should be <10ms total (<10μs per call)
    assert duration < 0.01
    print(f"1000 missing pin accesses: {duration*1000:.2f}ms")
```

---

## 8. Definition of Done

### 8.1 Feature Completeness

- [ ] `PinDirectionMap` tracks missing pins in `_accessed_missing_pins` set
- [ ] `get_direction()` adds missing pins to tracking set
- [ ] `get_missing_pin_stats()` returns accurate statistics
- [ ] `get_missing_pins()` returns defensive copy of set
- [ ] `FileService._report_pin_direction_stats()` logs summary

### 8.2 Behavior Requirements

- [ ] Missing pins return `PinDirection.INOUT` default
- [ ] Missing pins tracked on first access
- [ ] Multiple accesses to same pin tracked once (deduplication)
- [ ] Statistics include defined count, missing count, total count
- [ ] Missing pins set returned as copy (immutable)

### 8.3 Logging Requirements

- [ ] Per-pin warnings at DEBUG level (optional)
- [ ] Summary statistics at INFO level
- [ ] Missing pin list at WARNING level
- [ ] Sample limit of 10 pins for missing pin list
- [ ] Count of additional pins shown if >10 missing

### 8.4 Performance

- [ ] Tracking overhead <1% (measured with 1000 pins)
- [ ] `get_direction()` still O(1) with tracking
- [ ] `get_missing_pin_stats()` is O(1) calculation
- [ ] Memory overhead scales linearly with unique missing pins

### 8.5 Testing

- [ ] Unit tests for default behavior
- [ ] Unit tests for tracking behavior
- [ ] Unit tests for statistics calculation
- [ ] Integration tests with partial .pindir files
- [ ] Tests verify logging output
- [ ] Performance tests validate overhead
- [ ] 95%+ code coverage

### 8.6 Code Quality

- [ ] Type hints on all new methods
- [ ] Docstrings on all new methods (Google style)
- [ ] No breaking changes to existing API
- [ ] Code passes `mypy --strict` checks
- [ ] Code passes `ruff` linting

### 8.7 Documentation

- [ ] Statistics methods documented with examples
- [ ] Logging format documented
- [ ] Coverage calculation explained
- [ ] Example usage in docstrings

---

## 9. Open Questions

### 9.1 Design Questions

**Q1: Should we support heuristic-based direction inference?**
```python
# e.g., "CLK" → INPUT, "OUT" → OUTPUT, "DATA_*" → INOUT
```

**Answer**: Not in MVP. Too unreliable and confusing when wrong. Explicit `.pindir` file is better. Could add as optional P1 feature with clear documentation.

**Q2: Should we allow users to override defaults at runtime?**
```python
service.set_default_direction(PinDirection.INPUT)  # Change default from INOUT
```

**Answer**: Not in MVP. Design for future config, but keep simple for now. Most users won't need customization.

**Q3: Should statistics persist across sessions?**

**Answer**: No, statistics are session-specific (reset on new design load). Could save to design metadata in future.

### 9.2 Implementation Questions

**Q1: Should we cache negative lookups to avoid repeated tracking?**

**Answer**: No, Set.add() already handles duplicates efficiently (O(1)). Caching adds complexity for no benefit.

**Q2: Should we expose tracking as public API or keep internal?**

**Answer**: Expose via `get_missing_pins()` and `get_missing_pin_stats()`. Users may want programmatic access for validation or reporting.

**Q3: Should we validate tracked pins against netlist?**

**Answer**: Not in this task. Validation happens in graph construction (E01-F03). Tracking is format-agnostic.

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Extend PinDirectionMap**: Add tracking field and methods
2. **Update tests**: Add default behavior and tracking tests
3. **Add reporting**: Implement statistics logging in FileService
4. **Integration test**: Validate with partial .pindir file
5. **Performance test**: Verify tracking overhead acceptable

### 10.2 Follow-up Tasks

- **E01-F03**: Use default behavior during graph construction
- **Documentation**: Add user guide section on pin direction files
- **Future**: Implement `PinDirectionConfig` for customization (P1)

---

## Appendix A: Code Examples

### A.1 Enhanced PinDirectionMap

```python
# src/ink/infrastructure/parsing/pindir_parser.py (enhanced)
from dataclasses import dataclass, field
from typing import Dict, Set
from ink.domain.value_objects.pin_direction import PinDirection


@dataclass
class PinDirectionMap:
    """
    Mapping of pin names to their directions with default handling.

    Tracks missing pin accesses for statistics and reporting.
    """

    directions: Dict[str, PinDirection]
    _accessed_missing_pins: Set[str] = field(default_factory=set, init=False)

    def get_direction(self, pin_name: str) -> PinDirection:
        """
        Get direction for pin name, default to INOUT if not found.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            PinDirection for the pin, or INOUT if not found
        """
        if pin_name not in self.directions:
            # Track missing pin for statistics
            self._accessed_missing_pins.add(pin_name)
            return PinDirection.INOUT

        return self.directions[pin_name]

    def has_pin(self, pin_name: str) -> bool:
        """
        Check if pin name exists in the mapping.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            True if pin direction is defined, False otherwise
        """
        return pin_name in self.directions

    def get_missing_pin_stats(self) -> Dict[str, int]:
        """
        Get statistics on missing pin direction queries.

        Returns:
            Dictionary with statistics:
            - 'defined_pins': Number of pins with explicit directions
            - 'missing_pins_accessed': Number of unique missing pins queried
            - 'total_unique_pins': Total unique pins accessed

        Example:
            >>> stats = direction_map.get_missing_pin_stats()
            >>> coverage = stats['defined_pins'] / stats['total_unique_pins'] * 100
            >>> print(f"Coverage: {coverage:.1f}%")
        """
        return {
            'defined_pins': len(self.directions),
            'missing_pins_accessed': len(self._accessed_missing_pins),
            'total_unique_pins': len(self.directions) + len(self._accessed_missing_pins),
        }

    def get_missing_pins(self) -> Set[str]:
        """
        Get set of all pin names that were queried but not defined.

        Returns:
            Set of missing pin names (defensive copy)

        Example:
            >>> missing = direction_map.get_missing_pins()
            >>> with open("missing_pins.txt", "w") as f:
            ...     for pin in sorted(missing):
            ...         f.write(f"{pin}\\tINOUT\\n")
        """
        return self._accessed_missing_pins.copy()
```

### A.2 Statistics Reporting

```python
# src/ink/application/services/file_service.py (enhancement)
import logging
from pathlib import Path
from typing import Tuple

from ink.domain.model.design import Design
from ink.infrastructure.services.pin_direction_service_impl import PinDirectionServiceImpl


class FileService:
    """Application service for file operations"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def load_design_with_directions(
        self,
        cdl_path: Path,
        pindir_path: Path
    ) -> Tuple[Design, PinDirectionServiceImpl]:
        """
        Load design and pin directions, reporting missing direction statistics.

        Args:
            cdl_path: Path to CDL netlist file
            pindir_path: Path to pin direction file

        Returns:
            Tuple of (Design, PinDirectionService)
        """
        # Load pin directions
        pin_service = self.load_pin_directions(pindir_path)

        # Load and parse netlist (uses pin_service to set directions)
        design = self.load_netlist(cdl_path, pin_service)

        # Report statistics after design is fully loaded
        self._report_pin_direction_stats(pin_service)

        return design, pin_service

    def _report_pin_direction_stats(self, pin_service: PinDirectionServiceImpl):
        """
        Log statistics about pin direction usage and missing pins.

        Args:
            pin_service: Pin direction service with statistics
        """
        stats = pin_service._direction_map.get_missing_pin_stats()
        missing_pins = pin_service._direction_map.get_missing_pins()

        self.logger.info(
            f"Pin Direction Statistics:\n"
            f"  - Defined pins: {stats['defined_pins']}\n"
            f"  - Missing pins accessed: {stats['missing_pins_accessed']}\n"
            f"  - Total unique pins: {stats['total_unique_pins']}"
        )

        if missing_pins:
            # Show first 10 missing pins as examples
            sample_pins = sorted(missing_pins)[:10]
            more_count = len(missing_pins) - len(sample_pins)

            self.logger.warning(
                f"The following pins were not found in direction file "
                f"(defaulted to INOUT): {', '.join(sample_pins)}"
                + (f" and {more_count} more" if more_count > 0 else "")
            )
```

### A.3 Usage Example

```python
# Example: Load design and see statistics
from pathlib import Path
from ink.application.services.file_service import FileService

# Initialize service
file_service = FileService()

# Load design with pin directions
design, pin_service = file_service.load_design_with_directions(
    cdl_path=Path("netlist.ckt"),
    pindir_path=Path("partial.pindir")
)

# Console output:
# INFO: Pin Direction Statistics:
#   - Defined pins: 150
#   - Missing pins accessed: 23
#   - Total unique pins: 173
# WARNING: The following pins were not found in direction file (defaulted to INOUT):
#   CLK, DATA_IN, ENABLE, RESET, VDD, VSS, GND, AVDD, AVSS, DVDD and 13 more

# Programmatic access to statistics
stats = pin_service._direction_map.get_missing_pin_stats()
coverage = stats['defined_pins'] / stats['total_unique_pins'] * 100
print(f"Pin direction coverage: {coverage:.1f}%")  # 86.7%

# Export missing pins for user to populate
missing = pin_service._direction_map.get_missing_pins()
with open("missing_pins.txt", "w") as f:
    for pin in sorted(missing):
        f.write(f"{pin}\tINOUT\n")
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
