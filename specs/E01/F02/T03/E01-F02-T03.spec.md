# Spec: E01-F02-T03 - Default Direction Handling

## Metadata
- **ID**: E01-F02-T03
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E01-F02](../E01-F02.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 2
- **Actual Hours**:
- **Effort**: Small
- **Tags**: [domain, error-handling, configuration]

---

## 1. Overview

### 1.1 Problem Statement
Not all pins in a netlist may have explicit direction definitions in the `.pindir` file. The system needs a robust default handling strategy to gracefully handle missing pin directions without failing or producing incorrect visualizations. The default behavior must be predictable, safe, and provide appropriate warnings to users.

### 1.2 Goals
- Define default direction behavior for missing pin definitions (INOUT)
- Implement warning system for missing pin directions
- Provide configuration options for default behavior (future)
- Track and report statistics on default usage
- Ensure rendering and expansion logic work correctly with defaults

---

## 2. Technical Requirements

### 2.1 Default Direction Strategy

**Default Value**: `PinDirection.INOUT`

**Rationale**:
- **Conservative**: INOUT is the safest assumption (bidirectional)
- **Rendering**: Layout algorithms can handle INOUT pins
- **Expansion**: Fanin/fanout logic treats INOUT as both input and output
- **Correctness**: Better to show connections than hide them due to missing data

### 2.2 Warning System

**Location**: Integrated into `PinDirectionServiceImpl` and `PinDirectionMap`

**Warning Strategy**:
```python
# In PinDirectionMap.get_direction()
def get_direction(self, pin_name: str) -> PinDirection:
    """Get direction for pin name, default to INOUT if not found"""
    if pin_name not in self.directions:
        # Default behavior: return INOUT
        return PinDirection.INOUT
    return self.directions[pin_name]
```

**Warning Levels**:
- **Debug**: Per-pin warning for each missing direction query (verbose)
- **Info**: Summary statistics at end of parsing (recommended)
- **Warning**: Only if configured to treat missing directions as warnings

### 2.3 Missing Direction Tracking

**Enhancement to `PinDirectionMap`**:
```python
from dataclasses import dataclass, field
from typing import Dict, Set
from ink.domain.value_objects.pin_direction import PinDirection


@dataclass
class PinDirectionMap:
    """Mapping of pin names to their directions with default handling"""
    directions: Dict[str, PinDirection]
    _accessed_missing_pins: Set[str] = field(default_factory=set, init=False)

    def get_direction(self, pin_name: str) -> PinDirection:
        """
        Get direction for pin name, default to INOUT if not found.

        Args:
            pin_name: Name of the pin (case-sensitive)

        Returns:
            PinDirection for the pin, or INOUT if not found
        """
        if pin_name not in self.directions:
            # Track missing pin for statistics
            self._accessed_missing_pins.add(pin_name)
            return PinDirection.INOUT

        return self.directions[pin_name]

    def has_pin(self, pin_name: str) -> bool:
        """Check if pin name exists in the mapping"""
        return pin_name in self.directions

    def get_missing_pin_stats(self) -> Dict[str, int]:
        """
        Get statistics on missing pin direction queries.

        Returns:
            Dictionary with statistics:
            - 'defined_pins': Number of pins with explicit directions
            - 'missing_pins_accessed': Number of unique missing pins queried
            - 'total_unique_pins': Total unique pins accessed
        """
        return {
            'defined_pins': len(self.directions),
            'missing_pins_accessed': len(self._accessed_missing_pins),
            'total_unique_pins': len(self.directions) + len(self._accessed_missing_pins),
        }

    def get_missing_pins(self) -> Set[str]:
        """
        Get set of all pin names that were queried but not defined.

        Returns:
            Set of missing pin names
        """
        return self._accessed_missing_pins.copy()
```

### 2.4 Summary Reporting

**Location**: `src/ink/application/services/file_service.py`

**Post-Load Reporting**:
```python
class FileService:
    """Application service for file operations"""

    def load_design_with_directions(
        self,
        cdl_path: Path,
        pindir_path: Path
    ) -> Tuple[Design, PinDirectionServiceImpl]:
        """
        Load design and pin directions, reporting missing direction statistics.

        Args:
            cdl_path: Path to CDL netlist file
            pindir_path: Path to pin direction file

        Returns:
            Tuple of (Design, PinDirectionService)
        """
        # Load pin directions
        pin_service = self.load_pin_directions(pindir_path)

        # Load and parse netlist (uses pin_service to set directions)
        design = self.load_netlist(cdl_path, pin_service)

        # Report statistics after design is fully loaded
        self._report_pin_direction_stats(pin_service)

        return design, pin_service

    def _report_pin_direction_stats(self, pin_service: PinDirectionServiceImpl):
        """
        Log statistics about pin direction usage and missing pins.

        Args:
            pin_service: Pin direction service with statistics
        """
        stats = pin_service._direction_map.get_missing_pin_stats()
        missing_pins = pin_service._direction_map.get_missing_pins()

        self.logger.info(
            f"Pin Direction Statistics:\n"
            f"  - Defined pins: {stats['defined_pins']}\n"
            f"  - Missing pins accessed: {stats['missing_pins_accessed']}\n"
            f"  - Total unique pins: {stats['total_unique_pins']}"
        )

        if missing_pins:
            # Show first 10 missing pins as examples
            sample_pins = sorted(missing_pins)[:10]
            more_count = len(missing_pins) - len(sample_pins)

            self.logger.warning(
                f"The following pins were not found in direction file "
                f"(defaulted to INOUT): {', '.join(sample_pins)}"
                + (f" and {more_count} more" if more_count > 0 else "")
            )
```

### 2.5 Configuration Options (Future)

**Future Enhancement**: `PinDirectionConfig` for customizable behavior

```python
from dataclasses import dataclass
from ink.domain.value_objects.pin_direction import PinDirection


@dataclass
class PinDirectionConfig:
    """Configuration for pin direction handling behavior"""

    # Default direction for missing pins
    default_direction: PinDirection = PinDirection.INOUT

    # Warn on missing pins (if False, silently default)
    warn_on_missing: bool = True

    # Fail on missing pins instead of defaulting
    strict_mode: bool = False

    # Log level for missing pin warnings
    missing_pin_log_level: str = "DEBUG"  # DEBUG, INFO, WARNING
```

**Note**: Configuration implementation is deferred to future iteration. MVP uses hardcoded INOUT default with INFO-level statistics reporting.

---

## 3. Dependencies

### 3.1 Upstream
- Task E01-F02-T01: `PinDirectionMap` base implementation
- Task E01-F02-T02: `PinDirectionServiceImpl` for integration

### 3.2 Downstream
- Task E01-F03 (Graph Construction): Relies on default direction handling
- Application layer: Uses statistics for user feedback
- UI layer: May display missing pin warnings in future

### 3.3 External Dependencies
- Python standard library: `typing`, `dataclasses`, `logging`
- No third-party dependencies

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `get_direction()` returns `INOUT` for undefined pins
- [ ] Missing pin accesses are tracked in `_accessed_missing_pins`
- [ ] `get_missing_pin_stats()` returns accurate statistics
- [ ] `get_missing_pins()` returns set of all queried but undefined pins
- [ ] Statistics include defined count, missing count, and total unique count

### 4.2 Reporting
- [ ] Summary statistics logged at INFO level after design load
- [ ] Warning message lists sample of missing pins (max 10)
- [ ] Large missing pin lists show count of additional pins
- [ ] Statistics report includes all three metrics

### 4.3 Performance
- [ ] Tracking overhead is minimal (Set operations are O(1))
- [ ] Statistics computation is O(n) where n = number of unique pins
- [ ] No performance impact on repeated `get_direction()` calls

### 4.4 Testing
- [ ] Unit test: `get_direction()` returns INOUT for missing pin
- [ ] Unit test: Missing pin tracking accumulates unique pins
- [ ] Unit test: Statistics calculation with various pin access patterns
- [ ] Unit test: `get_missing_pins()` returns copy (immutability)
- [ ] Integration test: Full workflow with partial pin direction file
- [ ] Integration test: Verify logging output contains expected warnings
- [ ] 95%+ code coverage on tracking and reporting code

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why INOUT as default?**
- Most conservative assumption (treats pin as bidirectional)
- Layout algorithms handle INOUT pins correctly
- Expansion logic includes pin in both fanin and fanout
- Prevents missing connections in visualization

**Why track missing pins?**
- Provides visibility into data quality
- Helps users identify incomplete `.pindir` files
- Enables future enhancements (bulk direction import, auto-detection)

**Why limit warning sample to 10 pins?**
- Prevents log spam with hundreds of missing pins
- Provides enough context for user to investigate
- Shows count of additional missing pins for full picture

**Why use Set for tracking?**
- O(1) insertion and lookup
- Automatic deduplication
- Minimal memory overhead (stores only unique pin names)

### 5.2 Future Enhancements

**Smart Defaults**:
- Heuristic-based direction inference (e.g., pin "CLK" â†’ INPUT)
- Machine learning-based direction prediction
- Direction propagation from connected pins

**Configuration System**:
- Per-design configuration files
- UI settings for default behavior
- Strict mode for production (fail on missing directions)

**Enhanced Reporting**:
- Export missing pins to file for bulk editing
- Visual indicators in UI for pins using defaults
- Statistics dashboard with direction distribution charts

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/infrastructure/parsing/test_pin_direction_defaults.py`):
- Test default INOUT behavior
- Test missing pin tracking with various access patterns
- Test statistics calculation edge cases (empty, all missing, all defined)
- Test immutability of returned missing pin set

**Integration Tests** (`tests/integration/infrastructure/test_pin_direction_reporting.py`):
- Create partial `.pindir` file with only some pins
- Parse netlist that references undefined pins
- Verify statistics and warnings in logs
- Test with large designs (1000+ pins, 50% missing)

---

## 6. Usage Examples

### 6.1 Basic Default Handling
```python
from ink.infrastructure.parsing.pindir_parser import PinDirectionParser, PinDirectionMap

# Parse file with only some pins defined
parser = PinDirectionParser()
direction_map = parser.parse_file(Path("partial.pindir"))

# Query defined pin
a_dir = direction_map.get_direction("A")  # Returns INPUT (defined)

# Query undefined pin
unknown_dir = direction_map.get_direction("UNKNOWN")  # Returns INOUT (default)

# Check if pin is defined
has_a = direction_map.has_pin("A")  # True
has_unknown = direction_map.has_pin("UNKNOWN")  # False
```

### 6.2 Statistics Reporting
```python
from pathlib import Path
from ink.application.services.file_service import FileService

# Load design with pin directions
file_service = FileService()
design, pin_service = file_service.load_design_with_directions(
    cdl_path=Path("netlist.ckt"),
    pindir_path=Path("partial.pindir")
)

# Statistics automatically logged:
# INFO: Pin Direction Statistics:
#   - Defined pins: 15
#   - Missing pins accessed: 8
#   - Total unique pins: 23
# WARNING: The following pins were not found in direction file (defaulted to INOUT):
#   CLK, DATA_IN, ENABLE, RESET, VDD, VSS, GND, AVDD and 1 more
```

### 6.3 Programmatic Access to Statistics
```python
# Get statistics for programmatic use
stats = pin_service._direction_map.get_missing_pin_stats()
coverage = stats['defined_pins'] / stats['total_unique_pins'] * 100

print(f"Pin direction coverage: {coverage:.1f}%")

# Get list of missing pins for export
missing_pins = pin_service._direction_map.get_missing_pins()
with open("missing_pins.txt", "w") as f:
    for pin in sorted(missing_pins):
        f.write(f"{pin}\tINOUT\n")
```

---

## 7. Error Scenarios

### 7.1 Completely Missing `.pindir` File

**Scenario**: User doesn't provide `.pindir` file at all

**Handling**:
- Create empty `PinDirectionMap` (no defined pins)
- All pins default to INOUT
- Warning logged: "No pin direction file provided, all pins will default to INOUT"

### 7.2 Empty `.pindir` File

**Scenario**: `.pindir` file exists but contains only comments

**Handling**:
- `PinDirectionMap` with empty `directions` dict
- All pins default to INOUT
- Warning logged: "Pin direction file contains no pin definitions"

### 7.3 Partial Coverage

**Scenario**: `.pindir` defines 50% of pins used in netlist

**Handling**:
- Defined pins get explicit directions
- Undefined pins default to INOUT
- Warning logged with sample of missing pins
- Statistics show coverage percentage

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E01-F02 split |
