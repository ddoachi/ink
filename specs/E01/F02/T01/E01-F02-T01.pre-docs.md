# E01-F02-T01: Pin Direction File Parser - Pre-Implementation Documentation

## Document Metadata
- **Task**: E01-F02-T01 - Pin Direction File Parser
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Problem Context

The Ink schematic viewer needs to understand pin directions (INPUT, OUTPUT, INOUT) to correctly render signal flow and enable directional graph traversal for fanin/fanout expansion. Gate-level netlists (CDL files) contain only connectivity information without explicit pin directions. The `.pindir` file format provides a simple whitespace-separated mapping from pin names to their directions.

This parser is the first step in the pin direction handling workflow:
1. **Parse** `.pindir` file (this task)
2. **Query** pin directions via service API (E01-F02-T02)
3. **Handle** missing directions with defaults (E01-F02-T03)

### 1.2 Core Objectives

1. **Robust File Parsing**: Handle simple whitespace-separated format with error recovery
2. **Direction Validation**: Ensure only valid direction values (INPUT, OUTPUT, INOUT) with case-insensitive matching
3. **Error Reporting**: Provide clear error messages with line numbers for debugging
4. **Duplicate Detection**: Warn on duplicate pin definitions without failing
5. **Structured Output**: Return `PinDirectionMap` object with clean query API

### 1.3 Success Metrics

- Parse 1000-line `.pindir` file in < 100ms
- Handle all syntax variations (tabs, multiple spaces, mixed case)
- Provide line-numbered error messages for all syntax issues
- Zero data loss (all valid pin definitions preserved)
- 90%+ test coverage on parser module

---

## 2. Architecture Decisions

### 2.1 Parser Design Pattern

**Decision**: Simple line-by-line parser with string splitting

**Alternatives Considered**:

1. **Regex-based parser**: Pattern matching per line
   - Pros: Concise, single regex pattern
   - Cons: Less readable, harder to provide good error messages

2. **CSV parser (csv.DictReader)**: Use Python's built-in CSV module
   - Pros: Handles quoted fields, standard library
   - Cons: Overkill for two-column format, less control over errors

3. **PLY/ANTLR parser generator**: Formal grammar
   - Pros: Production-grade, handles complex syntax
   - Cons: Massive overkill for simple format, adds dependencies

**Rationale**: `.pindir` format is intentionally simple (2 columns, whitespace-separated). `str.split()` is fast, readable, and provides full control over error messages. Performance is optimal (no regex compilation overhead).

**Implementation Approach**:
```python
# Pseudocode algorithm
for line_number, line in enumerate(file, start=1):
    stripped = line.strip()

    # Skip empty lines and comments
    if not stripped or stripped.startswith('*'):
        continue

    # Parse data line
    parts = stripped.split()
    if len(parts) != 2:
        raise PinDirectionParseError(f"Line {line_number}: Expected 2 columns, got {len(parts)}")

    pin_name, direction_str = parts
    direction = validate_direction(direction_str)

    # Check duplicates (warn but continue)
    if pin_name in directions:
        logger.warning(f"Duplicate pin '{pin_name}' at line {line_number}")

    directions[pin_name] = direction
```

### 2.2 Data Model Design

**Decision**: Use `@dataclass` for `PinDirectionMap` with dictionary storage

**Key Design Choices**:

1. **Dictionary Storage**: `Dict[str, PinDirection]`
   - O(1) lookup by pin name
   - Simple, memory-efficient
   - Easy to serialize (JSON, pickle)

2. **Encapsulation**: Expose `get_direction()` and `has_pin()` methods
   - Hide internal dictionary structure
   - Allows future optimization (caching, compression)
   - Provides default value handling (INOUT)

3. **Immutability**: Dictionary is exposed read-only
   - Prevents external modification
   - Thread-safe for concurrent access
   - Return copy in `get_all_pins()` method

**Schema**:
```python
@dataclass
class PinDirectionMap:
    directions: Dict[str, PinDirection]

    def get_direction(self, pin_name: str) -> PinDirection:
        """Get direction, default to INOUT if not found"""
        return self.directions.get(pin_name, PinDirection.INOUT)

    def has_pin(self, pin_name: str) -> bool:
        """Check if pin exists in mapping"""
        return pin_name in self.directions
```

### 2.3 Error Handling Strategy

**Decision**: Strict parsing with informative errors, warn on duplicates

**Error Categories**:

1. **File Errors**: `FileNotFoundError` for missing file
   - Standard Python exception
   - Caller's responsibility to check file exists

2. **Syntax Errors**: `PinDirectionParseError` for invalid format
   - Include line number and actual line content
   - Suggest expected format
   - Stop parsing on first error (fail-fast)

3. **Duplicate Warnings**: Log warning, continue with last definition
   - Non-fatal (allows iterative development)
   - Last definition wins (predictable behavior)
   - Logged at WARNING level for visibility

**Error Message Format**:
```
PinDirectionParseError: Line 47: Invalid direction 'OUTPT'. Valid values: INPUT, OUTPUT, INOUT

PinDirectionParseError: Line 32: Expected format 'PIN_NAME DIRECTION', got: A B C

WARNING: Duplicate pin definition 'CLK' at line 89. Overwriting previous definition.
```

### 2.4 Case Sensitivity Design

**Decision**: Case-sensitive pin names, case-insensitive directions

**Rationale**:
- **Pin Names**: Circuit nets are case-sensitive (A vs a are different signals)
- **Direction Values**: Human input tolerance (INPUT vs input vs Input)
- **Implementation**: `PinDirection[direction_str.upper()]` for enum lookup

**Example**:
```python
# Valid - different pins
A    INPUT
a    OUTPUT

# Valid - same direction, different case
CLK  input
DATA INPUT
RST  InPuT
```

---

## 3. Implementation Approach

### 3.1 File Structure

```
src/ink/
├── domain/
│   └── value_objects/
│       └── pin_direction.py          # PinDirection enum (NEW)
└── infrastructure/
    └── parsing/
        └── pindir_parser.py          # PinDirectionParser + PinDirectionMap (NEW)

tests/
├── unit/
│   └── infrastructure/
│       └── parsing/
│           └── test_pindir_parser.py              # Unit tests (NEW)
└── integration/
    └── infrastructure/
        └── parsing/
            └── test_pindir_parser_integration.py  # Integration tests (NEW)

examples/
└── standard_cells.pindir             # Sample file for testing (NEW)
```

### 3.2 Development Phases

#### Phase 1: Domain Value Object (1 hour)
**Goal**: Define `PinDirection` enum

**Deliverables**:
- `src/ink/domain/value_objects/pin_direction.py`
- Enum with INPUT, OUTPUT, INOUT values
- `__str__()` method for display

**Success Criteria**:
- Enum values are strings (INPUT, OUTPUT, INOUT)
- Can convert to/from string representation
- Unit tests verify enum behavior

#### Phase 2: Parser Core (2 hours)
**Goal**: Implement line-by-line parsing logic

**Deliverables**:
- `PinDirectionParser` class with `parse_file()` method
- `_parse_line()` method for single line parsing
- `_validate_direction()` method for direction validation
- `PinDirectionMap` dataclass

**Success Criteria**:
- Parse valid `.pindir` file successfully
- Extract all pin name → direction mappings
- Return structured `PinDirectionMap` object

#### Phase 3: Error Handling (1 hour)
**Goal**: Add comprehensive error reporting

**Deliverables**:
- `PinDirectionParseError` exception class
- Line-numbered error messages
- Duplicate pin warning system
- Logging integration

**Success Criteria**:
- Invalid direction raises error with line number
- Malformed line raises error with expected format
- Duplicate pins logged as warnings
- All errors include line number context

#### Phase 4: Testing & Validation (30 minutes)
**Goal**: Comprehensive test coverage

**Deliverables**:
- Unit tests for each parsing method
- Integration test with sample `.pindir` file
- Error handling test cases
- Performance benchmark test

**Success Criteria**:
- 90%+ code coverage
- All edge cases covered (empty file, comments only, duplicates)
- Performance test validates <100ms for 1000 lines

### 3.3 Testing Strategy

**Unit Tests** (`test_pindir_parser.py`):
```python
class TestPinDirectionParser:
    def test_parse_valid_file_basic(self):
        """Parse file with valid pin directions"""

    def test_parse_case_insensitive_direction(self):
        """Handle input, INPUT, InPuT variations"""

    def test_parse_case_sensitive_pin_names(self):
        """A and a are different pins"""

    def test_parse_tabs_and_spaces(self):
        """Handle mixed whitespace separators"""

    def test_parse_skip_comments(self):
        """Ignore lines starting with *"""

    def test_parse_skip_empty_lines(self):
        """Ignore blank lines"""

    def test_parse_duplicate_pins_warning(self):
        """Warn on duplicate, use last definition"""

    def test_parse_invalid_direction_error(self):
        """Raise error for invalid direction value"""

    def test_parse_malformed_line_error(self):
        """Raise error for wrong column count"""

    def test_parse_file_not_found_error(self):
        """Raise FileNotFoundError for missing file"""

class TestPinDirectionMap:
    def test_get_direction_existing_pin(self):
        """Return correct direction for known pin"""

    def test_get_direction_missing_pin_default(self):
        """Return INOUT for unknown pin"""

    def test_has_pin_true_for_existing(self):
        """Return True for defined pins"""

    def test_has_pin_false_for_missing(self):
        """Return False for undefined pins"""
```

**Integration Tests** (`test_pindir_parser_integration.py`):
```python
def test_parse_full_pindir_file():
    """Parse complete .pindir file from examples/"""
    parser = PinDirectionParser()
    direction_map = parser.parse_file(Path("examples/standard_cells.pindir"))

    assert direction_map.get_direction("A") == PinDirection.INPUT
    assert direction_map.get_direction("Y") == PinDirection.OUTPUT
    assert len(direction_map.directions) > 0

def test_parse_performance_1000_pins(tmp_path):
    """Verify parsing performance for large file"""
    # Generate 1000-line test file
    pindir_file = tmp_path / "large.pindir"
    with open(pindir_file, 'w') as f:
        for i in range(1000):
            f.write(f"PIN_{i}  INPUT\n")

    start = time.perf_counter()
    parser = PinDirectionParser()
    direction_map = parser.parse_file(pindir_file)
    duration = time.perf_counter() - start

    assert duration < 0.1  # <100ms
    assert len(direction_map.directions) == 1000
```

**Test Data**:
```
examples/standard_cells.pindir:
* Standard cell pin directions
* Format: PIN_NAME  DIRECTION

A       INPUT
B       INPUT
C       INPUT
Y       OUTPUT
Z       OUTPUT
Q       OUTPUT
D       INPUT
CK      INPUT
RN      INPUT
SE      INPUT
SI      INPUT
ZN      OUTPUT
```

---

## 4. Key Design Decisions

### 4.1 Why Not Use Regex?

**Question**: Should we use regex patterns for parsing?

**Decision**: No, use `str.split()` for simplicity

**Rationale**:
- `.pindir` format is trivial (2 columns, whitespace-separated)
- `str.split()` is more readable and maintainable
- Performance is equivalent for this use case
- Error messages are easier to generate with explicit parsing
- No regex compilation overhead

**Trade-off**: If format becomes complex in future (quoted fields, escape sequences), may need to revisit.

### 4.2 Why Warn on Duplicates Instead of Error?

**Question**: Should duplicate pin definitions fail parsing?

**Decision**: Warn and continue with last definition

**Rationale**:
- **User Experience**: Allows iterative development (users can override defaults)
- **Predictability**: Last definition wins (similar to CSS, command-line flags)
- **Robustness**: Partial files still useful during development
- **Visibility**: WARNING log provides feedback without blocking

**Trade-off**: Could hide user mistakes. Future enhancement: strict mode flag.

### 4.3 Why Default to INOUT for Missing Pins?

**Question**: What should `get_direction()` return for undefined pins?

**Decision**: Return `PinDirection.INOUT` (bidirectional)

**Rationale**:
- **Conservative**: INOUT is safest assumption (treats as both input and output)
- **Layout Compatibility**: Rendering algorithms can handle INOUT pins
- **Expansion Logic**: Fanin/fanout traversal includes INOUT in both directions
- **User Feedback**: Warning system (E01-F02-T03) alerts user to missing pins

**Trade-off**: May hide incomplete `.pindir` files. Statistics reporting (E01-F02-T03) mitigates this.

### 4.4 Why Use Dataclass Instead of NamedTuple?

**Question**: Should `PinDirectionMap` be a dataclass or NamedTuple?

**Decision**: Use `@dataclass` for extensibility

**Rationale**:
- **Methods**: Can add query methods (`get_direction()`, `has_pin()`)
- **Mutability**: Can add tracking fields (E01-F02-T03 adds `_accessed_missing_pins`)
- **Inheritance**: Can extend in future (cell-type-specific overrides)
- **Type Hints**: Better IDE support than NamedTuple

**Trade-off**: Slightly more memory overhead than NamedTuple (negligible for single object).

---

## 5. Dependencies and Integration Points

### 5.1 Upstream Dependencies

**None** - This is a foundational task with no upstream dependencies.

**Domain Layer**:
- Creates `PinDirection` enum (new value object)

**Infrastructure Layer**:
- Creates `PinDirectionParser` (new infrastructure component)

### 5.2 Downstream Consumers

**E01-F02-T02** (Direction Lookup Service):
- Uses `PinDirectionMap` as data source
- Wraps in service interface for domain layer

**E01-F02-T03** (Default Direction Handling):
- Extends `PinDirectionMap` with tracking fields
- Uses `get_direction()` for default behavior

**E01-F03** (Graph Construction):
- Indirectly uses via `PinDirectionService`
- Sets `Pin.direction` during graph building

**Application Layer** (`FileService`):
- Calls `parse_file()` when loading design
- Handles `PinDirectionParseError` exceptions

### 5.3 External Dependencies

**Python Standard Library**:
- `pathlib.Path`: File path handling
- `dataclasses`: Data structure definition
- `logging`: Warning and error reporting
- `enum`: PinDirection enum
- `typing`: Type hints

**No third-party dependencies** - Keeps infrastructure layer lightweight.

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: File Encoding Issues
**Impact**: Medium (parser fails on non-UTF-8 files)
**Probability**: Low (most tools generate UTF-8)

**Mitigation**:
- Explicitly specify `encoding='utf-8'` in `open()`
- Catch `UnicodeDecodeError` and provide helpful message
- Document expected encoding in error message

**Contingency**:
- Add `encoding` parameter to `parse_file()` for flexibility
- Try fallback encodings (latin-1, cp1252) with warning

#### Risk 2: Windows Line Endings
**Impact**: Low (parsing still works, but line counts may differ)
**Probability**: Medium (users on Windows)

**Mitigation**:
- Python's `open()` in text mode handles `\r\n` automatically
- Use `newline=None` (default) for universal newline mode
- Line numbers will be consistent across platforms

**Contingency**: None needed - Python handles this transparently.

#### Risk 3: Very Large .pindir Files
**Impact**: Low (memory usage, parsing time)
**Probability**: Low (typical files <1000 lines)

**Mitigation**:
- Performance requirement: <100ms for 1000 lines
- Memory usage: O(n) where n = number of unique pins
- Typical file: 50-200 pins, <10KB

**Contingency**:
- If files exceed 10,000 pins, implement streaming parser
- Use generator pattern to avoid loading full dict in memory

### 6.2 Integration Risks

#### Risk 4: Missing .pindir File
**Impact**: Medium (all pins default to INOUT, suboptimal expansion)
**Probability**: High (users may not provide file)

**Mitigation**:
- `FileNotFoundError` provides clear message
- Application layer should offer to continue with defaults
- Warning system (E01-F02-T03) reports missing pins

**Contingency**:
- Provide default `.pindir` file with common pin names
- Auto-generate from standard cell library metadata

#### Risk 5: Pin Name Mismatches
**Impact**: Medium (pins in netlist not in .pindir file)
**Probability**: High (incomplete or outdated .pindir files)

**Mitigation**:
- Default to INOUT for missing pins
- Statistics reporting (E01-F02-T03) shows coverage
- Warning log lists missing pins

**Contingency**:
- Provide "generate missing pins" tool
- Export list of undefined pins for user to populate

### 6.3 Usability Risks

#### Risk 6: Confusing Error Messages
**Impact**: Medium (users can't fix syntax errors)
**Probability**: Medium (first-time users)

**Mitigation**:
- Include line number in all errors
- Show expected format in error message
- Provide example of valid syntax

**Example**:
```
PinDirectionParseError: Line 47: Expected format 'PIN_NAME DIRECTION', got: A B C

Expected:
  A    INPUT
  B    OUTPUT

See examples/standard_cells.pindir for reference.
```

**Contingency**: Add validation mode that checks file without loading design.

---

## 7. Testing and Validation

### 7.1 Test Coverage Goals

**Coverage Target**: 90%+ line coverage, 100% branch coverage

**Key Test Scenarios**:
1. Valid file parsing (happy path)
2. Comment line handling
3. Empty line handling
4. Case-insensitive direction matching
5. Case-sensitive pin name matching
6. Duplicate pin detection
7. Invalid direction error
8. Malformed line error
9. File not found error
10. Performance with large file

### 7.2 Validation Approach

**Syntax Validation**:
```python
def validate_pindir_syntax(file_path: Path) -> List[str]:
    """
    Validate .pindir file syntax without loading.

    Returns:
        List of error messages (empty if valid)
    """
    errors = []
    try:
        parser = PinDirectionParser()
        parser.parse_file(file_path)
    except PinDirectionParseError as e:
        errors.append(str(e))
    return errors
```

**Data Validation**:
- All pins have valid direction (INPUT, OUTPUT, or INOUT)
- No empty pin names
- Pin names match netlist (checked in E01-F03)

### 7.3 Performance Benchmarks

**Benchmark 1: Small File (100 pins)**
- Expected: <10ms
- Memory: <1KB (just dictionary overhead)

**Benchmark 2: Medium File (1000 pins)**
- Expected: <100ms
- Memory: <10KB

**Benchmark 3: Large File (10,000 pins)**
- Expected: <1 second
- Memory: <100KB

**Measurement**:
```python
import time
from pathlib import Path

def benchmark_parse_file(file_path: Path, iterations: int = 10):
    parser = PinDirectionParser()

    times = []
    for _ in range(iterations):
        start = time.perf_counter()
        parser.parse_file(file_path)
        times.append(time.perf_counter() - start)

    avg_time = sum(times) / len(times)
    print(f"Average parse time: {avg_time*1000:.2f}ms")
```

---

## 8. Definition of Done

### 8.1 Feature Completeness

- [ ] `PinDirection` enum defined with INPUT, OUTPUT, INOUT values
- [ ] `PinDirectionParser` parses valid `.pindir` files
- [ ] `PinDirectionMap` provides query API (`get_direction()`, `has_pin()`)
- [ ] Comment lines (starting with `*`) are ignored
- [ ] Empty lines are ignored
- [ ] Whitespace (tabs and spaces) handled correctly
- [ ] Case-insensitive direction matching works
- [ ] Case-sensitive pin name matching works
- [ ] Duplicate pins generate warnings

### 8.2 Error Handling

- [ ] `FileNotFoundError` raised for missing files
- [ ] `PinDirectionParseError` raised for syntax errors
- [ ] Error messages include line numbers
- [ ] Error messages show expected format
- [ ] Invalid directions list valid values in error
- [ ] Duplicate warnings logged at WARNING level

### 8.3 Testing

- [ ] Unit tests for `_parse_line()` method
- [ ] Unit tests for `_validate_direction()` method
- [ ] Unit tests for duplicate handling
- [ ] Integration test with sample `.pindir` file
- [ ] Performance test validates <100ms for 1000 lines
- [ ] Error handling tests for each error condition
- [ ] 90%+ code coverage

### 8.4 Code Quality

- [ ] Type hints on all public methods
- [ ] Docstrings on all classes and methods (Google style)
- [ ] Logging integrated (INFO for success, WARNING for duplicates)
- [ ] No hardcoded file paths or magic strings
- [ ] Code passes `mypy --strict` checks
- [ ] Code passes `ruff` linting

### 8.5 Documentation

- [ ] Module docstring explains purpose
- [ ] Class docstrings describe behavior
- [ ] Method docstrings include Args, Returns, Raises
- [ ] Example `.pindir` file in `examples/` directory
- [ ] README section on pin direction file format

### 8.6 Integration Readiness

- [ ] `PinDirectionMap` API is stable
- [ ] No breaking changes to downstream tasks (T02, T03)
- [ ] Example usage code in docstring
- [ ] Integration test demonstrates E2E workflow

---

## 9. Open Questions

### 9.1 Design Questions

**Q1: Should we support inline comments?**
```
A  INPUT   * This is pin A
B  OUTPUT  * This is pin B
```

**Answer**: Not in MVP. Keep parser simple. Can add in P1 if users request.

**Q2: Should we support cell-type-specific pin directions?**
```
[INV_X1]
A  INPUT
Y  OUTPUT

[TRI_X1]
A  INPUT
Y  OUTPUT
OE INPUT
```

**Answer**: Not in MVP. Global pin mapping is sufficient for 90% of cases. Add in P1 as enhancement.

**Q3: Should we validate pin names against netlist?**

**Answer**: Not in parser. Validation happens in graph construction (E01-F03). Parser is format-agnostic.

### 9.2 Implementation Questions

**Q1: Should `PinDirectionMap` be mutable after creation?**

**Answer**: No. Once parsed, it's immutable. Simplifies reasoning about state.

**Q2: Should we cache parsed `.pindir` files?**

**Answer**: Not in parser. Application layer can implement caching if needed.

**Q3: Should we support writing `.pindir` files?**

**Answer**: Not in MVP. Parser is read-only. Write support in P1 for "export missing pins" feature.

---

## 10. Next Steps

### 10.1 Immediate Actions

1. **Create `PinDirection` enum**: Define value object in domain layer
2. **Implement parser core**: `PinDirectionParser` class with parsing logic
3. **Write unit tests**: Cover all parsing methods and error cases
4. **Create sample file**: `examples/standard_cells.pindir` for testing
5. **Integration test**: End-to-end parsing workflow

### 10.2 Follow-up Tasks

- **E01-F02-T02**: Create service interface wrapping `PinDirectionMap`
- **E01-F02-T03**: Add missing pin tracking and statistics reporting
- **E01-F03**: Use pin directions during graph construction

---

## Appendix A: Code Examples

### A.1 Basic Usage

```python
from pathlib import Path
from ink.infrastructure.parsing.pindir_parser import PinDirectionParser

# Parse pin direction file
parser = PinDirectionParser()
direction_map = parser.parse_file(Path("examples/standard_cells.pindir"))

# Query pin directions
a_dir = direction_map.get_direction("A")      # PinDirection.INPUT
y_dir = direction_map.get_direction("Y")      # PinDirection.OUTPUT
unknown = direction_map.get_direction("UNKNOWN")  # PinDirection.INOUT (default)

# Check pin existence
has_a = direction_map.has_pin("A")           # True
has_unknown = direction_map.has_pin("UNKNOWN")  # False
```

### A.2 Error Handling

```python
from ink.infrastructure.parsing.pindir_parser import (
    PinDirectionParser,
    PinDirectionParseError
)

parser = PinDirectionParser()

try:
    direction_map = parser.parse_file(Path("design.pindir"))
except FileNotFoundError as e:
    print(f"Pin direction file not found: {e}")
except PinDirectionParseError as e:
    print(f"Failed to parse pin direction file: {e}")
```

### A.3 Sample .pindir File

```
* Pin direction definitions for standard cell library
* Format: PIN_NAME  DIRECTION
* Directions: INPUT, OUTPUT, INOUT

* Basic logic gates
A       INPUT
B       INPUT
C       INPUT
Y       OUTPUT
ZN      OUTPUT

* Flip-flops
D       INPUT
Q       OUTPUT
QN      OUTPUT
CK      INPUT
RN      INPUT
SN      INPUT

* Scan chain
SE      INPUT
SI      INPUT
SO      OUTPUT
```

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
