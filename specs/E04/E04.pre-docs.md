# E04 - Object Interaction: Pre-Implementation Documentation

## Document Information

- **Epic ID**: E04
- **Epic Title**: Object Interaction
- **Document Type**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Status**: Planning
- **Target Release**: MVP (P0)

---

## 1. Overview

### 1.1 Executive Summary

The Object Interaction epic (E04) establishes the core user interaction model for Ink's schematic viewer. This epic implements the selection system, property inspection, undo/redo functionality, and keyboard shortcuts - fundamental capabilities that enable users to efficiently navigate and manipulate gate-level schematics.

This epic is critical to the MVP as it bridges the gap between passive visualization (E02 Rendering) and active exploration (E03 Expansion, E05 Search). Without robust selection and undo capabilities, users cannot confidently explore complex netlists.

### 1.2 Scope

**In Scope:**
- Single and multi-object selection (cells, pins, nets, ports)
- Visual selection feedback and highlighting
- Property panel displaying object-specific attributes
- Command pattern-based undo/redo system for expansion/collapse operations
- Essential keyboard shortcuts for navigation and manipulation
- Selection state management and change notifications

**Out of Scope (Future Work):**
- Multi-object property editing (read-only for MVP)
- Advanced selection modes (select by type, select connected)
- Customizable keyboard shortcuts (fixed bindings for MVP)
- Selection history or named selections
- Copy/paste functionality
- Drag-and-drop operations

### 1.3 Success Metrics

- Selection response time < 16ms (60fps)
- Property panel update time < 50ms
- Undo/redo operation time < 100ms
- Support for 50+ undo stack depth without memory issues
- Zero shortcut conflicts with Qt default behaviors
- 100% coverage of PRD §7.1-7.3 requirements

---

## 2. Architecture Decisions

### 2.1 Selection Architecture

#### Decision: Centralized SelectionManager Pattern

**Rationale:**
- Single source of truth for selection state prevents synchronization bugs
- Enables easy observation of selection changes via signals
- Simplifies multi-view synchronization if needed later
- Facilitates testing by decoupling selection logic from UI

**Design:**

```python
# src/ink/core/selection/manager.py
from typing import List, Set, Optional
from PySide6.QtCore import QObject, Signal
from enum import Enum

class SelectMode(Enum):
    REPLACE = "replace"  # Clear previous, select new
    ADD = "add"          # Add to selection (Ctrl+click)
    TOGGLE = "toggle"    # Toggle selection state (Ctrl+click alt)
    REMOVE = "remove"    # Remove from selection

class SelectionManager(QObject):
    """Centralized selection state management."""

    selection_changed = Signal(list)  # Emits list of selected objects

    def __init__(self):
        super().__init__()
        self._selected: Set[str] = set()  # Object IDs
        self._objects: dict[str, SchematicObject] = {}  # ID -> object

    def select(self, obj: SchematicObject, mode: SelectMode = SelectMode.REPLACE):
        """Select object with specified mode."""

    def select_multiple(self, objects: List[SchematicObject], mode: SelectMode):
        """Batch select to minimize signal emissions."""

    def select_rect(self, rect: QRectF) -> int:
        """Select all objects whose bounds intersect rect. Returns count."""

    def clear(self):
        """Clear all selections."""

    def is_selected(self, obj: SchematicObject) -> bool:
        """Check if object is selected."""

    @property
    def selected_objects(self) -> List[SchematicObject]:
        """Get all selected objects."""

    @property
    def count(self) -> int:
        """Get selection count."""
```

**Alternatives Considered:**

1. **Distributed Selection State**: Each drawable object tracks its own selection
   - ❌ Hard to query "what's selected"
   - ❌ Difficult to implement multi-select operations
   - ✅ Simpler for individual objects

2. **Scene-Based Selection** (Qt's QGraphicsScene selection)
   - ✅ Built into Qt framework
   - ❌ Tightly coupled to graphics view
   - ❌ Less control over selection logic
   - ❌ Harder to implement custom selection modes

**Decision**: Centralized manager provides best balance of control and simplicity.

### 2.2 Undo/Redo Architecture

#### Decision: Command Pattern with QUndoStack

**Rationale:**
- Qt's `QUndoStack` provides robust, tested undo/redo infrastructure
- Command pattern cleanly encapsulates reversible operations
- Built-in support for undo limits and macro commands
- Integrates with Qt's menu system for enable/disable states

**Design:**

```python
# src/ink/core/undo/commands.py
from PySide6.QtGui import QUndoCommand
from typing import Set, Dict

class ExpansionCommand(QUndoCommand):
    """Undoable expansion operation."""

    def __init__(self,
                 graph_manager: GraphManager,
                 layout_manager: LayoutManager,
                 render_state: RenderState,
                 source_obj: SchematicObject,
                 direction: ExpansionDirection,
                 hops: int):
        super().__init__(f"Expand {source_obj.name}")
        self.graph_manager = graph_manager
        self.layout_manager = layout_manager
        self.render_state = render_state

        # Capture state before expansion
        self.source_obj_id = source_obj.id
        self.direction = direction
        self.hops = hops

        # Will be populated during redo/initial execution
        self.added_cells: Set[str] = set()
        self.added_nets: Set[str] = set()
        self.layout_snapshot: Optional[Dict] = None

    def redo(self):
        """Execute or re-execute expansion."""
        if self.added_cells:
            # Re-expansion: restore from snapshot
            self._restore_snapshot()
        else:
            # First execution: perform expansion
            result = self.graph_manager.expand(
                self.source_obj_id,
                self.direction,
                self.hops
            )
            self.added_cells = result.cells
            self.added_nets = result.nets
            self.layout_snapshot = self.layout_manager.get_snapshot()

    def undo(self):
        """Reverse expansion by removing added elements."""
        self.graph_manager.remove_cells(self.added_cells)
        self.graph_manager.remove_nets(self.added_nets)
        self.layout_manager.relayout()
        self.render_state.invalidate()

class CollapseCommand(QUndoCommand):
    """Undoable collapse operation."""
    # Similar structure to ExpansionCommand

# src/ink/services/undo/stack.py
from PySide6.QtGui import QUndoStack

class UndoManager:
    """Facade over QUndoStack for application-level undo/redo."""

    def __init__(self, max_stack_size: int = 50):
        self.stack = QUndoStack()
        self.stack.setUndoLimit(max_stack_size)

    def push(self, command: QUndoCommand):
        """Push command onto stack."""
        self.stack.push(command)

    def undo(self):
        """Undo last command."""
        if self.stack.canUndo():
            self.stack.undo()

    def redo(self):
        """Redo last undone command."""
        if self.stack.canRedo():
            self.stack.redo()

    def can_undo(self) -> bool:
        return self.stack.canUndo()

    def can_redo(self) -> bool:
        return self.stack.canRedo()
```

**Memory Management Strategy:**
- Store minimal state: object IDs rather than full objects
- Layout snapshots only store positions, not full layout data structures
- Implement snapshot compression for large expansions (P1 enhancement)
- 50-command limit prevents unbounded growth

**Alternatives Considered:**

1. **Memento Pattern with Full State Snapshots**
   - ✅ Simpler conceptually
   - ❌ High memory usage for large graphs
   - ❌ No Qt integration

2. **Event Sourcing**
   - ✅ Complete operation history
   - ❌ Overkill for MVP
   - ❌ Complex replay logic

**Decision**: Command pattern with Qt integration is industry standard for GUI applications.

### 2.3 Property Panel Architecture

#### Decision: Data-Driven Property Display with Custom Delegates

**Rationale:**
- Different object types (cell, pin, net, port) have different properties
- Data-driven approach minimizes code duplication
- Extensible for future property types
- Clean separation between data model and presentation

**Design:**

```python
# src/ink/ui/panels/property_panel.py
from PySide6.QtWidgets import QTableWidget
from dataclasses import dataclass, fields
from typing import Any, List, Tuple

@dataclass
class PropertyItem:
    """Single property for display."""
    name: str
    value: Any
    category: str = "General"
    readonly: bool = True

class PropertyPanel(QTableWidget):
    """Property inspection panel."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setColumnCount(2)
        self.setHorizontalHeaderLabels(["Property", "Value"])

    def display_properties(self, obj: SchematicObject):
        """Display properties for selected object."""
        properties = self._extract_properties(obj)
        self._populate_table(properties)

    def _extract_properties(self, obj: SchematicObject) -> List[PropertyItem]:
        """Extract displayable properties from object."""
        if isinstance(obj, Cell):
            return self._cell_properties(obj)
        elif isinstance(obj, Net):
            return self._net_properties(obj)
        elif isinstance(obj, Pin):
            return self._pin_properties(obj)
        elif isinstance(obj, Port):
            return self._port_properties(obj)
        return []

    def _cell_properties(self, cell: Cell) -> List[PropertyItem]:
        return [
            PropertyItem("Name", cell.name, "Identity"),
            PropertyItem("Type", cell.cell_type, "Identity"),
            PropertyItem("Is Sequential", cell.is_sequential, "Attributes"),
            PropertyItem("Pin Count", len(cell.pins), "Structure"),
            PropertyItem("Input Pins", ", ".join(p.name for p in cell.input_pins), "Pins"),
            PropertyItem("Output Pins", ", ".join(p.name for p in cell.output_pins), "Pins"),
        ]

    def _net_properties(self, net: Net) -> List[PropertyItem]:
        return [
            PropertyItem("Name", net.name, "Identity"),
            PropertyItem("Driver", net.driver.full_name if net.driver else "None", "Connectivity"),
            PropertyItem("Fanout Count", len(net.sinks), "Connectivity"),
            PropertyItem("Sinks", ", ".join(p.full_name for p in net.sinks), "Connectivity"),
        ]
```

**Multi-Selection Handling:**
- Display count of selected objects
- Show common properties (if all selected objects are same type)
- For MVP: display "Multiple objects selected (N)" placeholder
- P1: aggregate statistics (e.g., total pin count)

### 2.4 Keyboard Shortcut Architecture

#### Decision: Centralized Shortcut Registry with QAction Integration

**Rationale:**
- Qt's `QAction` provides built-in shortcut handling
- Centralized registry enables future customization
- Actions can be shared across menu, toolbar, and keyboard
- Consistent enable/disable state management

**Design:**

```python
# src/ink/ui/shortcuts/registry.py
from PySide6.QtWidgets import QWidget
from PySide6.QtGui import QKeySequence, QAction
from typing import Dict, Callable

class ShortcutRegistry:
    """Centralized keyboard shortcut management."""

    SHORTCUTS = {
        "search": ("Ctrl+F", "Open Search Dialog"),
        "undo": (QKeySequence.Undo, "Undo"),
        "redo": (QKeySequence.Redo, "Redo"),
        "delete": ("Delete", "Collapse Selected"),
        "backspace": ("Backspace", "Collapse Selected"),
        "fit_selection": ("Space", "Fit Selection to View"),
        "zoom_in": (QKeySequence.ZoomIn, "Zoom In"),
        "zoom_out": (QKeySequence.ZoomOut, "Zoom Out"),
        "escape": ("Escape", "Clear Selection"),
    }

    def __init__(self, parent_widget: QWidget):
        self.parent = parent_widget
        self.actions: Dict[str, QAction] = {}

    def register_all(self, handlers: Dict[str, Callable]):
        """Register all shortcuts with their handlers."""
        for action_id, handler in handlers.items():
            self.register(action_id, handler)

    def register(self, action_id: str, handler: Callable):
        """Register single shortcut."""
        if action_id not in self.SHORTCUTS:
            raise ValueError(f"Unknown action: {action_id}")

        shortcut, description = self.SHORTCUTS[action_id]
        action = QAction(description, self.parent)
        action.setShortcut(shortcut)
        action.triggered.connect(handler)

        self.parent.addAction(action)
        self.actions[action_id] = action

    def enable(self, action_id: str, enabled: bool):
        """Enable or disable action."""
        if action_id in self.actions:
            self.actions[action_id].setEnabled(enabled)
```

**Context-Aware Shortcuts:**
- Search (Ctrl+F): Always enabled
- Undo/Redo: Enabled based on undo stack state
- Delete/Backspace: Enabled only when selection is non-empty
- Fit Selection: Enabled only when selection is non-empty
- Zoom: Always enabled

---

## 3. Implementation Strategy

### 3.1 Phased Implementation Approach

#### Phase 1: Core Selection System (Week 1)
**Goal**: Basic single-selection with visual feedback

**Deliverables:**
- `SelectionManager` class with REPLACE mode
- Integration with `SchematicCanvas` mouse events
- Visual highlight rendering for selected objects
- Basic property panel shell (display cell/net name only)

**Acceptance:**
- Click on cell/net selects it with visual highlight
- Only one object selected at a time
- Selection updates property panel

**Dependencies:**
- E02 rendering system must support highlight overlay
- E01 object model must provide bounding box queries

#### Phase 2: Multi-Selection (Week 2)
**Goal**: Multi-select with rectangle and modifier keys

**Deliverables:**
- Add `ADD`, `TOGGLE`, `REMOVE` modes to `SelectionManager`
- Ctrl+click to add/toggle selection
- Rectangle selection with mouse drag
- Selection count in status bar

**Acceptance:**
- Ctrl+click adds objects to selection
- Drag rectangle selects all enclosed objects
- Multiple objects show highlight simultaneously

#### Phase 3: Property Panel (Week 2)
**Goal**: Complete property inspection for all object types

**Deliverables:**
- Property extraction for Cell, Net, Pin, Port
- Categorized property display
- Multi-selection handling (count display)

**Acceptance:**
- All object types display correct properties per spec
- Property panel updates within 50ms of selection change

#### Phase 4: Undo/Redo System (Week 3)
**Goal**: Full undo/redo for expansion/collapse

**Deliverables:**
- `QUndoStack` integration
- `ExpansionCommand` implementation
- `CollapseCommand` implementation
- Undo/redo menu items and shortcuts

**Acceptance:**
- Expansion can be undone, restoring previous view
- Redo re-applies expansion with same result
- Stack handles 50+ commands without crash

#### Phase 5: Keyboard Shortcuts (Week 3)
**Goal**: All P0 shortcuts functional

**Deliverables:**
- `ShortcutRegistry` implementation
- All shortcuts from spec registered
- Context-aware enable/disable logic

**Acceptance:**
- All listed shortcuts work as specified
- No conflicts with Qt default behaviors
- Shortcuts visually indicated in menus (P1)

### 3.2 Integration Points

**With E01 (Data Model):**
- Selection requires object IDs and bounding box queries
- Property extraction requires object attribute access
- Graph queries for connectivity information (net fanout, etc.)

**With E02 (Rendering):**
- Selection highlights rendered as overlay layer
- Multi-select highlights must be visually distinct
- Render invalidation on selection change

**With E03 (Expansion):**
- Expansion operations wrapped in `ExpansionCommand`
- Collapse operations wrapped in `CollapseCommand`
- Undo must trigger layout recalculation

**With E05 (Search):**
- Ctrl+F shortcut opens search dialog
- Search results update selection
- Selection state persists after search closes

### 3.3 Testing Strategy per Phase

**Phase 1-2 (Selection):**
```python
# tests/core/selection/test_manager.py
def test_single_selection_replaces_previous():
    manager = SelectionManager()
    cell1 = create_test_cell("C1")
    cell2 = create_test_cell("C2")

    manager.select(cell1)
    assert manager.count == 1

    manager.select(cell2)
    assert manager.count == 1
    assert not manager.is_selected(cell1)

def test_multi_selection_with_add_mode():
    manager = SelectionManager()
    cell1 = create_test_cell("C1")
    cell2 = create_test_cell("C2")

    manager.select(cell1, SelectMode.REPLACE)
    manager.select(cell2, SelectMode.ADD)

    assert manager.count == 2
    assert manager.is_selected(cell1)
    assert manager.is_selected(cell2)

def test_rectangle_selection():
    manager = SelectionManager()
    # Create cells at known positions
    cells = [create_cell_at_position(f"C{i}", x, y)
             for i, (x, y) in enumerate([(0,0), (10,10), (50,50)])]

    for cell in cells:
        manager.register_object(cell)

    # Select rectangle covering first two cells
    rect = QRectF(0, 0, 20, 20)
    count = manager.select_rect(rect)

    assert count == 2
    assert manager.is_selected(cells[0])
    assert manager.is_selected(cells[1])
    assert not manager.is_selected(cells[2])
```

**Phase 3 (Properties):**
```python
# tests/ui/panels/test_property_panel.py
def test_cell_properties_display():
    panel = PropertyPanel()
    cell = create_test_cell("INV_1", cell_type="INV_X1")
    cell.add_pin(Pin("A", PinDirection.INPUT))
    cell.add_pin(Pin("Y", PinDirection.OUTPUT))

    panel.display_properties(cell)

    assert panel.get_property("Name") == "INV_1"
    assert panel.get_property("Type") == "INV_X1"
    assert panel.get_property("Pin Count") == 2

def test_net_properties_show_fanout():
    panel = PropertyPanel()
    net = create_test_net("n1")
    net.driver = create_pin("U1/Y")
    net.sinks = [create_pin("U2/A"), create_pin("U3/A")]

    panel.display_properties(net)

    assert panel.get_property("Fanout Count") == 2
    assert "U2/A" in panel.get_property("Sinks")
```

**Phase 4 (Undo/Redo):**
```python
# tests/services/undo/test_commands.py
def test_expansion_undo_removes_cells():
    graph = create_test_graph()
    layout = create_test_layout()
    render = create_render_state()

    source_cell = graph.get_cell("U1")
    initial_cell_count = len(render.visible_cells)

    cmd = ExpansionCommand(graph, layout, render, source_cell,
                          ExpansionDirection.FANOUT, hops=1)
    cmd.redo()

    expanded_count = len(render.visible_cells)
    assert expanded_count > initial_cell_count

    cmd.undo()
    assert len(render.visible_cells) == initial_cell_count

def test_undo_stack_limit():
    stack = QUndoStack()
    stack.setUndoLimit(5)

    for i in range(10):
        stack.push(create_dummy_command(f"cmd_{i}"))

    # Should only be able to undo 5 times
    undo_count = 0
    while stack.canUndo():
        stack.undo()
        undo_count += 1

    assert undo_count == 5
```

**Phase 5 (Shortcuts):**
```python
# tests/ui/shortcuts/test_registry.py
def test_shortcut_registration():
    widget = QWidget()
    registry = ShortcutRegistry(widget)

    handler_called = False
    def handler():
        nonlocal handler_called
        handler_called = True

    registry.register("undo", handler)

    # Simulate Ctrl+Z
    QTest.keyClick(widget, Qt.Key_Z, Qt.ControlModifier)

    assert handler_called

def test_context_aware_enable_disable():
    registry = ShortcutRegistry(main_window)

    # Delete should be disabled when nothing selected
    assert not registry.actions["delete"].isEnabled()

    # Select object, delete should enable
    selection_manager.select(some_cell)
    registry.update_context(selection_manager)

    assert registry.actions["delete"].isEnabled()
```

---

## 4. Technical Deep Dive

### 4.1 Selection Hit Testing

**Challenge**: Efficiently determine which object was clicked, especially with overlapping elements.

**Solution**: Layered hit testing with priority order.

```python
# src/ink/ui/canvas/hit_testing.py
from typing import Optional, List
from PySide6.QtCore import QPointF
from enum import IntEnum

class HitTestPriority(IntEnum):
    """Priority order for hit testing (higher = test first)."""
    PIN = 3
    NET = 2
    CELL = 1
    BACKGROUND = 0

class HitTester:
    """Performs hit testing on schematic objects."""

    def __init__(self, render_state: RenderState):
        self.render_state = render_state

    def hit_test(self, point: QPointF, tolerance: float = 5.0) -> Optional[SchematicObject]:
        """
        Find topmost object at point, considering tolerance.

        Args:
            point: Scene coordinates
            tolerance: Hit test radius in pixels

        Returns:
            Topmost object or None
        """
        # Expand point to rectangle for tolerance
        hit_rect = QRectF(point.x() - tolerance, point.y() - tolerance,
                         2 * tolerance, 2 * tolerance)

        # Test in priority order
        candidates = []

        # Test pins first (small, high priority)
        for pin in self.render_state.visible_pins:
            if pin.bounds.intersects(hit_rect):
                candidates.append((HitTestPriority.PIN, pin))

        # Test nets (thin lines, medium priority)
        for net in self.render_state.visible_nets:
            if self._net_intersects_rect(net, hit_rect):
                candidates.append((HitTestPriority.NET, net))

        # Test cells (large, low priority)
        for cell in self.render_state.visible_cells:
            if cell.bounds.intersects(hit_rect):
                candidates.append((HitTestPriority.CELL, cell))

        # Return highest priority hit
        if candidates:
            candidates.sort(key=lambda x: x[0], reverse=True)
            return candidates[0][1]

        return None

    def _net_intersects_rect(self, net: Net, rect: QRectF) -> bool:
        """Check if any net segment intersects rectangle."""
        for segment in net.route_segments:
            if segment.intersects(rect):
                return True
        return False
```

**Performance Optimization (P1)**:
- Spatial indexing (R-tree) for large schematics
- View frustum culling to skip off-screen objects
- Distance-based early rejection

### 4.2 Selection Rendering

**Challenge**: Highlight selected objects without obscuring details.

**Solution**: Separate highlight overlay layer with configurable styles.

```python
# src/ink/ui/canvas/selection_overlay.py
from PySide6.QtGui import QPainter, QPen, QColor
from PySide6.QtCore import Qt

class SelectionOverlay:
    """Renders selection highlights over schematic."""

    HIGHLIGHT_COLOR = QColor(255, 165, 0, 180)  # Orange with alpha
    HIGHLIGHT_WIDTH = 2.0

    def render(self, painter: QPainter, selected_objects: List[SchematicObject]):
        """Render highlights for selected objects."""
        painter.save()

        # Configure highlight pen
        pen = QPen(self.HIGHLIGHT_COLOR)
        pen.setWidth(self.HIGHLIGHT_WIDTH)
        pen.setCosmetic(True)  # Width independent of zoom
        painter.setPen(pen)

        # Draw bounding box for each selected object
        for obj in selected_objects:
            if isinstance(obj, Cell):
                self._highlight_cell(painter, obj)
            elif isinstance(obj, Net):
                self._highlight_net(painter, obj)
            elif isinstance(obj, Pin):
                self._highlight_pin(painter, obj)

        painter.restore()

    def _highlight_cell(self, painter: QPainter, cell: Cell):
        """Draw cell highlight as thick border."""
        painter.drawRect(cell.bounds)

    def _highlight_net(self, painter: QPainter, net: Net):
        """Draw net highlight as thick route."""
        for segment in net.route_segments:
            painter.drawLine(segment.p1, segment.p2)

    def _highlight_pin(self, painter: QPainter, pin: Pin):
        """Draw pin highlight as circle."""
        painter.drawEllipse(pin.bounds)
```

**Visual Design Considerations:**
- Highlight must be visible on both light and dark backgrounds
- Cosmetic pen ensures consistent width regardless of zoom
- Alpha blending prevents complete occlusion of underlying objects
- Consider accessibility (colorblind users) - use pattern/style in addition to color (P1)

### 4.3 Undo State Compression

**Challenge**: Large expansions (50+ cells) consume significant memory if stored naively.

**Solution**: Incremental state storage with layout delta compression.

```python
# src/ink/core/undo/compression.py
from typing import Dict, Set
from dataclasses import dataclass

@dataclass
class LayoutDelta:
    """Compressed layout state for undo."""
    added_positions: Dict[str, tuple[float, float]]  # Only new cells
    removed_positions: Dict[str, tuple[float, float]]  # Only removed cells

    def compress(self) -> bytes:
        """Serialize to compact binary format (P1)."""
        # Use struct.pack for compact storage
        pass

    @classmethod
    def decompress(cls, data: bytes) -> 'LayoutDelta':
        """Deserialize from binary (P1)."""
        pass

class CompressedExpansionCommand(QUndoCommand):
    """Memory-efficient expansion command."""

    def __init__(self, ...):
        super().__init__(...)
        # Store only IDs, not full objects
        self.added_cell_ids: Set[str] = set()
        self.added_net_ids: Set[str] = set()
        # Store layout delta, not full layout
        self.layout_delta: Optional[LayoutDelta] = None

    def redo(self):
        if self.layout_delta:
            # Restore from delta
            self.layout_manager.apply_delta(self.layout_delta)
        else:
            # First execution - compute and store delta
            result = self.graph_manager.expand(...)
            self.added_cell_ids = result.cells
            self.layout_delta = self._compute_delta()

    def _compute_delta(self) -> LayoutDelta:
        """Compute minimal state difference."""
        before = self.layout_manager.get_positions()
        after = self.layout_manager.get_positions()

        added = {k: v for k, v in after.items() if k not in before}
        removed = {k: v for k, v in before.items() if k not in after}

        return LayoutDelta(added, removed)
```

**Memory Estimates:**
- Full object storage: ~1KB per cell (with all attributes)
- ID-only storage: ~50 bytes per cell (ID string + container overhead)
- Layout position: ~24 bytes per cell (ID ref + 2 floats)
- **Total per command**: ~74 bytes × cell_count
- **50 commands × 20 cells avg**: ~74KB (acceptable)

### 4.4 Property Extraction Performance

**Challenge**: Property panel must update quickly (<50ms) even for complex objects with many connections.

**Solution**: Lazy loading with progressive disclosure.

```python
# src/ink/ui/panels/property_panel.py
from PySide6.QtCore import QTimer

class PropertyPanel(QTableWidget):
    """Property panel with progressive loading."""

    def __init__(self):
        super().__init__()
        self._load_timer = QTimer()
        self._load_timer.setSingleShot(True)
        self._load_timer.timeout.connect(self._load_expensive_properties)
        self._pending_object = None

    def display_properties(self, obj: SchematicObject):
        """Display properties with progressive loading."""
        # Cancel pending load
        self._load_timer.stop()

        # Show basic properties immediately
        basic_props = self._extract_basic_properties(obj)
        self._populate_table(basic_props)

        # Schedule expensive properties (e.g., large fanout lists)
        if self._has_expensive_properties(obj):
            self._pending_object = obj
            self._load_timer.start(100)  # 100ms delay

    def _extract_basic_properties(self, obj: SchematicObject) -> List[PropertyItem]:
        """Extract properties that are immediately available."""
        if isinstance(obj, Cell):
            return [
                PropertyItem("Name", obj.name),
                PropertyItem("Type", obj.cell_type),
                PropertyItem("Pin Count", len(obj.pins)),
            ]
        # ... other types

    def _load_expensive_properties(self):
        """Load expensive properties after delay."""
        if not self._pending_object:
            return

        obj = self._pending_object
        if isinstance(obj, Net):
            # Fanout list can be large
            fanout_str = ", ".join(p.full_name for p in obj.sinks)
            self._add_property("Sinks", fanout_str)
```

**Performance Targets:**
- Basic properties: <16ms (synchronous)
- Expensive properties: <50ms total (async)
- Scrolling large lists: 60fps (virtualized table - P1)

---

## 5. Risk Analysis

### 5.1 Technical Risks

| Risk | Impact | Probability | Mitigation | Owner |
|------|--------|-------------|------------|-------|
| **Undo stack memory leak** | High | Medium | Implement stack size limit (50 commands), unit test memory usage over 100+ operations | Core Team |
| **Selection performance on large schematics** | Medium | Medium | Implement spatial indexing (R-tree) if >1000 objects, profile hit testing | Rendering Team |
| **Qt shortcut conflicts** | Low | High | Use standard `QKeySequence` constants, test on all platforms | UI Team |
| **Property panel slow for high-fanout nets** | Medium | Low | Implement progressive loading, truncate lists >100 items with "show more" | UI Team |
| **Undo/redo leaves stale visual state** | High | Medium | Strict render invalidation protocol, integration tests for all command types | Integration Team |

### 5.2 Integration Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **E02 rendering doesn't support highlight overlay** | High | Low | Verify overlay API in E02 spec, coordinate layer rendering order |
| **E03 expansion doesn't expose undo hooks** | High | Medium | Refactor expansion service to use command pattern, add undo entry points |
| **Property extraction requires E01 API not yet implemented** | Medium | Medium | Define required APIs early (e.g., `get_connected_nets()`), stub if needed |

### 5.3 User Experience Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Selection highlight not visible on all backgrounds** | Medium | High | Test on multiple color schemes, add configurable highlight color (P1) |
| **Undo/redo doesn't restore viewport** | Medium | Medium | Include viewport state in undo commands (P1 enhancement) |
| **Keyboard shortcuts not discoverable** | Low | High | Add tooltips to buttons, show shortcuts in menus (P1) |
| **Multi-select confusing without visual count** | Low | Medium | Display selection count in status bar |

### 5.4 Risk Mitigation Timeline

**Week 1 (Phase 1):**
- Validate E02 overlay API compatibility
- Define E01 property access interfaces

**Week 2 (Phase 2-3):**
- Profile selection performance with 1000+ cell test case
- Test property panel with high-fanout net (100+ sinks)

**Week 3 (Phase 4-5):**
- Memory profiling of undo stack with 50+ commands
- Cross-platform keyboard shortcut testing

---

## 6. Testing Strategy

### 6.1 Unit Testing

**Coverage Target**: >90% for core logic

**Key Test Areas:**

1. **SelectionManager**
   - Single selection replaces previous
   - Multi-select modes (ADD, TOGGLE, REMOVE)
   - Rectangle selection boundary cases
   - Signal emission on selection change
   - Clear selection

2. **Undo Commands**
   - ExpansionCommand undo/redo correctness
   - CollapseCommand undo/redo correctness
   - State restoration after multiple undo/redo cycles
   - Memory cleanup when commands removed from stack

3. **Property Extraction**
   - Correct properties for each object type
   - Handling of null/empty fields
   - Large fanout truncation

4. **Hit Testing**
   - Point in object bounds
   - Overlapping objects prioritized correctly
   - Tolerance handling
   - Edge cases (exactly on boundary)

**Example Test Structure:**
```python
# tests/core/selection/test_manager.py
import pytest
from ink.core.selection.manager import SelectionManager, SelectMode

class TestSelectionManager:
    @pytest.fixture
    def manager(self):
        return SelectionManager()

    @pytest.fixture
    def test_cells(self):
        return [create_test_cell(f"C{i}") for i in range(5)]

    def test_single_selection_clears_previous(self, manager, test_cells):
        """Selecting new object clears previous selection."""
        manager.select(test_cells[0])
        assert manager.count == 1

        manager.select(test_cells[1])
        assert manager.count == 1
        assert manager.is_selected(test_cells[1])
        assert not manager.is_selected(test_cells[0])

    def test_add_mode_preserves_selection(self, manager, test_cells):
        """ADD mode adds to selection without clearing."""
        manager.select(test_cells[0], SelectMode.REPLACE)
        manager.select(test_cells[1], SelectMode.ADD)

        assert manager.count == 2
        assert manager.is_selected(test_cells[0])
        assert manager.is_selected(test_cells[1])

    def test_selection_changed_signal(self, manager, test_cells):
        """selection_changed signal emits with selected objects."""
        signal_args = []
        manager.selection_changed.connect(lambda objs: signal_args.append(objs))

        manager.select(test_cells[0])

        assert len(signal_args) == 1
        assert test_cells[0] in signal_args[0]
```

### 6.2 Integration Testing

**Test Scenarios:**

1. **Selection → Property Panel Flow**
   ```python
   def test_selection_updates_property_panel(main_window):
       """Selecting object updates property panel."""
       cell = main_window.canvas.get_cell("U1")

       # Simulate click on cell
       main_window.canvas.click_at(cell.center)

       # Verify property panel updated
       assert main_window.property_panel.get_property("Name") == "U1"
       assert main_window.property_panel.get_property("Type") == cell.cell_type
   ```

2. **Expansion → Undo → Property Panel**
   ```python
   def test_undo_expansion_updates_property_panel(main_window):
       """Undoing expansion updates property panel if selected object removed."""
       cell = main_window.canvas.get_cell("U1")
       main_window.selection_manager.select(cell)

       # Expand fanout
       main_window.expansion_service.expand_fanout(cell, hops=1)

       # Select newly added cell
       new_cell = main_window.canvas.get_cell("U2")
       main_window.selection_manager.select(new_cell)

       # Undo expansion
       main_window.undo_manager.undo()

       # Verify property panel cleared (selected object no longer exists)
       assert main_window.property_panel.is_empty()
   ```

3. **Multi-Select → Keyboard Shortcut**
   ```python
   def test_delete_shortcut_collapses_selected(main_window):
       """Delete key collapses all selected cells."""
       cells = [main_window.canvas.get_cell(f"U{i}") for i in range(3)]

       for cell in cells:
           main_window.selection_manager.select(cell, SelectMode.ADD)

       initial_count = len(main_window.canvas.visible_cells)

       # Simulate Delete key
       QTest.keyClick(main_window, Qt.Key_Delete)

       # Verify cells collapsed
       assert len(main_window.canvas.visible_cells) < initial_count
       for cell in cells:
           assert not main_window.canvas.has_cell(cell.name)
   ```

### 6.3 Performance Testing

**Benchmarks:**

```python
# tests/performance/test_selection_perf.py
import pytest
from time import perf_counter

def test_selection_response_time(benchmark_canvas_1000_cells):
    """Selection must respond within 16ms (60fps)."""
    canvas = benchmark_canvas_1000_cells
    manager = canvas.selection_manager

    # Pick cell in middle of canvas
    cell = canvas.get_cell("U500")

    start = perf_counter()
    manager.select(cell)
    elapsed = perf_counter() - start

    assert elapsed < 0.016, f"Selection took {elapsed*1000:.2f}ms (max 16ms)"

def test_property_panel_update_time(benchmark_high_fanout_net):
    """Property panel update must complete within 50ms."""
    panel = PropertyPanel()
    net = benchmark_high_fanout_net  # 200+ sinks

    start = perf_counter()
    panel.display_properties(net)
    elapsed = perf_counter() - start

    assert elapsed < 0.050, f"Property update took {elapsed*1000:.2f}ms (max 50ms)"

def test_undo_response_time(benchmark_large_expansion):
    """Undo must complete within 100ms."""
    command = benchmark_large_expansion  # Expanded 50 cells

    start = perf_counter()
    command.undo()
    elapsed = perf_counter() - start

    assert elapsed < 0.100, f"Undo took {elapsed*1000:.2f}ms (max 100ms)"
```

### 6.4 UI Testing

**Manual Test Cases:**

1. **Selection Visual Feedback**
   - [ ] Single-click on cell shows orange highlight
   - [ ] Single-click on net shows orange highlight on route
   - [ ] Single-click on pin shows orange circle highlight
   - [ ] Multi-select shows all objects highlighted
   - [ ] Clicking empty space clears selection

2. **Property Panel Accuracy**
   - [ ] Cell properties match netlist data
   - [ ] Net fanout count matches visual connections
   - [ ] Pin direction matches schematic symbol
   - [ ] Multi-select shows "N objects selected"

3. **Undo/Redo Correctness**
   - [ ] Undo expansion removes added cells
   - [ ] Redo expansion restores removed cells
   - [ ] Undo/redo multiple times doesn't corrupt view
   - [ ] Undo/redo menu items enabled/disabled correctly

4. **Keyboard Shortcuts**
   - [ ] Ctrl+Z undoes last action
   - [ ] Ctrl+Shift+Z redoes last action
   - [ ] Delete collapses selected cells
   - [ ] Escape clears selection
   - [ ] Space fits selection to view

**Automated UI Testing (P1):**
- Use pytest-qt for Qt widget testing
- Simulate mouse clicks and keyboard events
- Verify visual state via screenshot comparison

---

## 7. Definition of Done

### 7.1 Functional Completeness

- [ ] All user stories (US-E04-01 through US-E04-05) acceptance criteria met
- [ ] Single-click selection works for cells, pins, nets, ports
- [ ] Multi-select works via Ctrl+click and rectangle drag
- [ ] Property panel displays all required properties for each object type
- [ ] Undo/redo works for expansion and collapse operations
- [ ] All keyboard shortcuts from spec are functional

### 7.2 Quality Criteria

- [ ] Unit test coverage >90% for core selection and undo logic
- [ ] All integration tests pass
- [ ] Performance benchmarks met:
  - Selection response <16ms
  - Property panel update <50ms
  - Undo/redo <100ms
- [ ] No memory leaks in 50+ undo command cycles
- [ ] Manual UI test cases 100% pass

### 7.3 Documentation

- [ ] Code documentation (docstrings) for all public APIs
- [ ] Architecture decisions recorded in ADR format (P1)
- [ ] User-facing documentation for keyboard shortcuts (P1)
- [ ] Known limitations documented (e.g., undo stack size limit)

### 7.4 Code Quality

- [ ] Passes mypy type checking with no errors
- [ ] Passes ruff linting with no errors
- [ ] Code review approved by 2+ team members
- [ ] No TODO/FIXME comments without associated tickets

### 7.5 Integration

- [ ] E02 rendering integration complete (selection overlay)
- [ ] E03 expansion integration complete (undo commands)
- [ ] E05 search integration stub ready (Ctrl+F handler)
- [ ] No blocking issues for dependent epics

### 7.6 Deployment Readiness

- [ ] Merged to main branch
- [ ] Release notes updated
- [ ] Breaking changes communicated to team
- [ ] Migration path documented if data model changes

---

## 8. Open Questions

### 8.1 Technical Questions

1. **Selection Persistence Across Views**
   - Q: Should selection persist when switching between multiple schematic tabs (future feature)?
   - A: TBD - likely yes for consistency, but needs design discussion

2. **Undo Scope**
   - Q: Should undo apply per-tab or globally?
   - A: Per-tab for MVP, global option in P1

3. **Property Panel Layout**
   - Q: Categorized sections (collapsible) or flat list?
   - A: Flat list for MVP, categorized in P1 for complex objects

### 8.2 UX Questions

1. **Multi-Select Visual Affordance**
   - Q: How to indicate that Ctrl+click adds to selection?
   - A: Status bar tooltip or inline hint (P1)

2. **Selection Color**
   - Q: Should highlight color be theme-dependent?
   - A: Fixed orange for MVP, themeable in P1

3. **Property Panel Multi-Select**
   - Q: Show aggregated properties or just count?
   - A: Just count for MVP, aggregation in P1

---

## 9. Success Criteria

### 9.1 MVP Success

The E04 epic is considered successful for MVP when:

1. **Engineers can efficiently select and inspect objects**
   - Selection feels responsive and intuitive
   - Property panel provides all needed information at a glance
   - No confusion about what is selected

2. **Undo/redo enables confident exploration**
   - Engineers experiment freely knowing they can undo
   - Undo consistently restores previous view state
   - No unexpected behavior after undo/redo

3. **Keyboard shortcuts accelerate workflows**
   - Power users adopt shortcuts for common actions
   - Shortcuts don't conflict with system/browser shortcuts
   - Discoverability through menus/tooltips

### 9.2 Quantitative Metrics

- Selection latency <16ms (measured via performance tests)
- Property panel update <50ms (measured via performance tests)
- Undo/redo latency <100ms (measured via performance tests)
- Zero crashes related to selection/undo in 1-week beta testing
- <3 bugs reported related to selection behavior in first month

### 9.3 Qualitative Metrics

- User feedback: "Selection feels natural and responsive"
- User feedback: "Undo saved me from mistakes multiple times"
- User feedback: "Keyboard shortcuts make me much faster"
- No user confusion about selection state (based on user studies)

---

## 10. References

### 10.1 Internal Documents

- [PRD - Product Requirements Document](../../docs/prd.md)
- [E01 Spec - Data Model](../E01/E01.spec.md)
- [E02 Spec - Rendering](../E02/E02.spec.md)
- [E03 Spec - Expansion](../E03/E03.spec.md)
- [E04 Spec - Object Interaction](./E04.spec.md)

### 10.2 External Resources

- [Qt Documentation - QUndoStack](https://doc.qt.io/qt-6/qundostack.html)
- [Qt Documentation - QAction and Shortcuts](https://doc.qt.io/qt-6/qaction.html)
- [Qt Documentation - QGraphicsScene Selection](https://doc.qt.io/qt-6/qgraphicsscene.html#selection)
- [Command Pattern - Design Patterns](https://refactoring.guru/design-patterns/command)

### 10.3 Related Patterns

- **Command Pattern**: Undo/redo implementation
- **Observer Pattern**: Selection change notifications
- **Facade Pattern**: UndoManager over QUndoStack
- **Strategy Pattern**: Hit testing priority strategies

---

## Appendix A: Selection State Machine

```
┌─────────────┐
│   EMPTY     │ ← Initial state, nothing selected
└──────┬──────┘
       │ click(obj, REPLACE)
       ▼
┌─────────────┐
│ SINGLE_SEL  │ ← One object selected
└──────┬──────┘
       │ click(obj2, ADD)
       ▼
┌─────────────┐
│ MULTI_SEL   │ ← Multiple objects selected
└──────┬──────┘
       │ click(empty) / Escape
       ▼
┌─────────────┐
│   EMPTY     │
└─────────────┘
```

## Appendix B: Property Panel Mockup

```
┌───────────────────────────────┐
│ Properties                    │
├───────────────────────────────┤
│ Property      │ Value         │
├───────────────┼───────────────┤
│ Name          │ U1            │
│ Type          │ AND2_X1       │
│ Is Sequential │ False         │
│ Pin Count     │ 3             │
│ Input Pins    │ A, B          │
│ Output Pins   │ Y             │
└───────────────┴───────────────┘
```

## Appendix C: Undo Command Memory Layout

```
ExpansionCommand (est. 200 bytes)
├── Command ID: 8 bytes
├── Description string: ~30 bytes
├── Source object ID: ~30 bytes
├── Direction enum: 1 byte
├── Hop count: 4 bytes
├── Added cells set: ~50 bytes (avg 3 cells × 16 bytes overhead)
├── Added nets set: ~50 bytes (avg 3 nets × 16 bytes overhead)
└── Layout delta: ~24 bytes (positions)

Total per command: ~200 bytes
50 commands: ~10 KB (negligible)
```

---

**End of Pre-Implementation Documentation**
