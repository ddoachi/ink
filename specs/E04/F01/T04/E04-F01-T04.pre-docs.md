# E04-F01-T04 - Selection Highlighting: Pre-Implementation Documentation

## Document Information
- **Task**: E04-F01-T04 - Selection Highlighting
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements visual highlighting for selected schematic objects. When objects are selected (via T02 single-click or T03 multi-select), they are rendered with a distinctive outline (orange/yellow, 2-3px width) and raised to a higher Z-order to ensure visibility. The highlighting system listens to the `SelectionService.selection_changed` signal and updates all item visuals immediately.

### 1.2 Problem Context

Selection without visual feedback is disorienting and error-prone. Users need immediate, unmistakable confirmation that:
- An object is selected (highlight appears)
- Multiple objects are selected (all have highlights)
- Selection is cleared (all highlights disappear)
- Which object has focus among multiple selections

The highlighting must be:
- **Immediate**: Appear within 16ms (60 FPS) of selection change
- **Distinctive**: Clearly distinguishable from normal rendering
- **Consistent**: Same style across all object types (cells, pins, nets)
- **Performant**: Update 100+ items without lag
- **Zoom-Independent**: Visible at all zoom levels

### 1.3 Success Metrics

- Highlight appears within 16ms of selection change
- 100 items can be highlighted simultaneously without performance degradation
- Highlight visible at zoom levels from 25% to 400%
- Consistent visual style across all object types
- Selected items always appear on top (higher Z-order)

---

## 2. Implementation Approach

### 2.1 Highlight Architecture

**Decision**: Implement highlighting in `SchematicItem` base class, propagate to all subclasses.

**Rationale**:
- **Single Source of Truth**: Highlight logic in one place, consistent behavior
- **Polymorphism**: Canvas can treat all items uniformly
- **Separation of Concerns**: Items manage their own visual state, canvas manages which items are selected

**Class Hierarchy**:
```
SchematicItem (base)
    ├── set_highlighted(bool) - State management
    ├── is_highlighted() - Query
    ├── _get_pen() - Pen selection based on state
    └── _get_normal_pen() - Abstract (subclass override)

CellItem, PinItem, NetItem (subclasses)
    ├── paint() - Uses _get_pen() for rendering
    └── _get_normal_pen() - Returns normal pen style
```

**Alternative Considered**: Separate `HighlightOverlay` items
- **Rejected**: Doubles item count, complicates Z-ordering, more complex lifecycle management

### 2.2 Highlight Visual Specification

**Constants** (in `SchematicItem`):
```python
SELECTION_COLOR = QColor(255, 140, 0)  # Orange (#FF8C00)
SELECTION_WIDTH = 2.5  # pixels
NORMAL_Z_VALUE = 0
SELECTED_Z_VALUE = 100
```

**Rationale**:
- **Orange Color**: High contrast, distinguishable from schematic colors (black, blue, gray)
- **2.5px Width**: Thick enough to be obvious, thin enough not to obscure
- **Z-Order Delta**: 100-point separation ensures selected items always on top

**Alternative Colors Considered**:
- **Yellow (#FFD700)**: Good contrast, but can blend with warning indicators
- **Blue (#0078D7)**: Standard selection color, but used for nets in schematic
- **Orange (#FF8C00)**: Best balance of visibility and distinction
- **Decision**: Use orange, make configurable in future theme support

### 2.3 Pen Abstraction Pattern

**Decision**: Use template method pattern for pen selection.

**Implementation**:
```python
class SchematicItem(QGraphicsItem):
    def _get_pen(self) -> QPen:
        """Get pen based on selection state (template method)"""
        if self._is_highlighted:
            return QPen(self.SELECTION_COLOR, self.SELECTION_WIDTH, Qt.SolidLine)
        else:
            return self._get_normal_pen()

    def _get_normal_pen(self) -> QPen:
        """Get normal pen (subclass override)"""
        return QPen(Qt.black, 1.0, Qt.SolidLine)
```

**Subclass Usage**:
```python
class CellItem(SchematicItem):
    def paint(self, painter, option, widget):
        pen = self._get_pen()  # Automatically gets selection or normal pen
        painter.setPen(pen)
        painter.drawRect(self.boundingRect())

    def _get_normal_pen(self) -> QPen:
        return QPen(Qt.black, 1.0, Qt.SolidLine)
```

**Rationale**:
- **Template Method**: Subclasses don't need to know about selection logic
- **Consistent**: All items automatically get selection highlighting
- **Extensible**: Easy to add other visual states (hover, focus, disabled)

### 2.4 Canvas Integration

**Decision**: Canvas listens to `selection_changed` signal and updates item highlights.

**Implementation**:
```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service

        # Map object_id -> item for quick lookup
        self._item_map: Dict[str, SchematicItem] = {}

        # Listen to selection changes
        self._selection_service.selection_changed.connect(self._on_selection_changed)

    def add_item(self, item: SchematicItem) -> None:
        """Add item to canvas and register in lookup map"""
        self._scene.addItem(item)
        self._item_map[item.object_id] = item

    def _on_selection_changed(self, selected_ids: List[str]) -> None:
        """Update highlights when selection changes"""
        selected_set = set(selected_ids)

        for object_id, item in self._item_map.items():
            should_highlight = object_id in selected_set
            item.set_highlighted(should_highlight)
```

**Rationale**:
- **ID Lookup Map**: O(1) lookup of items by ID
- **Batch Update**: Single signal triggers update of all items
- **Efficient**: Only updates items whose state changes (in `set_highlighted`)

**Alternative Considered**: Items listen to signal directly
- **Rejected**: N signal connections (one per item), harder to debug, memory overhead

### 2.5 Z-Order Management

**Decision**: Automatically raise selected items to higher Z-value.

**Implementation** (in `SchematicItem.set_highlighted()`):
```python
def set_highlighted(self, highlighted: bool) -> None:
    if self._is_highlighted != highlighted:
        self._is_highlighted = highlighted

        # Update Z-order
        if highlighted:
            self.setZValue(self.SELECTED_Z_VALUE)
        else:
            self.setZValue(self.NORMAL_Z_VALUE)

        # Trigger repaint
        self.update()
```

**Rationale**:
- **Visibility**: Selected items never hidden behind unselected items
- **Context**: User focuses on selected items, so they should be prominent
- **Automatic**: Coupled with selection state, no manual Z-order management

**Trade-off**: All selected items have same Z-value (can overlap each other)
- **Acceptable**: Within selection set, item order usually not critical
- **Future Enhancement**: Preserve relative Z-order within selected set if needed

---

## 3. Key Design Decisions

### 3.1 State Storage Location

**Decision**: Store highlight state in item (`_is_highlighted`), not in service.

**Rationale**:
- **Encapsulation**: Item knows its own visual state
- **Performance**: No service query needed during paint()
- **Consistency**: Visual state lives with visual object

**Alternative**: Query service during paint()
```python
# REJECTED:
def paint(self, painter, option, widget):
    if self._selection_service.is_selected(self.object_id):
        pen = get_selection_pen()
```
- **Problems**: Requires passing service to all items, tight coupling, slower

### 3.2 Change Detection in set_highlighted()

**Decision**: Only update if state actually changes.

```python
def set_highlighted(self, highlighted: bool) -> None:
    if self._is_highlighted != highlighted:  # Check before updating
        self._is_highlighted = highlighted
        self.setZValue(...)
        self.update()
```

**Rationale**:
- **Performance**: Avoids redundant Z-value changes and repaints
- **Event Noise**: Doesn't trigger unnecessary update events
- **Optimization**: Common case is selecting already-selected item (no-op)

### 3.3 Repaint Trigger

**Decision**: Call `self.update()` to trigger repaint, not `scene().update()`.

**Rationale**:
- **Minimal Repaint**: Only repaints affected item, not entire scene
- **Performance**: Faster for single-item selection changes
- **Qt Best Practice**: Let Qt's invalidation system handle scene updates

### 3.4 Pen Width Scaling

**Decision**: Use fixed pixel width (2.5px), not scaled with zoom.

**Rationale**:
- **Readability**: Highlight always same visual thickness on screen
- **Zoom Independence**: Visible at all zoom levels
- **Standard**: Matches most CAD/graphics applications

**Alternative**: Scale with zoom (cosmetic pen)
```python
pen = QPen(color, 2.5)
pen.setCosmetic(False)  # Width scales with zoom
```
- **Rejected**: Highlight becomes invisible when zoomed out, too thick when zoomed in

### 3.5 Multiple Visual States

**Decision**: Support only selected/unselected for MVP. Reserve for future:
- Hover state (item under mouse cursor)
- Focus state (keyboard focus)
- Disabled state (grayed out)

**Rationale**:
- **YAGNI**: Don't add complexity until needed
- **Extensible**: Design allows easy addition of states
```python
def _get_pen(self) -> QPen:
    if self._is_disabled:
        return self._get_disabled_pen()
    elif self._is_highlighted:
        return self._get_selection_pen()
    elif self._is_hovered:
        return self._get_hover_pen()
    else:
        return self._get_normal_pen()
```

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Critical Dependencies**:
1. **E04-F01-T01 (SelectionManager)**: Provides `selection_changed` signal
2. **E02 (Rendering)**: `CellItem`, `PinItem`, `NetItem` must exist with `paint()` methods

**Assumption**: Items already have working `paint()` methods that can be modified to use `_get_pen()`.

### 4.2 Downstream Dependencies

**Tasks Depending on T04**:
1. **E04-F02 (Property Panel)**: Visual feedback complements property display
2. **E03 (Expansion)**: Selected cells used as expansion origins
3. **Future (Undo/Redo)**: Selection highlighting must update after undo

### 4.3 Integration with Item Rendering

**Modification Pattern**:

**Before** (existing CellItem.paint()):
```python
def paint(self, painter, option, widget):
    pen = QPen(Qt.black, 1.0)
    painter.setPen(pen)
    painter.drawRect(self.boundingRect())
```

**After** (with highlighting):
```python
def paint(self, painter, option, widget):
    pen = self._get_pen()  # Uses selection or normal pen
    painter.setPen(pen)
    painter.drawRect(self.boundingRect())
```

**Impact**: Minimal changes to existing code.

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Highlight State Tests**:
```python
def test_item_starts_not_highlighted():
    """Items created without highlight by default"""

def test_set_highlighted_changes_state():
    """set_highlighted(True) changes state"""

def test_set_highlighted_updates_z_order():
    """Highlighted item has higher Z-value"""

def test_set_highlighted_idempotent():
    """Setting same state twice doesn't cause issues"""
```

**Pen Selection Tests**:
```python
def test_highlighted_pen_uses_selection_color():
    """Highlighted item returns orange pen"""

def test_normal_pen_uses_subclass_color():
    """Non-highlighted item uses subclass pen"""

def test_highlighted_pen_width_thicker():
    """Selection pen is thicker than normal"""
```

**Canvas Integration Tests**:
```python
def test_canvas_updates_highlights_on_selection(qtbot):
    """Canvas updates item highlights when selection changes"""

def test_single_selection_highlights_one_item(qtbot):
    """Single selection highlights only that item"""

def test_multi_selection_highlights_all(qtbot):
    """Multi-selection highlights all selected items"""

def test_clear_selection_removes_highlights(qtbot):
    """Clearing selection removes all highlights"""
```

**Z-Order Tests**:
```python
def test_selected_item_on_top():
    """Selected item has higher Z than unselected"""

def test_multiple_selected_same_z():
    """Multiple selected items have same Z-value"""
```

### 5.2 Visual Regression Testing

**Manual Inspection** (create test scenes):
1. Select single cell → verify orange outline
2. Select single pin → verify orange circle
3. Select single net → verify orange path
4. Select multiple objects → all have highlights
5. Zoom in/out → highlight thickness constant
6. Pan view → highlights move with items

**Screenshots**: Capture reference images for future comparison.

### 5.3 Performance Testing

**Highlight Update Latency**:
```python
def test_highlight_update_within_16ms():
    """Highlight updates complete within one frame (60 FPS)"""
    service = SelectionService()
    canvas = SchematicCanvas(service)

    # Add 100 items
    for i in range(100):
        item = CellItem(object_id=f"cell{i}", ...)
        canvas.add_item(item)

    import time
    start = time.perf_counter()

    # Select all items
    service.select_multiple([f"cell{i}" for i in range(100)], SelectMode.REPLACE)

    elapsed = (time.perf_counter() - start) * 1000  # ms
    assert elapsed < 16
```

**Repaint Performance**:
```python
def test_repaint_performance():
    """Repainting highlighted items doesn't degrade FPS"""
    # Measure frame rate with 100 highlighted items during pan/zoom
    # Target: Maintain 60 FPS
```

### 5.4 Integration Testing

**End-to-End Test**:
```python
def test_complete_highlight_workflow(qtbot):
    """Test complete workflow: click → select → highlight"""
    app = InkApplication()

    # Click cell
    # Verify: selection_changed signal emitted
    # Verify: item.set_highlighted(True) called
    # Verify: item Z-value increased
    # Verify: item repainted with orange pen

    # Click empty space
    # Verify: selection cleared
    # Verify: item.set_highlighted(False) called
    # Verify: item Z-value restored
    # Verify: item repainted with normal pen
```

---

## 6. Risks and Considerations

### 6.1 Performance Risks

**Risk**: Updating 1000+ item highlights causes frame drops.

**Impact**: Medium - Perceived lag during large multi-selection
**Probability**: Low - Highlight update is fast (just Z-value and flag)
**Mitigation**:
- Benchmark with 1000+ items
- If slow, batch updates and use `scene.update()` once after all items updated
- Consider progressive update (update visible items first)

**Optimization Strategy**:
```python
def _on_selection_changed(self, selected_ids: List[str]) -> None:
    selected_set = set(selected_ids)

    # Update all items
    for object_id, item in self._item_map.items():
        item.set_highlighted(object_id in selected_set)

    # Single scene update instead of N item updates
    self._scene.update()
```

### 6.2 Visual Clarity Risks

**Risk**: Highlight not visible on certain backgrounds.

**Impact**: Medium - User can't tell if object is selected
**Probability**: Low - Orange has good contrast on most backgrounds
**Mitigation**:
- Test on various schematic backgrounds (white, gray, black)
- Add configurable highlight color in future
- Consider highlight glow effect if needed (outer stroke)

### 6.3 Z-Order Conflicts

**Risk**: Other features also modify Z-order (e.g., animations).

**Impact**: Medium - Z-order fighting, visual flicker
**Probability**: Low - No other Z-order manipulation in MVP
**Mitigation**:
- Document Z-value ranges for different purposes:
  - 0-99: Normal items
  - 100-199: Selected items
  - 200-299: Temporary overlays (drag rectangle)
  - 1000+: Modal overlays
- Reserve Z-value ranges, don't let features conflict

### 6.4 Hover vs. Selection Confusion

**Risk**: Adding hover highlighting later conflicts with selection highlighting.

**Impact**: Low - Different visual styles can distinguish them
**Probability**: Medium - Hover highlighting is common feature
**Mitigation**:
- Selection: Orange outline, 2.5px
- Hover: Light blue glow, 1px (future)
- Can combine: Hovered + selected = both effects

### 6.5 Memory Leaks from Signal Connections

**Risk**: Item map holds references, preventing garbage collection.

**Impact**: Medium - Memory grows over long sessions
**Probability**: Low - Items removed from map when removed from scene
**Mitigation**:
- Implement `remove_item()` that cleans up map entry
- Use weak references if needed (probably not)
- Document item lifecycle expectations

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should highlight style vary by object type (cells vs. pins vs. nets)?
**Answer**: No for MVP. Uniform style is simpler and still clear. Consider in future for advanced users.

**Q2**: Should selected items have fill color change in addition to outline?
**Answer**: No. Outline is sufficient, less intrusive. Avoids obscuring internal details.

**Q3**: Should highlight animation (fade in) be added?
**Answer**: No for MVP. Instant feedback is better than animation delay. Consider in P2 polish phase.

**Q4**: What if item has no outline (e.g., text labels)?
**Answer**: Add bounding box outline for selection highlight. Text labels are rare in MVP.

### 7.2 UX Questions

**Q1**: Should highlight thickness be configurable?
**Answer**: Not in MVP. Hard-coded 2.5px. Add to settings in future.

**Q2**: Should there be different highlight for "primary" selection (last clicked item)?
**Answer**: Not in MVP. All selected items equal. Consider in future if needed.

**Q3**: Should highlight pulse or blink?
**Answer**: No. Static highlight is less distracting, doesn't cause eye strain.

### 7.3 Accessibility Questions

**Q1**: Is orange highlight accessible for color-blind users?
**Answer**: Orange-blue contrast works for most types. Add configurable colors in accessibility settings later.

**Q2**: Should selection have non-visual indicator (sound, status text)?
**Answer**: Status bar shows count (from T03). Audio feedback not needed for MVP.

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `SchematicItem` has `set_highlighted(bool)` method
- [ ] `SchematicItem` has `is_highlighted()` query method
- [ ] `SchematicItem` defines selection color, width, Z-value constants
- [ ] `_get_pen()` template method implemented in base class
- [ ] `_get_normal_pen()` abstract method defined
- [ ] `CellItem.paint()` uses `_get_pen()`
- [ ] `PinItem.paint()` uses `_get_pen()`
- [ ] `NetItem.paint()` uses `_get_pen()`
- [ ] Canvas maintains `_item_map` for ID lookup
- [ ] Canvas connected to `selection_changed` signal
- [ ] `_on_selection_changed()` updates all item highlights
- [ ] Selected items have higher Z-value than unselected

### 8.2 Quality Checklist

- [ ] All unit tests pass
- [ ] Highlight update completes within 16ms for 100 items
- [ ] Visual inspection confirms orange outline on all object types
- [ ] Highlight visible at zoom levels 25%-400%
- [ ] Type hints on all new methods
- [ ] Docstrings on highlight methods
- [ ] No mypy errors
- [ ] No ruff warnings

### 8.3 Visual Checklist

- [ ] Highlighted cells have orange outline
- [ ] Highlighted pins have orange outline
- [ ] Highlighted nets have orange path
- [ ] Outline width is 2.5 pixels
- [ ] Selected items appear on top of unselected
- [ ] Multiple selected items all highlighted
- [ ] Clearing selection removes all highlights

### 8.4 Integration Checklist

- [ ] Works with single selection (T02)
- [ ] Works with multi-selection (T03)
- [ ] Property panel integration still works
- [ ] Status bar integration still works
- [ ] No conflicts with existing rendering

---

## 9. Implementation Steps

### 9.1 Step-by-Step Plan

**Phase 1: Base Class Infrastructure (1 hour)**
1. Add constants to `SchematicItem`: colors, widths, Z-values
2. Add `_is_highlighted` state variable
3. Implement `set_highlighted()` method with Z-order update
4. Implement `is_highlighted()` query method
5. Implement `_get_pen()` template method
6. Define `_get_normal_pen()` abstract method

**Phase 2: Subclass Integration (1 hour)**
7. Modify `CellItem.paint()` to use `_get_pen()`
8. Implement `CellItem._get_normal_pen()`
9. Modify `PinItem.paint()` to use `_get_pen()`
10. Implement `PinItem._get_normal_pen()`
11. Modify `NetItem.paint()` to use `_get_pen()`
12. Implement `NetItem._get_normal_pen()`

**Phase 3: Canvas Integration (1 hour)**
13. Add `_item_map: Dict[str, SchematicItem]` to canvas
14. Update `add_item()` to populate map
15. Implement `remove_item()` to clean up map
16. Connect to `selection_changed` signal
17. Implement `_on_selection_changed()` handler

**Phase 4: Testing (1.5 hours)**
18. Create test file `tests/ui/canvas/test_selection_highlighting.py`
19. Write unit tests for highlight state
20. Write unit tests for pen selection
21. Write integration tests with canvas
22. Write performance test
23. Run manual visual testing

**Phase 5: Refinement (30 minutes)**
24. Add docstrings
25. Run type checker and linter
26. Fix any issues
27. Optimize if needed

### 9.2 Estimated Time Breakdown

- Phase 1: 1 hour
- Phase 2: 1 hour
- Phase 3: 1 hour
- Phase 4: 1.5 hours
- Phase 5: 30 minutes
- **Total**: ~5 hours (slightly over 4-hour estimate, but reasonable with polish)

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T04/E04-F01-T04.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Dependencies**:
  - T01: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T01/E04-F01-T01.spec.md`
  - E02 Rendering: (schematic items)
- **Qt Graphics**: https://doc.qt.io/qt-6/qgraphicsitem.html#paint
- **Qt Pen Styles**: https://doc.qt.io/qt-6/qpen.html

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
