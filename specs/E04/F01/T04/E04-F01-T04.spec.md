# Spec: E04-F01-T04 - Selection Highlighting

## Metadata
- **ID**: E04-F01-T04
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E04-F01](../E04-F01.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 4
- **Actual Hours**:
- **Effort**: Medium
- **Tags**: [selection, rendering, visual-feedback]

---

## 1. Overview

### 1.1 Problem Statement

Selected schematic objects must be visually distinguished from unselected objects to provide clear feedback about the current selection state. Users need immediate visual confirmation when objects are selected, with highlighting that is distinctive, consistent across object types, and maintains visibility during pan/zoom operations.

### 1.2 Goals

- Render distinct visual highlight for selected objects (yellow/orange outline)
- Apply consistent highlight style across all object types (cells, pins, nets)
- Draw selected objects on top (higher Z-order) for visibility
- Update highlights immediately when selection changes (<16ms)
- Maintain highlight visibility at all zoom levels

---

## 2. Technical Requirements

### 2.1 Selection Highlight Specification

**Visual Style:**
- **Color**: Orange (#FF8C00) or Yellow (#FFD700)
- **Outline Width**: 2-3 pixels
- **Outline Style**: Solid line
- **Z-Order**: Selected items rendered on top (higher Z-value)
- **Fill**: No change to object fill (only outline changes)

### 2.2 SchematicItem Highlight Implementation

**Location**: `src/ink/presentation/canvas/schematic_item.py`

```python
from PySide6.QtWidgets import QGraphicsItem
from PySide6.QtGui import QPen, QColor
from PySide6.QtCore import Qt

class SchematicItem(QGraphicsItem):
    """Base class for all schematic graphical items"""

    NORMAL_Z_VALUE = 0
    SELECTED_Z_VALUE = 100
    SELECTION_COLOR = QColor(255, 140, 0)  # Orange
    SELECTION_WIDTH = 2.5

    def __init__(self, object_id: str):
        super().__init__()
        self.object_id = object_id
        self._is_highlighted = False
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        self.setZValue(self.NORMAL_Z_VALUE)

    def set_highlighted(self, highlighted: bool) -> None:
        """
        Set selection highlight state.

        Args:
            highlighted: True to show highlight, False to remove
        """
        if self._is_highlighted != highlighted:
            self._is_highlighted = highlighted

            # Update Z-order
            if highlighted:
                self.setZValue(self.SELECTED_Z_VALUE)
            else:
                self.setZValue(self.NORMAL_Z_VALUE)

            # Trigger repaint
            self.update()

    def is_highlighted(self) -> bool:
        """Check if item is currently highlighted."""
        return self._is_highlighted

    def _get_pen(self) -> QPen:
        """
        Get pen for drawing outline.
        Subclasses should call this to get base pen, then modify as needed.
        """
        if self._is_highlighted:
            return QPen(self.SELECTION_COLOR, self.SELECTION_WIDTH, Qt.SolidLine)
        else:
            return self._get_normal_pen()

    def _get_normal_pen(self) -> QPen:
        """Get normal (non-highlighted) pen. Override in subclasses."""
        return QPen(Qt.black, 1.0, Qt.SolidLine)
```

### 2.3 CellItem Highlight Rendering

**Location**: `src/ink/presentation/canvas/cell_item.py`

```python
class CellItem(SchematicItem):
    """Graphical representation of a cell instance"""

    def paint(self, painter, option, widget):
        """Render cell with selection highlight if selected"""
        # Get appropriate pen based on selection state
        pen = self._get_pen()
        painter.setPen(pen)

        # Draw cell body (rectangle)
        painter.drawRect(self.boundingRect())

        # Draw cell name
        painter.setFont(QFont("Arial", 8))
        painter.drawText(self.boundingRect(), Qt.AlignCenter, self.cell_name)

    def _get_normal_pen(self) -> QPen:
        """Normal cell outline: black, 1px"""
        return QPen(Qt.black, 1.0, Qt.SolidLine)
```

### 2.4 PinItem Highlight Rendering

**Location**: `src/ink/presentation/canvas/pin_item.py`

```python
class PinItem(SchematicItem):
    """Graphical representation of a cell pin"""

    def paint(self, painter, option, widget):
        """Render pin with selection highlight if selected"""
        pen = self._get_pen()
        painter.setPen(pen)

        # Draw pin as small circle
        painter.drawEllipse(self.boundingRect())

    def _get_normal_pen(self) -> QPen:
        """Normal pin outline: dark gray, 1px"""
        return QPen(QColor(64, 64, 64), 1.0, Qt.SolidLine)
```

### 2.5 NetItem Highlight Rendering

**Location**: `src/ink/presentation/canvas/net_item.py`

```python
class NetItem(SchematicItem):
    """Graphical representation of a net (wire)"""

    def paint(self, painter, option, widget):
        """Render net with selection highlight if selected"""
        pen = self._get_pen()
        painter.setPen(pen)

        # Draw net path
        painter.drawPath(self._path)

    def _get_normal_pen(self) -> QPen:
        """Normal net line: dark blue, 1px"""
        return QPen(QColor(0, 0, 139), 1.0, Qt.SolidLine)
```

### 2.6 Canvas Integration - Selection Change Handler

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service
        self._scene = QGraphicsScene()
        self.setScene(self._scene)

        # Map object_id -> item for quick lookup
        self._item_map: Dict[str, SchematicItem] = {}

        # Listen to selection changes
        self._selection_service.selection_changed.connect(self._on_selection_changed)

    def add_item(self, item: SchematicItem) -> None:
        """Add item to canvas and register in lookup map"""
        self._scene.addItem(item)
        self._item_map[item.object_id] = item

    def remove_item(self, item: SchematicItem) -> None:
        """Remove item from canvas and lookup map"""
        self._scene.removeItem(item)
        self._item_map.pop(item.object_id, None)

    def _on_selection_changed(self, selected_ids: List[str]) -> None:
        """
        Update visual highlights when selection changes.

        Args:
            selected_ids: List of currently selected object IDs
        """
        selected_set = set(selected_ids)

        # Update all items
        for object_id, item in self._item_map.items():
            should_highlight = object_id in selected_set
            item.set_highlighted(should_highlight)
```

### 2.7 Design Decisions

1. **Base Class Pattern**: Highlight logic in `SchematicItem` base class for consistency
2. **Pen Abstraction**: `_get_pen()` method allows subclasses to customize normal appearance
3. **Z-Order Management**: Selected items automatically raised to top Z-layer
4. **Event-Driven Update**: Canvas listens to `selection_changed` signal and updates highlights
5. **Item Lookup Map**: Maintain `object_id -> item` map for efficient highlight updates
6. **Immediate Repaint**: Call `update()` immediately when highlight state changes

---

## 3. Implementation Steps

1. Define selection highlight constants in `SchematicItem`: color, width, Z-values
2. Add `_is_highlighted` state to `SchematicItem`
3. Implement `set_highlighted()` method to update state and Z-order
4. Implement `_get_pen()` method to return selection or normal pen
5. Add abstract `_get_normal_pen()` method for subclasses to override
6. Update `CellItem.paint()` to use `_get_pen()`
7. Update `PinItem.paint()` to use `_get_pen()`
8. Update `NetItem.paint()` to use `_get_pen()`
9. Add `_item_map` to `SchematicCanvas` for object_id lookup
10. Update `add_item()` and `remove_item()` to maintain map
11. Connect `selection_changed` signal to `_on_selection_changed()` handler
12. Implement `_on_selection_changed()` to update all item highlights

---

## 4. Testing Requirements

### 4.1 Unit Tests

**Location**: `tests/ui/canvas/test_selection_highlighting.py`

```python
def test_item_highlight_state():
    """Test item highlight state changes"""
    item = CellItem(object_id="cell1", cell_name="AND2")

    assert not item.is_highlighted()

    item.set_highlighted(True)
    assert item.is_highlighted()
    assert item.zValue() == SchematicItem.SELECTED_Z_VALUE

    item.set_highlighted(False)
    assert not item.is_highlighted()
    assert item.zValue() == SchematicItem.NORMAL_Z_VALUE

def test_highlighted_pen_color():
    """Test highlighted item uses selection color"""
    item = CellItem(object_id="cell1", cell_name="AND2")

    # Normal pen
    normal_pen = item._get_pen()
    assert normal_pen.color() == Qt.black

    # Selection pen
    item.set_highlighted(True)
    selected_pen = item._get_pen()
    assert selected_pen.color() == SchematicItem.SELECTION_COLOR
    assert selected_pen.widthF() == SchematicItem.SELECTION_WIDTH

def test_canvas_updates_highlights_on_selection_change(qtbot):
    """Test canvas updates item highlights when selection changes"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item1 = CellItem(object_id="cell1", cell_name="AND2")
    item2 = CellItem(object_id="cell2", cell_name="OR2")
    canvas.add_item(item1)
    canvas.add_item(item2)

    # Select first item
    selection_service.select("cell1", SelectMode.REPLACE)
    qtbot.wait(10)  # Allow signal propagation

    assert item1.is_highlighted()
    assert not item2.is_highlighted()

    # Select second item
    selection_service.select("cell2", SelectMode.REPLACE)
    qtbot.wait(10)

    assert not item1.is_highlighted()
    assert item2.is_highlighted()

def test_multi_select_highlights_all_selected(qtbot):
    """Test multiple items highlighted when multi-selected"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    items = [CellItem(object_id=f"cell{i}", cell_name=f"CELL{i}") for i in range(5)]
    for item in items:
        canvas.add_item(item)

    # Select first 3 items
    selection_service.select_multiple(["cell0", "cell1", "cell2"], SelectMode.REPLACE)
    qtbot.wait(10)

    assert items[0].is_highlighted()
    assert items[1].is_highlighted()
    assert items[2].is_highlighted()
    assert not items[3].is_highlighted()
    assert not items[4].is_highlighted()

def test_clear_selection_removes_all_highlights(qtbot):
    """Test clearing selection removes all highlights"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    items = [CellItem(object_id=f"cell{i}", cell_name=f"CELL{i}") for i in range(3)]
    for item in items:
        canvas.add_item(item)

    # Select all
    selection_service.select_multiple(["cell0", "cell1", "cell2"], SelectMode.REPLACE)
    qtbot.wait(10)

    # Clear
    selection_service.clear()
    qtbot.wait(10)

    for item in items:
        assert not item.is_highlighted()
```

### 4.2 Visual Tests

- Manual visual inspection of highlight color and width
- Verify highlights visible at various zoom levels
- Check Z-order: selected items appear on top

### 4.3 Performance Tests

```python
def test_highlight_update_performance():
    """Test highlight updates complete within 16ms"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    # Create 100 items
    for i in range(100):
        item = CellItem(object_id=f"cell{i}", cell_name=f"CELL{i}")
        canvas.add_item(item)

    import time
    start = time.perf_counter()

    # Select all items
    selection_service.select_multiple([f"cell{i}" for i in range(100)], SelectMode.REPLACE)

    elapsed = (time.perf_counter() - start) * 1000  # Convert to ms
    assert elapsed < 16  # Must complete within 16ms for 60 FPS
```

---

## 5. Acceptance Criteria

- [ ] `SchematicItem` base class has `set_highlighted()` method
- [ ] `SchematicItem` defines selection color, width, and Z-value constants
- [ ] Highlighted items drawn with orange/yellow outline, 2-3px width
- [ ] Highlighted items have higher Z-value (appear on top)
- [ ] `CellItem`, `PinItem`, `NetItem` use `_get_pen()` in `paint()` methods
- [ ] Canvas maintains `_item_map` for object_id lookup
- [ ] Canvas connected to `selection_changed` signal
- [ ] Selection changes trigger immediate highlight updates
- [ ] All unit tests pass
- [ ] Highlight updates complete within 16ms for 100 items
- [ ] Highlights visible at all zoom levels

---

## 6. Dependencies

- **Upstream**:
  - E04-F01-T01 (SelectionManager - provides selection_changed signal)
  - E02 (Rendering - CellItem, PinItem, NetItem must exist)
- **Downstream**:
  - E04-F02 (Property Panel - visual feedback complements property display)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F01 split |
