# E04-F01-T01 - SelectionManager Class: Pre-Implementation Documentation

## Document Information
- **Task**: E04-F01-T01 - SelectionManager Class
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements the foundational `SelectionService` class in the application layer, which serves as the centralized state manager for all schematic object selections. The service maintains a set of selected object IDs, supports three selection modes (REPLACE, ADD, TOGGLE), and emits Qt signals when selection state changes to notify UI components.

### 1.2 Problem Context

The selection system is a core interaction primitive in Ink. Users need to select schematic objects (cells, pins, nets, ports) to:
- Inspect properties in the property panel
- Perform batch operations (expansion, collapse, deletion)
- Navigate and analyze circuit connectivity
- Apply styling or annotations

Without a centralized selection manager, each UI component would maintain its own selection state, leading to inconsistencies, duplication, and difficult-to-debug synchronization issues.

### 1.3 Success Metrics

- Selection state changes propagate to listeners in <5ms
- Support for 1000+ selected objects without performance degradation
- Zero state inconsistencies between service and UI components
- Clean separation between selection state logic and UI rendering

---

## 2. Implementation Approach

### 2.1 Architecture Placement

**Decision**: Place `SelectionService` in the application layer (`src/ink/application/services/`).

**Rationale**:
- Selection is an application-level concern that coordinates UI actions with domain state
- It's not pure domain logic (domain objects don't "know" they're selected)
- It's not infrastructure (no external dependencies like databases or file systems)
- It bridges user interactions (presentation) with object queries (domain)

**Layer Dependencies**:
```
Presentation Layer (Canvas, Panels)
        ↓ (uses)
Application Layer (SelectionService) ← We are here
        ↓ (queries)
Domain Layer (Design, Cell, Pin, Net)
```

### 2.2 State Management Strategy

**Decision**: Use a `Set[str]` to maintain selected object IDs.

**Rationale**:
- **String IDs vs. Object References**: Storing IDs prevents memory leaks and coupling
  - Objects can be garbage collected when not rendered
  - No strong references prevent domain object lifecycle management
  - Serialization for session persistence is trivial (just write IDs to JSON)
- **Set vs. List**: O(1) membership testing, automatic duplicate prevention
  - `is_selected(id)` is O(1) instead of O(n)
  - Adding same ID twice is idempotent
  - Iteration order doesn't matter for most use cases

**Trade-offs**:
- **Pro**: Fast membership tests, small memory footprint
- **Pro**: Easy to serialize for session save/load
- **Con**: Must query domain model to get actual objects (acceptable cost)
- **Con**: No inherent ordering (can sort when needed)

### 2.3 Selection Modes

**Three modes** based on standard UI conventions:

1. **REPLACE** (default): Clear previous selection, select only new object
   - Used for single left-click
   - Matches behavior in file managers, CAD tools, IDEs

2. **ADD**: Add to existing selection without clearing
   - Used for Ctrl+click
   - Enables multi-selection workflows

3. **TOGGLE**: Toggle object in/out of selection
   - Used for Ctrl+click on already-selected objects
   - Some tools use separate toggle mode, others combine with ADD

**Decision**: Implement TOGGLE as separate mode rather than auto-detecting in ADD mode.

**Rationale**:
- Explicit mode gives caller control over behavior
- Easier to test each mode independently
- Clearer semantics in code: `select(id, TOGGLE)` vs. `select(id, ADD)` with implicit toggle

### 2.4 Change Detection and Signaling

**Decision**: Only emit `selection_changed` signal when selection actually changes.

**Rationale**:
- Prevents unnecessary UI updates (redraws, property panel queries)
- Reduces event noise in large systems
- Improves performance when selecting already-selected objects

**Implementation**:
```python
def select(self, object_id: str, mode: SelectMode) -> None:
    previous_selection = self._selected_ids.copy()

    # Modify selection based on mode...

    if self._selected_ids != previous_selection:
        self._emit_change()  # Only emit if changed
```

**Trade-offs**:
- **Pro**: Efficient, prevents redundant work
- **Con**: Slight overhead of copying set for comparison (acceptable for <1000 items)

### 2.5 Qt Integration

**Decision**: Inherit from `QObject` and use Qt `Signal` mechanism.

**Rationale**:
- Seamless integration with PySide6 UI components
- Thread-safe signal/slot connections (when needed)
- Automatic memory management for connections
- Familiar pattern for Qt developers

**Alternative Considered**: Pure Python observer pattern
- **Rejected**: Adds complexity, doesn't integrate well with Qt event loop
- **Rejected**: No built-in thread safety
- **Rejected**: Manual cleanup of listeners required

---

## 3. Key Design Decisions

### 3.1 Immutable State Returns

**Decision**: Return copies of selection state, not direct references.

```python
def get_selected(self) -> List[str]:
    return list(self._selected_ids)  # Returns copy, not reference
```

**Rationale**:
- Prevents external code from modifying internal state
- Enforces all changes go through service methods
- Easier to track state changes for debugging

**Trade-off**: Small memory overhead for copy (acceptable for <1000 items)

### 3.2 Single vs. Batch Operations

**Decision**: Provide both `select()` and `select_multiple()` methods.

**Rationale**:
- `select()`: Optimized for single object (common case from clicks)
- `select_multiple()`: Optimized for batch operations (drag rectangle, "select all")
- Batch operation emits single signal instead of N signals
- Clear API communicates intent

**Alternative Considered**: Only `select()` that accepts either string or list
- **Rejected**: Type signature ambiguity (`Union[str, List[str]]`)
- **Rejected**: Caller must check type at runtime
- **Rejected**: Less explicit

### 3.3 Clear vs. Deselect All

**Decision**: Provide `clear()` method, not `deselect_all()`.

**Rationale**:
- "Clear" is more concise
- Matches terminology in Qt (`QItemSelectionModel.clear()`)
- Implies resetting to empty state

### 3.4 Error Handling

**Decision**: No exceptions for selecting non-existent objects.

**Rationale**:
- Selection service doesn't know what objects exist (not its responsibility)
- Invalid IDs are silently added to set (validated by consumers when querying)
- Prevents crashes from race conditions (object deleted after selection attempt)

**Trade-off**: Potential to select "ghost" objects, but callers should validate when querying domain model

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**None** - This is a foundation task with no dependencies.

### 4.2 Downstream Dependencies

**Immediate Consumers**:
1. **E04-F01-T02 (Single Selection)**: Canvas mouse event handler calls `select()`
2. **E04-F01-T03 (Multi-Selection)**: Canvas calls `select_multiple()` for drag rectangle
3. **E04-F01-T04 (Selection Highlighting)**: Canvas listens to `selection_changed` to update highlights
4. **E04-F02 (Property Panel)**: Panel listens to `selection_changed` to display properties

**Integration Pattern**:
```python
# In composition root (app.py):
selection_service = SelectionService()

# Inject into consumers:
canvas = SchematicCanvas(selection_service)
property_panel = PropertyPanel(selection_service)

# Consumers use service:
selection_service.selection_changed.connect(property_panel.update)
selection_service.select("cell1", SelectMode.REPLACE)
```

### 4.3 Domain Model Integration

**Query Pattern**: Service stores IDs, consumers query domain for objects.

```python
# In PropertyPanel:
def _on_selection_changed(self, selected_ids: List[str]):
    for obj_id in selected_ids:
        obj = self._design_repository.get_object(obj_id)  # Query domain
        self._display_properties(obj)
```

**Why not store objects?**
- Avoids memory leaks (no circular references)
- Domain objects can be garbage collected when off-screen
- Simpler state serialization for session save/load

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Test Categories**:

1. **Mode Behavior Tests**:
   - `test_select_replace_mode()`: REPLACE clears previous
   - `test_select_add_mode()`: ADD accumulates
   - `test_select_toggle_mode()`: TOGGLE adds/removes

2. **Batch Operation Tests**:
   - `test_select_multiple()`: Batch selection works
   - `test_select_multiple_with_add_mode()`: Adds to existing

3. **State Query Tests**:
   - `test_is_selected()`: Membership check works
   - `test_get_selected()`: Returns correct list
   - `test_get_selection_count()`: Count is accurate

4. **Signal Emission Tests**:
   - `test_selection_changed_signal()`: Signal emitted on change
   - `test_no_signal_on_same_selection()`: No signal if no change
   - `test_signal_payload()`: Signal carries correct IDs

5. **Edge Case Tests**:
   - `test_select_empty_string()`: Handles empty ID
   - `test_select_none()`: Handles None gracefully (or raises TypeError)
   - `test_clear_empty_selection()`: Clear on empty is no-op

### 5.2 Integration Testing

**Test with Qt Event Loop**:
```python
def test_signal_reaches_connected_slot(qtbot):
    service = SelectionService()
    received = []

    service.selection_changed.connect(lambda ids: received.append(ids))
    service.select("cell1", SelectMode.REPLACE)

    qtbot.wait(10)  # Allow signal propagation
    assert received == [["cell1"]]
```

### 5.3 Performance Testing

**Benchmark Tests**:
```python
def test_select_performance_1000_objects():
    service = SelectionService()
    ids = [f"cell{i}" for i in range(1000)]

    start = time.perf_counter()
    service.select_multiple(ids, SelectMode.REPLACE)
    elapsed = time.perf_counter() - start

    assert elapsed < 0.010  # <10ms for 1000 objects
```

### 5.4 Test Coverage Target

- **Line Coverage**: 100% (small, critical class)
- **Branch Coverage**: 100% (all modes, all conditions)
- **Mutation Testing**: Consider using `mutmut` to verify test quality

---

## 6. Risks and Considerations

### 6.1 Performance Risks

**Risk**: Large selections (10,000+ objects) cause signal emission delays.

**Impact**: Medium - UI feels sluggish during mass selection
**Probability**: Low - Most selections <100 objects
**Mitigation**:
- Benchmark with 10K objects in unit tests
- If >100ms, consider debouncing signal emission
- Emit signal on next event loop tick for very large selections

### 6.2 Memory Risks

**Risk**: Selection set grows unbounded if IDs are never removed.

**Impact**: Low - String IDs are small (few bytes each)
**Probability**: Low - Selections are typically cleared frequently
**Mitigation**:
- Monitor memory usage in long-running sessions
- Add warning if selection exceeds reasonable limit (e.g., 10,000 objects)

### 6.3 Thread Safety Risks

**Risk**: Selection modified from multiple threads causes race conditions.

**Impact**: High - Corrupted state, crashes
**Probability**: Low - MVP is single-threaded
**Mitigation**:
- Document that service is not thread-safe
- If threading needed later, add `QMutex` locks
- Use Qt's thread-safe signal/slot connections (queued)

### 6.4 State Inconsistency Risks

**Risk**: Selection service and UI get out of sync.

**Impact**: High - Objects appear selected but aren't, or vice versa
**Probability**: Medium - Signal/slot disconnections, event ordering issues
**Mitigation**:
- All selection changes MUST go through service
- Canvas never maintains its own selection state
- Add validation mode: assert canvas highlights match `get_selected()`

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should service validate object IDs exist in domain model?
**Answer**: No. Service is agnostic to domain. Consumers validate when querying.

**Q2**: Should `select()` accept None for "clear selection"?
**Answer**: No. Use explicit `clear()` method. None should raise `TypeError`.

**Q3**: Should selection persist across file loads?
**Answer**: No for MVP. Selection cleared when new file loaded. Add to P1 session persistence.

**Q4**: Should service track selection "type" (cell vs. pin vs. net)?
**Answer**: No. IDs are unique across types. Consumers determine type by querying domain.

### 7.2 UX Questions

**Q1**: Should there be a selection limit?
**Answer**: No hard limit for MVP. Add soft warning at 10,000 objects.

**Q2**: Should selecting same object twice be idempotent?
**Answer**: Yes. `select("cell1", REPLACE)` twice should emit signal once.

**Q3**: Should service expose "select all" / "select none" convenience methods?
**Answer**: Not in service. Higher-level component (e.g., MainWindow) implements "Select All Cells" by querying domain and calling `select_multiple()`.

### 7.3 Future Considerations

**Q1**: Typed selections for heterogeneous multi-select?
- E.g., "2 cells, 3 pins, 1 net" instead of just "6 objects"
- **Answer**: Deferred to property panel (queries domain for types)

**Q2**: Selection groups or named selections?
- E.g., "Save Selection as 'Clock Tree'"
- **Answer**: P2 feature, not in MVP

**Q3**: Selection history (undo/redo)?
- **Answer**: Handled by E04 undo/redo system, not by service directly

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `SelectionService` class implemented with `QObject` inheritance
- [ ] `SelectMode` enum with REPLACE, ADD, TOGGLE modes
- [ ] `select(object_id, mode)` method implemented
- [ ] `select_multiple(object_ids, mode)` method implemented
- [ ] `clear()` method implemented
- [ ] `is_selected(object_id)` query method
- [ ] `get_selected()` returns list of IDs
- [ ] `get_selection_count()` returns count
- [ ] `selection_changed` signal defined and emitted correctly
- [ ] Change detection prevents redundant signal emission

### 8.2 Quality Checklist

- [ ] All unit tests pass with 100% coverage
- [ ] Type hints on all public methods
- [ ] Docstrings follow Google style guide
- [ ] No mypy type errors
- [ ] No ruff linting warnings
- [ ] Performance test passes (<10ms for 1000 objects)

### 8.3 Documentation Checklist

- [ ] Class docstring explains purpose and usage
- [ ] Method docstrings include Args, Returns, Examples
- [ ] Signal documented with payload format
- [ ] Example usage in docstring or separate example file

### 8.4 Integration Checklist

- [ ] Service exported from `src/ink/application/services/__init__.py`
- [ ] Can be imported by presentation layer components
- [ ] Signal/slot connection works in Qt environment
- [ ] No circular import dependencies

---

## 9. Implementation Steps

### 9.1 Step-by-Step Plan

1. **Create file structure**:
   - Create `src/ink/application/services/selection_service.py`
   - Update `src/ink/application/services/__init__.py`

2. **Implement `SelectMode` enum**:
   - Define REPLACE, ADD, TOGGLE values
   - Add docstrings for each mode

3. **Implement `SelectionService` class skeleton**:
   - Inherit from `QObject`
   - Define `selection_changed` signal
   - Add `__init__` with empty `_selected_ids` set

4. **Implement selection methods**:
   - `select()` with mode handling
   - `select_multiple()` with mode handling
   - `clear()` method

5. **Implement query methods**:
   - `is_selected()`
   - `get_selected()`
   - `get_selection_count()`

6. **Implement change detection**:
   - `_emit_change()` helper
   - Set comparison before emission

7. **Write unit tests**:
   - Test file: `tests/unit/application/test_selection_service.py`
   - All test cases from section 5.1

8. **Write performance tests**:
   - Benchmark with 100, 1000, 10000 objects

9. **Documentation**:
   - Add comprehensive docstrings
   - Create usage example

10. **Code review and refinement**:
    - Run type checker, linter
    - Address any issues
    - Optimize if needed

### 9.2 Estimated Time Breakdown

- File structure and skeleton: 15 minutes
- Core implementation: 1 hour
- Unit tests: 1.5 hours
- Documentation: 30 minutes
- Testing and refinement: 1 hour
- **Total**: ~4 hours (matches spec estimate)

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T01/E04-F01-T01.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Architecture**: `/home/joohan/dev/project-ink/ink/docs/architecture/layer-architecture.md`
- **Qt Documentation**: https://doc.qt.io/qtforpython-6/PySide6/QtCore/QObject.html

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
