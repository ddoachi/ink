---
id: E04-F01-T01
title: SelectionManager Class
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F01
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Medium
tags:
  - selection
  - core
  - domain
---

# Spec: E04-F01-T01 - SelectionManager Class

## 1. Overview

### 1.1 Problem Statement

The selection system requires a centralized state manager to track which schematic objects (cells, pins, nets, ports) are currently selected. This manager must support different selection modes (replace, add, toggle) and emit events when selection state changes, enabling the property panel and other UI components to react to selection changes.

### 1.2 Goals

- Implement core `SelectionManager` class in the application layer
- Support multiple selection modes (REPLACE, ADD, TOGGLE)
- Maintain selection state as a collection of object identifiers
- Emit selection change events for UI updates
- Provide clear API for selection operations

---

## 2. Technical Requirements

### 2.1 SelectionManager Implementation

**Location**: `src/ink/application/services/selection_service.py`

```python
from enum import Enum
from typing import Set, List
from PySide6.QtCore import QObject, Signal

class SelectMode(Enum):
    """Selection mode for select operations"""
    REPLACE = "replace"  # Clear previous, select new
    ADD = "add"          # Add to existing selection
    TOGGLE = "toggle"    # Toggle object in/out of selection

class SelectionService(QObject):
    """
    Application service managing selection state.

    Maintains the set of currently selected object IDs and provides
    operations to modify selection state. Emits signals when selection
    changes to notify UI components.
    """

    # Signal emitted when selection changes
    selection_changed = Signal(list)  # List of selected object IDs

    def __init__(self):
        super().__init__()
        self._selected_ids: Set[str] = set()

    def select(self, object_id: str, mode: SelectMode = SelectMode.REPLACE) -> None:
        """
        Select object with specified mode.

        Args:
            object_id: Unique identifier of object to select
            mode: Selection mode (REPLACE, ADD, TOGGLE)
        """
        previous_selection = self._selected_ids.copy()

        if mode == SelectMode.REPLACE:
            self._selected_ids = {object_id}
        elif mode == SelectMode.ADD:
            self._selected_ids.add(object_id)
        elif mode == SelectMode.TOGGLE:
            if object_id in self._selected_ids:
                self._selected_ids.remove(object_id)
            else:
                self._selected_ids.add(object_id)

        if self._selected_ids != previous_selection:
            self._emit_change()

    def select_multiple(self, object_ids: List[str], mode: SelectMode = SelectMode.REPLACE) -> None:
        """
        Select multiple objects with specified mode.

        Args:
            object_ids: List of object identifiers to select
            mode: Selection mode (REPLACE, ADD, TOGGLE)
        """
        previous_selection = self._selected_ids.copy()

        if mode == SelectMode.REPLACE:
            self._selected_ids = set(object_ids)
        elif mode == SelectMode.ADD:
            self._selected_ids.update(object_ids)
        elif mode == SelectMode.TOGGLE:
            for obj_id in object_ids:
                if obj_id in self._selected_ids:
                    self._selected_ids.remove(obj_id)
                else:
                    self._selected_ids.add(obj_id)

        if self._selected_ids != previous_selection:
            self._emit_change()

    def clear(self) -> None:
        """Clear all selections."""
        if self._selected_ids:
            self._selected_ids.clear()
            self._emit_change()

    def is_selected(self, object_id: str) -> bool:
        """Check if object is currently selected."""
        return object_id in self._selected_ids

    def get_selected(self) -> List[str]:
        """Get list of currently selected object IDs."""
        return list(self._selected_ids)

    def get_selection_count(self) -> int:
        """Get count of currently selected objects."""
        return len(self._selected_ids)

    def _emit_change(self) -> None:
        """Emit selection_changed signal with current selection."""
        self.selection_changed.emit(self.get_selected())
```

### 2.2 Design Decisions

1. **Application Layer Placement**: `SelectionService` belongs in the application layer as it coordinates UI actions with domain state
2. **Qt Signal Integration**: Uses `QObject` and `Signal` for seamless integration with PySide6 UI components
3. **ID-Based Selection**: Stores object IDs (strings) rather than object references to avoid coupling and memory issues
4. **Change Detection**: Only emits `selection_changed` when selection actually changes to prevent unnecessary updates
5. **Immutable State**: Returns copies of selection state to prevent external modification

### 2.3 File Structure

```
src/ink/application/services/
├── __init__.py
└── selection_service.py  # New file
```

---

## 3. Implementation Steps

1. Create `src/ink/application/services/selection_service.py`
2. Implement `SelectMode` enum with three modes
3. Implement `SelectionService` class with `QObject` inheritance
4. Add `select()` method with mode parameter
5. Add `select_multiple()` method for batch selection
6. Add `clear()` method to reset selection
7. Add query methods: `is_selected()`, `get_selected()`, `get_selection_count()`
8. Implement change detection to emit `selection_changed` signal only when needed
9. Update `src/ink/application/services/__init__.py` to export `SelectionService` and `SelectMode`

---

## 4. Testing Requirements

### 4.1 Unit Tests

**Location**: `tests/unit/application/test_selection_service.py`

```python
def test_select_replace_mode():
    """Test REPLACE mode clears previous selection"""
    service = SelectionService()
    service.select("obj1", SelectMode.REPLACE)
    service.select("obj2", SelectMode.REPLACE)
    assert service.get_selected() == ["obj2"]

def test_select_add_mode():
    """Test ADD mode accumulates selection"""
    service = SelectionService()
    service.select("obj1", SelectMode.REPLACE)
    service.select("obj2", SelectMode.ADD)
    assert set(service.get_selected()) == {"obj1", "obj2"}

def test_select_toggle_mode():
    """Test TOGGLE mode adds/removes objects"""
    service = SelectionService()
    service.select("obj1", SelectMode.TOGGLE)
    assert "obj1" in service.get_selected()
    service.select("obj1", SelectMode.TOGGLE)
    assert "obj1" not in service.get_selected()

def test_select_multiple():
    """Test bulk selection operations"""
    service = SelectionService()
    service.select_multiple(["obj1", "obj2", "obj3"], SelectMode.REPLACE)
    assert service.get_selection_count() == 3

def test_selection_changed_signal():
    """Test selection_changed signal emission"""
    service = SelectionService()
    signal_received = []
    service.selection_changed.connect(lambda ids: signal_received.append(ids))

    service.select("obj1", SelectMode.REPLACE)
    assert len(signal_received) == 1
    assert signal_received[0] == ["obj1"]

def test_no_signal_on_same_selection():
    """Test no signal emitted when selection doesn't change"""
    service = SelectionService()
    service.select("obj1", SelectMode.REPLACE)

    signal_count = [0]
    service.selection_changed.connect(lambda ids: signal_count.__setitem__(0, signal_count[0] + 1))

    service.select("obj1", SelectMode.REPLACE)
    assert signal_count[0] == 0  # No additional signal
```

### 4.2 Test Coverage Target

- Line coverage: 100%
- Branch coverage: 100%
- All selection modes tested
- Signal emission verified

---

## 5. Acceptance Criteria

- [ ] `SelectionService` class implemented in `application/services/selection_service.py`
- [ ] `SelectMode` enum with REPLACE, ADD, TOGGLE modes
- [ ] `select()` method supports all three selection modes
- [ ] `select_multiple()` method for batch operations
- [ ] `clear()` method resets selection state
- [ ] `is_selected()`, `get_selected()`, `get_selection_count()` query methods work correctly
- [ ] `selection_changed` signal emitted when selection changes
- [ ] No signal emitted when selection remains unchanged
- [ ] All unit tests pass with 100% coverage
- [ ] Type hints present on all methods
- [ ] Docstrings follow Google style guide

---

## 6. Dependencies

- **Upstream**: None (foundation task)
- **Downstream**:
  - E04-F01-T02 (Single Selection - uses SelectionService)
  - E04-F01-T03 (Multi-Selection - uses SelectionService)
  - E04-F01-T04 (Selection Highlighting - listens to selection_changed)
  - E04-F02 (Property Panel - consumes selection events)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F01 split |
