---
id: E04-F01-T05
title: Selection Events and Integration
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F01
created: 2025-12-26
estimated_hours: 3
actual_hours:
effort: Small
tags:
  - selection
  - integration
  - events
---

# Spec: E04-F01-T05 - Selection Events and Integration

## 1. Overview

### 1.1 Problem Statement

The selection system must integrate seamlessly with other application components. The property panel, context menus, and other UI elements need to respond to selection changes. Additionally, keyboard shortcuts (like Escape to clear selection) should be supported, and selection state must persist correctly during canvas operations like pan and zoom.

### 1.2 Goals

- Implement Escape key handler to clear selection
- Ensure selection state maintained during pan/zoom operations
- Verify `selection_changed` signal properly integrated with property panel
- Document selection event API for future features
- Add comprehensive integration tests

---

## 2. Technical Requirements

### 2.1 Keyboard Shortcut - Escape to Clear

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

```python
class SchematicCanvas(QGraphicsView):
    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle keyboard shortcuts for selection"""
        if event.key() == Qt.Key_Escape:
            # Clear selection
            self._selection_service.clear()
            event.accept()
        else:
            super().keyPressEvent(event)
```

### 2.2 Selection State During Pan/Zoom

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

```python
class SchematicCanvas(QGraphicsView):
    def wheelEvent(self, event: QWheelEvent) -> None:
        """Handle zoom while preserving selection state"""
        # Perform zoom operation
        zoom_factor = 1.15 if event.angleDelta().y() > 0 else 1 / 1.15
        self.scale(zoom_factor, zoom_factor)

        # Selection state automatically preserved (managed by SelectionService)
        # Highlights automatically maintained (items re-render at new scale)

        event.accept()

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        """Handle pan while preserving selection state"""
        if self._is_panning:
            # Pan logic
            delta = event.pos() - self._last_pan_pos
            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() - delta.x())
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() - delta.y())
            self._last_pan_pos = event.pos()

        # Selection state automatically preserved
        super().mouseMoveEvent(event)
```

**Note**: Selection state persistence is automatic because:
1. `SelectionService` holds selection state independently of view transformations
2. Item highlights are re-rendered automatically when view transforms change
3. No special handling needed beyond normal event processing

### 2.3 Property Panel Integration

**Location**: `src/ink/presentation/panels/property_panel.py`

```python
class PropertyPanel(QWidget):
    """Panel displaying properties of selected objects"""

    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service

        # UI components
        self._property_tree = QTreeWidget()
        # ... layout setup ...

        # Connect to selection changes
        self._selection_service.selection_changed.connect(self._on_selection_changed)

    def _on_selection_changed(self, selected_ids: List[str]) -> None:
        """
        Update property display when selection changes.

        Args:
            selected_ids: List of currently selected object IDs
        """
        self._property_tree.clear()

        if len(selected_ids) == 0:
            self._show_empty_message()
        elif len(selected_ids) == 1:
            self._show_single_object_properties(selected_ids[0])
        else:
            self._show_multi_object_summary(selected_ids)

    def _show_empty_message(self) -> None:
        """Display message when no objects selected"""
        item = QTreeWidgetItem(["No selection"])
        self._property_tree.addTopLevelItem(item)

    def _show_single_object_properties(self, object_id: str) -> None:
        """Display detailed properties of single selected object"""
        # Fetch object from domain model
        # obj = self._design_repository.get_object(object_id)
        # Display properties...
        pass

    def _show_multi_object_summary(self, selected_ids: List[str]) -> None:
        """Display summary when multiple objects selected"""
        summary_item = QTreeWidgetItem([f"{len(selected_ids)} objects selected"])
        self._property_tree.addTopLevelItem(summary_item)

        # Could add type breakdown: "2 cells, 3 pins, 1 net"
```

### 2.4 Composition Root - Dependency Injection

**Location**: `src/ink/presentation/app.py`

```python
class InkApplication:
    """Application composition root"""

    def __init__(self):
        # Create services
        self._selection_service = SelectionService()

        # Create UI components with injected dependencies
        self._canvas = SchematicCanvas(self._selection_service)
        self._property_panel = PropertyPanel(self._selection_service)

        # Create main window
        self._main_window = MainWindow(
            canvas=self._canvas,
            property_panel=self._property_panel,
            selection_service=self._selection_service
        )

    def run(self):
        """Start the application"""
        self._main_window.show()
```

### 2.5 Selection Event API Documentation

**Event**: `selection_changed`

**Signal Signature**: `Signal(list)`

**Payload**: `List[str]` - List of selected object IDs

**Emission Triggers**:
- Single object selected via click
- Multiple objects selected via Ctrl+click or drag rectangle
- Selection cleared (empty list emitted)
- Object toggled in/out of selection

**Consumers**:
- `PropertyPanel`: Updates displayed properties
- `SchematicCanvas`: Updates visual highlights
- `MainWindow`: Updates status bar selection count
- Future: Context menu, toolbar button states, etc.

---

## 3. Implementation Steps

1. Add `keyPressEvent()` to `SchematicCanvas` for Escape key handling
2. Verify pan/zoom preserve selection state (should work automatically)
3. Create `PropertyPanel` class with `selection_changed` connection
4. Implement `_on_selection_changed()` handler in property panel
5. Add property display methods: empty, single, multi-object
6. Update composition root to inject `SelectionService` into all components
7. Add keyboard shortcut documentation to user guide
8. Create integration tests for cross-component interaction

---

## 4. Testing Requirements

### 4.1 Integration Tests

**Location**: `tests/integration/test_selection_integration.py`

```python
def test_escape_key_clears_selection(qtbot):
    """Test Escape key clears selection"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    # Select item
    selection_service.select("cell1", SelectMode.REPLACE)
    assert selection_service.get_selection_count() == 1

    # Press Escape
    QTest.keyPress(canvas, Qt.Key_Escape)
    assert selection_service.get_selection_count() == 0

def test_selection_persists_during_zoom(qtbot):
    """Test selection state maintained during zoom operations"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item = CellItem(object_id="cell1", cell_name="AND2")
    canvas.add_item(item)

    # Select item
    selection_service.select("cell1", SelectMode.REPLACE)

    # Perform zoom
    wheel_event = QWheelEvent(
        QPointF(100, 100), QPointF(100, 100),
        QPoint(0, 120), QPoint(0, 120),  # Positive delta = zoom in
        Qt.NoButton, Qt.NoModifier, Qt.ScrollUpdate, False
    )
    canvas.wheelEvent(wheel_event)

    # Selection should persist
    assert selection_service.is_selected("cell1")
    assert item.is_highlighted()

def test_selection_persists_during_pan(qtbot):
    """Test selection state maintained during pan operations"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item = CellItem(object_id="cell1", cell_name="AND2")
    canvas.add_item(item)

    # Select item
    selection_service.select("cell1", SelectMode.REPLACE)

    # Simulate pan (middle mouse drag)
    canvas._is_panning = True
    canvas._last_pan_pos = QPoint(100, 100)

    move_event = QMouseEvent(
        QEvent.MouseMove, QPoint(150, 150),
        Qt.MiddleButton, Qt.MiddleButton, Qt.NoModifier
    )
    canvas.mouseMoveEvent(move_event)

    # Selection should persist
    assert selection_service.is_selected("cell1")

def test_property_panel_updates_on_selection(qtbot):
    """Test property panel updates when selection changes"""
    selection_service = SelectionService()
    property_panel = PropertyPanel(selection_service)

    # Initially empty
    assert property_panel._property_tree.topLevelItemCount() > 0
    assert "No selection" in property_panel._property_tree.topLevelItem(0).text(0)

    # Select single object
    selection_service.select("cell1", SelectMode.REPLACE)
    qtbot.wait(10)  # Allow signal propagation

    # Property panel should update (implementation dependent)
    # This is a placeholder - actual test depends on property panel implementation

def test_main_window_status_bar_updates(qtbot):
    """Test main window status bar reflects selection count"""
    selection_service = SelectionService()
    main_window = MainWindow(selection_service)

    # No selection
    assert "No selection" in main_window._selection_label.text()

    # Single selection
    selection_service.select("cell1", SelectMode.REPLACE)
    qtbot.wait(10)
    assert "1 object selected" in main_window._selection_label.text()

    # Multi-selection
    selection_service.select_multiple(["cell1", "cell2", "cell3"], SelectMode.REPLACE)
    qtbot.wait(10)
    assert "3 objects selected" in main_window._selection_label.text()

    # Clear
    selection_service.clear()
    qtbot.wait(10)
    assert "No selection" in main_window._selection_label.text()
```

### 4.2 End-to-End Tests

```python
def test_complete_selection_workflow(qtbot):
    """Test complete selection workflow across all components"""
    # Setup application
    app = InkApplication()

    # Load test design
    # ... load CDL, render schematic ...

    # Click to select cell
    # Verify: canvas highlights, property panel updates, status bar updates

    # Ctrl+click to add to selection
    # Verify: both items highlighted, property panel shows summary, status shows "2 objects"

    # Drag rectangle to select multiple
    # Verify: all enclosed items selected

    # Press Escape
    # Verify: all highlights removed, property panel cleared, status shows "No selection"

    # Zoom and pan
    # Verify: no crashes, UI responsive
```

---

## 5. Acceptance Criteria

- [ ] Escape key clears all selections
- [ ] Selection state preserved during zoom operations
- [ ] Selection state preserved during pan operations
- [ ] Property panel connected to `selection_changed` signal
- [ ] Property panel updates immediately when selection changes
- [ ] Main window status bar shows correct selection count
- [ ] Composition root (`InkApplication`) properly injects `SelectionService`
- [ ] All integration tests pass
- [ ] Selection event API documented in code comments
- [ ] No memory leaks from signal/slot connections

---

## 6. Dependencies

- **Upstream**:
  - E04-F01-T01 (SelectionManager - provides SelectionService)
  - E04-F01-T02 (Single Selection)
  - E04-F01-T03 (Multi-Selection)
  - E04-F01-T04 (Selection Highlighting)
- **Downstream**:
  - E04-F02 (Property Panel - full implementation)
  - E03 (Expansion - may use selection for "expand selected")

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F01 split |
