# E04-F01-T05 - Selection Events and Integration: Pre-Implementation Documentation

## Document Information
- **Task**: E04-F01-T05 - Selection Events and Integration
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task completes the selection system by ensuring seamless integration across all application components. It implements keyboard shortcuts (Escape to clear selection), verifies selection state persistence during canvas operations (pan/zoom), integrates with the property panel, and provides comprehensive documentation of the selection event API for future features.

### 1.2 Problem Context

The selection system isn't complete until it integrates smoothly with the rest of the application:
- **Keyboard Accessibility**: Users expect standard shortcuts (Escape to deselect)
- **View Persistence**: Selection should remain stable during navigation (pan, zoom)
- **Component Coordination**: Property panel must receive and display selection data
- **Future-Proofing**: Clear event API enables future features (context menus, batch operations)

Without proper integration, the selection system becomes isolated and difficult to use. This task ensures all components work together cohesively and the system is well-documented for future development.

### 1.3 Success Metrics

- Escape key clears selection 100% reliably
- Selection state persists during all pan/zoom operations
- Property panel updates within 50ms of selection change
- Zero memory leaks from signal/slot connections
- Selection event API fully documented with examples
- All integration tests pass

---

## 2. Implementation Approach

### 2.1 Keyboard Shortcut - Escape to Clear

**Decision**: Handle Escape key in `SchematicCanvas.keyPressEvent()`.

**Implementation**:
```python
class SchematicCanvas(QGraphicsView):
    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle keyboard shortcuts for selection"""
        if event.key() == Qt.Key_Escape:
            self._selection_service.clear()
            event.accept()  # Mark event as handled
        else:
            super().keyPressEvent(event)  # Propagate to Qt
```

**Rationale**:
- **Canvas Focus**: Keyboard shortcuts active when canvas has focus
- **Standard Behavior**: Escape clears selection in most applications
- **Simple Implementation**: Single line calls existing `clear()` method
- **Event Handling**: Accept event to prevent propagation

**Alternative Considered**: Handle in MainWindow action system
- **Rejected**: Requires action framework setup (overkill for MVP)
- **Rejected**: Canvas-level handling is simpler and more direct

**Future Enhancement**: Add to action system when implementing full keyboard shortcut framework.

### 2.2 Selection Persistence During Pan/Zoom

**Decision**: No special handling needed - selection persists automatically.

**Why It Works**:
1. **Separate State**: `SelectionService` holds selection state independently of view transformations
2. **Automatic Repainting**: Item highlights re-render when view transforms change (Qt handles this)
3. **No Invalidation**: Pan/zoom don't trigger `selection_changed` signal

**Verification** (no code changes needed, just testing):
```python
def test_selection_persists_during_zoom():
    """Selection state maintained during zoom operations"""
    # Select item
    selection_service.select("cell1", SelectMode.REPLACE)

    # Perform zoom
    canvas.scale(1.5, 1.5)

    # Verify selection still exists
    assert selection_service.is_selected("cell1")
    assert item.is_highlighted()  # Visual state also preserved
```

**Implementation Notes**:
- Pan implemented in `mouseMoveEvent()` (middle button drag)
- Zoom implemented in `wheelEvent()` (mouse wheel)
- Both modify view transform matrix, don't affect scene items
- Selection state and item highlights unaffected

### 2.3 Property Panel Integration

**Decision**: Create stub property panel that displays basic object information.

**Stub Implementation** (minimal for MVP):
```python
class PropertyPanel(QWidget):
    """Panel displaying properties of selected objects"""

    def __init__(self, selection_service: SelectionService, design_repository):
        super().__init__()
        self._selection_service = selection_service
        self._design_repository = design_repository

        # UI components
        self._property_tree = QTreeWidget()
        self._property_tree.setHeaderLabels(["Property", "Value"])

        layout = QVBoxLayout()
        layout.addWidget(QLabel("Properties"))
        layout.addWidget(self._property_tree)
        self.setLayout(layout)

        # Connect to selection changes
        self._selection_service.selection_changed.connect(self._on_selection_changed)

    def _on_selection_changed(self, selected_ids: List[str]) -> None:
        """Update property display when selection changes"""
        self._property_tree.clear()

        if len(selected_ids) == 0:
            self._show_empty_message()
        elif len(selected_ids) == 1:
            self._show_single_object_properties(selected_ids[0])
        else:
            self._show_multi_object_summary(selected_ids)

    def _show_empty_message(self) -> None:
        """Display message when no objects selected"""
        item = QTreeWidgetItem(["No selection", ""])
        self._property_tree.addTopLevelItem(item)

    def _show_single_object_properties(self, object_id: str) -> None:
        """Display detailed properties of single selected object"""
        # Query domain model for object
        obj = self._design_repository.get_object_by_id(object_id)

        if obj:
            # Display object ID
            id_item = QTreeWidgetItem(["Object ID", object_id])
            self._property_tree.addTopLevelItem(id_item)

            # Display object type
            type_item = QTreeWidgetItem(["Type", obj.__class__.__name__])
            self._property_tree.addTopLevelItem(type_item)

            # Add type-specific properties
            if isinstance(obj, Cell):
                self._add_cell_properties(obj)
            elif isinstance(obj, Pin):
                self._add_pin_properties(obj)
            elif isinstance(obj, Net):
                self._add_net_properties(obj)

    def _show_multi_object_summary(self, selected_ids: List[str]) -> None:
        """Display summary when multiple objects selected"""
        summary_item = QTreeWidgetItem(["Selection", f"{len(selected_ids)} objects"])
        self._property_tree.addTopLevelItem(summary_item)

        # TODO: Add type breakdown (e.g., "2 cells, 3 pins, 1 net")

    def _add_cell_properties(self, cell: Cell) -> None:
        """Add cell-specific properties"""
        name_item = QTreeWidgetItem(["Cell Name", cell.name])
        self._property_tree.addTopLevelItem(name_item)

        type_item = QTreeWidgetItem(["Cell Type", cell.cell_type])
        self._property_tree.addTopLevelItem(type_item)

    def _add_pin_properties(self, pin: Pin) -> None:
        """Add pin-specific properties"""
        name_item = QTreeWidgetItem(["Pin Name", pin.name])
        self._property_tree.addTopLevelItem(name_item)

        dir_item = QTreeWidgetItem(["Direction", pin.direction.value])
        self._property_tree.addTopLevelItem(dir_item)

    def _add_net_properties(self, net: Net) -> None:
        """Add net-specific properties"""
        name_item = QTreeWidgetItem(["Net Name", net.name])
        self._property_tree.addTopLevelItem(name_item)

        fanout_item = QTreeWidgetItem(["Fanout", str(len(net.pins))])
        self._property_tree.addTopLevelItem(fanout_item)
```

**Rationale**:
- **Minimal but Functional**: Displays basic properties to validate integration
- **Full Implementation Deferred**: E04-F02 will add rich property display
- **Testable**: Can verify signal connection and update behavior

### 2.4 Composition Root Integration

**Decision**: Wire all components together in `InkApplication`.

**Implementation**:
```python
class InkApplication:
    """Application composition root - dependency injection"""

    def __init__(self):
        # Create domain services (TODO: implement in E01)
        # self._design_repository = DesignRepository()

        # Create application services
        self._selection_service = SelectionService()

        # Create UI components with injected dependencies
        self._canvas = SchematicCanvas(self._selection_service)
        self._property_panel = PropertyPanel(
            self._selection_service,
            # self._design_repository  # TODO: uncomment when available
            None  # Stub for now
        )

        # Create main window with all components
        self._main_window = MainWindow(
            canvas=self._canvas,
            property_panel=self._property_panel,
            selection_service=self._selection_service
        )

    def run(self):
        """Start the application"""
        self._main_window.show()
```

**Rationale**:
- **Single Location**: All dependencies created and wired in one place
- **Testability**: Easy to create test configuration with mock services
- **Clarity**: Dependency graph visible at a glance

### 2.5 Selection Event API Documentation

**Decision**: Document `selection_changed` signal as public API for future consumers.

**Documentation Format** (in `SelectionService` docstring):
```python
class SelectionService(QObject):
    """
    Application service managing selection state.

    Signals:
        selection_changed(List[str]): Emitted when selection changes.
            Payload: List of currently selected object IDs.
            Emission triggers:
                - Object selected via select()
                - Multiple objects selected via select_multiple()
                - Selection cleared via clear()
                - Object toggled in/out of selection

    Current Consumers:
        - PropertyPanel: Updates displayed properties
        - SchematicCanvas: Updates visual highlights
        - MainWindow: Updates status bar selection count

    Future Consumers:
        - ContextMenuManager: Enable/disable menu items based on selection
        - ToolbarManager: Enable/disable toolbar buttons
        - ExportDialog: Pre-populate with selected objects
        - AnnotationTool: Apply annotations to selected objects

    Example Usage:
        # Create service
        selection_service = SelectionService()

        # Connect to signal
        def on_selection_changed(selected_ids: List[str]):
            print(f"Selected: {selected_ids}")

        selection_service.selection_changed.connect(on_selection_changed)

        # Trigger events
        selection_service.select("cell1", SelectMode.REPLACE)
        # Prints: "Selected: ['cell1']"

        selection_service.select("cell2", SelectMode.ADD)
        # Prints: "Selected: ['cell1', 'cell2']"

        selection_service.clear()
        # Prints: "Selected: []"
    """
```

**Rationale**:
- **Discoverability**: New developers know how to use the API
- **Contract**: Clear specification of signal behavior
- **Examples**: Concrete usage patterns
- **Future Planning**: Lists potential consumers to guide development

---

## 3. Key Design Decisions

### 3.1 Keyboard Focus Management

**Decision**: Canvas must have focus to receive keyboard events.

**Implementation** (in `MainWindow`):
```python
class MainWindow(QMainWindow):
    def __init__(self, canvas, property_panel, selection_service):
        super().__init__()

        # ... UI setup ...

        # Give canvas keyboard focus by default
        self._canvas.setFocus()

        # Also give focus on click
        self._canvas.setFocusPolicy(Qt.StrongFocus)
```

**Rationale**:
- **Standard Behavior**: Graphics view needs focus for keyboard input
- **User Expectation**: Clicking canvas gives it focus automatically
- **Strong Focus**: Accept focus via click and tab key

**Edge Case**: Property panel has text fields that need focus
- **Solution**: Clicking panel gives it focus, clicking canvas gives it back
- **Qt Behavior**: Automatic based on focus policy

### 3.2 Pan Implementation

**Decision**: Middle mouse button for pan (if not already implemented).

**Implementation** (for completeness):
```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        # ... existing setup ...

        # Pan state
        self._is_panning = False
        self._last_pan_pos = QPoint()

    def mousePressEvent(self, event: QMouseEvent) -> None:
        if event.button() == Qt.MiddleButton:
            self._is_panning = True
            self._last_pan_pos = event.pos()
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
        else:
            # Existing left-button selection logic
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        if self._is_panning:
            delta = event.pos() - self._last_pan_pos
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() - delta.x()
            )
            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() - delta.y()
            )
            self._last_pan_pos = event.pos()
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent) -> None:
        if event.button() == Qt.MiddleButton:
            self._is_panning = False
            self.setCursor(Qt.ArrowCursor)
            event.accept()
        else:
            super().mouseReleaseEvent(event)
```

**Rationale**:
- **Non-Interference**: Middle button doesn't conflict with selection (left button)
- **Standard**: Matches CAD tools and graphics applications
- **Visual Feedback**: Cursor changes to closed hand during pan

### 3.3 Zoom Implementation

**Decision**: Mouse wheel for zoom (if not already implemented).

**Implementation**:
```python
class SchematicCanvas(QGraphicsView):
    def wheelEvent(self, event: QWheelEvent) -> None:
        """Zoom with mouse wheel"""
        # Determine zoom direction
        zoom_factor = 1.15 if event.angleDelta().y() > 0 else 1 / 1.15

        # Apply zoom
        self.scale(zoom_factor, zoom_factor)

        event.accept()
```

**Rationale**:
- **Standard**: Mouse wheel zoom is universal
- **Smooth**: Small zoom increments (15% per notch)
- **Automatic**: Qt handles transform matrix, items re-render automatically

### 3.4 Property Panel Layout

**Decision**: Dock property panel to right side of main window.

**Implementation** (in `MainWindow`):
```python
class MainWindow(QMainWindow):
    def __init__(self, canvas, property_panel, selection_service):
        super().__init__()

        # Set canvas as central widget
        self.setCentralWidget(canvas)

        # Create dock widget for property panel
        property_dock = QDockWidget("Properties", self)
        property_dock.setWidget(property_panel)
        self.addDockWidget(Qt.RightDockWidgetArea, property_dock)
```

**Rationale**:
- **Standard Layout**: Canvas center, properties right (matches IDEs, CAD tools)
- **Dockable**: User can undock, resize, or hide panel
- **Persistent**: Dock state can be saved in future session persistence

### 3.5 Memory Management

**Decision**: Use Qt's automatic signal/slot cleanup (no manual disconnection needed).

**Rationale**:
- **Qt Behavior**: When receiver destroyed, Qt automatically disconnects signals
- **Simplicity**: No explicit cleanup code needed
- **Reliable**: Well-tested Qt mechanism

**Assumption**: All components have same lifetime (live entire session)
- If components destroyed dynamically, Qt still handles cleanup automatically

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Critical Dependencies**:
1. **E04-F01-T01 (SelectionManager)**: Provides `SelectionService`
2. **E04-F01-T02 (Single Selection)**: Canvas mouse events
3. **E04-F01-T03 (Multi-Selection)**: Keyboard event handling adds to existing
4. **E04-F01-T04 (Selection Highlighting)**: Visual feedback for testing

**Soft Dependencies** (stubs acceptable):
- **E01 (Data Model)**: Design repository for querying objects
  - Can use stub that returns mock objects
- **E02 (Rendering)**: Canvas and items
  - Must be partially implemented for testing

### 4.2 Downstream Dependencies

**Tasks Depending on T05**:
1. **E04-F02 (Property Panel)**: Full implementation builds on stub
2. **E03 (Expansion)**: May use selection as expansion origin
3. **Future Context Menus**: Will consume `selection_changed` signal

### 4.3 Integration Points Summary

**Signal Flow**:
```
User Action (click, keyboard)
    ↓
SelectionService.select() / clear()
    ↓
selection_changed signal emitted
    ↓ (splits to multiple consumers)
├→ PropertyPanel._on_selection_changed() → Query domain → Update UI
├→ SchematicCanvas._on_selection_changed() → Update highlights
└→ MainWindow._update_selection_status() → Update status bar
```

**Data Flow**:
```
SelectionService: Stores Set[str] of IDs
    ↓ (emits List[str])
PropertyPanel: Queries domain model for objects
    ↓ (fetches Cell/Pin/Net)
Domain Repository: Returns domain objects
    ↓ (provides properties)
PropertyPanel: Displays properties in tree widget
```

---

## 5. Testing Strategy

### 5.1 Keyboard Shortcut Tests

```python
def test_escape_clears_selection(qtbot):
    """Escape key clears all selections"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    # Select item
    selection_service.select("cell1", SelectMode.REPLACE)
    assert selection_service.get_selection_count() == 1

    # Set focus to canvas
    canvas.setFocus()

    # Press Escape
    QTest.keyPress(canvas, Qt.Key_Escape)
    qtbot.wait(10)

    assert selection_service.get_selection_count() == 0

def test_escape_without_selection_no_error(qtbot):
    """Escape when nothing selected doesn't cause error"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    canvas.setFocus()
    QTest.keyPress(canvas, Qt.Key_Escape)
    # Should complete without exception
```

### 5.2 Pan/Zoom Persistence Tests

```python
def test_selection_persists_during_zoom(qtbot):
    """Selection state maintained during zoom operations"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item = CellItem(object_id="cell1", ...)
    canvas.add_item(item)
    selection_service.select("cell1", SelectMode.REPLACE)

    # Perform zoom
    wheel_event = QWheelEvent(
        QPointF(100, 100), QPointF(100, 100),
        QPoint(0, 120), QPoint(0, 120),
        Qt.NoButton, Qt.NoModifier, Qt.ScrollUpdate, False
    )
    canvas.wheelEvent(wheel_event)

    # Selection should persist
    assert selection_service.is_selected("cell1")
    assert item.is_highlighted()

def test_selection_persists_during_pan(qtbot):
    """Selection state maintained during pan operations"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item = CellItem(object_id="cell1", ...)
    canvas.add_item(item)
    selection_service.select("cell1", SelectMode.REPLACE)

    # Simulate pan
    press_event = QMouseEvent(
        QEvent.MouseButtonPress, QPoint(100, 100),
        Qt.MiddleButton, Qt.MiddleButton, Qt.NoModifier
    )
    canvas.mousePressEvent(press_event)

    move_event = QMouseEvent(
        QEvent.MouseMove, QPoint(150, 150),
        Qt.MiddleButton, Qt.MiddleButton, Qt.NoModifier
    )
    canvas.mouseMoveEvent(move_event)

    # Selection should persist
    assert selection_service.is_selected("cell1")
```

### 5.3 Property Panel Integration Tests

```python
def test_property_panel_updates_on_selection(qtbot):
    """Property panel updates when selection changes"""
    selection_service = SelectionService()
    property_panel = PropertyPanel(selection_service, None)  # Stub repository

    # Initially shows "No selection"
    assert property_panel._property_tree.topLevelItemCount() > 0
    first_item = property_panel._property_tree.topLevelItem(0)
    assert "No selection" in first_item.text(0)

    # Select object
    selection_service.select("cell1", SelectMode.REPLACE)
    qtbot.wait(10)

    # Panel should update (specific content depends on implementation)
    assert property_panel._property_tree.topLevelItemCount() > 0

def test_property_panel_shows_multi_summary(qtbot):
    """Property panel shows summary for multi-selection"""
    selection_service = SelectionService()
    property_panel = PropertyPanel(selection_service, None)

    # Select multiple
    selection_service.select_multiple(["cell1", "cell2", "cell3"], SelectMode.REPLACE)
    qtbot.wait(10)

    # Should show count
    first_item = property_panel._property_tree.topLevelItem(0)
    assert "3 objects" in first_item.text(1)
```

### 5.4 End-to-End Integration Tests

```python
def test_complete_selection_workflow(qtbot):
    """Test complete selection workflow across all components"""
    # Setup application
    app = InkApplication()

    # TODO: Load test design, render schematic

    # Click to select cell
    # Verify:
    # - Canvas highlights cell
    # - Property panel updates
    # - Status bar shows "1 object selected"

    # Ctrl+click to add
    # Verify:
    # - Both cells highlighted
    # - Property panel shows summary
    # - Status bar shows "2 objects selected"

    # Press Escape
    # Verify:
    # - All highlights removed
    # - Property panel cleared
    # - Status shows "No selection"

    # Zoom and pan
    # Verify: No crashes, UI responsive
```

### 5.5 Memory Leak Tests

```python
def test_no_memory_leaks_from_signals():
    """Verify signal connections don't cause memory leaks"""
    import gc
    import weakref

    selection_service = SelectionService()

    # Create panel, get weak reference
    panel = PropertyPanel(selection_service, None)
    panel_ref = weakref.ref(panel)

    # Connect signal (automatic in __init__)
    # ...

    # Delete panel
    del panel
    gc.collect()

    # Panel should be garbage collected
    assert panel_ref() is None, "PropertyPanel leaked"
```

---

## 6. Risks and Considerations

### 6.1 Focus Management Risks

**Risk**: Canvas doesn't receive keyboard events because focus is elsewhere.

**Impact**: Medium - Escape key doesn't work
**Probability**: Medium - Other widgets can steal focus
**Mitigation**:
- Set canvas focus policy to `Qt.StrongFocus`
- Give canvas initial focus in `MainWindow.__init__`
- Document focus requirements
- Test with property panel interaction (clicking panel then clicking canvas)

### 6.2 Signal Connection Risks

**Risk**: Signal/slot connections established but not functioning.

**Impact**: High - Property panel doesn't update
**Probability**: Low - Qt signals are reliable
**Mitigation**:
- Verify connection with debug print in slot
- Check signal payload type matches slot signature
- Use `Qt.QueuedConnection` if threading issues arise (unlikely in MVP)

### 6.3 Repository Interface Risks

**Risk**: Design repository doesn't exist yet or has different API.

**Impact**: Medium - Property panel can't query objects
**Probability**: High - E01 not implemented yet
**Mitigation**:
- Create stub repository for testing
- Define expected interface:
  ```python
  class DesignRepository(Protocol):
      def get_object_by_id(self, object_id: str) -> Optional[Union[Cell, Pin, Net]]:
          ...
  ```
- Implement real repository in E01, swap out stub

### 6.4 Pan/Zoom Implementation Gaps

**Risk**: Pan/zoom not implemented in canvas yet.

**Impact**: Low - Can't test persistence, but core selection works
**Probability**: Medium - E02 may not include pan/zoom
**Mitigation**:
- Implement minimal pan/zoom in T05 if not present
- Or defer pan/zoom tests to E02 completion
- Core selection doesn't depend on pan/zoom working

### 6.5 Performance with Complex Properties

**Risk**: Querying domain objects for properties is slow.

**Impact**: Medium - Selection feels laggy
**Probability**: Low - Simple property queries should be fast
**Mitigation**:
- Use queued signal connection (async update)
- Show loading indicator if query >100ms
- Cache frequently accessed properties
- Lazy-load heavy properties (text fields, large arrays)

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should Escape clear selection even if canvas doesn't have focus?
**Answer**: No. Standard behavior requires focused widget. User can click canvas first.

**Q2**: Should pan/zoom have undo/redo support?
**Answer**: No for MVP. View navigation is ephemeral, not "document changes."

**Q3**: Should selection persist across file loads?
**Answer**: No for MVP. Clear selection when new file loaded. Add to P1 session persistence.

**Q4**: What if design repository query fails (object not found)?
**Answer**: Show error in property panel: "Object not found (ID: xyz)". Log warning.

### 7.2 UX Questions

**Q1**: Should there be visual feedback when Escape pressed?
**Answer**: Yes - highlights disappear (already implemented in T04). No additional feedback needed.

**Q2**: Should property panel collapse when selection cleared?
**Answer**: No. Show "No selection" message. Panel remains open.

**Q3**: Should status bar show anything else besides selection count?
**Answer**: Not in T05. Future: cursor position, zoom level, design statistics.

### 7.3 Integration Questions

**Q1**: If property panel is dockable, should it be collapsible to tab?
**Answer**: Yes (Qt default behavior). User can minimize dock widget.

**Q2**: Should selection be preserved when property panel closed?
**Answer**: Yes. Selection state independent of panel visibility.

**Q3**: Should Ctrl+A (Select All) be implemented now?
**Answer**: No. Separate task for keyboard shortcuts. Ctrl+A would be action in MainWindow.

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] Escape key clears selection when canvas has focus
- [ ] Selection state persists during zoom operations
- [ ] Selection state persists during pan operations
- [ ] Property panel stub created with basic UI
- [ ] Property panel connected to `selection_changed` signal
- [ ] Property panel displays "No selection" when empty
- [ ] Property panel displays object ID when single object selected
- [ ] Property panel displays count when multiple objects selected
- [ ] Main window integrates canvas and property panel
- [ ] Composition root (`InkApplication`) wires all dependencies
- [ ] Status bar selection count integrated (from T03)

### 8.2 Quality Checklist

- [ ] All integration tests pass
- [ ] Keyboard shortcut test passes
- [ ] Pan/zoom persistence tests pass
- [ ] Property panel update test passes
- [ ] No memory leaks from signal connections
- [ ] Type hints on all new methods
- [ ] Docstrings on selection event API
- [ ] No mypy errors
- [ ] No ruff warnings

### 8.3 Documentation Checklist

- [ ] Selection event API documented in `SelectionService` docstring
- [ ] Example usage code provided
- [ ] Current consumers listed
- [ ] Future consumers identified
- [ ] Keyboard shortcuts documented (Escape)
- [ ] Integration architecture documented

### 8.4 Integration Checklist

- [ ] Works with single selection (T02)
- [ ] Works with multi-selection (T03)
- [ ] Works with selection highlighting (T04)
- [ ] Property panel receives and displays data
- [ ] Status bar shows correct count
- [ ] Keyboard shortcuts functional
- [ ] Pan/zoom don't break selection

---

## 9. Implementation Steps

### 9.1 Step-by-Step Plan

**Phase 1: Keyboard Shortcuts (30 minutes)**
1. Override `keyPressEvent()` in `SchematicCanvas`
2. Add Escape key handler
3. Call `selection_service.clear()`
4. Test keyboard shortcut

**Phase 2: Pan/Zoom Implementation (if needed) (1 hour)**
5. Add pan state variables
6. Implement middle-button pan in mouse events
7. Implement mouse wheel zoom in `wheelEvent()`
8. Test pan and zoom

**Phase 3: Property Panel Stub (1 hour)**
9. Create `PropertyPanel` class in `src/ink/presentation/panels/`
10. Add `QTreeWidget` for property display
11. Connect to `selection_changed` signal
12. Implement `_on_selection_changed()` handler
13. Implement empty, single, multi-object display methods

**Phase 4: Composition Root (30 minutes)**
14. Create `InkApplication` class in `src/ink/presentation/app.py`
15. Instantiate `SelectionService`
16. Create and inject dependencies into canvas and panel
17. Create `MainWindow` with all components
18. Set up dock widget for property panel

**Phase 5: Testing (1 hour)**
19. Create `tests/integration/test_selection_integration.py`
20. Write keyboard shortcut tests
21. Write pan/zoom persistence tests
22. Write property panel integration tests
23. Write end-to-end workflow test
24. Run all tests

**Phase 6: Documentation (30 minutes)**
25. Document selection event API in docstring
26. Add example usage code
27. Document keyboard shortcuts
28. Create integration architecture diagram (optional)

**Phase 7: Refinement (30 minutes)**
29. Run type checker and linter
30. Fix any issues
31. Verify all acceptance criteria met

### 9.2 Estimated Time Breakdown

- Phase 1: 30 minutes
- Phase 2: 1 hour (if needed)
- Phase 3: 1 hour
- Phase 4: 30 minutes
- Phase 5: 1 hour
- Phase 6: 30 minutes
- Phase 7: 30 minutes
- **Total**: ~3.5-4.5 hours (depending on pan/zoom needs, within 3-hour estimate if pan/zoom exists)

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T05/E04-F01-T05.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Dependencies**:
  - T01: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T01/E04-F01-T01.spec.md`
  - T02: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T02/E04-F01-T02.spec.md`
  - T03: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T03/E04-F01-T03.spec.md`
  - T04: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T04/E04-F01-T04.spec.md`
- **Qt Keyboard Events**: https://doc.qt.io/qt-6/qkeyevent.html
- **Qt Dock Widgets**: https://doc.qt.io/qt-6/qdockwidget.html

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
