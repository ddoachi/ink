# E04-F01-T02 - Single Selection: Pre-Implementation Documentation

## Document Information
- **Task**: E04-F01-T02 - Single Selection
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task implements single-object selection via mouse clicks on the schematic canvas. When a user clicks on a schematic object (cell, pin, net, or port), the object is selected, any previous selection is cleared, and visual feedback is provided. The implementation integrates mouse event handling in the canvas with the `SelectionService` created in T01.

### 1.2 Problem Context

Circuit designers need an intuitive way to select schematic objects for inspection and manipulation. Single-click selection is the most fundamental interaction pattern:
- **Property Inspection**: Click cell → see properties in property panel
- **Context Operations**: Click net → right-click for "Highlight Path"
- **Expansion Origin**: Click pin → double-click to expand fanout

Without proper single selection, users cannot interact with the schematic effectively. The implementation must be fast (<16ms click-to-feedback), reliable, and follow standard UI conventions (left-click to select, click empty space to clear).

### 1.3 Success Metrics

- Click-to-selection response time <16ms (60 FPS)
- 100% accuracy in detecting clicked objects (no false positives/negatives)
- Previous selection cleared on single click (no Ctrl modifier)
- Clicking empty canvas clears all selections
- Integration with property panel triggers property display update

---

## 2. Implementation Approach

### 2.1 Event Handling Architecture

**Decision**: Handle mouse events at the `SchematicCanvas` level, not at individual item level.

**Rationale**:
- **Centralized Control**: Single point for selection logic, easier to maintain
- **Consistent Behavior**: All items handled uniformly, no per-item customization needed
- **Event Priority**: Canvas can handle empty space clicks before items
- **Performance**: One event handler instead of N handlers (one per item)

**Alternative Considered**: Override `mousePressEvent()` in each item class
- **Rejected**: Duplicated logic across `CellItem`, `PinItem`, `NetItem`
- **Rejected**: Harder to coordinate between items
- **Rejected**: Empty space click handling requires canvas-level handler anyway

**Event Flow**:
```
User clicks mouse
    ↓
Qt Event System
    ↓
SchematicCanvas.mousePressEvent()
    ↓ (determines clicked item)
QGraphicsView.itemAt(event.pos())
    ↓ (if item found)
SelectionService.select(item.object_id, mode)
    ↓
selection_changed signal emitted
    ↓
PropertyPanel and Canvas update
```

### 2.2 Item Identification Strategy

**Decision**: All schematic items expose an `object_id` attribute for identification.

**Rationale**:
- **Uniform Interface**: All items (cells, pins, nets) identified the same way
- **Decoupling**: Canvas doesn't need to know item type, just needs ID
- **String IDs**: Match `SelectionService` API (stores string IDs)

**Implementation**:
```python
class SchematicItem(QGraphicsItem):
    """Base class for all schematic items"""
    def __init__(self, object_id: str):
        super().__init__()
        self.object_id = object_id  # Publicly accessible
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
```

**Inheritance Hierarchy**:
```
QGraphicsItem (Qt base)
    ↓
SchematicItem (our base)
    ↓
├── CellItem
├── PinItem
├── NetItem
└── PortItem
```

### 2.3 Selection Mode Determination

**Decision**: Use Qt modifier keys to determine selection mode.

**Mapping**:
- **No modifier**: REPLACE mode (clear previous, select new)
- **Ctrl modifier**: ADD mode (implemented in T03)
- **Shift modifier**: Reserved for range selection (future)

**Implementation**:
```python
def mousePressEvent(self, event: QMouseEvent) -> None:
    if event.button() == Qt.LeftButton:
        item = self.itemAt(event.pos())

        if item and hasattr(item, 'object_id'):
            # Check modifiers
            if event.modifiers() & Qt.ControlModifier:
                mode = SelectMode.ADD  # T03 multi-selection
            else:
                mode = SelectMode.REPLACE  # T02 single selection

            self._selection_service.select(item.object_id, mode)
```

**Rationale**:
- Standard across all desktop applications
- Users already familiar with Ctrl+click pattern
- Qt provides built-in modifier detection

### 2.4 Empty Space Click Handling

**Decision**: Clicking empty canvas area clears selection.

**Rationale**:
- **Standard Behavior**: Matches file explorers, CAD tools, graphic editors
- **Reset Mechanism**: Provides easy way to clear selection
- **Focus Management**: Clicking canvas can give it keyboard focus

**Implementation**:
```python
def mousePressEvent(self, event: QMouseEvent) -> None:
    if event.button() == Qt.LeftButton:
        item = self.itemAt(event.pos())

        if item and hasattr(item, 'object_id'):
            # Select item (as above)
        else:
            # No item at click position → clear
            if not (event.modifiers() & Qt.ControlModifier):
                self._selection_service.clear()
```

**Edge Case**: Ctrl+click on empty space should NOT clear (preparing for multi-select drag rectangle in T03)

### 2.5 Dependency Injection Pattern

**Decision**: Inject `SelectionService` into `SchematicCanvas` via constructor.

**Rationale**:
- **Testability**: Can inject mock service for unit tests
- **Loose Coupling**: Canvas depends on service interface, not implementation
- **Single Responsibility**: Canvas handles UI, service handles state

**Composition Root Pattern** (in `app.py`):
```python
class InkApplication:
    def __init__(self):
        # Create services
        self.selection_service = SelectionService()

        # Inject into UI components
        self.canvas = SchematicCanvas(self.selection_service)
        self.property_panel = PropertyPanel(self.selection_service)
```

---

## 3. Key Design Decisions

### 3.1 SchematicItem Base Class

**Decision**: Create `SchematicItem` abstract base class for all schematic graphics.

**Responsibilities**:
- Provide `object_id` attribute
- Set Qt item flags (`ItemIsSelectable`, hover events)
- Define highlight interface (implemented in T04)

**Rationale**:
- **Code Reuse**: Common functionality in one place
- **Polymorphism**: Canvas can treat all items uniformly
- **Future-Proof**: Easy to add common behaviors (tooltips, drag-and-drop)

**Alternative Considered**: Duck typing (check `hasattr(item, 'object_id')`)
- **Rejected**: Less type-safe, harder to enforce contract
- **Accepted for now**: We do use `hasattr()` check as defense, but base class provides compile-time guarantee

### 3.2 Event Propagation

**Decision**: Call `super().mousePressEvent(event)` after custom handling.

**Rationale**:
- Allows Qt's default item selection mechanism to run
- Enables future Qt features (drag-and-drop, item movement)
- Doesn't break Qt's event processing chain

**When NOT to propagate**: If event fully handled and no further processing needed
- For now, always propagate to be safe

### 3.3 Item Hit Testing

**Decision**: Use `QGraphicsView.itemAt(pos)` for hit testing.

**Rationale**:
- **Built-in**: Qt provides optimized spatial query
- **Z-Order Aware**: Returns topmost item at position
- **Shape Aware**: Respects item's `shape()` and `boundingRect()`

**Performance**: O(log n) with Qt's internal spatial index (BSP tree)

**Alternative Considered**: Manual bounding box checks
- **Rejected**: Reinventing the wheel, slower, doesn't handle overlaps

### 3.4 Click vs. Press vs. Release

**Decision**: Handle selection in `mousePressEvent()`, not `mouseReleaseEvent()`.

**Rationale**:
- **Immediate Feedback**: User sees selection highlight on press, not release
- **Standard Pattern**: Most applications select on press
- **Drag Detection**: Allows distinguishing click from drag (check distance in release)

**Trade-off**: Can't cancel selection by dragging away (acceptable)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Critical Dependencies**:
1. **E04-F01-T01 (SelectionManager)**: Provides `SelectionService` class
   - Must be completed first
   - Canvas depends on service API

2. **E02 (Rendering)**: Schematic items must exist
   - `CellItem`, `PinItem`, `NetItem` classes must be implemented
   - Items must render on canvas before they can be selected

**Assumption**: E02 has basic rendering without selection highlights (added in T04)

### 4.2 Downstream Dependencies

**Tasks Depending on T02**:
1. **E04-F01-T03 (Multi-Selection)**: Extends mouse handling for Ctrl+click and drag rectangle
2. **E04-F01-T04 (Selection Highlighting)**: Adds visual feedback to selected items
3. **E04-F02 (Property Panel)**: Receives selection events and displays properties

### 4.3 Integration with Property Panel

**Signal/Slot Connection**:
```python
# In composition root:
self.selection_service.selection_changed.connect(
    self.property_panel.on_selection_changed
)

# In PropertyPanel:
def on_selection_changed(self, selected_ids: List[str]):
    if len(selected_ids) == 1:
        obj = self.design_repository.get_object(selected_ids[0])
        self.display_properties(obj)
    else:
        self.clear()
```

**Note**: Full property panel implementation is E04-F02, but stub can be tested in T02

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Test Categories**:

1. **Basic Selection Tests**:
   ```python
   def test_click_selects_item(qtbot):
       """Left-click on item selects it"""

   def test_click_clears_previous_selection(qtbot):
       """Single click replaces previous selection"""

   def test_click_empty_clears_selection(qtbot):
       """Click on empty canvas clears selection"""
   ```

2. **Item Identification Tests**:
   ```python
   def test_schematic_item_has_object_id():
       """All schematic items expose object_id"""

   def test_cell_item_inherits_schematic_item():
       """CellItem inherits from SchematicItem"""

   def test_pin_item_inherits_schematic_item():
       """PinItem inherits from SchematicItem"""
   ```

3. **Event Handling Tests**:
   ```python
   def test_left_button_triggers_selection():
       """Left mouse button selects items"""

   def test_right_button_no_selection():
       """Right mouse button doesn't change selection"""

   def test_middle_button_no_selection():
       """Middle mouse button doesn't change selection"""
   ```

4. **Modifier Key Tests**:
   ```python
   def test_no_modifier_uses_replace_mode():
       """Plain click uses REPLACE mode"""

   def test_ctrl_modifier_uses_add_mode():
       """Ctrl+click uses ADD mode (T03)"""
   ```

5. **Integration Tests**:
   ```python
   def test_selection_updates_property_panel(qtbot):
       """Property panel receives selection events"""

   def test_double_click_same_item_idempotent(qtbot):
       """Clicking selected item again is no-op"""
   ```

### 5.2 Performance Testing

**Response Time Test**:
```python
def test_click_to_selection_latency():
    """Measure time from click to selection signal emission"""
    import time

    # Setup
    service = SelectionService()
    canvas = SchematicCanvas(service)
    item = CellItem(object_id="cell1", ...)
    canvas.scene().addItem(item)

    # Measure
    start = time.perf_counter()
    click_pos = canvas.mapFromScene(item.pos())
    QTest.mouseClick(canvas.viewport(), Qt.LeftButton, pos=click_pos)
    # (selection_changed signal emitted)
    elapsed = (time.perf_counter() - start) * 1000  # ms

    assert elapsed < 16  # Must complete within one frame (60 FPS)
```

**Scalability Test**:
```python
def test_selection_with_many_items():
    """Selection performance with 100+ items on canvas"""
    service = SelectionService()
    canvas = SchematicCanvas(service)

    # Add 100 items
    for i in range(100):
        item = CellItem(object_id=f"cell{i}", ...)
        item.setPos(i * 50, 0)
        canvas.scene().addItem(item)

    # Click one item
    start = time.perf_counter()
    # ... click simulation ...
    elapsed = (time.perf_counter() - start) * 1000

    assert elapsed < 16  # Should not degrade with many items
```

### 5.3 Manual Testing Checklist

**Basic Functionality**:
- [ ] Click cell → cell selected
- [ ] Click pin → pin selected
- [ ] Click net → net selected
- [ ] Click empty → selection cleared
- [ ] Visual feedback appears (after T04)

**Edge Cases**:
- [ ] Click very small pin (hit testing accuracy)
- [ ] Click overlapping items (selects topmost)
- [ ] Click during pan/zoom (coordinates correct)
- [ ] Rapid clicking doesn't cause lag

**Integration**:
- [ ] Property panel updates on selection
- [ ] Status bar shows "1 object selected"
- [ ] Keyboard focus given to canvas on click

---

## 6. Risks and Considerations

### 6.1 Hit Testing Accuracy

**Risk**: Small items (pins) are hard to click.

**Impact**: High - Poor user experience, frustration
**Probability**: Medium - Pins are typically 4-6 pixels wide
**Mitigation**:
- Expand hit area with `shape()` override:
  ```python
  def shape(self) -> QPainterPath:
      # Return slightly larger path for hit testing
      path = QPainterPath()
      path.addEllipse(self.boundingRect().adjusted(-2, -2, 2, 2))
      return path
  ```
- Add hover preview (item highlights on mouse-over before click)
- Future: Snap-to-pin cursor behavior

### 6.2 Coordinate System Confusion

**Risk**: Mixing view coordinates and scene coordinates causes incorrect hit detection.

**Impact**: High - Items not selected when clicked
**Probability**: Medium - Common Qt mistake
**Mitigation**:
- **View Coordinates**: Mouse event positions (`event.pos()`)
- **Scene Coordinates**: Item positions (`item.scenePos()`)
- Use `mapToScene()` and `mapFromScene()` for conversion:
  ```python
  scene_pos = self.mapToScene(event.pos())  # View → Scene
  view_pos = self.mapFromScene(scene_pos)   # Scene → View
  ```
- Test with zoomed and panned views

### 6.3 Event Handling Conflicts

**Risk**: Future features (pan, zoom, drag) conflict with selection handling.

**Impact**: Medium - User interactions break each other
**Probability**: Medium - Will add pan/zoom in future tasks
**Mitigation**:
- Check mouse button explicitly: `if event.button() == Qt.LeftButton`
- Track interaction state: `_is_panning`, `_is_dragging_selection`
- Priority order: Drag selection > Pan > Selection
- Document event handling priority in code comments

### 6.4 Property Panel Performance

**Risk**: Property panel queries slow down selection response.

**Impact**: Medium - Perceived lag in selection
**Probability**: Low - Domain queries should be fast
**Mitigation**:
- Property panel updates asynchronously (queued signal connection)
- Cache frequently accessed properties
- Lazy load heavy properties (e.g., large text fields)
- Show loading indicator for slow queries (>100ms)

### 6.5 Memory Leaks from Signal Connections

**Risk**: Signal/slot connections not cleaned up when components destroyed.

**Impact**: Low - Memory leaks in long-running sessions
**Probability**: Low - Qt auto-disconnects when receiver destroyed
**Mitigation**:
- Use Qt's automatic connection management (default behavior)
- Document lifetime expectations (canvas and service should live entire session)
- Add cleanup in destructor if manual connections used

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should items be selectable while invisible (off-screen)?
**Answer**: Yes, selection state independent of rendering. But `itemAt()` only finds visible items, so this is automatic.

**Q2**: Should selection work during animations (e.g., expansion animation)?
**Answer**: Yes, don't disable selection. May feel responsive. If issues arise, add interaction lock during critical animations.

**Q3**: Should right-click select object before showing context menu?
**Answer**: Yes (standard behavior). Implement in T02 for consistency.
```python
if event.button() == Qt.RightButton:
    item = self.itemAt(event.pos())
    if item and hasattr(item, 'object_id'):
        self._selection_service.select(item.object_id, SelectMode.REPLACE)
    # Show context menu...
```

**Q4**: Should double-click select or trigger action (expansion)?
**Answer**: Both. Double-click selects first (in `mousePressEvent`), then triggers action (in `mouseDoubleClickEvent`).

### 7.2 UX Questions

**Q1**: Visual feedback timing - how fast should highlight appear?
**Answer**: Immediate (same frame). Implemented in T04, but design now.

**Q2**: Should clicking selected item deselect it?
**Answer**: No (standard behavior). Ctrl+click to toggle (T03).

**Q3**: Audio/haptic feedback on selection?
**Answer**: No for MVP. Accessibility consideration for future.

### 7.3 Integration Questions

**Q1**: What if property panel isn't implemented yet?
**Answer**: T02 can be tested with stub panel that just prints to console.

**Q2**: Should selection persist when switching views (if multiple canvases)?
**Answer**: Yes, selection is global. All canvases share same `SelectionService`.

**Q3**: Should selection be preserved when canvas is hidden/shown?
**Answer**: Yes, selection state independent of canvas visibility.

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] `SchematicItem` base class created with `object_id` attribute
- [ ] `CellItem`, `PinItem`, `NetItem` inherit from `SchematicItem`
- [ ] `SchematicCanvas` accepts `SelectionService` in constructor
- [ ] `mousePressEvent()` implemented in `SchematicCanvas`
- [ ] Left-click on item selects it (REPLACE mode)
- [ ] Clicking empty canvas clears selection
- [ ] Right-click selects item before context menu (if menu exists)
- [ ] `SelectionService.select()` called with correct object_id and mode

### 8.2 Quality Checklist

- [ ] All unit tests pass
- [ ] Click-to-selection response time <16ms
- [ ] No false positives (clicking empty doesn't select random item)
- [ ] No false negatives (clicking item always selects it)
- [ ] Type hints on all new methods
- [ ] Docstrings on `SchematicItem` and mouse event handlers
- [ ] No mypy errors
- [ ] No ruff warnings

### 8.3 Integration Checklist

- [ ] Property panel receives `selection_changed` signal
- [ ] Property panel displays correct object properties
- [ ] Status bar shows "1 object selected"
- [ ] No exceptions when clicking before any file loaded
- [ ] Selection works after zoom/pan operations

### 8.4 Testing Checklist

- [ ] Unit tests for all item types (cell, pin, net)
- [ ] Integration test with property panel
- [ ] Performance test passes (<16ms)
- [ ] Manual testing checklist completed
- [ ] Edge cases tested (overlapping items, small items)

---

## 9. Implementation Steps

### 9.1 Step-by-Step Plan

**Phase 1: Base Class Infrastructure**
1. Create `src/ink/presentation/canvas/schematic_item.py`
2. Implement `SchematicItem` base class:
   - Add `object_id` parameter to `__init__`
   - Set `ItemIsSelectable` flag
   - Enable hover events
3. Update `CellItem` to inherit from `SchematicItem`
4. Update `PinItem` to inherit from `SchematicItem`
5. Update `NetItem` to inherit from `SchematicItem`

**Phase 2: Mouse Event Handling**
6. Modify `SchematicCanvas.__init__()` to accept `SelectionService`
7. Store service as `self._selection_service`
8. Implement `mousePressEvent()`:
   - Check for left button
   - Get item at position with `itemAt()`
   - Check item has `object_id`
   - Determine mode from modifiers
   - Call `selection_service.select()`
9. Handle empty space clicks (call `clear()`)

**Phase 3: Composition Root Integration**
10. Update `InkApplication` in `src/ink/presentation/app.py`
11. Create `SelectionService` instance
12. Pass service to `SchematicCanvas` constructor
13. Pass service to `PropertyPanel` constructor (stub if not exists)

**Phase 4: Testing**
14. Create test file `tests/ui/canvas/test_selection_interaction.py`
15. Write unit tests for all scenarios
16. Write performance test
17. Run manual testing checklist

**Phase 5: Documentation and Refinement**
18. Add docstrings to all new methods
19. Document event handling flow
20. Run type checker and linter
21. Address any issues

### 9.2 Estimated Time Breakdown

- Phase 1 (Base class): 30 minutes
- Phase 2 (Event handling): 1 hour
- Phase 3 (Integration): 30 minutes
- Phase 4 (Testing): 1 hour
- Phase 5 (Documentation): 30 minutes
- **Total**: ~3.5 hours (within 3-hour estimate, buffer for debugging)

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T02/E04-F01-T02.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Dependency T01**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T01/E04-F01-T01.spec.md`
- **Qt Mouse Events**: https://doc.qt.io/qt-6/qmouseevent.html
- **QGraphicsView**: https://doc.qt.io/qt-6/qgraphicsview.html

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
