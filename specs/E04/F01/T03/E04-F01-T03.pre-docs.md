# E04-F01-T03 - Multi-Selection: Pre-Implementation Documentation

## Document Information
- **Task**: E04-F01-T03 - Multi-Selection
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26

---

## 1. Overview

### 1.1 Task Summary

This task extends single selection (T02) to support multi-object selection through two mechanisms: Ctrl+click to add individual objects to the selection set, and drag-rectangle selection to select all objects within a rectangular area. The implementation includes visual feedback during rectangle dragging and displays selection count in the status bar.

### 1.2 Problem Context

Circuit designers frequently need to select multiple objects for:
- **Batch Operations**: Collapse multiple cells, delete groups, export subsets
- **Comparative Analysis**: Compare properties of similar cells
- **Area Selection**: Select all logic within a functional block
- **Path Selection**: Select all cells along a signal path

Single selection is insufficient for these workflows. Multi-selection must be intuitive (following desktop UI conventions), performant (handle 1000+ objects in <100ms), and provide clear visual feedback during the selection process.

### 1.3 Success Metrics

- Ctrl+click adds to selection without clearing previous
- Drag rectangle selects all enclosed objects
- Rectangle selection with 1000+ objects completes in <100ms
- Visual feedback appears during drag operation (<16ms latency)
- Selection count displayed in status bar
- No duplicate selections regardless of operation sequence

---

## 2. Implementation Approach

### 2.1 Ctrl+Click Implementation

**Decision**: Detect Ctrl modifier in `mousePressEvent()` and use ADD mode.

**Implementation** (extends T02):
```python
def mousePressEvent(self, event: QMouseEvent) -> None:
    if event.button() == Qt.LeftButton:
        item = self.itemAt(event.pos())

        if item and hasattr(item, 'object_id'):
            # NEW: Check for Ctrl modifier
            if event.modifiers() & Qt.ControlModifier:
                mode = SelectMode.ADD  # Add to selection
            else:
                mode = SelectMode.REPLACE  # Clear and select (T02)

            self._selection_service.select(item.object_id, mode)
        else:
            # Empty space click
            if not (event.modifiers() & Qt.ControlModifier):
                self._selection_service.clear()
```

**Rationale**:
- Standard desktop convention (matches file explorers, IDEs, CAD tools)
- Minimal code change from T02
- Leverages existing `SelectionService.select()` with different mode

**User Workflow**:
1. Click cell A → A selected
2. Ctrl+click cell B → A and B selected
3. Ctrl+click cell B again → B deselected (toggle, if using TOGGLE mode)

**Design Choice**: Use ADD mode, not TOGGLE mode for Ctrl+click.
- **Rationale**: More predictable for users (always adds)
- **Alternative**: Use TOGGLE mode (Ctrl+click on selected item deselects it)
- **Decision**: Implement ADD mode for MVP, consider TOGGLE in future based on user feedback

### 2.2 Drag Rectangle Selection

**Decision**: Implement custom drag rectangle using Qt `QGraphicsRectItem`.

**State Management**:
```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service

        # Drag rectangle state
        self._drag_start_pos: Optional[QPointF] = None
        self._drag_rect_item: Optional[QGraphicsRectItem] = None
```

**Three-Phase Operation**:

**Phase 1: Start Drag** (Mouse Press on Empty Space)
```python
def mousePressEvent(self, event: QMouseEvent) -> None:
    if event.button() == Qt.LeftButton:
        item = self.itemAt(event.pos())

        if not item:  # Clicked empty space
            # Start drag rectangle
            self._drag_start_pos = self.mapToScene(event.pos())
            self._create_drag_rect()
        elif hasattr(item, 'object_id'):
            # Handle item click (as in T02)
```

**Phase 2: Update Drag** (Mouse Move)
```python
def mouseMoveEvent(self, event: QMouseEvent) -> None:
    if self._drag_start_pos:
        current_pos = self.mapToScene(event.pos())
        rect = QRectF(self._drag_start_pos, current_pos).normalized()
        self._drag_rect_item.setRect(rect)

    super().mouseMoveEvent(event)
```

**Phase 3: Complete Drag** (Mouse Release)
```python
def mouseReleaseEvent(self, event: QMouseEvent) -> None:
    if self._drag_start_pos and event.button() == Qt.LeftButton:
        # Get final rectangle
        end_pos = self.mapToScene(event.pos())
        rect = QRectF(self._drag_start_pos, end_pos).normalized()

        # Find items within rectangle
        selected_items = self._scene.items(rect, Qt.IntersectsItemShape)
        object_ids = [
            item.object_id for item in selected_items
            if hasattr(item, 'object_id')
        ]

        # Select items
        mode = SelectMode.ADD if (event.modifiers() & Qt.ControlModifier) else SelectMode.REPLACE
        self._selection_service.select_multiple(object_ids, mode)

        # Cleanup
        self._remove_drag_rect()
        self._drag_start_pos = None

    super().mouseReleaseEvent(event)
```

**Rationale**:
- **Empty Space Initiation**: Only start drag on empty space (avoids conflict with item selection)
- **Scene Coordinates**: Use scene coordinates for rectangle (independent of view zoom/pan)
- **Normalized Rectangle**: Handle dragging in any direction (top-left, bottom-right, etc.)
- **Intersection Mode**: `IntersectsItemShape` includes partially enclosed items (more forgiving than `ContainsItemShape`)

### 2.3 Visual Feedback During Drag

**Decision**: Draw semi-transparent dashed rectangle during drag operation.

**Visual Specification**:
- **Border**: Dashed line, 1px width, blue (#0078D7)
- **Fill**: Semi-transparent blue (#0078D7 at 12% opacity)
- **Z-Order**: Draw on top of all items (high Z-value)

**Implementation**:
```python
def _create_drag_rect(self) -> None:
    """Create visual drag rectangle item"""
    self._drag_rect_item = QGraphicsRectItem()

    # Style: dashed border, semi-transparent fill
    pen = QPen(QColor(0, 120, 215), 1, Qt.DashLine)
    brush = QBrush(QColor(0, 120, 215, 30))  # 30/255 ≈ 12% alpha

    self._drag_rect_item.setPen(pen)
    self._drag_rect_item.setBrush(brush)
    self._drag_rect_item.setZValue(1000)  # Draw on top

    self._scene.addItem(self._drag_rect_item)

def _remove_drag_rect(self) -> None:
    """Remove drag rectangle from scene"""
    if self._drag_rect_item:
        self._scene.removeItem(self._drag_rect_item)
        self._drag_rect_item = None
```

**Rationale**:
- **Dashed Border**: Clearly distinguishes from schematic elements
- **Semi-Transparent Fill**: Shows items being selected without obscuring them
- **Blue Color**: Matches standard Windows/Qt selection color
- **High Z-Value**: Ensures rectangle is always visible, not hidden behind objects

### 2.4 Selection Count Display

**Decision**: Add permanent widget to status bar showing selection count.

**Implementation** (in `MainWindow`):
```python
class MainWindow(QMainWindow):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service

        # Status bar setup
        self._status_bar = self.statusBar()
        self._selection_label = QLabel("No selection")
        self._status_bar.addPermanentWidget(self._selection_label)

        # Connect to selection changes
        self._selection_service.selection_changed.connect(self._update_selection_status)

    def _update_selection_status(self, selected_ids: List[str]) -> None:
        """Update status bar with selection count"""
        count = len(selected_ids)
        if count == 0:
            self._selection_label.setText("No selection")
        elif count == 1:
            self._selection_label.setText("1 object selected")
        else:
            self._selection_label.setText(f"{count} objects selected")
```

**Rationale**:
- **Permanent Widget**: Always visible, doesn't get overridden by temporary messages
- **Grammatical Correctness**: "1 object" (singular) vs. "N objects" (plural)
- **Clear Feedback**: User always knows how many objects are selected

---

## 3. Key Design Decisions

### 3.1 Rectangle Intersection Mode

**Decision**: Use `Qt.IntersectsItemShape` instead of `Qt.ContainsItemShape`.

**Rationale**:
- **User-Friendly**: Partially enclosed items are selected (more forgiving)
- **Standard**: Matches behavior in most graphics applications
- **Large Items**: Easier to select large cells without dragging huge rectangle

**Alternative**: `ContainsItemShape` (only select fully enclosed items)
- **Rejected**: Too strict, frustrates users
- **Use Case**: Could add as Shift+drag variant in future

### 3.2 Drag Initiation Threshold

**Decision**: Start drag immediately on mouse press, no distance threshold.

**Rationale**:
- **Immediate Feedback**: Visual rectangle appears instantly
- **Small Selections**: Can select 2-3 closely spaced items without moving mouse far
- **Cancellation**: User can press Escape to cancel drag (future feature)

**Alternative**: Require 3-5 pixel movement before starting drag
- **Rejected**: Adds latency, makes small selections harder
- **Note**: If accidental drags become issue, reconsider

### 3.3 Ctrl+Drag Behavior

**Decision**: Ctrl+drag adds to selection, plain drag replaces.

**Implementation**:
```python
# In mouseReleaseEvent:
mode = SelectMode.ADD if (event.modifiers() & Qt.ControlModifier) else SelectMode.REPLACE
self._selection_service.select_multiple(object_ids, mode)
```

**Rationale**:
- **Consistency**: Matches Ctrl+click behavior
- **Power User Workflow**: Select set A, then Ctrl+drag to add set B
- **Standard**: Matches file explorers, graphic editors

### 3.4 Rectangle Appearance

**Design Choices**:
- **Dashed vs. Solid**: Dashed distinguishes from schematic rectangles (cells)
- **Fill Opacity**: 12% visible but doesn't obscure items
- **Color**: Blue (#0078D7) is standard selection color in Windows/Qt
- **Border Width**: 1px is thin enough to be unobtrusive

**User Customization**: Future feature (theme support) can change colors

### 3.5 Performance Optimization

**Decision**: Use `QGraphicsScene.items(rect)` for spatial query.

**Rationale**:
- **Built-in Optimization**: Qt uses BSP tree for O(log n) queries
- **Handles Overlaps**: Correctly handles items with overlapping bounding boxes
- **Shape Aware**: Respects item's `shape()` method for accurate hit testing

**Performance Characteristics**:
- **1000 items in scene**: Query takes ~1-5ms
- **100 items in rectangle**: Processing takes ~5-10ms
- **Total**: Well under 100ms target

**Fallback**: If performance issues arise, implement:
- Limit rectangle size (warn if too large)
- Background thread for very large selections
- Progressive selection (select in chunks, update incrementally)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Critical Dependencies**:
1. **E04-F01-T01 (SelectionManager)**: Provides `select_multiple()` method
2. **E04-F01-T02 (Single Selection)**: Extends mouse event handling
   - Ctrl+click builds on existing `mousePressEvent()` logic
   - Drag rectangle adds to same event handler
3. **E02 (Rendering)**: Canvas and items must exist

### 4.2 Downstream Dependencies

**Tasks Depending on T03**:
1. **E04-F01-T04 (Selection Highlighting)**: Must handle multiple selected items
   - Highlight all items in `selected_ids` list
2. **E04-F02 (Property Panel)**: Must show multi-object summary
   - Display "N objects selected" instead of detailed properties

### 4.3 Integration with Status Bar

**Assumption**: `MainWindow` has status bar already set up (from basic app structure).

**If not**: Create status bar in T03 implementation:
```python
self._status_bar = QStatusBar()
self.setStatusBar(self._status_bar)
```

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Ctrl+Click Tests**:
```python
def test_ctrl_click_adds_to_selection(qtbot):
    """Ctrl+click adds without clearing previous"""

def test_ctrl_click_multiple_items(qtbot):
    """Multiple Ctrl+clicks accumulate selection"""

def test_plain_click_after_ctrl_click_clears(qtbot):
    """Plain click clears multi-selection"""
```

**Drag Rectangle Tests**:
```python
def test_drag_creates_rectangle(qtbot):
    """Dragging on empty space creates rectangle"""

def test_drag_rect_updates_during_move(qtbot):
    """Rectangle updates as mouse moves"""

def test_drag_selects_enclosed_items(qtbot):
    """Items within final rectangle are selected"""

def test_drag_rect_removed_on_release(qtbot):
    """Rectangle disappears after mouse release"""
```

**Ctrl+Drag Tests**:
```python
def test_ctrl_drag_adds_to_selection(qtbot):
    """Ctrl+drag adds to existing selection"""

def test_plain_drag_replaces_selection(qtbot):
    """Plain drag clears previous selection"""
```

**Status Bar Tests**:
```python
def test_status_shows_single_count(qtbot):
    """Status bar shows '1 object selected'"""

def test_status_shows_multiple_count(qtbot):
    """Status bar shows 'N objects selected'"""

def test_status_shows_no_selection(qtbot):
    """Status bar shows 'No selection' when cleared"""
```

**Edge Case Tests**:
```python
def test_drag_zero_size_rectangle():
    """Zero-size rectangle (click without drag) selects nothing"""

def test_drag_backwards_normalized():
    """Drag from bottom-right to top-left works correctly"""

def test_drag_partially_offscreen():
    """Drag extending beyond canvas bounds works"""
```

### 5.2 Performance Testing

**Large Selection Test**:
```python
def test_drag_select_1000_items_performance():
    """Rectangle selection with 1000+ items completes in <100ms"""
    service = SelectionService()
    canvas = SchematicCanvas(service)

    # Create 1000 items in grid
    for i in range(1000):
        item = CellItem(object_id=f"cell{i}", ...)
        item.setPos((i % 50) * 20, (i // 50) * 20)
        canvas.scene().addItem(item)

    # Measure rectangle selection
    import time
    start = time.perf_counter()

    # Simulate drag over all items
    start_pos = QPoint(0, 0)
    end_pos = QPoint(1000, 400)
    QTest.mousePress(canvas.viewport(), Qt.LeftButton, pos=start_pos)
    QTest.mouseMove(canvas.viewport(), end_pos)
    QTest.mouseRelease(canvas.viewport(), Qt.LeftButton, pos=end_pos)

    elapsed = (time.perf_counter() - start) * 1000  # ms
    assert elapsed < 100
```

**Rectangle Update Performance**:
```python
def test_drag_rect_update_latency():
    """Rectangle updates during drag complete in <16ms"""
    # Measure time from mouseMoveEvent to rectangle visual update
    # Target: <16ms for 60 FPS
```

### 5.3 Manual Testing Checklist

**Basic Multi-Selection**:
- [ ] Ctrl+click selects multiple cells
- [ ] Ctrl+click multiple pins works
- [ ] Ctrl+click mixed types (cells, pins, nets) works
- [ ] Status bar shows correct count

**Drag Rectangle**:
- [ ] Drag on empty space shows blue rectangle
- [ ] Rectangle updates smoothly during drag
- [ ] Rectangle disappears on release
- [ ] All enclosed items selected after release

**Combined Operations**:
- [ ] Select cells with click, add more with Ctrl+drag
- [ ] Drag select, then Ctrl+click to add more
- [ ] Clear with empty space click, then multi-select again

**Edge Cases**:
- [ ] Tiny drag (1-2 pixels) doesn't select unintended items
- [ ] Drag backwards (right to left, bottom to top) works
- [ ] Drag while zoomed in/out works correctly
- [ ] Drag partially off-screen works

---

## 6. Risks and Considerations

### 6.1 Performance Risks

**Risk**: Large rectangle selections (1000+ items) cause UI freeze.

**Impact**: High - Application appears hung, poor UX
**Probability**: Medium - Users may select large areas
**Mitigation**:
- Batch process items in chunks (select 100, emit signal, select next 100)
- Show progress indicator if selection takes >200ms
- Add size limit warning: "Selection contains 5000 items. Continue?"
- Optimize spatial query with scene's BSP tree (already done by Qt)

**Early Detection**:
```python
selected_items = self._scene.items(rect, Qt.IntersectsItemShape)
if len(selected_items) > 5000:
    response = QMessageBox.question(
        self, "Large Selection",
        f"This will select {len(selected_items)} items. Continue?",
        QMessageBox.Yes | QMessageBox.No
    )
    if response == QMessageBox.No:
        return
```

### 6.2 Visual Feedback Lag

**Risk**: Drag rectangle appears laggy during fast mouse movement.

**Impact**: Medium - Perceived sluggishness
**Probability**: Medium - Depends on item count and rendering complexity
**Mitigation**:
- Rectangle is simple QGraphicsRectItem (fast to render)
- Use `setRect()` instead of recreating item (updates in place)
- Throttle updates to 60 FPS (one update per 16ms max)
- Test on lower-end hardware

### 6.3 Coordinate System Bugs

**Risk**: Mixing view and scene coordinates causes incorrect rectangle.

**Impact**: High - Rectangle appears in wrong location
**Probability**: Medium - Common Qt mistake
**Mitigation**:
- Always use scene coordinates for rectangle
- Document coordinate system in code comments
- Test with zoomed and panned views
```python
# CORRECT:
scene_pos = self.mapToScene(event.pos())

# WRONG:
view_pos = event.pos()  # Don't use directly for scene items
```

### 6.4 Event Handling Conflicts

**Risk**: Drag rectangle conflicts with future pan/zoom gestures.

**Impact**: Medium - User can't pan while drag-selecting
**Probability**: Low - Different mouse buttons (left vs. middle)
**Mitigation**:
- Use left button for selection, middle for pan
- Document button assignments
- Future: Add mode toggle (selection mode vs. navigation mode)

### 6.5 Accidental Drags

**Risk**: User intends to click empty space (clear selection) but accidentally drags slightly.

**Impact**: Low - Rectangle appears briefly, then disappears on release
**Probability**: Medium - Shaky hand, touchpad sensitivity
**Mitigation**:
- Zero-size rectangles select nothing (already handled by `items(rect)`)
- Add distance threshold (e.g., 3 pixels) before showing rectangle (optional)
- Allow Escape key to cancel drag (future feature)

---

## 7. Open Questions

### 7.1 Technical Questions

**Q1**: Should rectangle selection include items touching edge or only fully enclosed?
**Answer**: Include touching (`IntersectsItemShape`). More user-friendly.

**Q2**: Should very small drags (1-2 pixels) be ignored?
**Answer**: No threshold for MVP. If issues arise, add 3-pixel threshold.

**Q3**: Should rectangle persist briefly after release (fade out)?
**Answer**: No. Disappear immediately. Selected items provide visual feedback (highlighting).

**Q4**: Should drag work on top of items or only empty space?
**Answer**: Empty space only. Dragging items could be future "move items" feature.

### 7.2 UX Questions

**Q1**: What happens if user drags huge rectangle (entire schematic)?
**Answer**: Allow, but show warning if >5000 items. Future: Add "Select All" command instead.

**Q2**: Should Shift+drag do anything different?
**Answer**: Reserved for future (e.g., strictly enclosed items, or range selection in lists).

**Q3**: Should rectangle color be customizable?
**Answer**: Not in MVP. Add to theme support (P1/P2).

**Q4**: Should status bar show type breakdown (2 cells, 3 nets)?
**Answer**: Not in status bar (too verbose). Show in property panel multi-object summary.

### 7.3 Integration Questions

**Q1**: If property panel doesn't exist yet, how to test?
**Answer**: Create minimal stub panel that prints selection to console.

**Q2**: Should selection count include hidden objects (collapsed)?
**Answer**: Only count visible objects. Collapsed objects not selectable anyway.

**Q3**: Should Ctrl+A (Select All) be implemented in this task?
**Answer**: No. Separate keyboard shortcut task. Ctrl+A would call `select_multiple(all_visible_ids)`.

---

## 8. Definition of Done

### 8.1 Functionality Checklist

- [ ] Ctrl+click adds object to selection (ADD mode)
- [ ] Multiple Ctrl+clicks accumulate selection
- [ ] Plain click after Ctrl+click replaces selection (REPLACE mode)
- [ ] Drag on empty space creates visible rectangle
- [ ] Rectangle updates during mouse movement
- [ ] Rectangle styled with dashed border and semi-transparent fill
- [ ] Rectangle removed after mouse release
- [ ] All items within final rectangle selected
- [ ] Ctrl+drag adds to existing selection
- [ ] Plain drag replaces existing selection
- [ ] Status bar shows selection count
- [ ] Status bar updates immediately on selection change

### 8.2 Quality Checklist

- [ ] All unit tests pass
- [ ] Drag selection with 1000+ items completes in <100ms
- [ ] Rectangle update latency <16ms (60 FPS)
- [ ] No visual glitches during drag
- [ ] Type hints on all new methods
- [ ] Docstrings on drag rectangle methods
- [ ] No mypy errors
- [ ] No ruff warnings

### 8.3 Integration Checklist

- [ ] Selection count appears in main window status bar
- [ ] Property panel receives multi-selection events
- [ ] Property panel shows "N objects selected" summary
- [ ] Highlighting works for multiple selected items (T04)
- [ ] No conflicts with existing single selection (T02)

### 8.4 Testing Checklist

- [ ] All unit tests pass (Ctrl+click, drag, status bar)
- [ ] Performance tests pass (<100ms for 1000 items)
- [ ] Manual testing checklist completed
- [ ] Edge cases tested (backward drag, partial offscreen)
- [ ] Integration test with property panel passes

---

## 9. Implementation Steps

### 9.1 Step-by-Step Plan

**Phase 1: Ctrl+Click (30 minutes)**
1. Modify `mousePressEvent()` in `SchematicCanvas`
2. Add Ctrl modifier check
3. Use `SelectMode.ADD` if Ctrl pressed
4. Test Ctrl+click accumulation

**Phase 2: Drag Rectangle State (30 minutes)**
5. Add state variables: `_drag_start_pos`, `_drag_rect_item`
6. Detect empty space click to initiate drag
7. Implement `_create_drag_rect()` helper
8. Implement `_remove_drag_rect()` helper

**Phase 3: Drag Rectangle Updates (1 hour)**
9. Implement `mouseMoveEvent()` override
10. Update rectangle position during drag
11. Test rectangle visual appearance
12. Ensure scene coordinates used (not view)

**Phase 4: Drag Selection Completion (1 hour)**
13. Implement `mouseReleaseEvent()` override
14. Query scene for items in rectangle
15. Filter items with `object_id` attribute
16. Call `select_multiple()` with correct mode
17. Cleanup rectangle and state

**Phase 5: Status Bar Integration (30 minutes)**
18. Add `_selection_label` to `MainWindow` status bar
19. Connect to `selection_changed` signal
20. Implement `_update_selection_status()` method
21. Test status updates

**Phase 6: Testing (1.5 hours)**
22. Create test file `tests/ui/canvas/test_multi_selection.py`
23. Write all unit tests
24. Write performance test
25. Run manual testing checklist

**Phase 7: Refinement (30 minutes)**
26. Add docstrings
27. Run type checker and linter
28. Fix any issues
29. Optimize if needed

### 9.2 Estimated Time Breakdown

- Phase 1: 30 minutes
- Phase 2: 30 minutes
- Phase 3: 1 hour
- Phase 4: 1 hour
- Phase 5: 30 minutes
- Phase 6: 1.5 hours
- Phase 7: 30 minutes
- **Total**: ~5 hours (matches spec estimate)

---

## 10. References

- **Primary Spec**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T03/E04-F01-T03.spec.md`
- **Parent Feature**: `/home/joohan/dev/project-ink/ink/specs/E04/F01/E04-F01.spec.md`
- **Dependencies**:
  - T01: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T01/E04-F01-T01.spec.md`
  - T02: `/home/joohan/dev/project-ink/ink/specs/E04/F01/T02/E04-F01-T02.spec.md`
- **Qt Graphics View**: https://doc.qt.io/qt-6/qgraphicsview.html
- **Qt Scene Items**: https://doc.qt.io/qt-6/qgraphicsscene.html#items

---

## 11. Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude | Initial pre-implementation documentation |
