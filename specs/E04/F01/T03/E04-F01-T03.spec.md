---
id: E04-F01-T03
title: Multi-Selection
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F01
created: 2025-12-26
estimated_hours: 5
actual_hours:
effort: Medium
tags:
  - selection
  - interaction
  - ui
---

# Spec: E04-F01-T03 - Multi-Selection

## 1. Overview

### 1.1 Problem Statement

Circuit designers need to select multiple schematic objects for batch operations and comparative analysis. This requires two selection mechanisms: Ctrl+click to add individual objects to the selection set, and drag-rectangle selection to select all objects within a rectangular region.

### 1.2 Goals

- Support Ctrl+click to add objects to selection without clearing previous selection
- Implement drag-rectangle selection for area-based multi-select
- Provide visual feedback during rectangle drag (dashed border, semi-transparent fill)
- Display selection count in status bar
- Handle large selections efficiently (1000+ objects in <100ms)

---

## 2. User Story

### US-E04-02: Multi-Selection
**As a** circuit designer
**I want to** select multiple objects
**So that** I can perform batch operations

**Acceptance Criteria:**
- [ ] Ctrl+click adds to selection
- [ ] Drag rectangle selects enclosed objects
- [ ] Selection count displayed in status
- [ ] Visual feedback during drag operation

---

## 3. Technical Requirements

### 3.1 Ctrl+Click Implementation

**Location**: `src/ink/presentation/canvas/schematic_canvas.py` (extends T02)

```python
class SchematicCanvas(QGraphicsView):
    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle mouse press for object selection"""
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())

            if item and hasattr(item, 'object_id'):
                # Check for Ctrl modifier
                if event.modifiers() & Qt.ControlModifier:
                    mode = SelectMode.ADD  # Add to selection
                else:
                    mode = SelectMode.REPLACE  # Replace selection

                self._selection_service.select(item.object_id, mode)
            else:
                # Only clear if not starting a drag rectangle
                if not (event.modifiers() & Qt.ControlModifier):
                    self._selection_service.clear()

        super().mousePressEvent(event)
```

### 3.2 Drag Rectangle Selection

**Location**: `src/ink/presentation/canvas/schematic_canvas.py`

```python
class SchematicCanvas(QGraphicsView):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service
        self._scene = QGraphicsScene()
        self.setScene(self._scene)

        # Drag rectangle state
        self._drag_start_pos: Optional[QPointF] = None
        self._drag_rect_item: Optional[QGraphicsRectItem] = None

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Start drag rectangle on empty space"""
        if event.button() == Qt.LeftButton:
            item = self.itemAt(event.pos())

            if not item:
                # Start drag rectangle
                self._drag_start_pos = self.mapToScene(event.pos())
                self._create_drag_rect()
            elif hasattr(item, 'object_id'):
                # Handle object click
                mode = SelectMode.ADD if (event.modifiers() & Qt.ControlModifier) else SelectMode.REPLACE
                self._selection_service.select(item.object_id, mode)

        super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        """Update drag rectangle during mouse drag"""
        if self._drag_start_pos:
            current_pos = self.mapToScene(event.pos())
            rect = QRectF(self._drag_start_pos, current_pos).normalized()
            self._drag_rect_item.setRect(rect)

        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent) -> None:
        """Complete drag rectangle selection"""
        if self._drag_start_pos and event.button() == Qt.LeftButton:
            # Get final rectangle
            end_pos = self.mapToScene(event.pos())
            rect = QRectF(self._drag_start_pos, end_pos).normalized()

            # Find items within rectangle
            selected_items = self._scene.items(rect, Qt.IntersectsItemShape)
            object_ids = [
                item.object_id for item in selected_items
                if hasattr(item, 'object_id')
            ]

            # Select items
            mode = SelectMode.ADD if (event.modifiers() & Qt.ControlModifier) else SelectMode.REPLACE
            self._selection_service.select_multiple(object_ids, mode)

            # Clean up drag rectangle
            self._remove_drag_rect()
            self._drag_start_pos = None

        super().mouseReleaseEvent(event)

    def _create_drag_rect(self) -> None:
        """Create visual drag rectangle item"""
        self._drag_rect_item = QGraphicsRectItem()

        # Style: dashed border, semi-transparent fill
        pen = QPen(QColor(0, 120, 215), 1, Qt.DashLine)
        brush = QBrush(QColor(0, 120, 215, 30))  # 30/255 alpha

        self._drag_rect_item.setPen(pen)
        self._drag_rect_item.setBrush(brush)
        self._drag_rect_item.setZValue(1000)  # Draw on top

        self._scene.addItem(self._drag_rect_item)

    def _remove_drag_rect(self) -> None:
        """Remove drag rectangle from scene"""
        if self._drag_rect_item:
            self._scene.removeItem(self._drag_rect_item)
            self._drag_rect_item = None
```

### 3.3 Selection Count Display

**Location**: `src/ink/presentation/main_window.py`

```python
class MainWindow(QMainWindow):
    def __init__(self, selection_service: SelectionService):
        super().__init__()
        self._selection_service = selection_service

        # Status bar
        self._status_bar = self.statusBar()
        self._selection_label = QLabel("No selection")
        self._status_bar.addPermanentWidget(self._selection_label)

        # Connect to selection changes
        self._selection_service.selection_changed.connect(self._update_selection_status)

    def _update_selection_status(self, selected_ids: List[str]) -> None:
        """Update status bar with selection count"""
        count = len(selected_ids)
        if count == 0:
            self._selection_label.setText("No selection")
        elif count == 1:
            self._selection_label.setText("1 object selected")
        else:
            self._selection_label.setText(f"{count} objects selected")
```

### 3.4 Design Decisions

1. **Drag Initiation**: Drag rectangle starts on empty space click, not on object click
2. **Visual Feedback**: Dashed blue border with semi-transparent fill during drag
3. **Item Detection**: Use `QGraphicsScene.items(rect)` for efficient spatial query
4. **Mode Support**: Ctrl+drag adds to selection, regular drag replaces
5. **Z-Order**: Drag rectangle drawn at high Z-value to appear on top

---

## 4. Implementation Steps

1. Add drag rectangle state variables to `SchematicCanvas`: `_drag_start_pos`, `_drag_rect_item`
2. Modify `mousePressEvent()` to detect empty space clicks and start drag
3. Implement `mouseMoveEvent()` to update drag rectangle during mouse movement
4. Implement `mouseReleaseEvent()` to complete selection and cleanup
5. Add `_create_drag_rect()` helper to create styled rectangle item
6. Add `_remove_drag_rect()` helper to cleanup rectangle item
7. Update `mousePressEvent()` to handle Ctrl modifier for ADD mode
8. Add selection count label to `MainWindow` status bar
9. Connect `selection_changed` signal to status bar update method

---

## 5. Testing Requirements

### 5.1 Unit Tests

**Location**: `tests/ui/canvas/test_multi_selection.py`

```python
def test_ctrl_click_adds_to_selection(qtbot):
    """Test Ctrl+click adds without clearing previous selection"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    item1 = CellItem(object_id="cell1", ...)
    item2 = CellItem(object_id="cell2", ...)
    canvas.scene().addItem(item1)
    canvas.scene().addItem(item2)

    # Click first item
    QTest.mouseClick(canvas.viewport(), Qt.LeftButton, pos=...)

    # Ctrl+click second item
    QTest.mouseClick(canvas.viewport(), Qt.LeftButton,
                     Qt.ControlModifier, pos=...)

    assert selection_service.get_selection_count() == 2
    assert selection_service.is_selected("cell1")
    assert selection_service.is_selected("cell2")

def test_drag_rectangle_selects_enclosed_items(qtbot):
    """Test drag rectangle selects all enclosed items"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    # Create items in grid
    for i in range(5):
        item = CellItem(object_id=f"cell{i}", ...)
        item.setPos(i * 100, 0)
        canvas.scene().addItem(item)

    # Drag rectangle over first 3 items
    start_pos = QPoint(0, 0)
    end_pos = QPoint(250, 100)

    QTest.mousePress(canvas.viewport(), Qt.LeftButton, pos=start_pos)
    QTest.mouseMove(canvas.viewport(), end_pos)
    QTest.mouseRelease(canvas.viewport(), Qt.LeftButton, pos=end_pos)

    assert selection_service.get_selection_count() == 3

def test_drag_rectangle_visual_feedback(qtbot):
    """Test drag rectangle is visible during drag"""
    canvas = SchematicCanvas(SelectionService())

    start_pos = QPoint(10, 10)
    QTest.mousePress(canvas.viewport(), Qt.LeftButton, pos=start_pos)

    # Check drag rectangle item exists
    assert canvas._drag_rect_item is not None
    assert canvas._drag_rect_item in canvas.scene().items()

    # Release cleans up
    QTest.mouseRelease(canvas.viewport(), Qt.LeftButton, pos=QPoint(50, 50))
    assert canvas._drag_rect_item is None

def test_selection_count_display(qtbot):
    """Test status bar shows selection count"""
    selection_service = SelectionService()
    main_window = MainWindow(selection_service)

    assert main_window._selection_label.text() == "No selection"

    selection_service.select("cell1", SelectMode.REPLACE)
    assert main_window._selection_label.text() == "1 object selected"

    selection_service.select("cell2", SelectMode.ADD)
    assert main_window._selection_label.text() == "2 objects selected"

    selection_service.clear()
    assert main_window._selection_label.text() == "No selection"
```

### 5.2 Performance Tests

```python
def test_large_rectangle_selection_performance():
    """Test rectangle selection with 1000+ objects completes in <100ms"""
    selection_service = SelectionService()
    canvas = SchematicCanvas(selection_service)

    # Create 1000 items
    for i in range(1000):
        item = CellItem(object_id=f"cell{i}", ...)
        item.setPos(i % 50 * 20, i // 50 * 20)
        canvas.scene().addItem(item)

    # Time rectangle selection
    import time
    start = time.perf_counter()

    # Drag rectangle over all items
    # ... simulate drag operation ...

    elapsed = (time.perf_counter() - start) * 1000  # Convert to ms
    assert elapsed < 100  # Must complete in <100ms
```

---

## 6. Acceptance Criteria

- [ ] Ctrl+click adds object to selection without clearing previous
- [ ] Drag rectangle initiated on empty canvas space
- [ ] Drag rectangle visually rendered with dashed border and semi-transparent fill
- [ ] Drag rectangle updated smoothly during mouse movement
- [ ] All objects intersecting final rectangle selected on mouse release
- [ ] Ctrl+drag adds to selection, regular drag replaces
- [ ] Selection count displayed in status bar
- [ ] Status bar updates immediately on selection change
- [ ] Rectangle selection with 1000+ objects completes in <100ms
- [ ] All unit tests pass
- [ ] Drag rectangle cleaned up after mouse release

---

## 7. Dependencies

- **Upstream**:
  - E04-F01-T01 (SelectionManager - provides `SelectionService`)
  - E04-F01-T02 (Single Selection - extends mouse event handling)
  - E02 (Rendering - schematic items must exist)
- **Downstream**:
  - E04-F01-T04 (Selection Highlighting - visual feedback for multiple selections)
  - E04-F02 (Property Panel - receives multi-selection events)

---

## Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F01 split |
