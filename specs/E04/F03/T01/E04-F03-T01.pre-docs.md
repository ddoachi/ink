# E04-F03-T01: Command Pattern Implementation - Pre-Implementation Documentation

## Document Metadata
- **Task**: E04-F03-T01 - Command Pattern Implementation
- **Feature**: E04-F03 - Undo/Redo System
- **Epic**: E04 - User Interaction & Controls
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

This task establishes the foundational infrastructure for undo/redo functionality by implementing the Command Pattern in the application layer. The implementation provides an abstract `UndoableCommand` base class with execute/undo/redo lifecycle management, result types for success/failure reporting, and metadata tracking for debugging and UI display.

### 1.2 Problem Context

The Ink application requires undo/redo support for expansion and collapse operations to enable users to safely explore netlists without fear of losing their current view state. A robust command pattern infrastructure is needed to:

- Encapsulate operations as first-class objects that can be stored and replayed
- Track execution state to prevent invalid undo/redo operations
- Provide consistent error handling across all undoable operations
- Enable composition of complex multi-step operations (future)
- Support UI features like undo history display and redo stack management

Without a well-designed command infrastructure, implementing reliable undo/redo would require ad-hoc state tracking in each service, leading to bugs, inconsistencies, and maintenance challenges.

### 1.3 Goals

**Primary Goals**:
1. Define `UndoableCommand` abstract base class with clear lifecycle contract
2. Implement `CommandResult` type for Railway-Oriented Programming pattern
3. Establish state tracking (`is_executed`, `timestamp`) for command lifecycle
4. Provide optional metadata extension for debugging and UI display
5. Document command pattern best practices for downstream task implementers

**Non-Goals**:
- Concrete command implementations (handled in T02, T03)
- Undo stack management (handled in separate task)
- Command serialization for session persistence (P1 feature)
- Multi-level undo grouping/transactions (P1 feature)

---

## 2. Implementation Approach

### 2.1 High-Level Design

**Architecture Pattern**: Abstract Base Class with Template Method Pattern

The design uses Python's `abc.ABC` to define a contract that all concrete commands must implement:

```
┌─────────────────────────────────────┐
│      UndoableCommand (ABC)          │
├─────────────────────────────────────┤
│ - _executed: bool                   │
│ - _timestamp: Optional[datetime]    │
├─────────────────────────────────────┤
│ + execute() -> CommandResult        │ ← Abstract
│ + undo() -> CommandResult           │ ← Abstract
│ + redo() -> CommandResult           │ ← Default impl
│ + description() -> str              │ ← Abstract
│ + is_executed: bool                 │ ← Property
│ + timestamp: Optional[datetime]     │ ← Property
│ # _mark_executed()                  │ ← Protected helper
│ # _mark_not_executed()              │ ← Protected helper
└─────────────────────────────────────┘
           ▲
           │ extends
           │
    ┌──────┴──────┐
    │             │
┌───┴──────┐ ┌───┴──────────┐
│ Expansion│ │   Collapse   │
│ Command  │ │   Command    │
└──────────┘ └──────────────┘
```

**State Machine**:
```
┌─────────┐
│ Created │ (is_executed = False, timestamp = None)
└────┬────┘
     │
     │ execute() -> success
     ▼
┌─────────┐
│Executed │ (is_executed = True, timestamp = set)
└────┬────┘       ▲
     │            │
     │ undo()     │ redo()
     ▼            │
┌─────────┐      │
│ Undone  ├──────┘ (is_executed = False, timestamp preserved)
└─────────┘
```

### 2.2 Component Breakdown

#### Component 1: CommandResult Class

**Purpose**: Explicit success/failure modeling without exceptions

**Implementation**:
```python
@dataclass
class CommandResult:
    success: bool
    error_message: Optional[str] = None

    @staticmethod
    def ok() -> 'CommandResult':
        return CommandResult(success=True)

    @staticmethod
    def fail(message: str) -> 'CommandResult':
        return CommandResult(success=False, error_message=message)
```

**Design Rationale**:
- Follows Railway-Oriented Programming pattern
- More explicit than exceptions for expected failure cases
- Easier to log and display in UI
- Reduces exception handling boilerplate in command stack

#### Component 2: UndoableCommand Base Class

**Purpose**: Abstract contract for all undoable operations

**Key Methods**:
1. `execute()`: Performs the action, returns success/failure
2. `undo()`: Reverses the action, restores previous state
3. `redo()`: Re-applies the action (default: calls execute())
4. `description()`: Returns UI-friendly description

**Protected Helpers**:
- `_mark_executed()`: Sets `_executed = True`, `_timestamp = now()`
- `_mark_not_executed()`: Sets `_executed = False`, preserves timestamp

**Design Decisions**:
- **Why ABC instead of Protocol?** Need to provide default `redo()` implementation and enforce lifecycle state tracking
- **Why protected helpers?** Centralize state management, prevent misuse from outside command hierarchy
- **Why preserve timestamp on undo?** Enables "undo at 2:35 PM" display, useful for debugging

#### Component 3: UndoableCommandWithMetadata Extension

**Purpose**: Optional metadata tracking for advanced use cases

**Use Cases**:
- Store parameters for debugging (e.g., "hop_count=2")
- Track performance metrics (e.g., "cells_added=47, execution_time=0.123s")
- Store UI context (e.g., "triggered_by=keyboard_shortcut")

**Implementation**:
```python
class UndoableCommandWithMetadata(UndoableCommand):
    def __init__(self):
        super().__init__()
        self._metadata: Dict[str, Any] = {}

    def add_metadata(self, key: str, value: Any):
        self._metadata[key] = value
```

### 2.3 File Structure

```
src/ink/application/commands/
├── __init__.py
├── undoable_command.py          # Core infrastructure (this task)
│   ├── CommandResult
│   ├── UndoableCommand
│   └── UndoableCommandWithMetadata
├── expansion_command.py         # T02
└── collapse_command.py          # T03

tests/unit/application/commands/
├── __init__.py
└── test_undoable_command.py     # Unit tests for base class
```

### 2.4 Algorithm Details

**Execute Lifecycle**:
```python
# Concrete command implementation pattern
def execute(self) -> CommandResult:
    try:
        # 1. Validate preconditions
        if not self._validate_preconditions():
            return CommandResult.fail("Precondition failed")

        # 2. Perform action through service
        result = self._service.perform_action(self._params)

        if not result.success:
            return CommandResult.fail(result.error_message)

        # 3. Record state for undo
        self._state_snapshot = self._capture_state()

        # 4. Mark as executed
        self._mark_executed()

        return CommandResult.ok()

    except Exception as e:
        return CommandResult.fail(f"Error: {str(e)}")
```

**Undo Lifecycle**:
```python
def undo(self) -> CommandResult:
    # 1. Validate command was executed
    if not self.is_executed:
        return CommandResult.fail("Cannot undo: not executed")

    try:
        # 2. Restore state
        result = self._restore_state(self._state_snapshot)

        if not result.success:
            return CommandResult.fail(result.error_message)

        # 3. Mark as not executed
        self._mark_not_executed()

        return CommandResult.ok()

    except Exception as e:
        return CommandResult.fail(f"Undo error: {str(e)}")
```

---

## 3. Key Design Decisions

### Decision 1: CommandResult vs Exceptions

**Context**: How should commands report execution success/failure?

**Options Considered**:
1. **Raise exceptions for failures** (traditional Python approach)
   - Pros: Built-in language feature, stack traces
   - Cons: Exceptions as control flow, harder to log/display, verbose try/catch

2. **Return bool** (simple approach)
   - Pros: Minimal, easy to understand
   - Cons: No error message, poor debugging

3. **Return CommandResult dataclass** (chosen)
   - Pros: Explicit success/failure, includes error message, Railway-Oriented Programming
   - Cons: Extra class, not idiomatic Python

**Decision**: Use `CommandResult` dataclass

**Rationale**:
- UI needs to display error messages, not stack traces
- Undo stack should continue after command failure (don't bubble exception)
- Easier to test (assert on result.success vs. catching exceptions)
- Consistent with modern functional programming patterns

**Consequences**:
- Concrete commands must return `CommandResult`, not raise exceptions for expected failures
- Undo stack can handle failures gracefully without try/catch blocks
- Error messages are first-class, forcing developers to write helpful text

### Decision 2: Default redo() Implementation

**Context**: Should `redo()` be abstract or have default implementation?

**Options Considered**:
1. **Make redo() abstract** - force each command to implement
   - Pros: Explicit, allows optimization per command
   - Cons: 90% of commands will just call `execute()`, boilerplate

2. **Default to calling execute()** (chosen)
   - Pros: DRY, works for most commands
   - Cons: May re-execute expensive operations unnecessarily

**Decision**: Default `redo()` calls `execute()`, allow override

**Rationale**:
- Most commands can simply re-execute (expansion, collapse)
- Commands with cached state can override for optimization (see T02)
- Reduces implementation burden on simple commands

### Decision 3: Timestamp Preservation on Undo

**Context**: Should `_timestamp` be cleared when command is undone?

**Decision**: Preserve timestamp, only clear `_executed` flag

**Rationale**:
- Enables "Undone at 2:35 PM" display in UI
- Useful for debugging command history
- Low cost (one datetime object)

### Decision 4: Abstract Base Class vs Protocol

**Context**: How to define command interface?

**Decision**: Use `abc.ABC` instead of `typing.Protocol`

**Rationale**:
- Need to provide default `redo()` implementation (not possible with Protocol)
- Want to enforce lifecycle state tracking in base class
- Runtime checking of abstract methods is valuable
- Protocol better for duck-typing, not needed here (we control all commands)

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Internal**:
- Python standard library only: `abc`, `dataclasses`, `typing`, `datetime`
- No dependencies on domain or infrastructure layers (pure application layer)

**External**:
- None (uses only Python standard library)

### 4.2 Downstream Consumers

**Immediate (within E04-F03)**:
- **T02 - ExpansionCommand**: Extends `UndoableCommand` for expansion operations
- **T03 - CollapseCommand**: Extends `UndoableCommand` for collapse operations
- **Future - UndoStack**: Stores and manages `UndoableCommand` instances

**Other Features**:
- **E04-F04 - Keyboard Shortcuts**: Trigger undo/redo via command execution
- **UI Layer**: Display command descriptions in undo history panel (future)

### 4.3 Integration Checklist

- [ ] Export `UndoableCommand`, `CommandResult` from `src/ink/application/commands/__init__.py`
- [ ] Document command lifecycle in module docstring with state machine diagram
- [ ] Provide example concrete command in docstring
- [ ] Ensure no circular imports with services layer
- [ ] Verify no Qt dependencies (pure Python)

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Test File**: `tests/unit/application/commands/test_undoable_command.py`

**Test Scenarios**:

1. **Abstract Method Enforcement**:
   ```python
   def test_cannot_instantiate_abstract_command():
       """UndoableCommand cannot be instantiated directly"""
       with pytest.raises(TypeError):
           UndoableCommand()
   ```

2. **Lifecycle State Transitions**:
   ```python
   def test_command_lifecycle():
       """Test created -> executed -> undone -> executed cycle"""
       cmd = ConcreteTestCommand()

       # Initial state
       assert not cmd.is_executed
       assert cmd.timestamp is None

       # Execute
       result = cmd.execute()
       assert result.success
       assert cmd.is_executed
       assert cmd.timestamp is not None

       # Undo
       result = cmd.undo()
       assert result.success
       assert not cmd.is_executed
       assert cmd.timestamp is not None  # Preserved

       # Redo
       result = cmd.redo()
       assert result.success
       assert cmd.is_executed
   ```

3. **CommandResult Factories**:
   ```python
   def test_command_result_ok():
       result = CommandResult.ok()
       assert result.success
       assert result.error_message is None

   def test_command_result_fail():
       result = CommandResult.fail("Operation failed")
       assert not result.success
       assert result.error_message == "Operation failed"
   ```

4. **Metadata Tracking**:
   ```python
   def test_metadata_storage():
       cmd = ConcreteTestCommandWithMetadata()
       cmd.add_metadata("hop_count", 2)
       cmd.add_metadata("direction", "fanout")

       assert cmd.get_metadata("hop_count") == 2
       assert cmd.get_metadata("direction") == "fanout"
       assert cmd.get_metadata("missing") is None
   ```

5. **Error Handling**:
   ```python
   def test_undo_without_execute():
       """Undo fails if command not executed"""
       cmd = ConcreteTestCommand()
       result = cmd.undo()

       assert not result.success
       assert "not executed" in result.error_message.lower()
   ```

6. **Idempotency**:
   ```python
   def test_multiple_execute_calls():
       """Execute can be called multiple times (idempotent)"""
       cmd = ConcreteTestCommand()

       result1 = cmd.execute()
       assert result1.success

       result2 = cmd.execute()
       assert result2.success
       assert cmd.execute_count == 2
   ```

### 5.2 Test Fixtures

**ConcreteTestCommand** (minimal implementation for testing):
```python
class ConcreteTestCommand(UndoableCommand):
    """Minimal concrete command for testing lifecycle"""

    def __init__(self):
        super().__init__()
        self.execute_count = 0
        self.undo_count = 0
        self.redo_count = 0

    def execute(self) -> CommandResult:
        self.execute_count += 1
        self._mark_executed()
        return CommandResult.ok()

    def undo(self) -> CommandResult:
        if not self.is_executed:
            return CommandResult.fail("Not executed")
        self.undo_count += 1
        self._mark_not_executed()
        return CommandResult.ok()

    def description(self) -> str:
        return "Test command"
```

### 5.3 Coverage Target

- **Line Coverage**: 100% (base class is small, should be fully covered)
- **Branch Coverage**: 100% (test all state transitions)
- **Edge Cases**: Invalid state transitions, multiple execute/undo/redo cycles

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: State Tracking Complexity
**Impact**: Medium
**Probability**: Low

**Description**: If concrete commands forget to call `_mark_executed()` or `_mark_not_executed()`, the command lifecycle becomes corrupted.

**Mitigation**:
- Clear documentation in docstrings with examples
- Unit tests verify state tracking in sample command
- Code review checklist: "Does execute() call `_mark_executed()`?"
- Consider using decorators to auto-mark state (complexity vs. benefit trade-off)

**Contingency**:
- Add runtime validation: `assert` statements in undo/redo checking `is_executed`
- Provide base class test mixin for concrete commands to verify contract

#### Risk 2: Timestamp Timezone Issues
**Impact**: Low
**Probability**: Medium

**Description**: `datetime.now()` uses local timezone, which may cause confusion if timestamps are displayed or logged.

**Mitigation**:
- Use `datetime.now()` for simplicity in MVP (single-user, local app)
- Document that timestamps are local time
- For P1: Switch to `datetime.now(timezone.utc)` for consistency

**Contingency**: Accept local time for MVP, fix in P1 if users report issues

#### Risk 3: Command Result Error Message Inconsistency
**Impact**: Low
**Probability**: Medium

**Description**: Different concrete commands may format error messages differently, leading to inconsistent UI experience.

**Mitigation**:
- Provide error message guidelines in base class docstring
- Example: "Always start with operation name: 'Expand fanout failed: ...'"
- Code review for error message quality

**Contingency**: Centralize error message formatting in future error handling layer

### 6.2 Integration Risks

#### Risk 4: Circular Dependency with Services
**Impact**: Medium
**Probability**: Low

**Description**: If `UndoableCommand` imports service classes for type hints, may create circular dependency (services create commands, commands import services).

**Mitigation**:
- Use forward references with `TYPE_CHECKING` guard:
  ```python
  from typing import TYPE_CHECKING
  if TYPE_CHECKING:
      from ink.application.services.expansion_service import ExpansionService
  ```
- Accept service as runtime parameter, not class-level import

**Contingency**: Use string type hints if needed: `service: "ExpansionService"`

### 6.3 Usability Risks

#### Risk 5: Confusing Abstract Method Requirements
**Impact**: Low
**Probability**: Medium

**Description**: Developers implementing concrete commands may be unclear on contract requirements (e.g., must call `_mark_executed()`).

**Mitigation**:
- Extensive docstrings with "MUST" and "SHOULD" language
- Provide complete example in base class docstring
- Create test mixin that concrete commands can inherit

**Contingency**: Add developer documentation page with step-by-step guide

---

## 7. Open Questions

### Question 1: Command Composition
**Status**: Deferred to P1

Should we support macro commands (composite pattern) that execute multiple commands as one unit?

**Use Case**: Expand fanin + fanout in single undoable action

**Decision**: Not needed for MVP. Defer to P1 if users request it.

### Question 2: Command Validation
**Status**: Needs decision before T02

Should commands validate their parameters in `__init__()` or in `execute()`?

**Options**:
1. Validate in `__init__()` - fail fast, but command can't be constructed
2. Validate in `execute()` - defer validation, but command may be invalid when added to undo stack

**Recommendation**: Validate in `execute()` to allow command construction in all cases, return `CommandResult.fail()` for invalid parameters.

### Question 3: Async Command Support
**Status**: Not needed for MVP

Should commands support async execution for long-running operations?

**Decision**: No for MVP. All operations are synchronous. If needed in P1, create `AsyncUndoableCommand` subclass.

---

## 8. Definition of Done

### 8.1 Code Complete
- [ ] `CommandResult` class implemented with factory methods
- [ ] `UndoableCommand` abstract base class implemented
- [ ] `UndoableCommandWithMetadata` extension class implemented
- [ ] All abstract methods declared (`execute`, `undo`, `description`)
- [ ] Default `redo()` implementation provided
- [ ] Protected helper methods (`_mark_executed`, `_mark_not_executed`) implemented
- [ ] Properties (`is_executed`, `timestamp`) implemented

### 8.2 Testing Complete
- [ ] Unit tests written for all test scenarios (see Section 5.1)
- [ ] `ConcreteTestCommand` fixture created for lifecycle testing
- [ ] 100% line and branch coverage achieved
- [ ] All tests pass with zero failures

### 8.3 Code Quality
- [ ] Type hints on 100% of public methods
- [ ] Docstrings on all classes and public methods (Google style)
- [ ] State machine diagram in module docstring
- [ ] Example usage in class docstring
- [ ] `mypy --strict` passes with no errors
- [ ] `ruff check` passes with no warnings
- [ ] No dependencies on domain or infrastructure layers

### 8.4 Documentation
- [ ] Module docstring explains command pattern architecture
- [ ] Class docstrings document lifecycle contract
- [ ] Method docstrings specify preconditions and postconditions
- [ ] Thread-safety warning documented
- [ ] Error handling strategy documented

### 8.5 Integration Ready
- [ ] Exported from `src/ink/application/commands/__init__.py`
- [ ] No circular dependencies detected
- [ ] Integration points documented for T02 and T03
- [ ] Example concrete command provided in docstring

---

## 9. Implementation Notes

### 9.1 Code Snippets

**Module Structure** (`src/ink/application/commands/undoable_command.py`):
```python
"""
Undoable Command Pattern Infrastructure

Provides base classes for implementing the Command Pattern with undo/redo support.
All undoable operations in Ink (expansion, collapse, etc.) extend UndoableCommand.

Command Lifecycle:
┌─────────┐
│ Created │ (is_executed=False)
└────┬────┘
     │ execute() -> success
     ▼
┌─────────┐
│Executed │ (is_executed=True)
└────┬────┘       ▲
     │ undo()     │ redo()
     ▼            │
┌─────────┐      │
│ Undone  ├──────┘ (is_executed=False)
└─────────┘

Example:
    class MyCommand(UndoableCommand):
        def execute(self) -> CommandResult:
            # Perform action
            self._mark_executed()
            return CommandResult.ok()

        def undo(self) -> CommandResult:
            if not self.is_executed:
                return CommandResult.fail("Not executed")
            # Reverse action
            self._mark_not_executed()
            return CommandResult.ok()

        def description(self) -> str:
            return "My custom command"
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional, Dict, Any
from datetime import datetime

# ... implementation follows spec ...
```

### 9.2 Testing Approach

Run tests with coverage:
```bash
pytest tests/unit/application/commands/test_undoable_command.py \
  --cov=src/ink/application/commands/undoable_command \
  --cov-report=term-missing \
  --cov-branch
```

Expected output:
```
tests/unit/application/commands/test_undoable_command.py .........  [100%]

---------- coverage: platform linux, python 3.10.x -----------
Name                                              Stmts   Miss Branch BrPart  Cover
-------------------------------------------------------------------------------------
src/ink/application/commands/undoable_command.py     45      0     12      0   100%
-------------------------------------------------------------------------------------
TOTAL                                                45      0     12      0   100%
```

### 9.3 Import Structure

```python
# src/ink/application/commands/__init__.py
"""
Application layer command infrastructure.

Provides base classes and utilities for implementing undoable commands.
"""

from .undoable_command import (
    CommandResult,
    UndoableCommand,
    UndoableCommandWithMetadata,
)

__all__ = [
    'CommandResult',
    'UndoableCommand',
    'UndoableCommandWithMetadata',
]
```

---

## 10. Next Steps

### 10.1 Immediate Actions
1. Create `src/ink/application/commands/` directory
2. Implement `undoable_command.py` following spec
3. Create test file `tests/unit/application/commands/test_undoable_command.py`
4. Run tests and verify 100% coverage
5. Run type checking with `mypy --strict`

### 10.2 After Task Completion
1. Update `CHANGELOG.md` with command infrastructure addition
2. Create PR for review
3. Merge to feature branch
4. Proceed to T02 (ExpansionCommand implementation)

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
