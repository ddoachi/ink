---
id: E04-F03-T01
title: Command Pattern Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F03
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - architecture
  - application-layer
  - command-pattern
clickup_task_id: ''
---

# Spec: E04-F03-T01 - Command Pattern Implementation

## 1. Overview

### 1.1 Problem Statement
Implement the core Command Pattern infrastructure that enables undo/redo functionality for expansion and collapse operations. The implementation must provide a base class for undoable commands and support execute/undo/redo lifecycle with proper state tracking.

### 1.2 Goals
- Implement abstract `UndoableCommand` base class with execute/undo/redo interface
- Define command result types for success/failure reporting
- Establish command lifecycle contract (execute -> undo -> redo)
- Provide foundation for concrete expansion and collapse commands
- Enable command composition for complex operations

---

## 2. Technical Requirements

### 2.1 UndoableCommand Base Class

**Location**: `src/ink/application/commands/undoable_command.py`

**Class Structure**:
```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Generic, TypeVar, Optional
from datetime import datetime


@dataclass
class CommandResult:
    """Result of command execution"""
    success: bool
    error_message: Optional[str] = None

    @staticmethod
    def ok() -> 'CommandResult':
        """Create successful result"""
        return CommandResult(success=True)

    @staticmethod
    def fail(message: str) -> 'CommandResult':
        """Create failed result with error message"""
        return CommandResult(success=False, error_message=message)


class UndoableCommand(ABC):
    """
    Abstract base class for all undoable commands.

    Implements the Command Pattern for operations that can be undone and redone.
    Subclasses must implement execute(), undo(), and optionally redo().

    Lifecycle:
    1. Command created with parameters
    2. execute() called - performs action, returns result
    3. If successful, command stored in undo stack
    4. undo() called - reverses action
    5. redo() called - re-applies action

    Thread-safety: Commands are not thread-safe. Execute from single thread.
    """

    def __init__(self):
        self._executed: bool = False
        self._timestamp: Optional[datetime] = None

    @abstractmethod
    def execute(self) -> CommandResult:
        """
        Execute the command and perform the action.

        Must be idempotent if called multiple times.
        Should record state needed for undo/redo.

        Returns:
            CommandResult indicating success or failure
        """
        pass

    @abstractmethod
    def undo(self) -> CommandResult:
        """
        Undo the command, reversing its effects.

        Can only be called after successful execute().
        Should restore exact previous state.

        Returns:
            CommandResult indicating success or failure
        """
        pass

    def redo(self) -> CommandResult:
        """
        Redo the command, re-applying its effects.

        Default implementation calls execute().
        Override if redo logic differs from initial execution.

        Returns:
            CommandResult indicating success or failure
        """
        return self.execute()

    @abstractmethod
    def description(self) -> str:
        """
        Human-readable description of the command.

        Used for UI display (e.g., "Expand fanout of pin A")

        Returns:
            Command description string
        """
        pass

    @property
    def is_executed(self) -> bool:
        """Check if command has been executed"""
        return self._executed

    @property
    def timestamp(self) -> Optional[datetime]:
        """Get execution timestamp"""
        return self._timestamp

    def _mark_executed(self):
        """Mark command as executed (called by execute implementations)"""
        self._executed = True
        self._timestamp = datetime.now()

    def _mark_not_executed(self):
        """Mark command as not executed (called by undo implementations)"""
        self._executed = False
```

### 2.2 Command Metadata

Commands should track metadata for debugging and UI display:

```python
from typing import Any, Dict


class UndoableCommandWithMetadata(UndoableCommand):
    """Extended command with metadata tracking"""

    def __init__(self):
        super().__init__()
        self._metadata: Dict[str, Any] = {}

    def add_metadata(self, key: str, value: Any):
        """Add metadata key-value pair"""
        self._metadata[key] = value

    def get_metadata(self, key: str) -> Optional[Any]:
        """Get metadata value by key"""
        return self._metadata.get(key)

    @property
    def metadata(self) -> Dict[str, Any]:
        """Get all metadata"""
        return self._metadata.copy()
```

### 2.3 Command Lifecycle State Machine

```
┌─────────┐
│ Created │
└────┬────┘
     │
     │ execute() -> success
     ▼
┌─────────┐
│Executed │◄──────┐
└────┬────┘       │
     │            │ redo()
     │ undo()     │
     ▼            │
┌─────────┐      │
│ Undone  ├──────┘
└─────────┘
```

### 2.4 Error Handling Requirements

- **Execute failures**: Return `CommandResult.fail()` with clear error message
- **Undo without execute**: Raise `ValueError("Cannot undo command that was not executed")`
- **Redo without undo**: Raise `ValueError("Cannot redo command that was not undone")`
- **State corruption**: Commands must validate state before undo/redo
- **Partial execution**: If execute partially succeeds, undo must clean up

### 2.5 Testing Requirements

**Location**: `tests/unit/application/commands/test_undoable_command.py`

Test scenarios:
- Abstract method enforcement (cannot instantiate base class)
- Execute lifecycle (created -> executed state transition)
- Undo lifecycle (executed -> undone state transition)
- Redo lifecycle (undone -> executed state transition)
- Multiple redo calls (idempotency)
- Error handling for invalid state transitions
- Timestamp tracking
- Metadata storage and retrieval

---

## 3. Dependencies

### 3.1 Upstream
- Python standard library: `abc`, `dataclasses`, `typing`, `datetime`
- No domain or infrastructure dependencies (pure application layer)

### 3.2 Downstream
- Task E04-F03-T02: `ExpansionCommand` extends `UndoableCommand`
- Task E04-F03-T03: `CollapseCommand` extends `UndoableCommand`
- Task E04-F03-T04: `UndoStack` operates on `UndoableCommand` instances

### 3.3 External Dependencies
- None (uses only Python standard library)

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `UndoableCommand` defined as abstract base class
- [ ] `execute()`, `undo()`, `description()` declared as abstract methods
- [ ] `redo()` has default implementation calling `execute()`
- [ ] `CommandResult` class with success/failure factory methods
- [ ] `is_executed` property tracks execution state
- [ ] `timestamp` property records execution time
- [ ] Cannot instantiate `UndoableCommand` directly (abstract)

### 4.2 Design Requirements
- [ ] Clear documentation of command lifecycle
- [ ] Type hints on all method signatures
- [ ] Docstrings explaining contract for each abstract method
- [ ] State machine diagram in module docstring
- [ ] Thread-safety warning in class documentation

### 4.3 Testing
- [ ] Unit tests verify abstract methods cannot be instantiated
- [ ] Concrete test command implementation for testing lifecycle
- [ ] Test state transitions (created -> executed -> undone -> executed)
- [ ] Test timestamp is set on execution
- [ ] Test `CommandResult.ok()` and `CommandResult.fail()` factories
- [ ] Test metadata storage in extended class
- [ ] 100% code coverage on command base classes

### 4.4 Code Quality
- [ ] Passes `mypy` type checking with no errors
- [ ] Follows PEP 8 style guidelines
- [ ] No circular dependencies with domain or infrastructure layers
- [ ] Clear separation between command interface and implementation

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why abstract base class instead of Protocol?**
- Need to provide default `redo()` implementation
- Want to enforce lifecycle state tracking in base class
- ABC provides better runtime checking for abstract methods
- Protocol better for duck-typing, not needed here

**Why `CommandResult` instead of exceptions?**
- Explicit success/failure modeling
- Allows returning error messages without exception overhead
- Easier to log and display in UI
- Follows Railway-Oriented Programming pattern

**Why track `is_executed` state?**
- Enables validation before undo/redo
- Helps detect programming errors early
- Supports debugging and logging
- Required for proper undo stack management

**Why `_mark_executed()` as protected method?**
- Concrete commands need to call it after successful execution
- Protected access prevents misuse from outside command hierarchy
- Centralizes state management logic

### 5.2 Alternative Approaches Considered

**Qt's QUndoCommand**:
- Pros: Battle-tested, integrated with Qt framework
- Cons: Couples to Qt (violates Clean Architecture), not Pythonic
- Decision: Implement our own for better control and testability

**Function-based commands**:
- Pros: Simpler, more Pythonic
- Cons: Harder to track state, less type-safe
- Decision: Use classes for better encapsulation and type safety

### 5.3 Testing Strategy

**Unit Tests**:
```python
class ConcreteTestCommand(UndoableCommand):
    """Minimal concrete command for testing"""
    def __init__(self):
        super().__init__()
        self.execute_count = 0
        self.undo_count = 0

    def execute(self) -> CommandResult:
        self.execute_count += 1
        self._mark_executed()
        return CommandResult.ok()

    def undo(self) -> CommandResult:
        if not self.is_executed:
            return CommandResult.fail("Not executed")
        self.undo_count += 1
        self._mark_not_executed()
        return CommandResult.ok()

    def description(self) -> str:
        return "Test command"


def test_command_lifecycle():
    cmd = ConcreteTestCommand()

    # Initial state
    assert not cmd.is_executed
    assert cmd.timestamp is None

    # Execute
    result = cmd.execute()
    assert result.success
    assert cmd.is_executed
    assert cmd.timestamp is not None
    assert cmd.execute_count == 1

    # Undo
    result = cmd.undo()
    assert result.success
    assert not cmd.is_executed
    assert cmd.undo_count == 1

    # Redo
    result = cmd.redo()
    assert result.success
    assert cmd.is_executed
    assert cmd.execute_count == 2
```

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F03 split |
