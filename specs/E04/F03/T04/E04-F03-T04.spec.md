# Spec: E04-F03-T04 - Undo/Redo Stack Management

## Metadata
- **ID**: E04-F03-T04
- **Type**: Task
- **Priority**: P0 (MVP)
- **Status**: Draft
- **Parent**: [E04-F03](../E04-F03.spec.md)
- **Created**: 2025-12-26
- **Estimated Hours**: 8
- **Actual Hours**:
- **Effort**: Medium-High
- **Tags**: [application-layer, undo-redo, state-management]

---

## 1. Overview

### 1.1 Problem Statement
Implement the undo/redo stack manager that maintains history of executed commands, handles undo/redo operations with proper stack management, integrates with keyboard shortcuts (Ctrl+Z, Ctrl+Shift+Z), and provides UI state updates (enabled/disabled menu items). The stack must be memory-efficient, performant, and maintain consistency across command execution.

### 1.2 Goals
- Implement `UndoStack` class managing undo and redo command stacks
- Support configurable maximum stack depth (default 50, max 200)
- Integrate with keyboard shortcuts (Ctrl+Z, Ctrl+Shift+Z)
- Provide signals for UI updates (can_undo, can_redo state changes)
- Maintain stack consistency when new commands clear redo history
- Support status bar feedback ("Undone: ...", "Redone: ...")
- Enable stack clearing and state inspection

---

## 2. Technical Requirements

### 2.1 UndoStack Implementation

**Location**: `src/ink/application/services/undo_stack.py`

**Class Structure**:
```python
from typing import List, Optional, Callable
from ink.application.commands.undoable_command import UndoableCommand, CommandResult
import logging


class UndoStack:
    """
    Manages undo/redo history for undoable commands.

    Maintains two stacks:
    - Undo stack: Commands that have been executed and can be undone
    - Redo stack: Commands that have been undone and can be redone

    When a new command is pushed:
    1. Command is executed
    2. If successful, added to undo stack
    3. Redo stack is cleared (can't redo after new action)
    4. If undo stack exceeds max depth, oldest command is removed

    Example:
        stack = UndoStack(max_depth=50)

        # Push command (executes and adds to undo stack)
        stack.push(expansion_command)

        # Undo last action
        stack.undo()  # Returns True if successful

        # Redo last undone action
        stack.redo()  # Returns True if successful

        # Check if undo/redo available
        if stack.can_undo:
            print(f"Can undo: {stack.undo_description}")
    """

    def __init__(self, max_depth: int = 50):
        """
        Initialize undo stack.

        Args:
            max_depth: Maximum number of commands to keep in undo history
                      (default: 50, max: 200)
        """
        if max_depth < 1:
            raise ValueError("max_depth must be at least 1")
        if max_depth > 200:
            raise ValueError("max_depth cannot exceed 200")

        self._max_depth = max_depth
        self._undo_stack: List[UndoableCommand] = []
        self._redo_stack: List[UndoableCommand] = []
        self._logger = logging.getLogger(__name__)

        # Callbacks for UI updates
        self._on_state_changed: List[Callable[[], None]] = []

    def push(self, command: UndoableCommand) -> bool:
        """
        Execute command and push to undo stack if successful.

        Clears redo stack when new command is executed.
        Removes oldest command if stack exceeds max depth.

        Args:
            command: Command to execute and add to stack

        Returns:
            True if command executed successfully and was pushed
        """
        # Execute command
        result = command.execute()

        if not result.success:
            self._logger.warning(
                f"Command execution failed: {result.error_message}"
            )
            return False

        # Add to undo stack
        self._undo_stack.append(command)

        # Clear redo stack (can't redo after new action)
        if self._redo_stack:
            self._logger.debug(f"Clearing {len(self._redo_stack)} commands from redo stack")
        self._redo_stack.clear()

        # Enforce max depth
        if len(self._undo_stack) > self._max_depth:
            removed = self._undo_stack.pop(0)
            self._logger.debug(
                f"Removed oldest command from stack: {removed.description()}"
            )

        self._logger.info(f"Executed: {command.description()}")
        self._notify_state_changed()
        return True

    def undo(self) -> bool:
        """
        Undo the last command.

        Pops command from undo stack, calls its undo() method,
        and pushes to redo stack if successful.

        Returns:
            True if undo was successful, False if undo stack is empty or undo failed
        """
        if not self._undo_stack:
            self._logger.debug("Cannot undo: undo stack is empty")
            return False

        command = self._undo_stack.pop()
        result = command.undo()

        if not result.success:
            self._logger.error(
                f"Undo failed for '{command.description()}': {result.error_message}"
            )
            # Put command back on undo stack
            self._undo_stack.append(command)
            return False

        # Move to redo stack
        self._redo_stack.append(command)
        self._logger.info(f"Undone: {command.description()}")
        self._notify_state_changed()
        return True

    def redo(self) -> bool:
        """
        Redo the last undone command.

        Pops command from redo stack, calls its redo() method,
        and pushes to undo stack if successful.

        Returns:
            True if redo was successful, False if redo stack is empty or redo failed
        """
        if not self._redo_stack:
            self._logger.debug("Cannot redo: redo stack is empty")
            return False

        command = self._redo_stack.pop()
        result = command.redo()

        if not result.success:
            self._logger.error(
                f"Redo failed for '{command.description()}': {result.error_message}"
            )
            # Put command back on redo stack
            self._redo_stack.append(command)
            return False

        # Move to undo stack
        self._undo_stack.append(command)
        self._logger.info(f"Redone: {command.description()}")
        self._notify_state_changed()
        return True

    def clear(self):
        """
        Clear both undo and redo stacks.

        Used when loading a new design or resetting application state.
        """
        self._undo_stack.clear()
        self._redo_stack.clear()
        self._logger.info("Cleared undo/redo history")
        self._notify_state_changed()

    @property
    def can_undo(self) -> bool:
        """Check if undo is available"""
        return len(self._undo_stack) > 0

    @property
    def can_redo(self) -> bool:
        """Check if redo is available"""
        return len(self._redo_stack) > 0

    @property
    def undo_description(self) -> Optional[str]:
        """
        Get description of command that would be undone.

        Returns:
            Description string or None if no undo available
        """
        if self._undo_stack:
            return self._undo_stack[-1].description()
        return None

    @property
    def redo_description(self) -> Optional[str]:
        """
        Get description of command that would be redone.

        Returns:
            Description string or None if no redo available
        """
        if self._redo_stack:
            return self._redo_stack[-1].description()
        return None

    @property
    def undo_count(self) -> int:
        """Get number of commands in undo stack"""
        return len(self._undo_stack)

    @property
    def redo_count(self) -> int:
        """Get number of commands in redo stack"""
        return len(self._redo_stack)

    @property
    def max_depth(self) -> int:
        """Get maximum stack depth"""
        return self._max_depth

    def on_state_changed(self, callback: Callable[[], None]):
        """
        Register callback for state change notifications.

        Callback is invoked whenever can_undo or can_redo state changes
        (after push, undo, redo, or clear).

        Args:
            callback: Function to call on state change (no parameters)
        """
        self._on_state_changed.append(callback)

    def _notify_state_changed(self):
        """Notify all registered callbacks of state change"""
        for callback in self._on_state_changed:
            try:
                callback()
            except Exception as e:
                self._logger.error(f"Error in state change callback: {e}")

    def get_undo_history(self, limit: int = 10) -> List[str]:
        """
        Get descriptions of recent undo commands.

        Args:
            limit: Maximum number of commands to return

        Returns:
            List of command descriptions (most recent first)
        """
        return [cmd.description() for cmd in reversed(self._undo_stack[-limit:])]

    def get_redo_history(self, limit: int = 10) -> List[str]:
        """
        Get descriptions of redo commands.

        Args:
            limit: Maximum number of commands to return

        Returns:
            List of command descriptions (most recent first)
        """
        return [cmd.description() for cmd in reversed(self._redo_stack[-limit:])]
```

### 2.2 UI Integration

**Location**: `src/ink/presentation/main_window.py` (additions)

```python
from PySide6.QtGui import QAction, QKeySequence
from PySide6.QtWidgets import QMainWindow
from ink.application.services.undo_stack import UndoStack


class MainWindow(QMainWindow):
    """Main application window"""

    def __init__(self, undo_stack: UndoStack):
        super().__init__()
        self._undo_stack = undo_stack

        # Setup actions
        self._setup_undo_redo_actions()

        # Connect to stack state changes
        self._undo_stack.on_state_changed(self._update_undo_redo_actions)

        # Initial update
        self._update_undo_redo_actions()

    def _setup_undo_redo_actions(self):
        """Setup undo/redo menu actions and shortcuts"""
        # Undo action
        self._undo_action = QAction("Undo", self)
        self._undo_action.setShortcut(QKeySequence.Undo)  # Ctrl+Z
        self._undo_action.triggered.connect(self._on_undo)
        self.addAction(self._undo_action)

        # Redo action
        self._redo_action = QAction("Redo", self)
        self._redo_action.setShortcut(QKeySequence.Redo)  # Ctrl+Shift+Z or Ctrl+Y
        self._redo_action.triggered.connect(self._on_redo)
        self.addAction(self._redo_action)

        # Add to Edit menu
        edit_menu = self.menuBar().addMenu("Edit")
        edit_menu.addAction(self._undo_action)
        edit_menu.addAction(self._redo_action)

    def _update_undo_redo_actions(self):
        """Update enabled state and text of undo/redo actions"""
        # Undo action
        if self._undo_stack.can_undo:
            self._undo_action.setEnabled(True)
            desc = self._undo_stack.undo_description
            self._undo_action.setText(f"Undo {desc}")
            self._undo_action.setToolTip(f"Undo: {desc}")
        else:
            self._undo_action.setEnabled(False)
            self._undo_action.setText("Undo")
            self._undo_action.setToolTip("Nothing to undo")

        # Redo action
        if self._undo_stack.can_redo:
            self._redo_action.setEnabled(True)
            desc = self._undo_stack.redo_description
            self._redo_action.setText(f"Redo {desc}")
            self._redo_action.setToolTip(f"Redo: {desc}")
        else:
            self._redo_action.setEnabled(False)
            self._redo_action.setText("Redo")
            self._redo_action.setToolTip("Nothing to redo")

    def _on_undo(self):
        """Handle undo action"""
        if self._undo_stack.undo():
            desc = self._undo_stack.redo_description or "action"
            self.statusBar().showMessage(f"Undone: {desc}", 2000)

    def _on_redo(self):
        """Handle redo action"""
        if self._undo_stack.redo():
            desc = self._undo_stack.undo_description or "action"
            self.statusBar().showMessage(f"Redone: {desc}", 2000)
```

### 2.3 Application Service Integration

**Location**: `src/ink/application/services/schematic_application_service.py`

```python
from ink.application.services.undo_stack import UndoStack
from ink.application.commands.expansion_command import ExpansionCommand
from ink.application.commands.collapse_command import CollapseCommand


class SchematicApplicationService:
    """Main application service coordinating expansion, collapse, and undo/redo"""

    def __init__(self, expansion_service, undo_stack: UndoStack):
        self._expansion_service = expansion_service
        self._undo_stack = undo_stack

    def expand_with_undo(
        self,
        target: Union[CellId, PinId, NetId],
        params: ExpansionParams
    ) -> bool:
        """
        Perform expansion and add to undo stack.

        Args:
            target: Expansion target
            params: Expansion parameters

        Returns:
            True if expansion succeeded
        """
        command = ExpansionCommand(
            self._expansion_service,
            target,
            params
        )
        return self._undo_stack.push(command)

    def collapse_with_undo(
        self,
        target: Union[CellId, Set[CellId]],
        params: CollapseParams = None
    ) -> bool:
        """
        Perform collapse and add to undo stack.

        Args:
            target: Collapse target
            params: Collapse parameters

        Returns:
            True if collapse succeeded
        """
        command = CollapseCommand(
            self._expansion_service,
            target,
            params or CollapseParams()
        )
        return self._undo_stack.push(command)

    def undo(self) -> bool:
        """Undo last action"""
        return self._undo_stack.undo()

    def redo(self) -> bool:
        """Redo last undone action"""
        return self._undo_stack.redo()

    @property
    def undo_stack(self) -> UndoStack:
        """Get undo stack for UI integration"""
        return self._undo_stack
```

### 2.4 Performance Requirements

- **Push operation**: < 5ms overhead (on top of command execution)
- **Undo operation**: < 100ms (dominated by command.undo())
- **Redo operation**: < 150ms (dominated by command.redo())
- **State change notification**: < 1ms (callback invocation)
- **Memory per stack entry**: < 5KB (just command object reference)
- **Total stack memory**: < 250KB for 50 commands

### 2.5 Thread Safety

**Not thread-safe**: `UndoStack` is designed for single-threaded UI applications. All operations must be called from the main/UI thread.

If multi-threading is needed in the future:
- Add mutex/lock around stack operations
- Use thread-safe notification mechanism
- Document thread-safety guarantees

---

## 3. Dependencies

### 3.1 Upstream
- Task E04-F03-T01: Uses `UndoableCommand` base class
- Task E04-F03-T02: Pushes `ExpansionCommand` instances
- Task E04-F03-T03: Pushes `CollapseCommand` instances

### 3.2 Downstream
- E04-F04: Keyboard shortcuts trigger undo/redo via this stack
- Presentation layer: UI actions call push/undo/redo methods

### 3.3 External Dependencies
- PySide6: For Qt keyboard shortcuts and UI integration
- Python standard library: `typing`, `logging`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `UndoStack` successfully manages undo and redo stacks
- [ ] `push()` executes command and adds to undo stack if successful
- [ ] `push()` clears redo stack when new command is pushed
- [ ] `undo()` moves command from undo to redo stack
- [ ] `redo()` moves command from redo to undo stack
- [ ] Maximum depth enforced (removes oldest when exceeded)
- [ ] `clear()` removes all commands from both stacks
- [ ] `can_undo` and `can_redo` properties accurate

### 4.2 UI Integration
- [ ] Ctrl+Z triggers undo
- [ ] Ctrl+Shift+Z (or Ctrl+Y) triggers redo
- [ ] Menu items show enabled/disabled state correctly
- [ ] Menu items show command descriptions ("Undo Expand fanout...")
- [ ] Status bar shows feedback after undo/redo
- [ ] UI updates immediately when stack state changes

### 4.3 State Management
- [ ] State change callbacks invoked after push/undo/redo/clear
- [ ] Multiple callbacks can be registered
- [ ] Callback errors don't crash stack operations
- [ ] History inspection methods return correct data

### 4.4 Error Handling
- [ ] Failed command execution doesn't add to undo stack
- [ ] Failed undo returns command to undo stack
- [ ] Failed redo returns command to redo stack
- [ ] Clear error messages logged for failures
- [ ] `max_depth` validation on construction

### 4.5 Performance
- [ ] Push overhead < 5ms
- [ ] Undo completes in < 100ms
- [ ] Redo completes in < 150ms
- [ ] State notification < 1ms
- [ ] Memory usage < 250KB for 50 commands

### 4.6 Testing
- [ ] Unit tests for push/undo/redo sequences
- [ ] Test max depth enforcement
- [ ] Test redo stack clearing on new push
- [ ] Test state change notifications
- [ ] Test error handling for failed commands
- [ ] Test history inspection methods
- [ ] Integration test with real commands
- [ ] UI integration test with keyboard shortcuts
- [ ] 95%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate undo and redo stacks?**
- Clear separation of concerns
- Standard pattern used in most applications
- Easy to understand and debug
- Efficient push/pop operations

**Why clear redo stack on new command?**
- Standard undo/redo UX behavior
- Users expect new action to invalidate redo history
- Prevents confusing state where redo applies to old branch
- Matches Qt's QUndoStack and other frameworks

**Why limit max depth to 200?**
- Memory efficiency (200 commands â‰ˆ 1MB max)
- Most users don't need more than 50 operations
- Prevents unbounded memory growth
- Configurable for power users

**Why use callbacks instead of Qt signals?**
- Application layer should not depend on Qt (Clean Architecture)
- Simple callback pattern sufficient for this use case
- Presentation layer can adapt to Qt signals
- Easier to test without Qt dependencies

**Why not use Qt's QUndoStack?**
- Violates Clean Architecture (couples application to Qt)
- Our commands already implement their own pattern
- More control over behavior and testing
- Can still integrate with Qt at presentation layer

### 5.2 Alternative Approaches Considered

**Single combined stack with direction flag**:
- Considered: One stack with "position" pointer
- Decision: Separate stacks
- Rationale: Two stacks simpler to understand and implement

**Unlimited undo history**:
- Considered: No max depth limit
- Decision: Configurable limit (default 50, max 200)
- Rationale: Prevents unbounded memory growth, users rarely need more

**Persistent undo history**:
- Considered: Save undo stack to disk for session restore
- Decision: In-memory only for MVP
- Rationale: Simpler, defer persistence to P1 session save/load

**Composite commands (macro recording)**:
- Considered: Group multiple commands into single undo action
- Decision: Not for MVP, can add later
- Rationale: YAGNI - simple stack sufficient for MVP

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/application/services/test_undo_stack.py`):
```python
def test_push_execute_and_adds_to_undo_stack():
    """Test push executes command and adds to undo stack"""
    stack = UndoStack(max_depth=10)
    cmd = Mock(spec=UndoableCommand)
    cmd.execute.return_value = CommandResult.ok()
    cmd.description.return_value = "Test command"

    result = stack.push(cmd)

    assert result is True
    assert stack.can_undo is True
    assert stack.undo_count == 1
    cmd.execute.assert_called_once()


def test_push_clears_redo_stack():
    """Test push clears redo stack"""
    stack = UndoStack(max_depth=10)
    cmd1 = create_test_command("Command 1")
    cmd2 = create_test_command("Command 2")

    # Push, undo, then push new command
    stack.push(cmd1)
    stack.undo()
    assert stack.can_redo is True

    stack.push(cmd2)
    assert stack.can_redo is False
    assert stack.redo_count == 0


def test_max_depth_enforcement():
    """Test old commands removed when max depth exceeded"""
    stack = UndoStack(max_depth=3)

    for i in range(5):
        cmd = create_test_command(f"Command {i}")
        stack.push(cmd)

    assert stack.undo_count == 3
    # Should have commands 2, 3, 4 (0 and 1 removed)
    assert stack.undo_description == "Command 4"


def test_undo_redo_cycle():
    """Test complete undo/redo cycle"""
    stack = UndoStack()
    cmd = create_test_command("Test")

    # Push
    stack.push(cmd)
    assert stack.can_undo is True
    assert stack.can_redo is False

    # Undo
    stack.undo()
    assert stack.can_undo is False
    assert stack.can_redo is True

    # Redo
    stack.redo()
    assert stack.can_undo is True
    assert stack.can_redo is False


def test_state_change_notification():
    """Test callbacks invoked on state change"""
    stack = UndoStack()
    callback_count = 0

    def callback():
        nonlocal callback_count
        callback_count += 1

    stack.on_state_changed(callback)

    # Should trigger callback
    stack.push(create_test_command("Test"))
    assert callback_count == 1

    stack.undo()
    assert callback_count == 2

    stack.clear()
    assert callback_count == 3
```

**Integration Tests** (`tests/integration/application/test_undo_stack_integration.py`):
- Test with real `ExpansionCommand` and `CollapseCommand`
- Test keyboard shortcut integration
- Test UI updates (enabled/disabled state)
- Test status bar messages
- Performance test with 50 commands

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F03 split |
