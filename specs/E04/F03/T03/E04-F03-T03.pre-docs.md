# E04-F03-T03: Collapse Command Implementation - Pre-Implementation Documentation

## Document Metadata
- **Task**: E04-F03-T03 - Collapse Command Implementation
- **Feature**: E04-F03 - Undo/Redo System
- **Epic**: E04 - User Interaction & Controls
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

This task implements a concrete undoable command for collapse operations that safely removes cells and their dependent nets from the visible schematic while recording what was removed to enable precise undo (restore) and efficient redo (re-collapse). The command validates collapse safety to prevent orphaning connected cells and maintains state consistency across execute/undo/redo cycles.

### 1.2 Problem Context

When users collapse schematic views (e.g., Delete key to hide selected cells), the application needs to:

1. **Validate safety**: Ensure collapse won't orphan other visible cells (leave them disconnected)
2. **Track what changed**: Record exactly which cells and nets were removed
3. **Enable undo**: Restore cells with their exact layout positions
4. **Optimize redo**: Efficiently re-hide cells without recomputing dependencies
5. **Handle multi-cell selection**: Support collapsing multiple cells simultaneously
6. **Manage dependencies**: Optionally remove cells that become disconnected

Without careful collapse handling, users could accidentally break schematic connectivity, making the view confusing or unusable. Undo must restore the exact visual state, not just add cells back in random positions.

### 1.3 Goals

**Primary Goals**:
1. Implement `CollapseCommand` extending `UndoableCommand` base class
2. Record cells and nets removed during collapse for precise undo
3. Validate collapse safety before execution (prevent orphaned cells)
4. Cache layout state before collapse for exact undo restoration
5. Support both single-cell and multi-cell collapse
6. Enable efficient redo without recomputing dependencies
7. Generate human-readable descriptions for UI display

**Non-Goals**:
- Implementing the collapse algorithm itself (handled by `ExpansionService` in E03)
- Layout computation (handled by layout engine in E02)
- Undo stack management (separate task)
- Advanced dependency analysis (complex transitive closure - P1)

---

## 2. Implementation Approach

### 2.1 High-Level Design

**Architecture Pattern**: Command Pattern with Safety Validation

```
┌──────────────────────────────────────────────────────────┐
│              CollapseCommand                             │
├──────────────────────────────────────────────────────────┤
│ Fields:                                                  │
│ - _service: ExpansionService                            │
│ - _target: Set[CellId]                                  │
│ - _params: CollapseParams (safety, dependencies)        │
│ - _cells_removed: Set[CellId]    # State cache          │
│ - _nets_removed: Set[NetId]      # State cache          │
│ - _layout_state: Optional[dict]  # Position cache       │
├──────────────────────────────────────────────────────────┤
│ Methods:                                                 │
│ + execute() -> CommandResult                            │
│   ├─> Validate safety (optional)                       │
│   ├─> Capture layout state (before collapse)           │
│   └─> service.collapse(target, remove_deps)            │
│ + undo() -> CommandResult                               │
│   └─> service.expand_specific(cells, nets, layout)    │
│ + redo() -> CommandResult                               │
│   └─> service.collapse_specific(cells, nets)          │
│ + description() -> str                                  │
└──────────────────────────────────────────────────────────┘
          │
          │ uses
          ▼
┌──────────────────────────────────────────────────────────┐
│           ExpansionService                               │
├──────────────────────────────────────────────────────────┤
│ + collapse(cells, remove_deps) -> CollapseResult        │
│ + validate_collapse_safety(cells) -> CommandResult      │
│ + capture_layout_state_for_cells(cells) -> dict         │
│ + collapse_specific(cells, nets) -> CommandResult       │
│ + expand_specific(cells, nets, layout) -> CommandResult │
└──────────────────────────────────────────────────────────┘
```

**Execution Flow**:
```
User Selects Cells + Presses Delete
        │
        ▼
Create CollapseCommand(target={C1, C2, C3}, params={validate_safety=True})
        │
        ▼
Execute Command
        ├─> Validate safety (optional)
        │   └─> Check for orphaned connections
        ├─> Capture layout state BEFORE collapse
        │   └─> Store positions of cells to be removed
        ├─> Service.collapse(target, remove_dependencies)
        │   └─> Returns cells_removed, nets_removed
        ├─> Store cells_removed, nets_removed
        └─> Mark as executed

Undo Command (Restore)
        ├─> Service.expand_specific(cells_removed, nets_removed, layout_state)
        │   └─> Restore elements with original positions
        └─> Mark as not executed

Redo Command (Re-collapse)
        ├─> Service.collapse_specific(cells_removed, nets_removed)
        │   └─> Remove same elements again
        └─> Mark as executed
```

**Key Difference from ExpansionCommand**:
- **ExpansionCommand**: Captures layout AFTER expansion (for redo)
- **CollapseCommand**: Captures layout BEFORE collapse (for undo)

### 2.2 Component Breakdown

#### Component 1: CollapseParams Dataclass

**Purpose**: Encapsulate collapse parameters for type safety

```python
@dataclass
class CollapseParams:
    remove_dependencies: bool = True   # Remove cells that depend on collapsed cells
    validate_safety: bool = True       # Check for orphaned connections
```

**Parameter Semantics**:
- `remove_dependencies=True`: Clean collapse - remove everything that becomes disconnected
- `remove_dependencies=False`: Precise collapse - remove only target cells (may leave orphans if `validate_safety=False`)
- `validate_safety=True`: Reject collapse if it would orphan visible cells
- `validate_safety=False`: Allow unsafe collapse (for advanced users)

#### Component 2: CollapseResult Dataclass

**Purpose**: Return type from `ExpansionService.collapse()`

```python
@dataclass
class CollapseResult:
    success: bool
    cells_removed: Set[CellId]
    nets_removed: Set[NetId]
    error_message: Optional[str] = None
```

**Design Note**: Mirrors `ExpansionResult` for consistency

#### Component 3: CollapseCommand Class

**Constructor Normalization**:
```python
def __init__(
    self,
    expansion_service: ExpansionService,
    target: Union[CellId, Set[CellId]],
    params: CollapseParams = None
):
    # Normalize single CellId to set
    if isinstance(target, CellId):
        self._target = {target}
    else:
        self._target = target

    self._params = params or CollapseParams()
```

**Key State Variables**:
1. `_cells_removed`: Set of cell IDs removed during execute (immutable after first execute)
2. `_nets_removed`: Set of net IDs removed during execute (immutable after first execute)
3. `_layout_state`: Dictionary of positions captured BEFORE collapse (for undo restoration)

**State Invariants**:
- After `execute()`: `_cells_removed` and `_nets_removed` populated, all elements hidden
- After `undo()`: All elements in `_cells_removed` and `_nets_removed` visible with original layout
- After `redo()`: Same state as after `execute()` (elements hidden)
- Sets never change after first `execute()`
- Layout state captured before collapse remains valid for undo

**Method Implementation Strategy**:

**execute()**:
```python
def execute(self) -> CommandResult:
    # 1. Validate safety if requested
    if self._params.validate_safety:
        validation = self._service.validate_collapse_safety(self._target)
        if not validation.success:
            return CommandResult.fail(validation.error_message)

    # 2. Capture layout state BEFORE collapse (for undo)
    self._layout_state = self._service.capture_layout_state_for_cells(
        self._target
    )

    # 3. Perform collapse
    result = self._service.collapse(
        self._target,
        remove_dependencies=self._params.remove_dependencies
    )

    if not result.success:
        return CommandResult.fail(result.error_message)

    # 4. Record what was removed
    self._cells_removed = result.cells_removed
    self._nets_removed = result.nets_removed

    # 5. Mark as executed
    self._mark_executed()
    return CommandResult.ok()
```

**undo()**:
```python
def undo(self) -> CommandResult:
    if not self.is_executed:
        return CommandResult.fail("Cannot undo: not executed")

    # Restore cells/nets with original layout
    result = self._service.expand_specific(
        self._cells_removed,
        self._nets_removed,
        layout_state=self._layout_state
    )

    if not result.success:
        return CommandResult.fail(result.error_message)

    self._mark_not_executed()
    return CommandResult.ok()
```

**redo()**:
```python
def redo(self) -> CommandResult:
    if not self._cells_removed or len(self._cells_removed) == 0:
        # No cached state - fall back to execute
        return self.execute()

    # Remove the same cells/nets again
    result = self._service.collapse_specific(
        self._cells_removed,
        self._nets_removed
    )

    if not result.success:
        # Fallback to full execute
        return self.execute()

    self._mark_executed()
    return CommandResult.ok()
```

**description()**:
```python
def description(self) -> str:
    count = len(self._target)
    if count == 1:
        cell_id = next(iter(self._target))
        return f"Collapse cell {cell_id}"
    else:
        return f"Collapse {count} cells"
```

### 2.3 Collapse Safety Validation

**Safety Rules**:

1. **No Orphaned Connections**:
   - After removing target cells, no net should have only one connected pin
   - If a net connects two visible cells through a target cell, removing the target would orphan the connection

2. **Preserve Visible Connectivity**:
   - Don't remove cells if removal disconnects two other visible cells
   - Exception: if `remove_dependencies=True`, can remove the disconnected cells too

3. **Respect Dependencies**:
   - If `remove_dependencies=False`, only validate target cells
   - If `remove_dependencies=True`, validate target + transitive dependencies

**Validation Algorithm** (implemented in `ExpansionService.validate_collapse_safety()`):

```python
def validate_collapse_safety(cells: Set[CellId]) -> CommandResult:
    """
    Check if collapsing cells is safe (won't orphan visible cells).

    Algorithm:
    1. For each cell in target:
       a. Get all nets connected to cell
       b. For each net:
          - Get all visible pins on net (excluding target cells)
          - If removing cell leaves net with 1 pin AND that pin connects
            to another visible cell:
            * Unsafe - would orphan connection
       c. If any net would be orphaned:
          * Return failure with explanation

    2. Return success if all checks pass
    """
    for cell in cells:
        nets = get_nets_connected_to_cell(cell)

        for net in nets:
            visible_pins = get_visible_pins_on_net(net, excluding=cells)

            if len(visible_pins) == 1:
                # Net would have only one connection after collapse
                other_cell = visible_pins[0].cell
                if other_cell.is_visible() and other_cell not in cells:
                    return CommandResult.fail(
                        f"Collapse would orphan cell {other_cell.id} "
                        f"(net {net.name} would have only one connection)"
                    )

    return CommandResult.ok()
```

**Edge Cases**:
- **All pins on net are being removed**: Safe (entire net disappears)
- **Net has 2+ remaining pins**: Safe (connectivity preserved)
- **Net has 0 remaining pins**: Safe (net disappears)
- **Net has 1 remaining pin**: Unsafe IF that pin connects to visible cell

### 2.4 Layout State Capture (Before Collapse)

**Why Capture Before Collapse?**
- Undo needs to restore cells to their original positions
- After collapse, cells are hidden - can't capture layout from invisible elements
- Must capture before elements disappear

**Cache Format** (same as `ExpansionCommand`):
```python
{
    'cells': {
        'C1': {'x': 100, 'y': 200, 'width': 50, 'height': 30},
        'C2': {'x': 200, 'y': 200, 'width': 50, 'height': 30},
    },
    'nets': {
        'N1': {
            'route': [
                {'type': 'segment', 'start': (150, 215), 'end': (200, 215)},
            ]
        }
    }
}
```

**Implementation in `ExpansionService`**:
```python
def capture_layout_state_for_cells(self, cells: Set[CellId]) -> dict:
    """
    Capture layout state for cells and their connected nets.

    Args:
        cells: Cell IDs to capture state for

    Returns:
        Dictionary with positions and routing for cells/nets
    """
    # Get all nets connected to target cells
    nets = set()
    for cell_id in cells:
        cell = self._graph.get_cell(cell_id)
        for pin in cell.pins:
            if pin.net:
                nets.add(pin.net.id)

    # Capture state
    return self.capture_layout_state(cells, nets)
```

---

## 3. Key Design Decisions

### Decision 1: Capture Layout Before vs After Collapse

**Context**: When should layout state be captured?

**Options**:
1. **Before collapse** (chosen for undo)
2. **After collapse** (for redo, like ExpansionCommand)

**Decision**: Capture before collapse in `_layout_state`

**Rationale**:
- Undo needs to restore original positions
- After collapse, cells are hidden - can't capture from invisible elements
- Redo doesn't need layout (just hides elements again)

### Decision 2: Safety Validation Default

**Context**: Should collapse validate safety by default?

**Options**:
1. **Default to safe** (`validate_safety=True`) - chosen
2. **Default to unsafe** (user must opt-in to validation)
3. **Always validate** (no option to disable)

**Decision**: Default to `validate_safety=True`, allow override

**Rationale**:
- Safe by default prevents frustrating user errors
- Advanced users can disable for complex workflows
- Validation is fast (<50ms) so minimal UX impact
- Better to be conservative (can always relax later)

### Decision 3: Undo via expand_specific()

**Context**: How should undo restore collapsed cells?

**Options**:
1. **Create new "restore" method** in service
2. **Reuse expand_specific()** (chosen)
3. **Store cell/net objects and manually re-add**

**Decision**: Reuse `expand_specific(cells, nets, layout_state)`

**Rationale**:
- Collapse undo is logically "expand these specific cells"
- Code reuse reduces bugs and maintenance
- Consistent with expansion command pattern
- Layout state parameter enables exact restoration

### Decision 4: Single Cell vs Multi-Cell Constructor

**Context**: Should `CollapseCommand` accept single cell or set?

**Decision**: Accept `Union[CellId, Set[CellId]]`, normalize to set in constructor

**Rationale**:
- Common case: collapse single selected cell (don't force user to wrap in set)
- Multi-select case: collapse all selected cells together
- Internal implementation always uses set for consistency
- Type hint makes both cases clear

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Internal**:
- **T01 - UndoableCommand**: Base class that `CollapseCommand` extends
- **T02 - ExpansionCommand**: Reuses `expand_specific()` for undo
- **E03-F02**: `ExpansionService` with collapse functionality
- **E01**: Domain value objects (`CellId`, `NetId`)
- **E02**: Layout engine (indirectly via service)

**External**:
- Python standard library: `dataclasses`, `typing`

### 4.2 Downstream Consumers

**Immediate**:
- **UndoStack** (future task): Will push `CollapseCommand` instances
- **E04-F04 - Keyboard Shortcuts**: Delete/Backspace handlers create collapse commands

**Future (P1)**:
- **Session Persistence**: Serialize collapse commands for save/load
- **Batch Operations**: Collapse multiple selections in one command

### 4.3 Integration Points Checklist

- [ ] `ExpansionService` implements required methods:
  - `collapse(cells, remove_dependencies)` (may already exist from E03-F02)
  - `validate_collapse_safety(cells)` (new)
  - `capture_layout_state_for_cells(cells)` (new)
  - `collapse_specific(cells, nets)` (shared with ExpansionCommand.undo)
- [ ] Domain value objects are hashable for set operations
- [ ] Layout state format consistent with `ExpansionCommand`
- [ ] Error messages from validation are user-friendly

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Test File**: `tests/unit/application/commands/test_collapse_command.py`

**Test Scenarios**:

1. **Execute Success (Single Cell)**:
   ```python
   def test_collapse_command_execute_single_cell():
       """Execute collapse for single cell"""
       mock_service = Mock(spec=ExpansionService)
       mock_service.validate_collapse_safety.return_value = CommandResult.ok()
       mock_service.capture_layout_state_for_cells.return_value = {
           'cells': {'C1': {'x': 0, 'y': 0}}
       }
       mock_service.collapse.return_value = CollapseResult(
           success=True,
           cells_removed={CellId("C1")},
           nets_removed={NetId("N1")}
       )

       cmd = CollapseCommand(
           mock_service,
           target=CellId("C1"),  # Single cell, not set
           params=CollapseParams(validate_safety=True)
       )

       result = cmd.execute()

       assert result.success
       assert cmd.is_executed
       assert cmd.cells_removed == {CellId("C1")}
       assert cmd.nets_removed == {NetId("N1")}
   ```

2. **Execute Success (Multi-Cell)**:
   ```python
   def test_collapse_command_execute_multi_cell():
       """Execute collapse for multiple cells"""
       mock_service = Mock(spec=ExpansionService)
       # ... setup ...

       cmd = CollapseCommand(
           mock_service,
           target={CellId("C1"), CellId("C2"), CellId("C3")},
           params=CollapseParams(validate_safety=True)
       )

       result = cmd.execute()
       assert result.success
   ```

3. **Safety Validation Failure**:
   ```python
   def test_collapse_command_safety_validation_fails():
       """Execute fails if safety validation rejects collapse"""
       mock_service = Mock(spec=ExpansionService)
       mock_service.validate_collapse_safety.return_value = CommandResult.fail(
           "Collapse would orphan cell C3 (net N2 would have only one connection)"
       )

       cmd = CollapseCommand(
           mock_service,
           target={CellId("C1")},
           params=CollapseParams(validate_safety=True)
       )

       result = cmd.execute()

       assert not result.success
       assert "orphan" in result.error_message.lower()
       assert not cmd.is_executed
       # Verify collapse was NOT called
       mock_service.collapse.assert_not_called()
   ```

4. **Safety Validation Bypassed**:
   ```python
   def test_collapse_command_bypass_safety():
       """Safety validation can be disabled"""
       mock_service = Mock(spec=ExpansionService)
       # ... setup collapse to succeed ...

       cmd = CollapseCommand(
           mock_service,
           target={CellId("C1")},
           params=CollapseParams(validate_safety=False)  # Disabled
       )

       result = cmd.execute()

       assert result.success
       # Verify validation was NOT called
       mock_service.validate_collapse_safety.assert_not_called()
   ```

5. **Undo Restores Layout**:
   ```python
   def test_collapse_command_undo_restores_layout():
       """Undo restores cells with original layout positions"""
       mock_service = Mock(spec=ExpansionService)
       layout_state = {'cells': {'C1': {'x': 100, 'y': 200}}}
       mock_service.capture_layout_state_for_cells.return_value = layout_state
       # ... execute ...

       mock_service.expand_specific.return_value = CommandResult.ok()
       result = cmd.undo()

       assert result.success
       assert not cmd.is_executed
       # Verify layout state was passed
       call_args = mock_service.expand_specific.call_args
       assert call_args[0][0] == {CellId("C1")}  # cells
       assert call_args[0][1] == {NetId("N1")}  # nets
       assert call_args[1]['layout_state'] == layout_state
   ```

6. **Redo Uses Cached IDs**:
   ```python
   def test_collapse_command_redo_uses_cache():
       """Redo uses cached cell/net IDs for efficiency"""
       mock_service = Mock(spec=ExpansionService)
       # ... execute and undo ...

       mock_service.collapse_specific.return_value = CommandResult.ok()
       result = cmd.redo()

       assert result.success
       assert cmd.is_executed
       mock_service.collapse_specific.assert_called_once_with(
           {CellId("C1")},
           {NetId("N1")}
       )
       # Verify full collapse() was NOT called again
       assert mock_service.collapse.call_count == 1  # Only from initial execute
   ```

7. **Description Generation**:
   ```python
   def test_collapse_command_description_single_cell():
       cmd = CollapseCommand(mock_service, target=CellId("XINV_1"))
       assert cmd.description() == "Collapse cell XINV_1"

   def test_collapse_command_description_multi_cell():
       cmd = CollapseCommand(
           mock_service,
           target={CellId("C1"), CellId("C2"), CellId("C3")}
       )
       assert cmd.description() == "Collapse 3 cells"
   ```

8. **Remove Dependencies Parameter**:
   ```python
   def test_collapse_with_dependencies():
       """remove_dependencies=True removes dependent cells"""
       mock_service = Mock(spec=ExpansionService)
       mock_service.collapse.return_value = CollapseResult(
           success=True,
           cells_removed={CellId("C1"), CellId("C2")},  # C2 was dependency
           nets_removed={NetId("N1"), NetId("N2")}
       )

       cmd = CollapseCommand(
           mock_service,
           target={CellId("C1")},
           params=CollapseParams(remove_dependencies=True)
       )

       result = cmd.execute()
       assert result.success
       assert len(cmd.cells_removed) == 2  # Target + dependency
   ```

### 5.2 Integration Tests

**Test File**: `tests/integration/application/test_collapse_command_integration.py`

**Scenarios**:
1. End-to-end with real `ExpansionService`
2. Verify safety validation with real graph connectivity
3. Test collapse followed by expansion (interleaved commands)
4. Measure performance for various collapse sizes

### 5.3 Performance Tests

**Benchmarks**:
```python
@pytest.mark.benchmark
def test_collapse_50_cells(benchmark):
    """Execute should complete in <100ms for 50 cells"""
    service = ExpansionService(large_graph)
    cmd = CollapseCommand(service, target=get_50_cells())

    result = benchmark(cmd.execute)
    assert result.success
    assert benchmark.stats.mean < 0.1  # <100ms

@pytest.mark.benchmark
def test_undo_collapse(benchmark, executed_collapse_cmd):
    """Undo should complete in <150ms (restore with layout)"""
    result = benchmark(executed_collapse_cmd.undo)
    assert result.success
    assert benchmark.stats.mean < 0.15  # <150ms

@pytest.mark.benchmark
def test_safety_validation(benchmark):
    """Safety validation should complete in <50ms for 100 cells"""
    service = ExpansionService(large_graph)

    result = benchmark(service.validate_collapse_safety, get_100_cells())
    assert benchmark.stats.mean < 0.05  # <50ms
```

### 5.4 Coverage Target

- **Line Coverage**: 90%+ (allow for edge case error handling)
- **Branch Coverage**: 85%+ (many error paths, validation branches)
- **Edge Cases**: Empty target, safety failures, service errors

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: Safety Validation False Positives
**Impact**: Medium
**Probability**: Medium

**Description**: Safety validation may incorrectly reject valid collapses (e.g., complex multi-hop dependencies).

**Mitigation**:
- Start with simple validation (direct connections only)
- Provide clear error messages explaining why collapse is unsafe
- Allow users to override with `validate_safety=False`
- Log validation decisions for debugging

**Contingency**: If users report too many false positives, add "force collapse" option in UI with warning dialog

#### Risk 2: Layout State Capture Performance
**Impact**: Low
**Probability**: Low

**Description**: Capturing layout state for 1000+ cells may be slow (>100ms).

**Mitigation**:
- Profile layout state capture in performance tests
- Only capture positions, not full rendering state
- Use efficient data structures (dict lookup, not list iteration)

**Contingency**: Make layout caching optional (trade undo quality for speed)

#### Risk 3: Dependency Removal Complexity
**Impact**: Medium
**Probability**: Medium

**Description**: Determining which cells are "dependencies" (should be removed with target) is non-trivial for complex graphs.

**Mitigation**:
- Start with simple algorithm: cells reachable only through target cells
- Use breadth-first search to find dependencies
- Set maximum depth (prevent removing entire design)

**Contingency**: For MVP, disable `remove_dependencies` feature if algorithm is too complex. Defer to P1.

### 6.2 Integration Risks

#### Risk 4: Validation and Collapse Disagreement
**Impact**: High
**Probability**: Low

**Description**: Safety validation says safe, but collapse fails (or vice versa).

**Mitigation**:
- Use same graph query methods for validation and collapse
- Add assertions: if validation passes, collapse must succeed
- Integration tests verify validation accuracy

**Contingency**: If disagreement detected, log error and skip validation (fail safe)

#### Risk 5: Undo After Graph Changes
**Impact**: Low
**Probability**: Very Low (MVP)

**Description**: If design is modified between collapse and undo, cached layout state may be invalid.

**Mitigation**:
- For MVP: assume design never changes (read-only exploration)
- `expand_specific()` handles missing cells gracefully (skip them)

**Contingency**: Add cache validation in P1 if needed

### 6.3 Usability Risks

#### Risk 6: Confusing Safety Error Messages
**Impact**: Medium
**Probability**: Medium

**Description**: Users may not understand why collapse was rejected ("would orphan cell C3").

**Mitigation**:
- Use clear language: "Removing C1 would disconnect C3 from the rest of the circuit"
- Highlight affected cells in UI (future enhancement)
- Provide "show why" option to visualize connectivity

**Contingency**: Collect user feedback, iterate on error message wording

---

## 7. Open Questions

### Question 1: Should Zero-Cell Collapse Be Valid?
**Status**: Needs decision

If all target cells are already hidden, should command execute successfully or fail?

**Options**:
1. Succeed (idempotent)
2. Fail with "cells already hidden"
3. Succeed but don't add to undo stack

**Recommendation**: Option 1 - succeed and add to stack. Consistent with expansion command handling.

### Question 2: How Deep to Check Dependencies?
**Status**: Needs decision

When `remove_dependencies=True`, how far should we traverse to find dependent cells?

**Options**:
1. Only direct dependencies (1 hop)
2. Transitive closure (all reachable cells)
3. Configurable depth limit

**Recommendation**: Option 3 - use configurable limit (default 3 hops) to prevent removing entire design.

### Question 3: Should Validation Consider Hidden Cells?
**Status**: Needs decision

When checking for orphaned connections, should validation consider only visible cells or all cells in graph?

**Recommendation**: Only visible cells. Hidden cells are not orphaned (already hidden).

---

## 8. Definition of Done

### 8.1 Code Complete
- [ ] `CollapseParams` dataclass implemented
- [ ] `CollapseResult` dataclass implemented
- [ ] `CollapseCommand` class implemented extending `UndoableCommand`
- [ ] Constructor normalizes single `CellId` to set
- [ ] `execute()` method with safety validation and layout capture
- [ ] `undo()` method restores layout via `expand_specific()`
- [ ] `redo()` method uses cached cell/net IDs
- [ ] `description()` method generates readable text
- [ ] Properties implemented: `cells_removed`, `nets_removed`, `target`, `params`

### 8.2 Service Interface Extensions
- [ ] `ExpansionService.collapse()` implemented (may exist from E03-F02)
- [ ] `ExpansionService.validate_collapse_safety()` implemented
- [ ] `ExpansionService.capture_layout_state_for_cells()` implemented
- [ ] `ExpansionService.collapse_specific()` implemented (shared with ExpansionCommand)
- [ ] Safety validation algorithm tested with real graph

### 8.3 Testing Complete
- [ ] Unit tests for execute success (single and multi-cell)
- [ ] Unit tests for safety validation (pass and fail)
- [ ] Unit tests for undo with layout restoration
- [ ] Unit tests for redo with cache
- [ ] Unit tests for `remove_dependencies` parameter
- [ ] Unit tests for description generation
- [ ] Integration test with real service
- [ ] Performance tests meet targets (<100ms execute, <150ms undo, <100ms redo, <50ms validation)
- [ ] 90%+ code coverage

### 8.4 Code Quality
- [ ] Type hints on all methods
- [ ] Docstrings on class and public methods
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] No circular dependencies

### 8.5 Documentation
- [ ] Class docstring with usage examples
- [ ] Safety validation rules documented
- [ ] Error message guidelines documented
- [ ] State invariants documented

---

## 9. Implementation Notes

### 9.1 File Structure

```
src/ink/application/commands/
├── __init__.py
├── undoable_command.py          # From T01
├── expansion_command.py         # From T02
└── collapse_command.py          # This task
    ├── CollapseParams
    ├── CollapseResult
    └── CollapseCommand

tests/unit/application/commands/
└── test_collapse_command.py

tests/integration/application/
└── test_collapse_command_integration.py
```

### 9.2 Import Structure

```python
# src/ink/application/commands/__init__.py
from .undoable_command import UndoableCommand, CommandResult
from .expansion_command import ExpansionCommand, ExpansionParams, ExpansionResult
from .collapse_command import CollapseCommand, CollapseParams, CollapseResult

__all__ = [
    'UndoableCommand',
    'CommandResult',
    'ExpansionCommand',
    'ExpansionParams',
    'ExpansionResult',
    'CollapseCommand',
    'CollapseParams',
    'CollapseResult',
]
```

### 9.3 Example Usage

```python
# Collapse single selected cell
from ink.application.commands import CollapseCommand, CollapseParams
from ink.domain.value_objects.identifiers import CellId

cmd = CollapseCommand(
    expansion_service,
    target=CellId("XINV_1"),
    params=CollapseParams(
        validate_safety=True,
        remove_dependencies=True
    )
)

# Execute
result = cmd.execute()
if result.success:
    print(f"Collapsed: removed {len(cmd.cells_removed)} cells")
else:
    print(f"Failed: {result.error_message}")

# Undo (restore)
result = cmd.undo()

# Redo (re-collapse)
result = cmd.redo()
```

---

## 10. Next Steps

### 10.1 Immediate Actions
1. Verify `ExpansionService` interface from E03 supports collapse
2. Implement safety validation algorithm in service
3. Implement `CollapseParams` and `CollapseResult` dataclasses
4. Implement `CollapseCommand` class
5. Write unit tests with mocked service
6. Write integration tests with real service

### 10.2 Coordination Required
- [ ] Sync with E03 implementer on collapse and safety validation
- [ ] Sync with T02 on `expand_specific()` and `collapse_specific()` interfaces
- [ ] Confirm layout state format matches ExpansionCommand

### 10.3 After Task Completion
1. Update `CHANGELOG.md`
2. Create PR for review
3. Merge to feature branch
4. Proceed to undo stack implementation (next task in feature)

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
