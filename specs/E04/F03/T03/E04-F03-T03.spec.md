---
id: E04-F03-T03
title: Collapse Command Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F03
created: 2025-12-26
estimated_hours: 6
actual_hours:
effort: Medium
tags:
  - application-layer
  - collapse
  - undo-redo
clickup_task_id: '86evzm2x2'
---

# Spec: E04-F03-T03 - Collapse Command Implementation

## 1. Overview

### 1.1 Problem Statement
Implement a concrete undoable command for collapse operations that safely removes cells and their dependent nets from the visible schematic while recording what was removed to enable precise undo (restore) and redo (re-collapse). The command must validate that collapse won't orphan connected cells and maintain state consistency.

### 1.2 Goals
- Implement `CollapseCommand` extending `UndoableCommand`
- Record cells and nets removed during collapse for precise undo
- Validate collapse safety (don't orphan connected cells)
- Support both single-cell and multi-cell collapse
- Enable efficient redo without recomputing dependencies
- Restore exact layout state on undo

---

## 2. Technical Requirements

### 2.1 CollapseCommand Implementation

**Location**: `src/ink/application/commands/collapse_command.py`

**Class Structure**:
```python
from dataclasses import dataclass
from typing import Set, Union, Optional
from ink.application.commands.undoable_command import UndoableCommand, CommandResult
from ink.application.services.expansion_service import ExpansionService
from ink.domain.value_objects.identifiers import CellId, NetId


@dataclass
class CollapseParams:
    """Parameters for collapse operation"""
    remove_dependencies: bool = True  # Remove cells that depend on collapsed cells
    validate_safety: bool = True  # Check for orphaned connections


@dataclass
class CollapseResult:
    """Result of collapse operation"""
    success: bool
    cells_removed: Set[CellId]
    nets_removed: Set[NetId]
    error_message: Optional[str] = None


class CollapseCommand(UndoableCommand):
    """
    Undoable command for collapse operations.

    Removes cells and their nets from the visible schematic, recording all
    removed elements for precise undo/redo. Validates collapse safety to
    prevent orphaning connected cells.

    Example:
        # Collapse single cell
        cmd = CollapseCommand(
            expansion_service,
            target={CellId("C1")},
            params=CollapseParams(validate_safety=True)
        )
        result = cmd.execute()

        # Collapse multiple selected cells
        cmd = CollapseCommand(
            expansion_service,
            target={CellId("C1"), CellId("C2"), CellId("C3")},
            params=CollapseParams(remove_dependencies=True)
        )
    """

    def __init__(
        self,
        expansion_service: ExpansionService,
        target: Union[CellId, Set[CellId]],
        params: CollapseParams = None
    ):
        """
        Initialize collapse command.

        Args:
            expansion_service: Service for performing collapse
            target: Cell ID or set of cell IDs to collapse
            params: Optional collapse parameters
        """
        super().__init__()
        self._service = expansion_service

        # Normalize target to set
        if isinstance(target, CellId):
            self._target = {target}
        else:
            self._target = target

        self._params = params or CollapseParams()

        # State recorded during execution
        self._cells_removed: Set[CellId] = set()
        self._nets_removed: Set[NetId] = set()
        self._layout_state: Optional[dict] = None  # For undo restoration

    def execute(self) -> CommandResult:
        """
        Execute collapse operation.

        Determines which cells can be safely removed, removes them and their
        nets, and records state for undo.

        Returns:
            CommandResult with success status
        """
        try:
            # Validate collapse safety if requested
            if self._params.validate_safety:
                validation_result = self._service.validate_collapse_safety(
                    self._target
                )
                if not validation_result.success:
                    return CommandResult.fail(
                        validation_result.error_message or
                        "Collapse would orphan connected cells"
                    )

            # Capture layout state before collapse for undo
            self._layout_state = self._service.capture_layout_state_for_cells(
                self._target
            )

            # Perform collapse through service
            result = self._service.collapse(
                self._target,
                remove_dependencies=self._params.remove_dependencies
            )

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Collapse failed"
                )

            # Record state for undo/redo
            self._cells_removed = result.cells_removed
            self._nets_removed = result.nets_removed

            self._mark_executed()
            return CommandResult.ok()

        except Exception as e:
            return CommandResult.fail(f"Collapse error: {str(e)}")

    def undo(self) -> CommandResult:
        """
        Undo collapse by restoring removed cells and nets.

        Restores exactly the cells/nets that were removed, including their
        layout positions and net routing.

        Returns:
            CommandResult with success status
        """
        if not self.is_executed:
            return CommandResult.fail("Cannot undo: command not executed")

        try:
            # Restore cells and nets with original layout
            result = self._service.expand_specific(
                self._cells_removed,
                self._nets_removed,
                layout_state=self._layout_state
            )

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Undo collapse failed"
                )

            self._mark_not_executed()
            return CommandResult.ok()

        except Exception as e:
            return CommandResult.fail(f"Undo collapse error: {str(e)}")

    def redo(self) -> CommandResult:
        """
        Redo collapse by removing the same cells and nets again.

        Uses cached cell/net IDs for efficiency, avoiding recomputation
        of dependencies.

        Returns:
            CommandResult with success status
        """
        if self._cells_removed is None or len(self._cells_removed) == 0:
            # No cached state, fall back to execute
            return self.execute()

        try:
            # Remove the same cells/nets as before
            result = self._service.collapse_specific(
                self._cells_removed,
                self._nets_removed
            )

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Redo collapse failed"
                )

            self._mark_executed()
            return CommandResult.ok()

        except Exception as e:
            # Fallback to full execute if restore fails
            return self.execute()

    def description(self) -> str:
        """
        Generate human-readable description.

        Returns:
            String like "Collapse 3 cells" or "Collapse cell C1"
        """
        count = len(self._target)
        if count == 1:
            cell_id = next(iter(self._target))
            return f"Collapse cell {cell_id}"
        else:
            return f"Collapse {count} cells"

    @property
    def cells_removed(self) -> Set[CellId]:
        """Get set of cell IDs removed by this collapse"""
        return self._cells_removed.copy()

    @property
    def nets_removed(self) -> Set[NetId]:
        """Get set of net IDs removed by this collapse"""
        return self._nets_removed.copy()

    @property
    def target(self) -> Set[CellId]:
        """Get collapse target cells"""
        return self._target.copy()

    @property
    def params(self) -> CollapseParams:
        """Get collapse parameters"""
        return self._params
```

### 2.2 ExpansionService Interface Extensions

The `ExpansionService` needs additional methods for collapse support:

```python
# In src/ink/application/services/expansion_service.py

class ExpansionService:
    """Application service for expansion and collapse operations"""

    def collapse(
        self,
        cells: Set[CellId],
        remove_dependencies: bool = True
    ) -> CollapseResult:
        """
        Remove cells and their nets from view.

        Args:
            cells: Cell IDs to collapse
            remove_dependencies: If True, also remove cells that depend on collapsed cells

        Returns:
            CollapseResult with cells/nets removed
        """

    def validate_collapse_safety(
        self,
        cells: Set[CellId]
    ) -> CommandResult:
        """
        Check if collapse is safe (won't orphan connected cells).

        Args:
            cells: Cell IDs to potentially collapse

        Returns:
            CommandResult.ok() if safe, CommandResult.fail() with reason if not
        """

    def capture_layout_state_for_cells(
        self,
        cells: Set[CellId]
    ) -> dict:
        """
        Capture layout state for cells and their connected nets.

        Includes positions, routing, and any visual properties needed
        to restore exact appearance on undo.

        Args:
            cells: Cell IDs to capture state for

        Returns:
            Dictionary with layout state
        """
```

### 2.3 Collapse Safety Validation

**Safety Rules**:
1. **No orphaned connections**: Removing a cell should not leave a net with only one pin connected
2. **Preserve visible connectivity**: Don't remove cells if their removal would disconnect two visible cells
3. **Respect dependencies**: If `remove_dependencies=False`, only remove target cells

**Validation Algorithm**:
```
1. For each cell in target set:
   a. Get all nets connected to cell
   b. For each net:
      - Count remaining visible pins if cell removed
      - If count < 2 and net connects to other visible cells:
        * Collapse is unsafe (would orphan connection)
        * Return failure with explanation
   c. If safe, add to removal set

2. If remove_dependencies=True:
   a. Find all cells that only connect through target cells
   b. Add to removal set (recursive dependency check)

3. Return success with final removal set
```

### 2.4 State Consistency Requirements

**Invariants to maintain**:
- After execute: all cells/nets in `_cells_removed` and `_nets_removed` are hidden
- After undo: all cells/nets in `_cells_removed` and `_nets_removed` are visible with original layout
- After redo: same state as after execute
- Sets `_cells_removed` and `_nets_removed` never change after first execute
- Layout state captured before collapse remains valid for undo

**Edge cases**:
- Collapse target contains cells not currently visible: ignore missing cells
- Collapse removes zero cells (all filtered by safety check): still valid command
- Undo after design reload: layout state may be stale, use default positions
- Service failures during redo: fall back to full execute

### 2.5 Performance Requirements

- **Execute time**: < 100ms for collapsing 50 cells
- **Undo time**: < 150ms (restore from cache, includes layout)
- **Redo time**: < 100ms (just hide elements)
- **Memory per command**: < 10KB (store IDs + layout state)
- **Safety validation**: < 50ms for 100 connected cells

---

## 3. Dependencies

### 3.1 Upstream
- Task E04-F03-T01: Extends `UndoableCommand` base class
- E03-F02: `ExpansionService` implements collapse functionality
- E01: Domain value objects (`CellId`, `NetId`)

### 3.2 Downstream
- Task E04-F03-T04: `UndoStack` pushes `CollapseCommand` instances
- E04-F04: Keyboard shortcuts (Delete/Backspace) trigger collapse via commands

### 3.3 External Dependencies
- Python standard library: `dataclasses`, `typing`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `CollapseCommand` successfully extends `UndoableCommand`
- [ ] Execute performs collapse and records removed cells/nets
- [ ] Undo restores exactly the cells/nets that were removed
- [ ] Redo collapses the same cells/nets efficiently
- [ ] Description generates human-readable text for UI display
- [ ] Supports both single-cell and multi-cell collapse
- [ ] Validates collapse safety when requested

### 4.2 Safety Validation
- [ ] Safety validation detects orphaned connections
- [ ] Safety validation allows safe collapses
- [ ] Clear error messages explain why collapse is unsafe
- [ ] Can bypass safety check via parameters (for advanced users)

### 4.3 State Management
- [ ] `_cells_removed` and `_nets_removed` populated after first execute
- [ ] Sets remain unchanged across undo/redo cycles
- [ ] Layout state captured before collapse
- [ ] Undo restores original layout positions
- [ ] Redo uses cached IDs for efficiency

### 4.4 Error Handling
- [ ] Returns `CommandResult.fail()` on service errors
- [ ] Undo fails gracefully if elements already visible
- [ ] Redo falls back to execute if cache unavailable
- [ ] Clear error messages in all failure cases

### 4.5 Performance
- [ ] Execute completes in < 100ms for 50 cells
- [ ] Undo completes in < 150ms
- [ ] Redo completes in < 100ms
- [ ] Safety validation < 50ms for 100 connected cells
- [ ] Memory usage < 10KB per command instance

### 4.6 Testing
- [ ] Unit tests for execute with mock service
- [ ] Unit tests for undo/redo cycle
- [ ] Test single-cell collapse
- [ ] Test multi-cell collapse
- [ ] Test safety validation (safe and unsafe cases)
- [ ] Test dependency removal
- [ ] Test error handling for service failures
- [ ] Test description generation
- [ ] Integration test with real `ExpansionService`
- [ ] 90%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why validate safety by default?**
- Prevents frustrating user errors (accidentally orphaning cells)
- Can be disabled for advanced workflows
- Validation is fast (< 50ms) so minimal UX impact
- Better safe by default, opt-in to unsafe

**Why capture layout state before collapse?**
- Undo should restore exact visual appearance
- Users expect cells to return to same positions
- Small memory cost (< 10KB) for better UX
- Alternative (recompute layout) would give different positions

**Why support `remove_dependencies` parameter?**
- Different use cases:
  - Clean collapse: remove everything that becomes disconnected
  - Precise collapse: remove only what user selected
- Gives users control over behavior
- Defaults to `True` for cleaner results

**Why allow collapsing non-visible cells?**
- User may select cells from hierarchy panel that aren't visible
- Command should be forgiving (ignore missing cells)
- Only remove cells that are actually visible
- Alternative (error) would be frustrating

**Why use same `expand_specific` for undo?**
- Collapse undo is logically "expand these specific cells"
- Code reuse reduces bugs
- Consistent with expansion command pattern
- Layout state parameter enables exact restoration

### 5.2 Alternative Approaches Considered

**Separate Undo/Redo logic vs. cached IDs**:
- Considered: Undo calls different service method than redo
- Decision: Use cached IDs for both, call same service methods
- Rationale: Simpler, more consistent, easier to test

**Eager vs. Lazy safety validation**:
- Considered: Validate during command construction
- Decision: Validate during execute()
- Rationale: State may change between construction and execution

**Store full objects vs. IDs**:
- Considered: Cache removed cell/net objects for undo
- Decision: Store only IDs, resolve via service
- Rationale: Lower memory, avoid stale references, enables serialization

### 5.3 Testing Strategy

**Unit Tests** (`tests/unit/application/commands/test_collapse_command.py`):
```python
def test_collapse_command_execute():
    """Test collapse command execution"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    mock_service.validate_collapse_safety.return_value = CommandResult.ok()
    mock_service.capture_layout_state_for_cells.return_value = {
        "C1": {"pos": (0, 0)}, "C2": {"pos": (1, 0)}
    }
    mock_service.collapse.return_value = CollapseResult(
        success=True,
        cells_removed={CellId("C1"), CellId("C2")},
        nets_removed={NetId("N1")}
    )

    cmd = CollapseCommand(
        mock_service,
        target={CellId("C1"), CellId("C2")},
        params=CollapseParams(validate_safety=True)
    )

    # Execute
    result = cmd.execute()

    # Verify
    assert result.success
    assert cmd.is_executed
    assert cmd.cells_removed == {CellId("C1"), CellId("C2")}
    assert cmd.nets_removed == {NetId("N1")}
    mock_service.validate_collapse_safety.assert_called_once()
    mock_service.collapse.assert_called_once()


def test_collapse_command_safety_validation_failure():
    """Test collapse command with safety validation failure"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    mock_service.validate_collapse_safety.return_value = CommandResult.fail(
        "Would orphan cell C3"
    )

    cmd = CollapseCommand(
        mock_service,
        target={CellId("C1")},
        params=CollapseParams(validate_safety=True)
    )

    # Execute
    result = cmd.execute()

    # Verify
    assert not result.success
    assert "orphan" in result.error_message.lower()
    assert not cmd.is_executed
    mock_service.collapse.assert_not_called()


def test_collapse_command_undo():
    """Test collapse command undo restores layout"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    layout_state = {"C1": {"pos": (0, 0)}, "C2": {"pos": (1, 0)}}
    # ... setup as above ...
    cmd = CollapseCommand(...)
    cmd.execute()

    # Undo
    mock_service.expand_specific.return_value = CommandResult.ok()
    result = cmd.undo()

    # Verify
    assert result.success
    assert not cmd.is_executed
    # Verify layout_state was passed to expand_specific
    call_args = mock_service.expand_specific.call_args
    assert call_args[1]['layout_state'] == layout_state
```

**Integration Tests** (`tests/integration/application/test_collapse_command_integration.py`):
- Test with real `ExpansionService` and mock domain services
- Verify end-to-end execute -> undo -> redo cycle
- Test safety validation with real graph connectivity
- Test collapse followed by expansion (interleaved commands)
- Measure performance for various collapse sizes

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F03 split |
