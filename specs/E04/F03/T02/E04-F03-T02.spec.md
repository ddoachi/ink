---
id: E04-F03-T02
title: Expansion Command Implementation
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F03
created: 2025-12-26
estimated_hours: 8
actual_hours:
effort: Medium-High
tags:
  - application-layer
  - expansion
  - undo-redo
---

# Spec: E04-F03-T02 - Expansion Command Implementation

## 1. Overview

### 1.1 Problem Statement
Implement a concrete undoable command for expansion operations that records which cells and nets were added during expansion, enabling precise undo by removing only those elements and redo by restoring them. The command must integrate with the expansion service and maintain state consistency across execute/undo/redo cycles.

### 1.2 Goals
- Implement `ExpansionCommand` extending `UndoableCommand`
- Record cells and nets added during expansion for precise undo
- Support both hop-based and boundary-based expansion modes
- Integrate with `ExpansionService` from application layer
- Enable efficient redo without full graph re-traversal
- Maintain layout state consistency across undo/redo

---

## 2. Technical Requirements

### 2.1 ExpansionCommand Implementation

**Location**: `src/ink/application/commands/expansion_command.py`

**Class Structure**:
```python
from dataclasses import dataclass
from typing import Set, Union, Optional
from ink.application.commands.undoable_command import UndoableCommand, CommandResult
from ink.application.services.expansion_service import ExpansionService
from ink.domain.value_objects.identifiers import CellId, NetId, PinId


@dataclass
class ExpansionParams:
    """Parameters for expansion operation"""
    direction: str  # "fanin" or "fanout"
    mode: str  # "hop" or "boundary"
    hop_count: int = 1  # Only used for hop mode
    include_boundary: bool = True  # Include sequential cells in boundary mode


@dataclass
class ExpansionResult:
    """Result of expansion operation"""
    success: bool
    cells_added: Set[CellId]
    nets_added: Set[NetId]
    error_message: Optional[str] = None


class ExpansionCommand(UndoableCommand):
    """
    Undoable command for expansion operations.

    Expands circuit from a starting point (cell/pin/net) in specified direction,
    recording all added elements for precise undo/redo.

    Example:
        cmd = ExpansionCommand(
            expansion_service,
            target=PinId("cell_1", "OUT"),
            params=ExpansionParams(direction="fanout", mode="hop", hop_count=2)
        )
        result = cmd.execute()
    """

    def __init__(
        self,
        expansion_service: ExpansionService,
        target: Union[CellId, PinId, NetId],
        params: ExpansionParams
    ):
        """
        Initialize expansion command.

        Args:
            expansion_service: Service for performing expansions
            target: Starting point for expansion
            params: Expansion parameters (direction, mode, hop count)
        """
        super().__init__()
        self._service = expansion_service
        self._target = target
        self._params = params

        # State recorded during execution
        self._cells_added: Set[CellId] = set()
        self._nets_added: Set[NetId] = set()
        self._layout_state: Optional[dict] = None  # For redo optimization

    def execute(self) -> CommandResult:
        """
        Execute expansion operation.

        Performs graph traversal based on parameters, records added elements,
        and triggers layout/rendering updates.

        Returns:
            CommandResult with success status
        """
        try:
            # Perform expansion through service
            result = self._service.expand(self._target, self._params)

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Expansion failed"
                )

            # Record state for undo/redo
            self._cells_added = result.cells_added
            self._nets_added = result.nets_added

            # Store layout state for efficient redo
            self._layout_state = self._service.capture_layout_state(
                self._cells_added, self._nets_added
            )

            self._mark_executed()
            return CommandResult.ok()

        except Exception as e:
            return CommandResult.fail(f"Expansion error: {str(e)}")

    def undo(self) -> CommandResult:
        """
        Undo expansion by removing added cells and nets.

        Removes only the cells/nets that were added by this expansion,
        preserving any elements that were already visible or added by
        other expansions.

        Returns:
            CommandResult with success status
        """
        if not self.is_executed:
            return CommandResult.fail("Cannot undo: command not executed")

        try:
            # Remove specific cells and nets added by this expansion
            result = self._service.collapse_specific(
                self._cells_added,
                self._nets_added
            )

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Undo expansion failed"
                )

            self._mark_not_executed()
            return CommandResult.ok()

        except Exception as e:
            return CommandResult.fail(f"Undo expansion error: {str(e)}")

    def redo(self) -> CommandResult:
        """
        Redo expansion by restoring previously added cells and nets.

        Uses cached layout state for efficiency, avoiding full graph
        re-traversal and layout recalculation.

        Returns:
            CommandResult with success status
        """
        if self._layout_state is None:
            # First redo or layout state not cached, fall back to execute
            return self.execute()

        try:
            # Restore cells/nets with cached layout positions
            result = self._service.expand_specific(
                self._cells_added,
                self._nets_added,
                layout_state=self._layout_state
            )

            if not result.success:
                return CommandResult.fail(
                    result.error_message or "Redo expansion failed"
                )

            self._mark_executed()
            return CommandResult.ok()

        except Exception as e:
            # Fallback to full execute if restore fails
            return self.execute()

    def description(self) -> str:
        """
        Generate human-readable description.

        Returns:
            String like "Expand fanout (2 hops) from pin cell_1.OUT"
        """
        # Format target description
        if isinstance(self._target, PinId):
            target_desc = f"pin {self._target.cell_id}.{self._target.pin_name}"
        elif isinstance(self._target, CellId):
            target_desc = f"cell {self._target}"
        else:  # NetId
            target_desc = f"net {self._target}"

        # Format mode description
        if self._params.mode == "hop":
            mode_desc = f"{self._params.hop_count} hop{'s' if self._params.hop_count > 1 else ''}"
        else:
            mode_desc = "to boundary"

        return f"Expand {self._params.direction} ({mode_desc}) from {target_desc}"

    @property
    def cells_added(self) -> Set[CellId]:
        """Get set of cell IDs added by this expansion"""
        return self._cells_added.copy()

    @property
    def nets_added(self) -> Set[NetId]:
        """Get set of net IDs added by this expansion"""
        return self._nets_added.copy()

    @property
    def target(self) -> Union[CellId, PinId, NetId]:
        """Get expansion target"""
        return self._target

    @property
    def params(self) -> ExpansionParams:
        """Get expansion parameters"""
        return self._params
```

### 2.2 ExpansionService Interface Extensions

The `ExpansionService` needs to support the command's requirements:

```python
# In src/ink/application/services/expansion_service.py

class ExpansionService:
    """Application service for expansion operations"""

    def expand(
        self,
        target: Union[CellId, PinId, NetId],
        params: ExpansionParams
    ) -> ExpansionResult:
        """
        Perform expansion from target.

        Returns:
            ExpansionResult with cells/nets added
        """

    def collapse_specific(
        self,
        cells: Set[CellId],
        nets: Set[NetId]
    ) -> CommandResult:
        """
        Remove specific cells and nets from view.

        Used by undo to remove exactly what was added.

        Args:
            cells: Cell IDs to remove
            nets: Net IDs to remove

        Returns:
            CommandResult indicating success
        """

    def expand_specific(
        self,
        cells: Set[CellId],
        nets: Set[NetId],
        layout_state: Optional[dict] = None
    ) -> CommandResult:
        """
        Add specific cells and nets to view.

        Used by redo to restore exactly what was removed.
        If layout_state provided, restores positions.

        Args:
            cells: Cell IDs to add
            nets: Net IDs to add
            layout_state: Optional cached layout positions

        Returns:
            CommandResult indicating success
        """

    def capture_layout_state(
        self,
        cells: Set[CellId],
        nets: Set[NetId]
    ) -> dict:
        """
        Capture current layout positions for cells/nets.

        Used to cache state for efficient redo.

        Args:
            cells: Cell IDs to capture
            nets: Net IDs to capture

        Returns:
            Dictionary with layout state (positions, routing)
        """
```

### 2.3 State Consistency Requirements

**Invariants to maintain**:
- After execute: all cells/nets in `_cells_added` and `_nets_added` are visible
- After undo: all cells/nets in `_cells_added` and `_nets_added` are hidden
- After redo: same state as after execute
- Sets `_cells_added` and `_nets_added` never change after first execute
- Layout state captured after first execute remains valid

**Edge cases**:
- Expansion adds zero cells (already expanded): still valid, undo does nothing
- Cell already visible from another expansion: not added to `_cells_added`
- Redo after design reload: may need to fall back to full execute
- Service failures during undo: should not corrupt state

### 2.4 Performance Requirements

- **Execute time**: < 500ms for 5-hop expansion
- **Undo time**: < 100ms (just hide elements, no traversal)
- **Redo time**: < 150ms (restore from cache, no layout calculation)
- **Memory per command**: < 5KB (store only IDs, not full objects)
- **Layout state cache**: < 20KB for typical expansion (100 cells)

---

## 3. Dependencies

### 3.1 Upstream
- Task E04-F03-T01: Extends `UndoableCommand` base class
- E03-F01: `ExpansionService` implements hop-based expansion
- E03-F03: `ExpansionService` implements boundary-based expansion
- E01: Domain value objects (`CellId`, `NetId`, `PinId`)

### 3.2 Downstream
- Task E04-F03-T04: `UndoStack` pushes `ExpansionCommand` instances
- E04-F04: Keyboard shortcuts trigger expansion via commands

### 3.3 External Dependencies
- Python standard library: `dataclasses`, `typing`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `ExpansionCommand` successfully extends `UndoableCommand`
- [ ] Execute performs expansion and records added cells/nets
- [ ] Undo removes exactly the cells/nets that were added
- [ ] Redo restores cells/nets efficiently using cached state
- [ ] Description generates human-readable text for UI display
- [ ] Supports both hop-based and boundary-based expansion modes
- [ ] Supports fanin and fanout directions

### 4.2 State Management
- [ ] `_cells_added` and `_nets_added` populated after first execute
- [ ] Sets remain unchanged across undo/redo cycles
- [ ] Layout state cached after first execute
- [ ] Redo uses cached state when available
- [ ] Falls back to full execute if cache unavailable

### 4.3 Error Handling
- [ ] Returns `CommandResult.fail()` on service errors
- [ ] Undo fails gracefully if elements already removed
- [ ] Redo falls back to execute if restore fails
- [ ] Clear error messages in all failure cases

### 4.4 Performance
- [ ] Execute completes in < 500ms for 5-hop expansion
- [ ] Undo completes in < 100ms
- [ ] Redo completes in < 150ms
- [ ] Memory usage < 5KB per command instance
- [ ] Layout cache < 20KB for 100-cell expansion

### 4.5 Testing
- [ ] Unit tests for execute with mock service
- [ ] Unit tests for undo/redo cycle
- [ ] Test both hop and boundary modes
- [ ] Test both fanin and fanout directions
- [ ] Test edge case: expansion adds zero cells
- [ ] Test error handling for service failures
- [ ] Test description generation for all target types
- [ ] Integration test with real `ExpansionService`
- [ ] 90%+ code coverage

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why store IDs instead of full objects?**
- Reduces memory footprint (IDs are strings, objects are large)
- Avoids stale object references after state changes
- Service resolves IDs to current objects during undo/redo
- Enables serialization for session save/load (future)

**Why cache layout state for redo?**
- Redo should restore exact visual state, not recompute layout
- Avoids non-determinism in layout algorithm
- Significantly faster than full execute
- Small memory cost (< 20KB) for large UX improvement

**Why separate `expand_specific` from `expand`?**
- `expand` traverses graph and discovers cells
- `expand_specific` just adds known cells (for redo)
- Clear separation of concerns
- Enables redo optimization without complicating expand logic

**Why return `CommandResult` instead of raising exceptions?**
- Consistent with `UndoableCommand` base class design
- Easier to log and display errors in UI
- Allows partial success handling (future enhancement)
- Cleaner control flow for command execution

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/application/commands/test_expansion_command.py`):
```python
def test_expansion_command_execute():
    """Test expansion command execution"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    mock_service.expand.return_value = ExpansionResult(
        success=True,
        cells_added={CellId("C1"), CellId("C2")},
        nets_added={NetId("N1")}
    )
    mock_service.capture_layout_state.return_value = {"C1": (0, 0), "C2": (1, 0)}

    cmd = ExpansionCommand(
        mock_service,
        target=PinId("C0", "OUT"),
        params=ExpansionParams(direction="fanout", mode="hop", hop_count=1)
    )

    # Execute
    result = cmd.execute()

    # Verify
    assert result.success
    assert cmd.is_executed
    assert cmd.cells_added == {CellId("C1"), CellId("C2")}
    assert cmd.nets_added == {NetId("N1")}
    mock_service.expand.assert_called_once()


def test_expansion_command_undo():
    """Test expansion command undo"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    # ... setup as above ...
    cmd = ExpansionCommand(...)
    cmd.execute()

    # Undo
    mock_service.collapse_specific.return_value = CommandResult.ok()
    result = cmd.undo()

    # Verify
    assert result.success
    assert not cmd.is_executed
    mock_service.collapse_specific.assert_called_once_with(
        {CellId("C1"), CellId("C2")},
        {NetId("N1")}
    )


def test_expansion_command_redo_uses_cache():
    """Test redo uses cached layout state"""
    # Setup
    mock_service = Mock(spec=ExpansionService)
    # ... setup ...
    cmd = ExpansionCommand(...)
    cmd.execute()
    cmd.undo()

    # Redo
    mock_service.expand_specific.return_value = CommandResult.ok()
    result = cmd.redo()

    # Verify
    assert result.success
    mock_service.expand_specific.assert_called_once()
    # Verify layout_state parameter was passed
    call_args = mock_service.expand_specific.call_args
    assert call_args[1]['layout_state'] is not None
```

**Integration Tests** (`tests/integration/application/test_expansion_command_integration.py`):
- Test with real `ExpansionService` and mock domain services
- Verify end-to-end execute -> undo -> redo cycle
- Measure performance for various expansion sizes
- Test multiple commands in sequence (undo order)

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F03 split |
