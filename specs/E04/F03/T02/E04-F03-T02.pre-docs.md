# E04-F03-T02: Expansion Command Implementation - Pre-Implementation Documentation

## Document Metadata
- **Task**: E04-F03-T02 - Expansion Command Implementation
- **Feature**: E04-F03 - Undo/Redo System
- **Epic**: E04 - User Interaction & Controls
- **Status**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Last Updated**: 2025-12-26
- **Author**: Claude Sonnet 4.5

---

## 1. Overview

### 1.1 Task Summary

This task implements a concrete undoable command for expansion operations that records which cells and nets were added during expansion, enabling precise undo by removing only those elements and efficient redo by restoring them with cached layout state. The command integrates with the `ExpansionService` from the application layer and maintains state consistency across execute/undo/redo cycles.

### 1.2 Problem Context

When users expand a schematic view (e.g., double-click on a cell to reveal its fanout), the application needs to:

1. **Track what changed**: Record exactly which cells and nets became visible
2. **Enable undo**: Remove only the cells/nets added by this specific expansion (not other expansions)
3. **Optimize redo**: Restore cells with their exact layout positions instead of recomputing
4. **Support multiple expansion modes**: Hop-based and boundary-based expansion
5. **Handle errors gracefully**: Invalid targets, expansion failures, service errors

Without a robust expansion command implementation, undo/redo would be unreliable - users might accidentally remove more than intended, redo might place cells in different positions, and the system would lack a clear audit trail of what changed.

### 1.3 Goals

**Primary Goals**:
1. Implement `ExpansionCommand` extending `UndoableCommand` base class
2. Record cells and nets added during expansion for precise undo
3. Cache layout state for efficient redo (avoid full graph re-traversal)
4. Support both hop-based (N-level) and boundary-based (to sequential cells) expansion
5. Integrate seamlessly with `ExpansionService` from application layer
6. Generate human-readable descriptions for UI display

**Non-Goals**:
- Implementing the expansion algorithm itself (handled by `ExpansionService` in E03)
- Layout computation (handled by layout engine in E02)
- Undo stack management (separate task)
- Command serialization for session save/load (P1 feature)

---

## 2. Implementation Approach

### 2.1 High-Level Design

**Architecture Pattern**: Command Pattern with State Caching

```
┌─────────────────────────────────────────────────────────┐
│              ExpansionCommand                           │
├─────────────────────────────────────────────────────────┤
│ Fields:                                                 │
│ - _service: ExpansionService                           │
│ - _target: Union[CellId, PinId, NetId]                │
│ - _params: ExpansionParams (direction, mode, hops)    │
│ - _cells_added: Set[CellId]      # State cache         │
│ - _nets_added: Set[NetId]        # State cache         │
│ - _layout_state: Optional[dict]  # Position cache      │
├─────────────────────────────────────────────────────────┤
│ Methods:                                                │
│ + execute() -> CommandResult                           │
│   └─> service.expand(target, params)                  │
│   └─> Capture cells_added, nets_added, layout_state  │
│ + undo() -> CommandResult                              │
│   └─> service.collapse_specific(cells, nets)         │
│ + redo() -> CommandResult                              │
│   └─> service.expand_specific(cells, nets, layout)   │
│ + description() -> str                                 │
└─────────────────────────────────────────────────────────┘
          │
          │ uses
          ▼
┌─────────────────────────────────────────────────────────┐
│           ExpansionService                              │
├─────────────────────────────────────────────────────────┤
│ + expand(target, params) -> ExpansionResult            │
│ + collapse_specific(cells, nets) -> CommandResult     │
│ + expand_specific(cells, nets, layout) -> CommandResult│
│ + capture_layout_state(cells, nets) -> dict           │
└─────────────────────────────────────────────────────────┘
```

**Execution Flow**:
```
User Double-Clicks Cell
        │
        ▼
Create ExpansionCommand(target=cell, params={direction, mode, hops})
        │
        ▼
Execute Command
        ├─> Service.expand(target, params)
        │   └─> Graph traversal
        │   └─> Returns cells_added, nets_added
        ├─> Store cells_added, nets_added
        ├─> Capture layout state (positions, routing)
        └─> Mark as executed

Undo Command
        ├─> Service.collapse_specific(cells_added, nets_added)
        │   └─> Remove specific elements
        └─> Mark as not executed

Redo Command
        ├─> Service.expand_specific(cells_added, nets_added, layout_state)
        │   └─> Restore elements with cached positions
        └─> Mark as executed
```

### 2.2 Component Breakdown

#### Component 1: ExpansionParams Dataclass

**Purpose**: Encapsulate expansion parameters for type safety

```python
@dataclass
class ExpansionParams:
    direction: str  # "fanin" or "fanout"
    mode: str  # "hop" or "boundary"
    hop_count: int = 1  # Only used for hop mode
    include_boundary: bool = True  # Include sequential cells in boundary mode
```

**Validation**:
- `direction` must be "fanin" or "fanout"
- `mode` must be "hop" or "boundary"
- `hop_count` must be >= 1 (for hop mode)

#### Component 2: ExpansionResult Dataclass

**Purpose**: Return type from `ExpansionService.expand()`

```python
@dataclass
class ExpansionResult:
    success: bool
    cells_added: Set[CellId]
    nets_added: Set[NetId]
    error_message: Optional[str] = None
```

**Design Rationale**:
- Separates service result from command result
- Includes exact elements that were added (for undo)
- Follows same success/failure pattern as `CommandResult`

#### Component 3: ExpansionCommand Class

**Key State Variables**:
1. `_cells_added`: Set of cell IDs added during execute (immutable after first execute)
2. `_nets_added`: Set of net IDs added during execute (immutable after first execute)
3. `_layout_state`: Dictionary of positions/routing (cached for redo optimization)

**State Invariants**:
- After `execute()`: `_cells_added` and `_nets_added` are populated, all elements visible
- After `undo()`: All elements in `_cells_added` and `_nets_added` are hidden
- After `redo()`: Same state as after `execute()`, using cached layout
- Sets never change after first `execute()` (even across undo/redo cycles)

**Method Implementation Strategy**:

**execute()**:
```python
def execute(self) -> CommandResult:
    # 1. Call service to perform expansion
    result = self._service.expand(self._target, self._params)

    if not result.success:
        return CommandResult.fail(result.error_message)

    # 2. Record what was added
    self._cells_added = result.cells_added
    self._nets_added = result.nets_added

    # 3. Capture layout state for redo
    self._layout_state = self._service.capture_layout_state(
        self._cells_added, self._nets_added
    )

    # 4. Mark as executed
    self._mark_executed()

    return CommandResult.ok()
```

**undo()**:
```python
def undo(self) -> CommandResult:
    if not self.is_executed:
        return CommandResult.fail("Cannot undo: not executed")

    # Remove specific cells/nets that were added
    result = self._service.collapse_specific(
        self._cells_added, self._nets_added
    )

    if not result.success:
        return CommandResult.fail(result.error_message)

    self._mark_not_executed()
    return CommandResult.ok()
```

**redo()**:
```python
def redo(self) -> CommandResult:
    if self._layout_state is None:
        # First redo or cache unavailable - fall back to execute
        return self.execute()

    # Restore with cached layout positions
    result = self._service.expand_specific(
        self._cells_added, self._nets_added,
        layout_state=self._layout_state
    )

    if not result.success:
        # Fallback to full execute if restore fails
        return self.execute()

    self._mark_executed()
    return CommandResult.ok()
```

**description()**:
```python
def description(self) -> str:
    # Format: "Expand fanout (2 hops) from pin cell_1.OUT"
    target_desc = self._format_target(self._target)
    mode_desc = self._format_mode(self._params)
    return f"Expand {self._params.direction} ({mode_desc}) from {target_desc}"
```

### 2.3 Service Interface Extensions

**New methods required in `ExpansionService`**:

1. **expand()** (already exists from E03, may need parameter changes):
   ```python
   def expand(
       self,
       target: Union[CellId, PinId, NetId],
       params: ExpansionParams
   ) -> ExpansionResult
   ```

2. **collapse_specific()** (new for undo support):
   ```python
   def collapse_specific(
       self,
       cells: Set[CellId],
       nets: Set[NetId]
   ) -> CommandResult
   ```
   - Removes exactly the specified cells and nets
   - Used by undo to reverse expansion
   - Must handle cases where elements already removed by other operations

3. **expand_specific()** (new for redo optimization):
   ```python
   def expand_specific(
       self,
       cells: Set[CellId],
       nets: Set[NetId],
       layout_state: Optional[dict] = None
   ) -> CommandResult
   ```
   - Adds exactly the specified cells and nets
   - If `layout_state` provided, restores positions instead of recomputing
   - Used by redo to restore exact state

4. **capture_layout_state()** (new for caching):
   ```python
   def capture_layout_state(
       self,
       cells: Set[CellId],
       nets: Set[NetId]
   ) -> dict
   ```
   - Returns dictionary with cell positions and net routing paths
   - Format: `{cell_id: {pos: (x, y), ...}, net_id: {route: [...]}}`
   - Used to cache state for efficient redo

### 2.4 Layout State Cache Format

**Cache Structure**:
```python
{
    'cells': {
        'C1': {'x': 100, 'y': 200, 'width': 50, 'height': 30},
        'C2': {'x': 200, 'y': 200, 'width': 50, 'height': 30},
    },
    'nets': {
        'N1': {
            'route': [
                {'type': 'segment', 'start': (150, 215), 'end': (200, 215)},
                {'type': 'segment', 'start': (200, 215), 'end': (200, 215)},
            ]
        }
    }
}
```

**Cache Invalidation**: Cache remains valid unless:
- Design is reloaded (new file)
- Graph structure changes (unlikely in MVP)
- For MVP: assume cache always valid, add invalidation in P1 if needed

---

## 3. Key Design Decisions

### Decision 1: Store IDs vs Full Objects

**Context**: What should `_cells_added` and `_nets_added` store?

**Options**:
1. **Store full Cell/Net objects**
   - Pros: Direct access to properties
   - Cons: Large memory footprint, stale references if objects change

2. **Store IDs only** (chosen)
   - Pros: Minimal memory (~5KB per command), no stale references, enables serialization
   - Cons: Requires service lookup to access full objects

**Decision**: Store IDs only (`Set[CellId]`, `Set[NetId]`)

**Rationale**:
- Memory efficiency: 100 cells × 20 bytes/ID = 2KB vs 100 cells × 500 bytes/object = 50KB
- Avoids stale object references if cells are modified
- Service resolves IDs to current objects during undo/redo
- Future-proof for session save/load (IDs serialize easily)

### Decision 2: Cache Layout State for Redo

**Context**: Should redo recompute layout or restore from cache?

**Options**:
1. **Recompute layout on redo** - call `execute()` again
   - Pros: Simple, no extra memory
   - Cons: Slow, non-deterministic (cells may appear in different positions)

2. **Cache layout state** (chosen)
   - Pros: Fast redo, deterministic (cells return to exact positions)
   - Cons: Extra memory (~20KB per command)

**Decision**: Cache layout state in `_layout_state` dictionary

**Rationale**:
- User expectation: redo should restore exact visual state
- Performance: redo should be faster than initial execute
- Memory cost is acceptable (~20KB for 100 cells)
- Non-deterministic layout would be confusing (cells jump around)

### Decision 3: Separate expand() vs expand_specific()

**Context**: Should `ExpansionService` have one method or two for expansion?

**Options**:
1. **Single expand() method with optional cell/net sets**
   - Pros: Fewer methods
   - Cons: Confusing interface (when to pass cells vs target?)

2. **Separate methods** (chosen):
   - `expand(target, params)` - graph traversal, discover cells
   - `expand_specific(cells, nets, layout)` - just add known cells
   - Pros: Clear separation of concerns, explicit intent
   - Cons: More methods in service interface

**Decision**: Use separate methods

**Rationale**:
- `expand()` is for user-initiated expansion (graph traversal)
- `expand_specific()` is for redo (restore known state)
- Clear separation makes code easier to understand and test
- Avoids "magic" behavior based on parameter presence

### Decision 4: Redo Optimization Strategy

**Context**: How should redo handle cached state?

**Options**:
1. **Always fall back to execute()** if cache unavailable
2. **Fail redo if cache unavailable**
3. **Try expand_specific(), fall back to execute()** (chosen)

**Decision**: Try cached restore, fall back to full execute on failure

**Rationale**:
- Graceful degradation if cache is invalid
- User experience: redo always works (even if slower)
- Error handling: catch service failures, don't propagate to UI

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Internal**:
- **T01 - UndoableCommand**: Base class that `ExpansionCommand` extends
- **E03-F01**: `ExpansionService` with hop-based expansion
- **E03-F03**: `ExpansionService` with boundary-based expansion
- **E01**: Domain value objects (`CellId`, `NetId`, `PinId`)
- **E02**: Layout engine (indirectly via service for `capture_layout_state`)

**External**:
- Python standard library: `dataclasses`, `typing`

### 4.2 Downstream Consumers

**Immediate**:
- **UndoStack** (future task): Will push `ExpansionCommand` instances
- **E04-F04 - Keyboard Shortcuts**: Double-click handler creates and executes expansion commands

**Future (P1)**:
- **Session Persistence**: Serialize expansion commands for save/load
- **Macro Commands**: Combine multiple expansions into single undoable unit

### 4.3 Integration Points Checklist

- [ ] `ExpansionService` implements required new methods:
  - `collapse_specific(cells, nets)`
  - `expand_specific(cells, nets, layout_state)`
  - `capture_layout_state(cells, nets)`
- [ ] Domain value objects (`CellId`, `NetId`, `PinId`) are hashable for set operations
- [ ] Layout state format is compatible with rendering layer
- [ ] Error messages from service are user-friendly
- [ ] Command can be constructed without executing (validation happens in execute)

---

## 5. Testing Strategy

### 5.1 Unit Test Coverage

**Test File**: `tests/unit/application/commands/test_expansion_command.py`

**Test Scenarios**:

1. **Execute Success**:
   ```python
   def test_expansion_command_execute():
       """Execute expansion and record added cells/nets"""
       mock_service = Mock(spec=ExpansionService)
       mock_service.expand.return_value = ExpansionResult(
           success=True,
           cells_added={CellId("C1"), CellId("C2")},
           nets_added={NetId("N1")}
       )
       mock_service.capture_layout_state.return_value = {
           'cells': {'C1': {'x': 0, 'y': 0}, 'C2': {'x': 1, 'y': 0}}
       }

       cmd = ExpansionCommand(
           mock_service,
           target=PinId("C0", "OUT"),
           params=ExpansionParams(direction="fanout", mode="hop", hop_count=1)
       )

       result = cmd.execute()

       assert result.success
       assert cmd.is_executed
       assert cmd.cells_added == {CellId("C1"), CellId("C2")}
       assert cmd.nets_added == {NetId("N1")}
       mock_service.expand.assert_called_once_with(
           PinId("C0", "OUT"),
           ExpansionParams(direction="fanout", mode="hop", hop_count=1)
       )
   ```

2. **Execute Failure**:
   ```python
   def test_expansion_command_execute_failure():
       """Execute returns failure on service error"""
       mock_service = Mock(spec=ExpansionService)
       mock_service.expand.return_value = ExpansionResult(
           success=False,
           cells_added=set(),
           nets_added=set(),
           error_message="Target cell not found"
       )

       cmd = ExpansionCommand(...)
       result = cmd.execute()

       assert not result.success
       assert "not found" in result.error_message.lower()
       assert not cmd.is_executed
   ```

3. **Undo Success**:
   ```python
   def test_expansion_command_undo():
       """Undo removes specific cells/nets added by expansion"""
       mock_service = Mock(spec=ExpansionService)
       # ... setup execute ...
       cmd.execute()

       mock_service.collapse_specific.return_value = CommandResult.ok()
       result = cmd.undo()

       assert result.success
       assert not cmd.is_executed
       mock_service.collapse_specific.assert_called_once_with(
           {CellId("C1"), CellId("C2")},
           {NetId("N1")}
       )
   ```

4. **Redo with Cache**:
   ```python
   def test_expansion_command_redo_uses_cache():
       """Redo uses cached layout state instead of re-executing"""
       mock_service = Mock(spec=ExpansionService)
       layout_state = {'cells': {'C1': {'x': 0, 'y': 0}}}
       mock_service.capture_layout_state.return_value = layout_state
       # ... setup and execute ...
       cmd.execute()
       cmd.undo()

       mock_service.expand_specific.return_value = CommandResult.ok()
       result = cmd.redo()

       assert result.success
       assert cmd.is_executed
       mock_service.expand_specific.assert_called_once_with(
           {CellId("C1"), CellId("C2")},
           {NetId("N1")},
           layout_state=layout_state
       )
       # Verify expand() was NOT called again
       assert mock_service.expand.call_count == 1  # Only from initial execute
   ```

5. **Redo Fallback**:
   ```python
   def test_expansion_command_redo_fallback_on_failure():
       """Redo falls back to execute if expand_specific fails"""
       mock_service = Mock(spec=ExpansionService)
       # ... execute and undo ...

       mock_service.expand_specific.return_value = CommandResult.fail("Cache invalid")
       mock_service.expand.return_value = ExpansionResult(success=True, ...)

       result = cmd.redo()

       assert result.success
       mock_service.expand_specific.assert_called_once()
       mock_service.expand.assert_called()  # Fallback called
   ```

6. **Description Generation**:
   ```python
   def test_expansion_command_description_pin_target():
       cmd = ExpansionCommand(
           mock_service,
           target=PinId("C1", "OUT"),
           params=ExpansionParams(direction="fanout", mode="hop", hop_count=2)
       )

       desc = cmd.description()
       assert desc == "Expand fanout (2 hops) from pin C1.OUT"

   def test_expansion_command_description_boundary_mode():
       cmd = ExpansionCommand(
           mock_service,
           target=CellId("C1"),
           params=ExpansionParams(direction="fanin", mode="boundary")
       )

       desc = cmd.description()
       assert desc == "Expand fanin (to boundary) from cell C1"
   ```

7. **Multiple Undo/Redo Cycles**:
   ```python
   def test_expansion_command_multiple_cycles():
       """Test execute -> undo -> redo -> undo -> redo"""
       mock_service = Mock(spec=ExpansionService)
       # ... setup ...

       # First cycle
       cmd.execute()
       assert cmd.cells_added == {CellId("C1"), CellId("C2")}

       cmd.undo()
       assert not cmd.is_executed

       cmd.redo()
       assert cmd.is_executed

       # Second cycle
       cmd.undo()
       cmd.redo()

       # Verify sets never changed
       assert cmd.cells_added == {CellId("C1"), CellId("C2")}
       assert cmd.nets_added == {NetId("N1")}
   ```

### 5.2 Integration Tests

**Test File**: `tests/integration/application/test_expansion_command_integration.py`

**Scenarios**:
1. End-to-end with real `ExpansionService` (mock domain services)
2. Verify layout state capture and restore
3. Measure performance for various expansion sizes
4. Test multiple commands in sequence (verify independent undo)

### 5.3 Performance Tests

**Benchmarks**:
```python
@pytest.mark.benchmark
def test_execute_5_hop_expansion(benchmark, large_graph):
    """Execute should complete in <500ms for 5-hop expansion"""
    service = ExpansionService(large_graph)
    cmd = ExpansionCommand(
        service,
        target=CellId("XBUF_0"),
        params=ExpansionParams(direction="fanout", mode="hop", hop_count=5)
    )

    result = benchmark(cmd.execute)
    assert result.success
    assert benchmark.stats.mean < 0.5  # <500ms

@pytest.mark.benchmark
def test_undo_performance(benchmark, executed_expansion_cmd):
    """Undo should complete in <100ms"""
    result = benchmark(executed_expansion_cmd.undo)
    assert result.success
    assert benchmark.stats.mean < 0.1  # <100ms

@pytest.mark.benchmark
def test_redo_performance(benchmark, undone_expansion_cmd):
    """Redo should complete in <150ms (faster than execute)"""
    result = benchmark(undone_expansion_cmd.redo)
    assert result.success
    assert benchmark.stats.mean < 0.15  # <150ms
```

### 5.4 Coverage Target

- **Line Coverage**: 90%+ (allow for edge case error handling)
- **Branch Coverage**: 85%+ (many error paths)
- **Edge Cases**: Zero cells added, service failures, invalid targets

---

## 6. Risks and Considerations

### 6.1 Technical Risks

#### Risk 1: Layout State Cache Invalidation
**Impact**: Medium
**Probability**: Low (MVP only)

**Description**: If design is modified between undo and redo, cached layout state may become invalid (cells deleted, positions changed).

**Mitigation**:
- For MVP: assume design never changes (read-only)
- Redo falls back to `execute()` if `expand_specific()` fails
- Cache includes version/checksum (future enhancement)

**Contingency**: If users report redo issues, add cache validation before restore

#### Risk 2: ExpansionService Interface Changes
**Impact**: High
**Probability**: Medium

**Description**: `ExpansionService` may not support required new methods (`collapse_specific`, `expand_specific`, `capture_layout_state`) if E03 implementation differs from spec.

**Mitigation**:
- Coordinate with E03 implementer on service interface
- Create service interface tests before implementing command
- Use protocol/interface for service (dependency inversion)

**Contingency**: Implement missing methods in `ExpansionService` as part of this task

#### Risk 3: Memory Usage for Large Expansions
**Impact**: Medium
**Probability**: Low

**Description**: Large expansions (1000+ cells) may result in large layout state caches (>1MB per command).

**Mitigation**:
- Set memory budget: <20KB for 100 cells → <200KB for 1000 cells (acceptable)
- Profile memory usage in performance tests
- Compress cache if needed (pickle, gzip)

**Contingency**: Make layout caching optional via parameter (trade speed for memory)

### 6.2 Integration Risks

#### Risk 4: Cell/Net Already Removed by Another Operation
**Impact**: Low
**Probability**: Medium

**Description**: When undo calls `collapse_specific()`, some cells may already be hidden by another collapse command.

**Mitigation**:
- `collapse_specific()` should be idempotent (ignore already-hidden cells)
- Don't error if some cells missing, just remove what exists
- Log warning for debugging

**Contingency**: Return success if >50% of cells removed, failure only if 0% removed

#### Risk 5: Target Type Ambiguity
**Impact**: Low
**Probability**: Low

**Description**: `target` is `Union[CellId, PinId, NetId]`, may be confusing to determine which type.

**Mitigation**:
- Use `isinstance()` checks in `description()` method
- Service handles all target types uniformly
- Type hints prevent wrong types at compile time

**Contingency**: Add runtime validation in `execute()` if needed

### 6.3 Usability Risks

#### Risk 6: Confusing Description for Boundary Mode
**Impact**: Low
**Probability**: Medium

**Description**: "Expand fanout (to boundary)" may not be clear to users what "boundary" means.

**Mitigation**:
- Use clearer language: "to sequential cells" or "to latches"
- Add tooltip in UI explaining boundary mode
- Include cell count in description: "Expand fanout (23 cells added)"

**Contingency**: Make description format configurable in future

---

## 7. Open Questions

### Question 1: Should Empty Expansion Be Valid?
**Status**: Needs decision

If expansion returns zero cells (target already fully expanded), should command still be added to undo stack?

**Options**:
1. Add to stack, undo does nothing
2. Don't add to stack, treat as no-op
3. Return failure, notify user

**Recommendation**: Option 1 - add to stack, undo is idempotent. User may expect to see it in history.

### Question 2: Should Redo Reset Timestamp?
**Status**: Needs decision

When redo is called, should `_timestamp` be updated to current time or preserve original execute time?

**Recommendation**: Update timestamp to redo time. Timestamp represents "last executed", not "first executed".

### Question 3: How to Handle Power/Ground Nets?
**Status**: Deferred to E01

Should expansion include VDD/VSS nets in `_nets_added`?

**Decision**: Depends on E01 implementation. If power nets are filtered out, they won't appear in results. Accept whatever service returns.

---

## 8. Definition of Done

### 8.1 Code Complete
- [ ] `ExpansionParams` dataclass implemented
- [ ] `ExpansionResult` dataclass implemented
- [ ] `ExpansionCommand` class implemented extending `UndoableCommand`
- [ ] `execute()` method implemented with service integration
- [ ] `undo()` method implemented with `collapse_specific()` call
- [ ] `redo()` method implemented with cache optimization
- [ ] `description()` method generates readable text for all target types
- [ ] Properties implemented: `cells_added`, `nets_added`, `target`, `params`

### 8.2 Service Interface Extensions
- [ ] `ExpansionService.collapse_specific()` implemented or stubbed
- [ ] `ExpansionService.expand_specific()` implemented or stubbed
- [ ] `ExpansionService.capture_layout_state()` implemented or stubbed
- [ ] Service methods return expected types (`CommandResult`, `dict`)

### 8.3 Testing Complete
- [ ] Unit tests for execute success/failure
- [ ] Unit tests for undo success/failure
- [ ] Unit tests for redo with cache and fallback
- [ ] Unit tests for description generation (all target types)
- [ ] Unit tests for multiple undo/redo cycles
- [ ] Integration test with real service
- [ ] Performance tests meet targets (<500ms execute, <100ms undo, <150ms redo)
- [ ] 90%+ code coverage

### 8.4 Code Quality
- [ ] Type hints on all methods
- [ ] Docstrings on class and public methods
- [ ] `mypy --strict` passes
- [ ] `ruff check` passes
- [ ] No circular dependencies

### 8.5 Documentation
- [ ] Class docstring with usage examples
- [ ] Method docstrings explain behavior
- [ ] State invariants documented in comments
- [ ] Error handling strategy documented

---

## 9. Implementation Notes

### 9.1 File Structure

```
src/ink/application/commands/
├── __init__.py
├── undoable_command.py          # From T01
└── expansion_command.py         # This task
    ├── ExpansionParams
    ├── ExpansionResult
    └── ExpansionCommand

tests/unit/application/commands/
└── test_expansion_command.py

tests/integration/application/
└── test_expansion_command_integration.py
```

### 9.2 Import Structure

```python
# src/ink/application/commands/__init__.py
from .undoable_command import UndoableCommand, CommandResult
from .expansion_command import (
    ExpansionCommand,
    ExpansionParams,
    ExpansionResult,
)

__all__ = [
    'UndoableCommand',
    'CommandResult',
    'ExpansionCommand',
    'ExpansionParams',
    'ExpansionResult',
]
```

### 9.3 Example Usage

```python
# Create expansion command
from ink.application.commands import ExpansionCommand, ExpansionParams
from ink.domain.value_objects.identifiers import PinId

cmd = ExpansionCommand(
    expansion_service,
    target=PinId("XINV_1", "OUT"),
    params=ExpansionParams(
        direction="fanout",
        mode="hop",
        hop_count=2
    )
)

# Execute
result = cmd.execute()
if result.success:
    print(f"Expanded: added {len(cmd.cells_added)} cells")
else:
    print(f"Failed: {result.error_message}")

# Undo
result = cmd.undo()

# Redo
result = cmd.redo()
```

---

## 10. Next Steps

### 10.1 Immediate Actions
1. Verify `ExpansionService` interface from E03 matches requirements
2. Create stub implementations for new service methods if needed
3. Implement `ExpansionParams` and `ExpansionResult` dataclasses
4. Implement `ExpansionCommand` class
5. Write unit tests with mocked service
6. Write integration tests with real service

### 10.2 Coordination Required
- [ ] Sync with E03 implementer on service interface
- [ ] Sync with E02 on layout state format
- [ ] Confirm domain value objects are hashable

### 10.3 After Task Completion
1. Update `CHANGELOG.md`
2. Create PR for review
3. Merge to feature branch
4. Proceed to T03 (CollapseCommand implementation)

---

## Document Revision History

| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 1.0 | Claude Sonnet 4.5 | Initial pre-implementation documentation |

---

**End of Pre-Implementation Documentation**
