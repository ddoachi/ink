# E04-F04-T01 - Shortcut Manager: Pre-Implementation Documentation

## Document Information

- **Task ID**: E04-F04-T01
- **Task Title**: Shortcut Manager (Central Registry)
- **Document Type**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Status**: Planning
- **Target Release**: MVP (P0)
- **Estimated Hours**: 4
- **Effort**: Medium

---

## 1. Overview

### 1.1 Executive Summary

This task establishes the foundational keyboard shortcut infrastructure for Ink. The `ShortcutManager` provides a centralized registry for all keyboard shortcuts in the application, ensuring consistency, preventing conflicts, and enabling future customization. This is the foundational task for the E04-F04 (Keyboard Shortcuts) feature, and all subsequent shortcut implementations depend on it.

### 1.2 Problem Context

Without centralized shortcut management, keyboard shortcuts would be scattered across individual widgets and components, leading to:
- **Shortcut Conflicts**: Multiple widgets registering the same key sequence for different actions
- **Maintenance Burden**: Changing a shortcut requires hunting through multiple files
- **Inconsistent Behavior**: Same action might have different shortcuts in different contexts
- **No Customization Path**: Future user-configurable shortcuts would require significant refactoring

The `ShortcutManager` solves these problems by providing a single source of truth for all keyboard bindings.

### 1.3 Scope

**In Scope:**
- `ShortcutManager` class for registering and managing shortcuts
- Centralized `SHORTCUTS` configuration dictionary
- Platform-aware shortcuts using `QKeySequence.StandardKey`
- Multiple key sequences for the same action (e.g., Delete + Backspace)
- Enable/disable functionality for context-aware shortcuts
- Human-readable shortcut text for UI display
- Shortcut descriptions and categorization for help dialog

**Out of Scope (Future Work):**
- User-customizable shortcuts (P1)
- Shortcut conflict detection and warnings (P1)
- Persistence of custom shortcuts to settings (P1)
- Import/export of shortcut configurations (P1)
- Recording/macro functionality

---

## 2. Architecture Decisions

### 2.1 Centralized Registry Pattern

#### Decision: Single ShortcutManager instance in MainWindow

**Rationale:**
- Single source of truth prevents duplication and conflicts
- Easy to query all registered shortcuts for documentation
- Simplifies future customization features
- Clear ownership and lifecycle management

**Design:**

```python
# src/ink/presentation/shortcuts/shortcut_manager.py
from typing import Dict, List, Union, Callable
from PySide6.QtWidgets import QMainWindow
from PySide6.QtGui import QShortcut, QKeySequence
from PySide6.QtCore import Qt

class ShortcutManager:
    """
    Centralized keyboard shortcut management for the application.

    Manages registration, enable/disable, and documentation of all
    keyboard shortcuts. Each shortcut is identified by a unique name
    and can have multiple key sequences.
    """

    def __init__(self, main_window: QMainWindow):
        self._window = main_window
        self._shortcuts: Dict[str, List[QShortcut]] = {}

    def register_shortcut(
        self,
        name: str,
        key_sequence: Union[QKeySequence, QKeySequence.StandardKey, List[...]],
        callback: Callable[[], None],
        context: Qt.ShortcutContext = Qt.ShortcutContext.WindowShortcut
    ) -> None:
        """Register a keyboard shortcut with one or more key sequences."""

    def enable_shortcut(self, name: str, enabled: bool = True) -> None:
        """Enable or disable a registered shortcut."""

    def get_shortcut_text(self, name: str) -> str:
        """Get human-readable shortcut text for UI display."""
```

**Alternatives Considered:**

1. **Distributed Shortcut Management** (Each widget manages its own)
   - ✅ Simpler initial implementation
   - ❌ No way to prevent conflicts
   - ❌ Difficult to document all shortcuts
   - ❌ Hard to implement customization later

2. **QAction-based System** (Use QActions for all shortcuts)
   - ✅ Qt's standard pattern
   - ✅ Automatic menu integration
   - ❌ Not all shortcuts have corresponding menu actions
   - ❌ More boilerplate code
   - Decision: We'll use this for menu actions in T04, but not for all shortcuts

3. **Hybrid Approach** (Actions + Direct Shortcuts)
   - ✅ Flexibility for different use cases
   - ✅ Menu actions automatically show shortcuts
   - ✅ Non-menu shortcuts still centralized
   - ✅ Best of both worlds
   - **This is our chosen approach**

### 2.2 Configuration Structure

#### Decision: Separate configuration file with type annotations

**Rationale:**
- Separates data from logic
- Easy to review all shortcuts at a glance
- Type hints enable IDE autocomplete and type checking
- Clear structure for future JSON/YAML export

**Design:**

```python
# src/ink/presentation/shortcuts/shortcut_config.py
from PySide6.QtGui import QKeySequence
from PySide6.QtCore import Qt
from typing import Union, List

# Type alias for clarity
ShortcutDef = Union[
    QKeySequence,
    QKeySequence.StandardKey,
    List[Union[QKeySequence, QKeySequence.StandardKey]]
]

# Global shortcut configuration
SHORTCUTS: dict[str, ShortcutDef] = {
    # Platform-aware shortcuts using StandardKey
    "undo": QKeySequence.StandardKey.Undo,  # Ctrl+Z / Cmd+Z
    "redo": QKeySequence.StandardKey.Redo,  # Ctrl+Y / Cmd+Shift+Z

    # Multiple sequences for same action
    "collapse_selected": [
        QKeySequence.StandardKey.Delete,
        QKeySequence(Qt.Key.Key_Backspace)
    ],

    # Custom shortcuts
    "search": QKeySequence("Ctrl+F"),
    # ... more shortcuts
}

# Human-readable descriptions for help dialog
SHORTCUT_DESCRIPTIONS: dict[str, str] = {
    "undo": "Undo last action",
    "redo": "Redo last undone action",
    "collapse_selected": "Collapse selected objects",
    # ... more descriptions
}

# Categorization for help dialog organization
SHORTCUT_CATEGORIES = {
    "Navigation": ["search", "navigate_forward", "navigate_back"],
    "Editing": ["undo", "redo", "collapse_selected", "expand_selected"],
    # ... more categories
}
```

### 2.3 Platform Awareness

#### Decision: Use QKeySequence.StandardKey for common operations

**Rationale:**
- Qt automatically handles platform differences (Ctrl vs Cmd, etc.)
- Consistent with native applications on each platform
- Less maintenance burden (no manual platform detection)
- Better user experience (matches user expectations)

**Platform Differences Handled:**

| Action | Windows/Linux | macOS |
|--------|---------------|-------|
| Undo | Ctrl+Z | Cmd+Z |
| Redo | Ctrl+Y | Cmd+Shift+Z |
| Copy | Ctrl+C | Cmd+C |
| Open | Ctrl+O | Cmd+O |
| Save | Ctrl+S | Cmd+S |
| Quit | Ctrl+Q | Cmd+Q |
| Zoom In | Ctrl++ | Cmd++ |

---

## 3. Implementation Approach

### 3.1 Development Phases

#### Phase 1: Core ShortcutManager Implementation (1 hour)

**Deliverables:**
- `ShortcutManager` class with `register_shortcut()` method
- Support for single and multiple key sequences
- Support for `QKeySequence.StandardKey` enum values
- Enable/disable functionality

**Implementation Steps:**
1. Create `src/ink/presentation/shortcuts/` directory
2. Implement `ShortcutManager` class
3. Handle list vs single key sequence normalization
4. Store `QShortcut` objects in dictionary by name
5. Implement enable/disable methods

**Key Code Sections:**

```python
def register_shortcut(self, name: str, key_sequence: ..., callback: ..., context: ...):
    # Normalize to list
    sequences = [key_sequence] if not isinstance(key_sequence, list) else key_sequence
    shortcuts = []

    for seq in sequences:
        # Handle StandardKey enum
        if isinstance(seq, QKeySequence.StandardKey):
            shortcut = QShortcut(QKeySequence(seq), self._window)
        else:
            shortcut = QShortcut(seq, self._window)

        shortcut.setContext(context)
        shortcut.activated.connect(callback)
        shortcuts.append(shortcut)

    self._shortcuts[name] = shortcuts
```

#### Phase 2: Configuration File (1 hour)

**Deliverables:**
- `SHORTCUTS` dictionary with all MVP shortcuts defined
- `SHORTCUT_DESCRIPTIONS` for help documentation
- `SHORTCUT_CATEGORIES` for help dialog organization

**Implementation Steps:**
1. Create `shortcut_config.py` file
2. Define `ShortcutDef` type alias
3. Populate `SHORTCUTS` with all actions from spec
4. Write descriptions for each shortcut
5. Organize shortcuts into logical categories

#### Phase 3: Utility Methods (1 hour)

**Deliverables:**
- `get_shortcut_text()` for UI display
- `get_all_shortcuts()` for bulk queries
- `unregister_shortcut()` for cleanup

**Implementation Steps:**
1. Implement shortcut text formatting
2. Handle multiple sequences (comma-separated display)
3. Add bulk query method
4. Add cleanup/unregister method

**Key Code Sections:**

```python
def get_shortcut_text(self, name: str) -> str:
    if name not in self._shortcuts:
        return ""

    # Get text from each QShortcut and join with comma
    sequences = [sc.key().toString() for sc in self._shortcuts[name]]
    return ", ".join(sequences)
```

#### Phase 4: Integration and Testing (1 hour)

**Deliverables:**
- `ShortcutManager` initialized in `MainWindow`
- Unit tests for all public methods
- Integration test with `MainWindow`

**Implementation Steps:**
1. Add `ShortcutManager` initialization in `MainWindow.__init__()`
2. Write unit tests for registration
3. Write unit tests for enable/disable
4. Write unit tests for text formatting
5. Write integration test

### 3.2 Key Design Decisions

**1. Shortcut Context**

Decision: Default to `Qt.ShortcutContext.WindowShortcut`

**Rationale:**
- Scoped to main window, not application-wide
- Prevents conflicts with system shortcuts
- More predictable behavior
- Can override for specific cases (e.g., widget-specific shortcuts)

**2. Multiple Key Sequences**

Decision: Store as list internally, always

**Rationale:**
- Simplifies internal logic (no special cases)
- Easy to add additional sequences later
- Clean iteration for enable/disable

**3. Error Handling**

Decision: Raise exceptions for invalid operations, don't fail silently

**Rationale:**
- Easier to catch bugs during development
- Clear contract for API users
- Better than silently ignoring errors

```python
def enable_shortcut(self, name: str, enabled: bool = True) -> None:
    if name not in self._shortcuts:
        # Option 1: Raise exception (chosen)
        raise KeyError(f"No shortcut registered with name: {name}")

        # Option 2: Fail silently (rejected)
        # return
```

### 3.3 Integration Points

**With MainWindow:**
- `ShortcutManager` created in `MainWindow.__init__()`
- Reference stored as `self.shortcut_manager`
- Shortcuts registered in `_register_shortcuts()` method

**With Future Tasks:**
- T02 (Navigation Shortcuts): Uses `register_shortcut()` for zoom, pan, fit, search
- T03 (Action Shortcuts): Uses `register_shortcut()` for undo, redo, expand, collapse
- T04 (Documentation): Uses `get_shortcut_text()` and `get_all_shortcuts()` for help dialog

---

## 4. Testing Strategy

### 4.1 Unit Tests

**Test Coverage Target**: >95% (core infrastructure)

**Key Test Cases:**

```python
# tests/unit/presentation/shortcuts/test_shortcut_manager.py
from PySide6.QtWidgets import QMainWindow
from PySide6.QtGui import QKeySequence
from PySide6.QtCore import Qt
import pytest

class TestShortcutManager:
    @pytest.fixture
    def main_window(self, qtbot):
        window = QMainWindow()
        qtbot.addWidget(window)
        return window

    @pytest.fixture
    def manager(self, main_window):
        return ShortcutManager(main_window)

    def test_register_single_shortcut(self, manager):
        """Test registering a single key sequence."""
        called = False
        def callback():
            nonlocal called
            called = True

        manager.register_shortcut("test", QKeySequence("Ctrl+T"), callback)

        # Verify shortcut registered
        assert "test" in manager._shortcuts
        assert len(manager._shortcuts["test"]) == 1

    def test_register_multiple_shortcuts(self, manager):
        """Test registering multiple key sequences for same action."""
        called = False
        def callback():
            nonlocal called
            called = True

        manager.register_shortcut(
            "delete",
            [QKeySequence.StandardKey.Delete, QKeySequence(Qt.Key.Key_Backspace)],
            callback
        )

        # Verify both shortcuts registered
        assert "delete" in manager._shortcuts
        assert len(manager._shortcuts["delete"]) == 2

    def test_enable_disable_shortcut(self, manager):
        """Test enabling and disabling shortcuts."""
        manager.register_shortcut("test", QKeySequence("Ctrl+T"), lambda: None)

        # Disable
        manager.disable_shortcut("test")
        for shortcut in manager._shortcuts["test"]:
            assert not shortcut.isEnabled()

        # Re-enable
        manager.enable_shortcut("test")
        for shortcut in manager._shortcuts["test"]:
            assert shortcut.isEnabled()

    def test_get_shortcut_text_single(self, manager):
        """Test getting text for single shortcut."""
        manager.register_shortcut("test", QKeySequence("Ctrl+T"), lambda: None)

        text = manager.get_shortcut_text("test")
        assert text == "Ctrl+T"

    def test_get_shortcut_text_multiple(self, manager):
        """Test getting text for multiple shortcuts (comma-separated)."""
        manager.register_shortcut(
            "delete",
            [QKeySequence.StandardKey.Delete, QKeySequence(Qt.Key.Key_Backspace)],
            lambda: None
        )

        text = manager.get_shortcut_text("delete")
        # Should be comma-separated
        assert "," in text
        assert "Del" in text or "Delete" in text
        assert "Backspace" in text

    def test_standard_key_shortcuts(self, manager):
        """Test platform-aware StandardKey shortcuts."""
        manager.register_shortcut("undo", QKeySequence.StandardKey.Undo, lambda: None)

        # Should have created shortcut
        assert "undo" in manager._shortcuts

        # Text should be platform-appropriate
        text = manager.get_shortcut_text("undo")
        assert len(text) > 0  # Should have some text

    def test_unregister_shortcut(self, manager):
        """Test unregistering a shortcut."""
        manager.register_shortcut("test", QKeySequence("Ctrl+T"), lambda: None)
        assert "test" in manager._shortcuts

        manager.unregister_shortcut("test")
        assert "test" not in manager._shortcuts

    def test_get_all_shortcuts(self, manager):
        """Test getting all shortcuts as dictionary."""
        manager.register_shortcut("undo", QKeySequence("Ctrl+Z"), lambda: None)
        manager.register_shortcut("redo", QKeySequence("Ctrl+Y"), lambda: None)

        all_shortcuts = manager.get_all_shortcuts()

        assert "undo" in all_shortcuts
        assert "redo" in all_shortcuts
        assert all_shortcuts["undo"] == "Ctrl+Z"
        assert all_shortcuts["redo"] == "Ctrl+Y"
```

### 4.2 Integration Tests

**Test Scenarios:**

```python
# tests/integration/presentation/test_shortcut_integration.py
def test_shortcut_manager_in_main_window(qtbot):
    """Test ShortcutManager integration in MainWindow."""
    from ink.presentation.main_window import MainWindow

    window = MainWindow()
    qtbot.addWidget(window)

    # Verify manager exists
    assert hasattr(window, 'shortcut_manager')
    assert isinstance(window.shortcut_manager, ShortcutManager)

def test_shortcut_activation(qtbot, main_window):
    """Test that registered shortcuts actually trigger callbacks."""
    manager = ShortcutManager(main_window)

    called = False
    def callback():
        nonlocal called
        called = True

    manager.register_shortcut("test", QKeySequence("Ctrl+T"), callback)

    # Simulate Ctrl+T
    qtbot.keyClick(main_window, Qt.Key.Key_T, Qt.KeyboardModifier.ControlModifier)

    # Callback should have been called
    assert called
```

### 4.3 Manual Testing Checklist

- [ ] `ShortcutManager` initializes without errors in `MainWindow`
- [ ] Registering shortcuts doesn't raise exceptions
- [ ] Platform-aware shortcuts (Undo, Redo) show correct key for OS
- [ ] Multiple shortcuts for same action both work
- [ ] Enable/disable affects all shortcuts for an action
- [ ] `get_shortcut_text()` formats multiple shortcuts correctly
- [ ] No memory leaks when registering/unregistering many shortcuts

---

## 5. Risks and Considerations

### 5.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Platform-specific shortcut issues** | Medium | Low | Use `QKeySequence.StandardKey` for all common operations, test on Linux (primary platform) |
| **Shortcut conflicts with Qt defaults** | Low | Medium | Use `WindowShortcut` context instead of `ApplicationShortcut`, audit Qt default shortcuts |
| **Memory leaks from QShortcut objects** | High | Low | Implement proper cleanup in `unregister_shortcut()`, store shortcuts with parent window for automatic cleanup |
| **Callback lifecycle issues** | Medium | Low | Use weak references if callbacks are bound methods (P1 enhancement) |

### 5.2 Design Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Future customization requires refactoring** | Medium | Medium | Design with extensibility in mind, use clear data structures that can be serialized |
| **Hard to add context-specific shortcuts later** | Low | Low | Support `context` parameter in `register_shortcut()`, document pattern |
| **Shortcut text formatting inconsistent** | Low | High | Use Qt's `toString()` method consistently, add tests for formatting |

### 5.3 Integration Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **MainWindow not yet implemented** | High | Low | Coordinate with E04 main implementation, stub if needed |
| **Conflicts with future menu system** | Medium | Low | Design to support both direct shortcuts and menu actions (hybrid approach) |

### 5.4 Assumptions

1. **MainWindow exists and is a QMainWindow**: Required for `QShortcut` parent
2. **Single main window**: MVP has one window, no multi-window scenarios
3. **No dynamic shortcut changes during runtime**: All shortcuts registered at startup (customization is P1)
4. **Linux primary platform**: macOS/Windows testing is secondary

---

## 6. Dependencies

### 6.1 Upstream Dependencies

**Hard Dependencies:**
- PySide6 installed and importable
- `MainWindow` class exists (or stub for testing)
- Qt event loop running (for shortcut activation)

**Soft Dependencies:**
- None (this is a foundational task)

### 6.2 Downstream Dependencies

**This task is a dependency for:**
- E04-F04-T02 (Navigation Shortcuts): Uses `ShortcutManager.register_shortcut()`
- E04-F04-T03 (Action Shortcuts): Uses `ShortcutManager.register_shortcut()`
- E04-F04-T04 (Documentation): Uses `ShortcutManager.get_shortcut_text()` and config

**Interfaces Provided:**
- `ShortcutManager.register_shortcut()`: Register new shortcuts
- `ShortcutManager.enable_shortcut()`: Enable/disable shortcuts
- `ShortcutManager.get_shortcut_text()`: Get display text
- `SHORTCUTS` config: Central shortcut definitions
- `SHORTCUT_DESCRIPTIONS` config: Help text
- `SHORTCUT_CATEGORIES` config: Categorization

---

## 7. Success Criteria

### 7.1 Functional Completeness

- [ ] `ShortcutManager` class implemented with all specified methods
- [ ] `SHORTCUTS` configuration complete with all MVP shortcuts
- [ ] `SHORTCUT_DESCRIPTIONS` and `SHORTCUT_CATEGORIES` populated
- [ ] Support for single and multiple key sequences
- [ ] Support for `QKeySequence.StandardKey` enum
- [ ] Enable/disable functionality working
- [ ] Human-readable text formatting working
- [ ] Integration with `MainWindow` complete

### 7.2 Quality Criteria

- [ ] Unit test coverage >95%
- [ ] All unit tests passing
- [ ] Integration tests passing
- [ ] No type errors (mypy passes)
- [ ] No linting errors (ruff passes)
- [ ] Code review approved

### 7.3 Documentation

- [ ] All public methods have docstrings
- [ ] Type hints on all function signatures
- [ ] Configuration file has explanatory comments
- [ ] Pre-docs and post-docs updated

### 7.4 Non-Functional

- [ ] Shortcut registration takes <1ms per shortcut
- [ ] No memory leaks in register/unregister cycles
- [ ] Clean separation of concerns (manager vs config)

---

## 8. Open Questions

### 8.1 Technical Questions

1. **Q: Should we support shortcut sequences (e.g., Ctrl+K, Ctrl+S)?**
   - A: No for MVP, single-key shortcuts only. Multi-step sequences are P1 enhancement.

2. **Q: How to handle shortcut conflicts if multiple widgets register same key?**
   - A: Use `WindowShortcut` context and careful registration. Add conflict detection in P1.

3. **Q: Should callbacks be stored as weak references to prevent memory leaks?**
   - A: No for MVP (all callbacks are methods on long-lived MainWindow). Consider for P1 if needed.

### 8.2 UX Questions

1. **Q: How should multiple shortcuts be displayed in UI (Delete, Backspace)?**
   - A: Comma-separated for MVP ("Delete, Backspace"). Consider better formatting in P1.

2. **Q: Should disabled shortcuts be visually indicated in menus?**
   - A: Yes, Qt handles this automatically when shortcuts are disabled. Document behavior.

---

## 9. Implementation Checklist

### 9.1 Pre-Implementation

- [ ] Review E04-F04 feature spec
- [ ] Review Qt QShortcut documentation
- [ ] Confirm MainWindow exists or create stub
- [ ] Set up test fixtures

### 9.2 Implementation

- [ ] Create `src/ink/presentation/shortcuts/` directory
- [ ] Implement `ShortcutManager` class
- [ ] Implement `shortcut_config.py` with all shortcuts
- [ ] Add `ShortcutManager` to `MainWindow`
- [ ] Implement utility methods (get_text, get_all, unregister)

### 9.3 Testing

- [ ] Write unit tests for `ShortcutManager`
- [ ] Write unit tests for configuration
- [ ] Write integration tests
- [ ] Run manual testing checklist
- [ ] Performance testing (registration time)

### 9.4 Documentation

- [ ] Add docstrings to all public methods
- [ ] Add comments to configuration file
- [ ] Update post-docs with implementation notes
- [ ] Document any deviations from spec

### 9.5 Review and Cleanup

- [ ] Run mypy type checking
- [ ] Run ruff linting
- [ ] Code review
- [ ] Address review feedback
- [ ] Final testing pass

---

## 10. References

### 10.1 Internal Documents

- [E04-F04 Feature Spec](../E04-F04.spec.md)
- [E04-F04-T01 Task Spec](./E04-F04-T01.spec.md)
- [PRD Section 7.3 - Keyboard Shortcuts](../../../../docs/prd.md)

### 10.2 Qt Documentation

- [QShortcut Class](https://doc.qt.io/qt-6/qshortcut.html)
- [QKeySequence Class](https://doc.qt.io/qt-6/qkeysequence.html)
- [QKeySequence.StandardKey](https://doc.qt.io/qt-6/qkeysequence.html#StandardKey-enum)
- [Qt Shortcut Context](https://doc.qt.io/qt-6/qt.html#ShortcutContext-enum)

### 10.3 Design Patterns

- **Registry Pattern**: Central storage and lookup of shortcuts
- **Facade Pattern**: Simplified interface over Qt's QShortcut
- **Strategy Pattern**: Different handling for StandardKey vs custom sequences

---

**End of Pre-Implementation Documentation**
