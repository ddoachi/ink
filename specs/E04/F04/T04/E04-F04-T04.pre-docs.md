# E04-F04-T04 - Shortcut Documentation and Help Dialog: Pre-Implementation Documentation

## Document Information

- **Task ID**: E04-F04-T04
- **Task Title**: Shortcut Documentation and Help Dialog
- **Document Type**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Status**: Planning
- **Target Release**: MVP (P0)
- **Estimated Hours**: 4
- **Effort**: Medium

---

## 1. Overview

### 1.1 Executive Summary

This task makes keyboard shortcuts discoverable and usable by implementing visible documentation throughout the UI. Without visible documentation, shortcuts remain hidden features that only power users discover by chance. This task ensures all users can learn and leverage keyboard shortcuts through menu hints, tooltips, and a comprehensive help dialog.

Good shortcut documentation transforms shortcuts from "expert features" to "accessible productivity tools," significantly improving the user experience and reducing the learning curve.

### 1.2 Problem Context

Even with fully functional keyboard shortcuts implemented in T01-T03, users face discoverability challenges:

- **Hidden Functionality**: Users don't know shortcuts exist unless they read documentation
- **Learning Curve**: Users must memorize shortcuts without reference
- **Inconsistent Experience**: Mouse users miss productivity gains from keyboard access
- **Support Burden**: Users ask "how do I do X?" when a shortcut exists

Without in-app documentation:
- New users default to mouse-only workflows (slower)
- Shortcuts become "power user secrets" rather than accessible features
- Users reinvent workarounds for operations that have simple shortcuts
- Training and onboarding require external documentation

### 1.3 Scope

**In Scope:**
- Display shortcuts in menu items (automatically via Qt)
- Add shortcut hints to toolbar button tooltips
- Create keyboard shortcuts help dialog (`F1`)
- Organize shortcuts by category in help dialog
- Human-readable shortcut text formatting
- Help menu integration
- Code comments documenting shortcut configuration

**Out of Scope (Future Work):**
- Searchable shortcuts help dialog (P1)
- Printable/exportable shortcuts reference (P1)
- Interactive shortcut tutorial or guided tour (P1)
- Customizable shortcuts UI (P1)
- Keyboard shortcut conflict warnings (P1)
- Context-sensitive help (P1)

---

## 2. Architecture Decisions

### 2.1 Menu Integration Strategy

#### Decision: Use QAction.setShortcut() for automatic display

**Rationale:**
- Qt automatically displays shortcuts in menu items when using `QAction`
- No manual formatting or layout needed
- Consistent with platform conventions (shortcuts on right side of menu)
- Shortcut changes automatically reflected in menu
- Standard Qt pattern, well-tested

**Design:**

```python
# src/ink/presentation/main_window.py
def _create_menus(self) -> None:
    """Create menu bar with shortcuts displayed."""
    menubar = self.menuBar()

    # File menu
    file_menu = menubar.addMenu("&File")

    open_action = QAction("&Open...", self)
    open_action.setShortcut(SHORTCUTS["open"])
    open_action.triggered.connect(self._on_open_file)
    file_menu.addAction(open_action)

    # Qt automatically displays "Ctrl+O" on right side of menu item

    # Edit menu
    edit_menu = menubar.addMenu("&Edit")

    undo_action = QAction("&Undo", self)
    undo_action.setShortcut(SHORTCUTS["undo"])
    undo_action.triggered.connect(self._on_undo)
    edit_menu.addAction(undo_action)
    # Qt displays platform-appropriate shortcut (Ctrl+Z, Cmd+Z)
```

**Platform-Specific Rendering:**

Qt automatically formats shortcuts according to platform conventions:

| Platform | Display Format |
|----------|----------------|
| Windows | Ctrl+O, Ctrl+Z |
| Linux | Ctrl+O, Ctrl+Z |
| macOS | ⌘O, ⌘Z (uses symbols) |

**Alternatives Considered:**

1. **Manual menu text with shortcuts**
   - Example: `"Open (Ctrl+O)"`
   - ❌ Manual formatting, error-prone
   - ❌ Not platform-aware
   - ❌ Harder to maintain

2. **Separate label widget in menu**
   - ✅ More control over formatting
   - ❌ Non-standard, complex
   - ❌ Doesn't match platform conventions

3. **QAction with setShortcut() (chosen)**
   - ✅ Automatic, platform-aware
   - ✅ Standard Qt pattern
   - ✅ Zero maintenance

### 2.2 Tooltip Integration Strategy

#### Decision: Dynamically append shortcuts to tooltip text

**Rationale:**
- Tooltips are already used for toolbar buttons
- Adding shortcut hint makes tooltip more informative
- Uses `ShortcutManager.get_shortcut_text()` for consistency
- Simple concatenation pattern

**Design:**

```python
def _create_toolbar(self) -> None:
    """Create toolbar with shortcut hints in tooltips."""
    toolbar = self.addToolBar("Main Toolbar")

    # Expand button
    expand_button = toolbar.addAction("Expand")
    expand_button.setToolTip(
        f"Expand selected cell/pin/net ({self.shortcut_manager.get_shortcut_text('expand_selected')})"
    )
    expand_button.triggered.connect(self._on_expand_selected)

    # Zoom in button
    zoom_in_button = toolbar.addAction("Zoom In")
    zoom_in_button.setToolTip(
        f"Zoom in ({self.shortcut_manager.get_shortcut_text('zoom_in')})"
    )
```

**Tooltip Format:**
```
Action description (Shortcut)

Examples:
- "Expand selected cell/pin/net (Enter)"
- "Zoom in (Ctrl+=, +)"
- "Undo (Ctrl+Z)"
```

### 2.3 Help Dialog Design

#### Decision: Modal dialog with categorized tables

**Rationale:**
- Categorization makes shortcuts easy to find
- Tables provide clean two-column layout (shortcut | description)
- Modal dialog focuses user attention
- Separate table per category improves scannability
- Keyboard navigable for accessibility

**Design:**

```python
# src/ink/presentation/dialogs/shortcuts_dialog.py
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QTableWidget, QTableWidgetItem,
    QHeaderView, QPushButton, QHBoxLayout, QLabel
)
from PySide6.QtCore import Qt

class ShortcutsDialog(QDialog):
    """
    Keyboard shortcuts help dialog.

    Displays all registered shortcuts organized by category.
    Each category has its own table for improved scannability.
    """

    def __init__(self, shortcut_manager: ShortcutManager, parent=None):
        super().__init__(parent)
        self.shortcut_manager = shortcut_manager
        self.setWindowTitle("Keyboard Shortcuts")
        self.setMinimumSize(600, 500)
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Setup dialog UI with categorized tables."""
        layout = QVBoxLayout(self)

        # Title
        title_label = QLabel("Keyboard Shortcuts")
        title_label.setStyleSheet("font-size: 14pt; font-weight: bold;")
        layout.addWidget(title_label)

        # Create table for each category
        for category, shortcut_names in SHORTCUT_CATEGORIES.items():
            # Category header
            category_label = QLabel(category)
            category_label.setStyleSheet(
                "font-size: 11pt; font-weight: bold; margin-top: 10px;"
            )
            layout.addWidget(category_label)

            # Category table
            table = self._create_category_table(shortcut_names)
            layout.addWidget(table)

        # Close button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        close_button = QPushButton("Close")
        close_button.clicked.connect(self.accept)
        button_layout.addWidget(close_button)
        layout.addLayout(button_layout)

    def _create_category_table(self, shortcut_names: list[str]) -> QTableWidget:
        """Create table for a category of shortcuts."""
        table = QTableWidget(len(shortcut_names), 2)
        table.setHorizontalHeaderLabels(["Shortcut", "Description"])
        table.verticalHeader().setVisible(False)
        table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)

        # Configure columns
        header = table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)

        # Populate table
        for row, name in enumerate(shortcut_names):
            # Shortcut text
            shortcut_text = self.shortcut_manager.get_shortcut_text(name)
            shortcut_item = QTableWidgetItem(shortcut_text)
            shortcut_item.setTextAlignment(
                Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
            )
            table.setItem(row, 0, shortcut_item)

            # Description
            description = SHORTCUT_DESCRIPTIONS.get(name, "")
            desc_item = QTableWidgetItem(description)
            desc_item.setTextAlignment(
                Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter
            )
            table.setItem(row, 1, desc_item)

        # Adjust row heights
        table.resizeRowsToContents()

        # Set fixed height based on content
        total_height = (
            table.verticalHeader().length() +
            table.horizontalHeader().height() +
            5  # margin
        )
        table.setMaximumHeight(total_height)

        return table
```

**Visual Layout:**

```
┌───────────────────────────────────────────────────┐
│  Keyboard Shortcuts                      [x]       │
├───────────────────────────────────────────────────┤
│                                                    │
│  Navigation                                        │
│  ┌─────────────┬─────────────────────────────┐   │
│  │ Shortcut    │ Description                 │   │
│  ├─────────────┼─────────────────────────────┤   │
│  │ Ctrl+F      │ Open search dialog          │   │
│  │ Alt+Right   │ Navigate forward in history │   │
│  │ Alt+Left    │ Navigate back in history    │   │
│  └─────────────┴─────────────────────────────┘   │
│                                                    │
│  Editing                                           │
│  ┌─────────────┬─────────────────────────────┐   │
│  │ Shortcut    │ Description                 │   │
│  ├─────────────┼─────────────────────────────┤   │
│  │ Ctrl+Z      │ Undo last action            │   │
│  │ Ctrl+Y      │ Redo last undone action     │   │
│  │ Delete, ...  │ Collapse selected objects   │   │
│  │ Enter       │ Expand selected cell/pin    │   │
│  └─────────────┴─────────────────────────────┘   │
│                                                    │
│  [... more categories ...]                        │
│                                                    │
│                                  [Close]           │
└───────────────────────────────────────────────────┘
```

**Alternatives Considered:**

1. **Single flat table**
   - ✅ Simpler implementation
   - ❌ Hard to scan (30+ shortcuts)
   - ❌ No logical grouping

2. **Tab-based categories**
   - ✅ One category per tab
   - ❌ Requires extra clicks to see all
   - ❌ Hides other categories

3. **Collapsible sections**
   - ✅ Space-efficient
   - ❌ More complex implementation
   - ❌ Requires user interaction

4. **Categorized tables (chosen)**
   - ✅ All shortcuts visible at once
   - ✅ Easy to scan
   - ✅ Logical organization
   - ❌ Longer dialog (acceptable)

---

## 3. Implementation Approach

### 3.1 Development Phases

#### Phase 1: Menu Integration (1 hour)

**Deliverables:**
- All menus created with `QAction` instances
- Shortcuts assigned to actions via `setShortcut()`
- Menu items show shortcuts automatically
- Menu actions connected to same handlers as shortcuts

**Implementation Steps:**
1. Create `_create_menus()` method in `MainWindow`
2. Create File, Edit, View, Search, Help menus
3. Add actions with shortcuts and handlers
4. Test menu display and activation

**Key Sections:**

```python
def _create_menus(self) -> None:
    """Create application menus with shortcuts."""
    menubar = self.menuBar()

    # File menu
    self._create_file_menu(menubar)

    # Edit menu
    self._create_edit_menu(menubar)

    # View menu
    self._create_view_menu(menubar)

    # Search menu
    self._create_search_menu(menubar)

    # Help menu
    self._create_help_menu(menubar)

def _create_file_menu(self, menubar: QMenuBar) -> None:
    """Create File menu."""
    file_menu = menubar.addMenu("&File")

    # Open
    open_action = QAction("&Open...", self)
    open_action.setShortcut(SHORTCUTS["open"])
    open_action.triggered.connect(self._on_open_file)
    file_menu.addAction(open_action)

    # ... more actions
```

**Note on Shortcut Display:**
- For actions with multiple shortcuts (e.g., zoom has `+` and `Ctrl+=`), Qt displays only the first one
- This is acceptable; help dialog shows all shortcuts
- Example: Zoom In menu shows "Ctrl+=" but both work

#### Phase 2: Toolbar Tooltips (0.5 hour)

**Deliverables:**
- Toolbar buttons created with tooltips
- Tooltips include shortcut hints
- Tooltips use `ShortcutManager.get_shortcut_text()` for consistency

**Implementation Steps:**
1. Create `_create_toolbar()` method (or update existing)
2. Add buttons for common actions (zoom, pan, expand, collapse)
3. Set tooltips with shortcut hints
4. Test tooltip display

**Tooltip Format Pattern:**

```python
button.setToolTip(
    f"{action_description} ({self.shortcut_manager.get_shortcut_text(shortcut_name)})"
)
```

#### Phase 3: Shortcuts Dialog Implementation (1.5 hours)

**Deliverables:**
- `ShortcutsDialog` class implemented
- Dialog shows all categories with tables
- Dialog accessible via `F1` and Help menu
- Close button dismisses dialog

**Implementation Steps:**
1. Create `src/ink/presentation/dialogs/shortcuts_dialog.py`
2. Implement `ShortcutsDialog` class
3. Implement `_create_category_table()` method
4. Add styling for headers and labels
5. Add close button
6. Test dialog display and navigation

**Key Implementation Details:**

```python
def _create_category_table(self, shortcut_names: list[str]) -> QTableWidget:
    """Create table widget for a category."""
    table = QTableWidget(len(shortcut_names), 2)

    # Disable editing and selection
    table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
    table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)

    # Configure columns (shortcut column auto-sizes, description stretches)
    header = table.horizontalHeader()
    header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
    header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)

    # Hide vertical header (row numbers)
    table.verticalHeader().setVisible(False)

    # Populate rows
    for row, name in enumerate(shortcut_names):
        # ... create and add items

    # Set table height to fit content exactly
    table.resizeRowsToContents()
    total_height = table.verticalHeader().length() + table.horizontalHeader().height() + 5
    table.setMaximumHeight(total_height)

    return table
```

#### Phase 4: Help Menu and F1 Integration (0.5 hour)

**Deliverables:**
- Help menu with "Keyboard Shortcuts" action
- `F1` shortcut registered to show dialog
- Dialog instantiated and shown when activated

**Implementation Steps:**
1. Add Help menu to menubar
2. Add "Keyboard Shortcuts" action with `F1` shortcut
3. Register `F1` with `ShortcutManager`
4. Implement `_on_show_shortcuts_dialog()` handler
5. Test via menu and `F1` key

**Key Code:**

```python
def _create_help_menu(self, menubar: QMenuBar) -> None:
    """Create Help menu."""
    help_menu = menubar.addMenu("&Help")

    shortcuts_action = QAction("&Keyboard Shortcuts", self)
    shortcuts_action.setShortcut(QKeySequence("F1"))
    shortcuts_action.triggered.connect(self._on_show_shortcuts_dialog)
    help_menu.addAction(shortcuts_action)

def _on_show_shortcuts_dialog(self) -> None:
    """Show keyboard shortcuts help dialog."""
    dialog = ShortcutsDialog(self.shortcut_manager, self)
    dialog.exec()  # Modal dialog
```

#### Phase 5: Documentation and Polish (0.5 hour)

**Deliverables:**
- Code comments added to configuration file
- Docstrings added to all methods
- Manual testing checklist completed
- Any visual tweaks based on testing

**Implementation Steps:**
1. Add comments to `shortcut_config.py` explaining each shortcut
2. Add docstrings to dialog methods
3. Add module-level docstrings
4. Manual testing of all documentation features
5. Visual polish (spacing, alignment, fonts)

### 3.2 Key Design Decisions

**1. Modal vs Modeless Dialog**

Decision: Modal dialog (`exec()`)

**Rationale:**
- User focuses on learning shortcuts, not interacting with app
- Simpler implementation (no state management)
- Matches standard help dialog pattern
- User can close with `Escape` or Close button

**2. Dialog Size**

Decision: Minimum 600x500, resizable

**Rationale:**
- Large enough to show multiple categories without scrolling
- Resizable allows users to expand if needed
- 600px width accommodates description text comfortably
- Height auto-adjusts based on content

**3. Category Order**

Decision: Most commonly used categories first

**Rationale:**
- Navigation and Editing are used most frequently
- Progressive disclosure: common first, specialized later
- Matches mental model of workflow

**Suggested Category Order:**
1. Navigation (search, history)
2. Editing (undo/redo, expand/collapse)
3. Selection
4. View (zoom, pan, fit)
5. File
6. Copy

**4. Multiple Shortcuts Display**

Decision: Comma-separated in single cell

**Rationale:**
- Simple, compact
- Easy to implement
- Clear that both shortcuts do the same thing

Example: "Delete, Backspace"

### 3.3 Integration Points

**With E04-F04-T01 (Shortcut Manager):**
- Uses `ShortcutManager.get_shortcut_text()` for consistency
- Uses `SHORTCUT_DESCRIPTIONS` for descriptions
- Uses `SHORTCUT_CATEGORIES` for organization

**With E04-F04-T02, T03 (Shortcut Implementations):**
- Documents all shortcuts implemented in previous tasks
- No code dependencies, just documentation

**With MainWindow:**
- Adds menus and toolbar
- Integrates help dialog
- Reuses existing shortcut handlers

---

## 4. Testing Strategy

### 4.1 Unit Tests

**Test Coverage Target**: >80%

**Key Test Cases:**

```python
# tests/unit/presentation/dialogs/test_shortcuts_dialog.py
from ink.presentation.dialogs.shortcuts_dialog import ShortcutsDialog
from ink.presentation.shortcuts.shortcut_manager import ShortcutManager
from ink.presentation.shortcuts.shortcut_config import SHORTCUT_CATEGORIES
import pytest

class TestShortcutsDialog:
    @pytest.fixture
    def shortcut_manager(self, qtbot, main_window):
        return ShortcutManager(main_window)

    @pytest.fixture
    def dialog(self, qtbot, shortcut_manager, main_window):
        dialog = ShortcutsDialog(shortcut_manager, main_window)
        qtbot.addWidget(dialog)
        return dialog

    def test_dialog_title(self, dialog):
        """Test dialog has correct title."""
        assert dialog.windowTitle() == "Keyboard Shortcuts"

    def test_dialog_minimum_size(self, dialog):
        """Test dialog has minimum size set."""
        assert dialog.minimumWidth() == 600
        assert dialog.minimumHeight() == 500

    def test_all_categories_displayed(self, dialog):
        """Test all categories from config are displayed."""
        # Find all category labels
        category_labels = dialog.findChildren(QLabel)

        # Filter to category headers (bold, larger font)
        category_names = [
            label.text() for label in category_labels
            if "font-weight: bold" in label.styleSheet()
            and label.text() in SHORTCUT_CATEGORIES
        ]

        # All categories should be present
        for category in SHORTCUT_CATEGORIES.keys():
            assert category in category_names

    def test_category_tables_created(self, dialog):
        """Test tables created for each category."""
        tables = dialog.findChildren(QTableWidget)

        # Should have one table per category
        assert len(tables) == len(SHORTCUT_CATEGORIES)

    def test_table_has_correct_columns(self, dialog):
        """Test tables have Shortcut and Description columns."""
        tables = dialog.findChildren(QTableWidget)

        for table in tables:
            assert table.columnCount() == 2
            assert table.horizontalHeaderItem(0).text() == "Shortcut"
            assert table.horizontalHeaderItem(1).text() == "Description"

    def test_table_not_editable(self, dialog):
        """Test table cells are not editable."""
        tables = dialog.findChildren(QTableWidget)

        for table in tables:
            assert table.editTriggers() == QTableWidget.EditTrigger.NoEditTriggers

    def test_shortcut_text_displayed(self, dialog, shortcut_manager):
        """Test shortcut text is correctly displayed in tables."""
        tables = dialog.findChildren(QTableWidget)

        # Check first table, first row (assuming it exists)
        if tables and tables[0].rowCount() > 0:
            shortcut_text = tables[0].item(0, 0).text()
            assert len(shortcut_text) > 0  # Should have some text

    def test_close_button_exists(self, dialog):
        """Test close button is present."""
        buttons = dialog.findChildren(QPushButton)
        close_buttons = [btn for btn in buttons if btn.text() == "Close"]

        assert len(close_buttons) == 1

    def test_close_button_closes_dialog(self, dialog, qtbot):
        """Test close button closes the dialog."""
        # Find close button
        buttons = dialog.findChildren(QPushButton)
        close_button = next(btn for btn in buttons if btn.text() == "Close")

        # Click button
        with qtbot.waitSignal(dialog.finished):
            close_button.click()

        # Dialog should be closed
        assert not dialog.isVisible()
```

### 4.2 Integration Tests

**Test Scenarios:**

```python
# tests/integration/presentation/test_shortcuts_documentation.py
from PySide6.QtCore import Qt
from PySide6.QtTest import QTest

class TestShortcutsDocumentation:
    def test_f1_opens_shortcuts_dialog(self, main_window, qtbot):
        """Test F1 key opens shortcuts dialog."""
        # Press F1
        QTest.keyClick(main_window, Qt.Key.Key_F1)

        # Find dialog
        dialogs = main_window.findChildren(ShortcutsDialog)
        assert len(dialogs) > 0

        active_dialog = dialogs[-1]  # Most recent
        assert active_dialog.isVisible()

    def test_help_menu_shows_shortcuts_action(self, main_window):
        """Test Help menu has Keyboard Shortcuts action."""
        menubar = main_window.menuBar()
        help_menu = None

        for action in menubar.actions():
            if action.text() == "&Help":
                help_menu = action.menu()
                break

        assert help_menu is not None

        # Find shortcuts action
        shortcuts_action = None
        for action in help_menu.actions():
            if "Keyboard Shortcuts" in action.text():
                shortcuts_action = action
                break

        assert shortcuts_action is not None
        assert shortcuts_action.shortcut().toString() == "F1"

    def test_menu_items_show_shortcuts(self, main_window):
        """Test menu items display shortcuts."""
        # Get File menu
        menubar = main_window.menuBar()
        file_menu = None

        for action in menubar.actions():
            if action.text() == "&File":
                file_menu = action.menu()
                break

        assert file_menu is not None

        # Check Open action has shortcut
        for action in file_menu.actions():
            if "Open" in action.text():
                assert not action.shortcut().isEmpty()
                # Should be Ctrl+O
                assert "Ctrl" in action.shortcut().toString()
                break

    def test_toolbar_tooltips_include_shortcuts(self, main_window):
        """Test toolbar button tooltips include shortcut hints."""
        toolbar = main_window.findChild(QToolBar)
        if toolbar:
            actions = toolbar.actions()
            for action in actions:
                tooltip = action.toolTip()
                if tooltip:
                    # Should have format "Description (Shortcut)"
                    # At minimum, tooltip should exist
                    assert len(tooltip) > 0
```

### 4.3 Manual Testing Checklist

**Menu Integration:**
- [ ] File menu shows shortcuts (Ctrl+O, Ctrl+S, Ctrl+Q)
- [ ] Edit menu shows shortcuts (Ctrl+Z, Ctrl+Y, Ctrl+A, Ctrl+C)
- [ ] View menu shows shortcuts (Ctrl+=, Ctrl+-, Ctrl+0, Ctrl+1, Space)
- [ ] Search menu shows shortcut (Ctrl+F)
- [ ] Help menu shows shortcut (F1)
- [ ] Menu shortcuts match actual shortcuts (no typos)
- [ ] Platform-appropriate shortcuts shown (Ctrl on Linux)

**Toolbar Tooltips:**
- [ ] Expand button tooltip includes "Enter"
- [ ] Collapse button tooltip includes "Delete, Backspace"
- [ ] Zoom In tooltip includes shortcuts
- [ ] Zoom Out tooltip includes shortcuts
- [ ] Tooltips appear on hover
- [ ] Tooltip text is readable and formatted correctly

**Help Dialog:**
- [ ] F1 opens help dialog
- [ ] Help > Keyboard Shortcuts opens dialog
- [ ] Dialog shows all categories
- [ ] Each category has a table
- [ ] Tables have "Shortcut" and "Description" columns
- [ ] All shortcuts are listed
- [ ] Multiple shortcuts shown as comma-separated
- [ ] Descriptions are clear and accurate
- [ ] Close button closes dialog
- [ ] Escape key closes dialog
- [ ] Dialog is keyboard-navigable (Tab through tables)
- [ ] Dialog is resizable
- [ ] Tables resize appropriately with dialog

**Visual Quality:**
- [ ] Category headers are bold and larger
- [ ] Tables are aligned and consistent
- [ ] Text is legible (good contrast, size)
- [ ] Spacing is comfortable (not cramped)
- [ ] Dialog doesn't require scrolling (or scrolls smoothly if it does)

---

## 5. Risks and Considerations

### 5.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Qt shortcut display varies by platform** | Low | Medium | Test on Linux (primary), document behavior |
| **Long shortcut lists make dialog too tall** | Low | Low | Make dialog scrollable if needed |
| **Tooltip formatting inconsistent** | Low | Medium | Use consistent pattern: `f"{desc} ({shortcut})"` |
| **Menu shortcut display only shows first of multiple** | Low | High | Acceptable limitation, help dialog shows all |

### 5.2 UX Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Users don't discover F1 help** | Medium | Medium | Add to Help menu as well, mention in welcome screen (P1) |
| **Help dialog too long to scan** | Low | Medium | Categorization helps, consider search in P1 |
| **Shortcut text not intuitive** | Low | Low | Use Qt's toString() which is well-tested |
| **Category organization doesn't match mental model** | Low | Medium | User testing, iterate on categories |

### 5.3 Design Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **SHORTCUT_CATEGORIES gets out of sync with SHORTCUTS** | Medium | Medium | Add unit test to verify all shortcuts are categorized |
| **Description text too verbose or too terse** | Low | Medium | Review with users, iterate |
| **Dialog styling doesn't match app theme** | Low | Low | Use default Qt styling for MVP, theme in P1 |

### 5.4 Assumptions

1. **All shortcuts from T01-T03 are implemented**: Required for documentation
2. **ShortcutManager.get_shortcut_text() works correctly**: Dependency on T01
3. **MainWindow has menubar and toolbar**: Standard Qt main window
4. **Users expect F1 for help**: Industry standard
5. **Qt handles platform-specific shortcut formatting**: Tested Qt feature

---

## 6. Dependencies

### 6.1 Upstream Dependencies

**Hard Dependencies:**
- E04-F04-T01 (Shortcut Manager): `ShortcutManager`, `SHORTCUTS`, `SHORTCUT_DESCRIPTIONS`, `SHORTCUT_CATEGORIES`
- E04-F04-T02 (Navigation Shortcuts): Shortcuts to document
- E04-F04-T03 (Action Shortcuts): Shortcuts to document
- `MainWindow` class with menubar and toolbar support

**Soft Dependencies:**
- None

### 6.2 Downstream Dependencies

**This task has no downstream dependencies** (final task in E04-F04)

**Interfaces Used:**
- `ShortcutManager.get_shortcut_text(name: str) -> str`
- `SHORTCUTS: dict[str, ShortcutDef]`
- `SHORTCUT_DESCRIPTIONS: dict[str, str]`
- `SHORTCUT_CATEGORIES: dict[str, list[str]]`

---

## 7. Success Criteria

### 7.1 Functional Completeness

- [ ] All menu items show shortcuts
- [ ] All toolbar tooltips include shortcuts
- [ ] F1 opens help dialog
- [ ] Help menu includes "Keyboard Shortcuts" action
- [ ] Help dialog shows all shortcuts organized by category
- [ ] Help dialog is modal and closeable
- [ ] All shortcuts are documented somewhere in UI

### 7.2 Quality Criteria

- [ ] Unit test coverage >80%
- [ ] All integration tests passing
- [ ] Manual testing checklist 100% complete
- [ ] No type errors (mypy passes)
- [ ] No linting errors (ruff passes)

### 7.3 UX Quality

- [ ] Shortcut text is consistently formatted
- [ ] Dialog is easy to scan and read
- [ ] Categories are logically organized
- [ ] No important shortcuts missing from documentation
- [ ] Visual design is clean and professional

### 7.4 Discoverability

- [ ] New users can find help dialog (F1, Help menu)
- [ ] Menu shortcuts visible without clicking
- [ ] Tooltip shortcuts appear on hover
- [ ] All documentation methods tested with fresh users (P1)

---

## 8. Open Questions

### 8.1 Technical Questions

1. **Q: Should help dialog be modal or modeless?**
   - A: Modal for MVP. User focuses on learning, not interacting with app.

2. **Q: Should we include descriptions in tooltips too?**
   - A: No, tooltips are brief. Just "Action (Shortcut)". Description in help dialog.

3. **Q: What if SHORTCUT_DESCRIPTIONS is incomplete?**
   - A: Unit test to verify all shortcuts have descriptions. Fail build if missing.

### 8.2 UX Questions

1. **Q: Should categories be collapsible in help dialog?**
   - A: No for MVP. Adds complexity. All categories visible by default.

2. **Q: Should dialog have search functionality?**
   - A: No for MVP. P1 enhancement. Categorization is sufficient for ~20-30 shortcuts.

3. **Q: Should we show keyboard shortcuts in status bar?**
   - A: No for MVP. P1: Could show hint like "Press F1 for keyboard shortcuts".

### 8.3 Design Questions

1. **Q: What if new shortcuts are added but not categorized?**
   - A: Unit test fails, forcing update to SHORTCUT_CATEGORIES.

2. **Q: How to handle very long shortcut lists in future?**
   - A: P1: Add search, tabs, or better filtering. MVP categorization scales to ~50 shortcuts.

---

## 9. Implementation Checklist

### 9.1 Pre-Implementation

- [ ] Review E04-F04-T04 task spec
- [ ] Confirm all shortcuts from T01-T03 are in SHORTCUT_DESCRIPTIONS
- [ ] Confirm all shortcuts are in SHORTCUT_CATEGORIES
- [ ] Design category order based on usage frequency

### 9.2 Implementation

- [ ] Implement menu creation with shortcuts
- [ ] Implement toolbar with shortcut tooltips
- [ ] Create ShortcutsDialog class
- [ ] Implement category table creation
- [ ] Add F1 shortcut registration
- [ ] Add Help menu integration
- [ ] Add styling for dialog

### 9.3 Testing

- [ ] Write unit tests for ShortcutsDialog
- [ ] Write integration tests for menu/toolbar
- [ ] Write integration test for F1 activation
- [ ] Manual testing of all documentation features
- [ ] Visual review of dialog
- [ ] Test on different screen sizes

### 9.4 Documentation

- [ ] Add docstrings to all methods
- [ ] Add comments to shortcut_config.py
- [ ] Update post-docs
- [ ] Document any deviations from spec

### 9.5 Review and Cleanup

- [ ] Run mypy type checking
- [ ] Run ruff linting
- [ ] Code review
- [ ] Address feedback
- [ ] Final visual polish
- [ ] Final testing pass

---

## 10. References

### 10.1 Internal Documents

- [E04-F04 Feature Spec](../E04-F04.spec.md)
- [E04-F04-T04 Task Spec](./E04-F04-T04.spec.md)
- [E04-F04-T01 Pre-Docs](../T01/E04-F04-T01.pre-docs.md)
- [PRD Section 7.3 - Keyboard Shortcuts](../../../../docs/prd.md)

### 10.2 Qt Documentation

- [QAction Class](https://doc.qt.io/qt-6/qaction.html)
- [QAction::setShortcut()](https://doc.qt.io/qt-6/qaction.html#setShortcut)
- [QDialog Class](https://doc.qt.io/qt-6/qdialog.html)
- [QTableWidget Class](https://doc.qt.io/qt-6/qtablewidget.html)
- [QHeaderView Resize Modes](https://doc.qt.io/qt-6/qheaderview.html#ResizeMode-enum)

### 10.3 UX Best Practices

- F1 for help is industry standard
- Menu shortcuts on right side of menu item
- Tooltip format: "Action (Shortcut)"
- Help dialog: Categorized, scannable, modal
- Keyboard shortcuts should be discoverable without reading manual

---

**End of Pre-Implementation Documentation**
