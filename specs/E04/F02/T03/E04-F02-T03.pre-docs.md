# E04-F02-T03 - Selection Listener: Pre-Implementation Documentation

## Document Information

- **Task ID**: E04-F02-T03
- **Task Title**: Selection Listener - Update panel on selection changes
- **Document Type**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Status**: Planning
- **Estimated Hours**: 5
- **Parent Feature**: [E04-F02](../E04-F02.spec.md) - Property Panel

---

## 1. Overview

### 1.1 Problem Context

The PropertyPanelController acts as the orchestration layer connecting the selection system to the property panel. When users select objects in the schematic, the controller must:
1. Listen to selection change events
2. Query the domain model for selected objects and related data
3. Format properties using the formatter service
4. Update the PropertyPanel UI with formatted data

This controller is critical for maintaining the separation between the selection system (application logic), domain model (data), property formatting (transformation), and property panel (UI).

### 1.2 Scope

**In Scope:**
- PropertyPanelController class in presentation layer
- Selection change event handling
- Domain repository queries for objects and related data
- Integration with PropertyFormatterService
- Integration with PropertyPanel widget
- Performance monitoring and logging
- Error handling and graceful degradation
- Empty, single, and multi-selection state handling

**Out of Scope:**
- Selection system implementation (handled by E04-F01)
- Property formatting logic (handled by T02)
- PropertyPanel UI implementation (handled by T01)
- Property caching or optimization (P1 enhancement)
- Asynchronous property loading (P1 enhancement)

### 1.3 Success Criteria

- Property panel updates within < 50ms of selection change
- Handles all selection states correctly (empty, single, multi, mixed)
- Graceful error handling with logging
- No coupling between PropertyPanel and domain model
- Clean separation of concerns via controller pattern

---

## 2. Implementation Approach

### 2.1 Controller Architecture

**Layer**: Presentation Layer (Controllers subdirectory)
**Pattern**: Model-View-Controller (MVC) - Controller component

**Component Interactions:**
```
SelectionService (Application)
         ↓ (selection_changed signal)
PropertyPanelController (Presentation/Controllers)
         ↓ (queries)
DesignRepository (Domain/Repositories)
         ↓ (formats)
PropertyFormatterService (Application)
         ↓ (updates)
PropertyPanel (Presentation/Panels)
```

**Controller Responsibilities:**
- Listen to `selection_changed` signal from SelectionService
- Determine object type from selection
- Query domain repository for objects and related data
- Delegate formatting to PropertyFormatterService
- Update PropertyPanel with formatted data
- Handle errors and edge cases
- Log performance metrics

### 2.2 Event Handling Flow

**Selection Changed Event Processing:**

```python
@Slot(object)
def _on_selection_changed(event: SelectionChangedEvent):
    1. Extract selected object IDs from event
    2. Determine selection type (empty, single, multi)

    If empty:
        → Call panel.show_empty_state()

    If single:
        → Determine object type (Cell, Pin, Net, Port)
        → Query repository for object
        → Query repository for related data (parent cell, connected pins)
        → Format properties via formatter service
        → Call panel.display_properties()

    If multi:
        → Determine if same type or mixed
        → Call panel.show_multi_selection_state()
```

### 2.3 Repository Query Strategy

**Required Repository Methods:**
- `get_cell(cell_id)` → Optional[Cell]
- `get_pin(pin_id)` → Optional[Pin]
- `get_net(net_id)` → Optional[Net]
- `get_port(port_id)` → Optional[Port]
- `get_cell_containing_pin(pin_id)` → Optional[Cell]
- `get_pins_on_net(net_id)` → List[Pin]

**Query Optimization:**
- Query only what's needed for the specific object type
- Related data queries are conditional (e.g., pins for nets)
- No preemptive caching for MVP
- Performance target: < 10ms per query

### 2.4 Error Handling Strategy

**Error Scenarios:**
1. **Object not found in repository**: Show empty state, log error
2. **Exception during formatting**: Show empty state, log error
3. **Exception during UI update**: Show empty state, log error
4. **Invalid object ID type**: Show empty state, log warning

**Principles:**
- Never crash on selection change
- Always show valid UI state (prefer empty over corrupted)
- Log all errors for debugging
- Fail gracefully without user-visible exceptions

### 2.5 Performance Monitoring

**Instrumentation:**
- Time each selection update end-to-end
- Log when exceeding 50ms target
- Track breakdown: query time vs. format time vs. UI time
- Use `time.perf_counter()` for high-resolution timing

**Logging Levels:**
- DEBUG: All selection changes with timing
- INFO: Successful updates
- WARNING: Performance target exceeded
- ERROR: Exceptions and failures

---

## 3. Key Design Decisions

### 3.1 Why Separate Controller Class?

**Decision**: Create dedicated PropertyPanelController instead of inline signal handling

**Rationale:**
- Follows MVC pattern, controller coordinates between components
- Decouples PropertyPanel from SelectionService
- Easier to test in isolation with mocks
- Single responsibility: orchestrate property updates
- Can be reused if multiple property panels needed

**Alternatives Considered:**
- Direct connection: SelectionService → PropertyPanel
  - ❌ Couples UI to application logic
  - ❌ Harder to test
  - ❌ Violates separation of concerns

### 3.2 Why Query Related Data in Controller?

**Decision**: Controller queries parent cells and connected pins, not formatter

**Rationale:**
- Formatters are pure transformation functions
- Formatters shouldn't depend on repositories
- Controller knows what context is needed for each type
- Easier to mock in formatter tests
- Clear separation: controller = orchestration, formatter = transformation

**Alternatives Considered:**
- Formatter queries repository directly
  - ❌ Couples formatter to infrastructure
  - ❌ Harder to test formatter in isolation
  - ❌ Violates single responsibility

### 3.3 Why Show Empty State on Errors?

**Decision**: Display empty state when errors occur, not stale data

**Rationale:**
- Prevents showing incorrect/outdated information
- Clear signal to user that something is wrong (nothing selected)
- Avoids confusing partial updates
- Fail-safe approach
- Error logged for developer investigation

**Alternatives Considered:**
- Show last valid state
  - ❌ Confusing to user (selection vs. displayed object mismatch)
  - ❌ May show deleted objects
- Show error message in panel
  - ❌ Clutters UI for transient errors
  - ❌ Error details not useful to end users

### 3.4 Why Performance Logging?

**Decision**: Log all selection updates with timing information

**Rationale:**
- Enables performance profiling in production
- Identifies bottlenecks (query vs. format vs. UI)
- Warns when targets exceeded
- Helps prioritize optimizations
- Minimal overhead (< 1ms for logging)

**Alternatives Considered:**
- No performance tracking
  - ❌ Can't identify performance regressions
  - ❌ No data for optimization decisions

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**SelectionService (Application Layer - E04-F01):**
- Provides `selection_changed` signal
- Emits `SelectionChangedEvent` with selected object IDs
- Event structure: `SelectionChangedEvent(selected_objects: List[ObjectId])`

**DesignRepository (Domain Layer - E01):**
- Provides object query methods
- Returns domain entities (Cell, Pin, Net, Port)
- May return None if object not found

**PropertyFormatterService (Application Layer - T02):**
- Provides `format_cell_properties()`, etc.
- Returns `FormattedProperties` dataclass
- Pure transformation, no side effects

**PropertyPanel (Presentation Layer - T01):**
- Provides `show_empty_state()` method
- Provides `display_properties()` method
- Provides `show_multi_selection_state()` method

### 4.2 Integration in Main Application

**Composition Root** (`src/ink/presentation/app.py`):

```python
def _setup_controllers(self) -> None:
    """Initialize controllers connecting services to UI"""

    # Create formatter service (stateless)
    property_formatter = PropertyFormatterService()

    # Create property panel controller
    self.property_panel_controller = PropertyPanelController(
        property_panel=self.main_window.property_panel,
        selection_service=self.selection_service,
        design_repository=self.design_repository,
        property_formatter=property_formatter
    )

    # Controller connects to selection_changed signal in __init__
```

**Dependency Injection:**
- All dependencies injected via constructor
- No global state or singletons
- Easy to substitute mocks for testing
- Clear dependency graph

### 4.3 Signal Connection

**Qt Signal/Slot Mechanism:**
```python
# In PropertyPanelController.__init__():
self.selection_service.selection_changed.connect(
    self._on_selection_changed
)
```

**Event Object Structure:**
```python
@dataclass
class SelectionChangedEvent:
    selected_objects: List[Union[CellId, PinId, NetId, PortId]]
```

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/presentation/controllers/test_property_panel_controller.py`

**Test Coverage:**

1. **Empty Selection Tests**
   - Empty selection calls `show_empty_state()`
   - Panel is cleared
   - No repository queries made

2. **Single Cell Selection Tests**
   - Cell selection queries repository correctly
   - Formatter called with cell object
   - Panel updated with formatted properties
   - Error handling when cell not found

3. **Single Pin Selection Tests**
   - Pin selection queries pin and parent cell
   - Formatter called with pin and parent cell
   - Panel updated with formatted properties
   - Handles missing parent cell gracefully

4. **Single Net Selection Tests**
   - Net selection queries net and connected pins
   - Formatter called with net and pins
   - Panel updated with formatted properties
   - Handles empty connected pins list

5. **Single Port Selection Tests**
   - Port selection queries repository
   - Formatter called with port
   - Panel updated with formatted properties

6. **Multi-Selection Tests**
   - Same-type selection shows type name
   - Mixed-type selection shows "mixed" indicator
   - Panel called with correct count and type

7. **Error Handling Tests**
   - Object not found shows empty state
   - Exception during format shows empty state
   - Exception during UI update shows empty state
   - Errors logged appropriately

8. **Performance Monitoring Tests**
   - Timing logged for each update
   - Warning logged when exceeding 50ms

**Example Test:**
```python
def test_single_cell_selection():
    # Mock dependencies
    panel = Mock(spec=PropertyPanel)
    selection_service = Mock(spec=SelectionService)
    design_repo = Mock(spec=DesignRepository)
    formatter = Mock(spec=PropertyFormatterService)

    # Create controller
    controller = PropertyPanelController(
        property_panel=panel,
        selection_service=selection_service,
        design_repository=design_repo,
        property_formatter=formatter
    )

    # Setup test data
    cell_id = CellId("U1")
    cell = Cell(id=cell_id, name="U_NAND_1", cell_type="NAND2_X1",
                pins=[], is_sequential=False)
    formatted = FormattedProperties(
        object_type="Cell",
        object_name="U_NAND_1",
        groups={"General": {"Name": "U_NAND_1"}}
    )

    design_repo.get_cell.return_value = cell
    formatter.format_cell_properties.return_value = formatted

    # Trigger selection change
    event = SelectionChangedEvent(selected_objects=[cell_id])
    controller._on_selection_changed(event)

    # Verify interactions
    design_repo.get_cell.assert_called_once_with(cell_id)
    formatter.format_cell_properties.assert_called_once_with(cell)
    panel.display_properties.assert_called_once_with(
        object_type="Cell",
        object_name="U_NAND_1",
        properties={"General": {"Name": "U_NAND_1"}}
    )

def test_object_not_found_shows_empty_state():
    panel = Mock(spec=PropertyPanel)
    design_repo = Mock(spec=DesignRepository)
    design_repo.get_cell.return_value = None  # Not found

    controller = PropertyPanelController(panel, ..., design_repo, ...)

    event = SelectionChangedEvent(selected_objects=[CellId("U999")])
    controller._on_selection_changed(event)

    panel.show_empty_state.assert_called_once()
```

### 5.2 Integration Tests

**File**: `tests/integration/presentation/test_property_panel_integration.py`

**Test Coverage:**
- Real PropertyPanel widget (no mock)
- Mock SelectionService emitting real events
- Mock DesignRepository with test data
- Verify end-to-end flow from event to UI update
- Test with actual Qt event loop

**Example Integration Test:**
```python
def test_selection_to_panel_integration(qtbot):
    # Real PropertyPanel
    panel = PropertyPanel()
    qtbot.addWidget(panel)

    # Mock selection service
    selection_service = Mock(spec=SelectionService)
    selection_service.selection_changed = Signal(object)

    # Mock repository with test data
    design_repo = Mock(spec=DesignRepository)
    cell = create_test_cell("U1")
    design_repo.get_cell.return_value = cell

    # Real formatter
    formatter = PropertyFormatterService()

    # Create controller
    controller = PropertyPanelController(
        panel, selection_service, design_repo, formatter
    )

    # Emit selection changed
    event = SelectionChangedEvent(selected_objects=[cell.id])
    selection_service.selection_changed.emit(event)

    # Wait for Qt event processing
    qtbot.waitUntil(lambda: panel.header_label.text() == "Cell: U1")

    # Verify panel updated
    assert "U1" in panel.header_label.text()
```

### 5.3 Performance Tests

**File**: `tests/performance/test_property_panel_controller_perf.py`

**Benchmarks:**
- Single selection update: < 50ms
- Multi-selection (100 objects) update: < 50ms
- Repository query time: < 10ms
- Formatting time: < 5ms
- UI update time: < 40ms

```python
def test_single_selection_performance():
    controller = create_test_controller_with_real_deps()
    cell_id = CellId("U1")

    import time
    start = time.perf_counter()

    event = SelectionChangedEvent(selected_objects=[cell_id])
    controller._on_selection_changed(event)

    elapsed = time.perf_counter() - start

    assert elapsed < 0.050, f"Update took {elapsed*1000:.2f}ms"
```

### 5.4 Coverage Target

- **Unit tests**: 85%+ coverage on PropertyPanelController
- **All selection types**: Empty, single (4 types), multi (same/mixed)
- **All error paths**: Not found, exceptions, invalid types

---

## 6. Risks and Considerations

### 6.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Repository queries too slow** | High | Medium | Profile queries, optimize if needed, consider caching (P1) |
| **Selection events fire too frequently** | Medium | Low | Debouncing in selection service, not controller |
| **Memory leaks from signal connections** | Medium | Low | Proper Qt parent-child relationships, disconnect on destroy |
| **Exception in formatter crashes app** | High | Low | Try-catch around formatter calls, show empty state |

### 6.2 Performance Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **High-fanout nets slow query** | Medium | Limit pins returned, progressive loading (P1) |
| **Large multi-selection slow** | Low | Simple count display, no property extraction |
| **Formatter allocation overhead** | Low | Stateless service, minimal allocation |

### 6.3 Integration Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **SelectionChangedEvent format mismatch** | High | Define event contract clearly, coordinate with E04-F01 |
| **Repository interface incomplete** | High | Define required methods early, stub if needed |
| **PropertyPanel API changes** | Medium | Lock down panel API in T01, share interface spec |

### 6.4 Error Handling Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Silent failures hide bugs** | Medium | Log all errors, unit test error paths |
| **Empty state confuses users** | Low | Clear "No object selected" message |
| **Partial UI updates on error** | Medium | Atomic updates: clear first, then populate |

---

## 7. Implementation Checklist

### 7.1 Core Implementation

- [ ] Create `PropertyPanelController` class
- [ ] Implement `__init__()` with dependency injection
- [ ] Connect to `selection_changed` signal
- [ ] Implement `_on_selection_changed()` event handler
- [ ] Implement `_handle_single_selection()` method
- [ ] Implement `_handle_multi_selection()` method
- [ ] Implement `_get_type_name()` utility method
- [ ] Add performance timing instrumentation
- [ ] Add error handling with try-catch blocks

### 7.2 Repository Integration

- [ ] Add calls to `get_cell()`, `get_pin()`, `get_net()`, `get_port()`
- [ ] Add calls to `get_cell_containing_pin()` for pin context
- [ ] Add calls to `get_pins_on_net()` for net fanout
- [ ] Handle None returns from repository
- [ ] Add type checking for object IDs

### 7.3 Formatter Integration

- [ ] Call `format_cell_properties()` for cells
- [ ] Call `format_pin_properties()` for pins with parent cell
- [ ] Call `format_net_properties()` for nets with connected pins
- [ ] Call `format_port_properties()` for ports
- [ ] Handle formatter exceptions gracefully

### 7.4 Panel Integration

- [ ] Call `show_empty_state()` for empty selection
- [ ] Call `display_properties()` for single selection
- [ ] Call `show_multi_selection_state()` for multi-selection
- [ ] Pass formatted data correctly to panel methods

### 7.5 Testing

- [ ] Unit tests for each selection type
- [ ] Unit tests for error scenarios
- [ ] Integration test with real panel and mocked services
- [ ] Performance test for 50ms target
- [ ] Test with mock Qt signals

### 7.6 Documentation

- [ ] Docstrings for all public methods
- [ ] Document event handling flow
- [ ] Document error handling strategy
- [ ] Comment performance-critical sections

---

## 8. Open Questions

### 8.1 Resolved Questions

**Q**: Should controller cache formatted properties?
**A**: No for MVP. Formatting is fast enough (< 5ms).

**Q**: Who queries related data (parent cell, connected pins)?
**A**: Controller queries, formatter receives as parameters.

**Q**: What happens if repository query fails?
**A**: Show empty state, log error at ERROR level.

**Q**: Should we debounce rapid selection changes?
**A**: Not in controller. Selection service handles if needed.

### 8.2 Pending Questions

**Q**: Should we profile query time separately from format time?
**A**: Yes for debugging, but may be overkill for MVP logging.

**Q**: Should controller validate FormattedProperties structure?
**A**: No, trust formatter contract. Add validation in debug mode (P1).

**Q**: How to handle very slow repository queries (> 100ms)?
**A**: Log warning. Consider async queries in P1 if becomes issue.

---

## 9. References

### 9.1 Specifications

- [E04-F02 Feature Spec](../E04-F02.spec.md) - Property Panel feature
- [E04-F02-T03 Task Spec](./E04-F02-T03.spec.md) - This task specification
- [E04-F01 Feature Spec](../../F01/E04-F01.spec.md) - Selection System

### 9.2 Design Patterns

- **Model-View-Controller (MVC)**: Controller coordinates between model and view
- **Observer Pattern**: Controller observes SelectionService via signals
- **Dependency Injection**: All dependencies injected via constructor

### 9.3 Qt Documentation

- [Qt Signals and Slots](https://doc.qt.io/qt-6/signalsandslots.html)
- [QObject and Memory Management](https://doc.qt.io/qt-6/qobject.html)

---

**End of Pre-Implementation Documentation**
