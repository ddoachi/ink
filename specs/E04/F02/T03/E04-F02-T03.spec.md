---
id: E04-F02-T03
title: Selection Listener
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F02
created: 2025-12-26
estimated_hours: 5
actual_hours:
effort: Medium
tags:
  - application
  - integration
  - event-handling
clickup_task_id: '86evzm2vw'
---

# Spec: E04-F02-T03 - Selection Listener

## 1. Overview

### 1.1 Problem Statement
Connect the selection system to the property panel by listening to selection change events and updating the panel with formatted properties. The listener must handle single selections, multi-selections, empty selections, and query the domain model efficiently to gather all necessary property data.

### 1.2 Goals
- Listen to `selection_changed` signal from SelectionManager
- Query domain model to retrieve selected objects and their related data
- Format properties using PropertyFormatterService
- Update PropertyPanel with formatted data
- Handle all selection states: empty, single, multi, mixed types
- Meet performance target of < 50ms total update time
- Handle errors gracefully when objects cannot be found

---

## 2. Technical Requirements

### 2.1 PropertyPanelController

**Location**: `src/ink/presentation/controllers/property_panel_controller.py`

**Class Structure**:
```python
from typing import Optional, List, Any
from PySide6.QtCore import QObject, Slot
import logging

from ink.application.services.property_formatter_service import PropertyFormatterService
from ink.application.services.selection_service import SelectionService, SelectionChangedEvent
from ink.domain.repositories.design_repository import DesignRepository
from ink.domain.value_objects.identifiers import CellId, PinId, NetId, PortId
from ink.presentation.panels.property_panel import PropertyPanel


class PropertyPanelController(QObject):
    """
    Controller connecting SelectionService to PropertyPanel.

    Responsibilities:
    - Listen to selection change events
    - Query domain model for selected objects
    - Format properties for display
    - Update PropertyPanel UI
    - Handle performance optimization and error handling
    """

    def __init__(
        self,
        property_panel: PropertyPanel,
        selection_service: SelectionService,
        design_repository: DesignRepository,
        property_formatter: PropertyFormatterService
    ):
        """
        Initialize the property panel controller.

        Args:
            property_panel: PropertyPanel widget to update
            selection_service: Service managing object selection
            design_repository: Repository for querying domain objects
            property_formatter: Service for formatting properties
        """
        super().__init__()
        self.logger = logging.getLogger(__name__)

        self.property_panel = property_panel
        self.selection_service = selection_service
        self.design_repository = design_repository
        self.property_formatter = property_formatter

        # Connect to selection change signal
        self.selection_service.selection_changed.connect(self._on_selection_changed)

        self.logger.info("PropertyPanelController initialized")

    @Slot(object)
    def _on_selection_changed(self, event: SelectionChangedEvent) -> None:
        """
        Handle selection change events.

        Args:
            event: Selection change event with new selection state
        """
        try:
            # Performance tracking
            import time
            start_time = time.perf_counter()

            selected_objects = event.selected_objects
            count = len(selected_objects)

            # Handle empty selection
            if count == 0:
                self.property_panel.show_empty_state()
                self.logger.debug("Selection cleared, showing empty state")
                return

            # Handle single selection
            if count == 1:
                self._handle_single_selection(selected_objects[0])
            else:
                # Handle multi-selection
                self._handle_multi_selection(selected_objects)

            # Log performance
            elapsed_ms = (time.perf_counter() - start_time) * 1000
            self.logger.debug(f"Property panel update completed in {elapsed_ms:.2f}ms")

            # Warn if exceeding performance target
            if elapsed_ms > 50:
                self.logger.warning(
                    f"Property panel update took {elapsed_ms:.2f}ms "
                    f"(target: 50ms) for {count} object(s)"
                )

        except Exception as e:
            self.logger.error(f"Error updating property panel: {e}", exc_info=True)
            self.property_panel.show_empty_state()

    def _handle_single_selection(self, object_id: Any) -> None:
        """
        Handle single object selection.

        Args:
            object_id: ID of the selected object (CellId, PinId, NetId, or PortId)
        """
        try:
            # Determine object type and fetch from repository
            if isinstance(object_id, CellId):
                cell = self.design_repository.get_cell(object_id)
                if cell is None:
                    raise ValueError(f"Cell not found: {object_id}")
                formatted = self.property_formatter.format_cell_properties(cell)

            elif isinstance(object_id, PinId):
                pin = self.design_repository.get_pin(object_id)
                if pin is None:
                    raise ValueError(f"Pin not found: {object_id}")

                # Get parent cell for context
                parent_cell = self.design_repository.get_cell_containing_pin(object_id)
                formatted = self.property_formatter.format_pin_properties(pin, parent_cell)

            elif isinstance(object_id, NetId):
                net = self.design_repository.get_net(object_id)
                if net is None:
                    raise ValueError(f"Net not found: {object_id}")

                # Get connected pins for fanout information
                connected_pins = self.design_repository.get_pins_on_net(object_id)
                formatted = self.property_formatter.format_net_properties(net, connected_pins)

            elif isinstance(object_id, PortId):
                port = self.design_repository.get_port(object_id)
                if port is None:
                    raise ValueError(f"Port not found: {object_id}")
                formatted = self.property_formatter.format_port_properties(port)

            else:
                self.logger.warning(f"Unknown object type: {type(object_id)}")
                self.property_panel.show_empty_state()
                return

            # Update panel with formatted properties
            self.property_panel.display_properties(
                object_type=formatted.object_type,
                object_name=formatted.object_name,
                properties=formatted.groups
            )

        except Exception as e:
            self.logger.error(f"Error handling single selection: {e}", exc_info=True)
            self.property_panel.show_empty_state()

    def _handle_multi_selection(self, object_ids: List[Any]) -> None:
        """
        Handle multi-object selection.

        Args:
            object_ids: List of selected object IDs
        """
        try:
            count = len(object_ids)

            # Determine if all objects are the same type
            object_types = set(type(obj_id) for obj_id in object_ids)

            if len(object_types) == 1:
                # All same type
                object_type_class = object_types.pop()
                type_name = self._get_type_name(object_type_class)
                self.property_panel.show_multi_selection_state(count, type_name)
            else:
                # Mixed types
                self.property_panel.show_multi_selection_state(count, None)

            self.logger.debug(f"Multi-selection: {count} objects, {len(object_types)} type(s)")

        except Exception as e:
            self.logger.error(f"Error handling multi-selection: {e}", exc_info=True)
            self.property_panel.show_empty_state()

    def _get_type_name(self, type_class: type) -> str:
        """
        Get display name for object type.

        Args:
            type_class: Type class (CellId, PinId, NetId, PortId)

        Returns:
            Display name ("Cell", "Pin", "Net", "Port")
        """
        type_map = {
            CellId: "Cell",
            PinId: "Pin",
            NetId: "Net",
            PortId: "Port",
        }
        return type_map.get(type_class, "Object")
```

### 2.2 Repository Query Methods

**Required methods in DesignRepository** (may already exist in domain layer):

```python
# In src/ink/domain/repositories/design_repository.py

from typing import Optional, List, Protocol
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.domain.value_objects.identifiers import CellId, PinId, NetId, PortId


class DesignRepository(Protocol):
    """Repository interface for querying design objects"""

    def get_cell(self, cell_id: CellId) -> Optional[Cell]:
        """Get cell by ID"""
        ...

    def get_pin(self, pin_id: PinId) -> Optional[Pin]:
        """Get pin by ID"""
        ...

    def get_net(self, net_id: NetId) -> Optional[Net]:
        """Get net by ID"""
        ...

    def get_port(self, port_id: PortId) -> Optional[Port]:
        """Get port by ID"""
        ...

    def get_cell_containing_pin(self, pin_id: PinId) -> Optional[Cell]:
        """Get the cell that contains the specified pin"""
        ...

    def get_pins_on_net(self, net_id: NetId) -> List[Pin]:
        """Get all pins connected to the specified net"""
        ...
```

### 2.3 Integration with Main Window

**Location**: `src/ink/presentation/app.py` (Composition Root)

```python
# In App.__init__() or setup method:
def _setup_controllers(self) -> None:
    """Setup controller layer connecting services to UI"""

    # Create property formatter service
    property_formatter = PropertyFormatterService()

    # Create property panel controller
    self.property_panel_controller = PropertyPanelController(
        property_panel=self.main_window.property_panel,
        selection_service=self.selection_service,
        design_repository=self.design_repository,
        property_formatter=property_formatter
    )
```

### 2.4 Performance Optimization

**Strategies to meet 50ms target**:

1. **Lazy loading**: Only fetch related objects when needed
2. **Batch queries**: Fetch multiple objects in single repository call if possible
3. **Cache frequently accessed data**: Consider caching cell types, pin counts
4. **Async updates**: Use Qt signals/slots for non-blocking updates
5. **Debouncing**: If selection changes rapidly, debounce updates (out of scope for MVP)

**Performance measurement**:
- Log update time for each selection change
- Warn when exceeding 50ms target
- Track time spent in repository queries vs. formatting vs. UI update

---

## 3. Dependencies

### 3.1 Upstream
- Task E04-F01: SelectionService and selection_changed signal
- Task E04-F02-T01: PropertyPanel widget
- Task E04-F02-T02: PropertyFormatterService
- Domain repositories: DesignRepository interface

### 3.2 Downstream
- None (terminal integration task)

### 3.3 External Dependencies
- PySide6 (Qt signals/slots)
- Python standard library: `typing`, `logging`, `time`

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] Controller connects to `selection_changed` signal from SelectionService
- [ ] Empty selection displays empty state in PropertyPanel
- [ ] Single cell selection displays formatted cell properties
- [ ] Single pin selection displays formatted pin properties with parent cell
- [ ] Single net selection displays formatted net properties with connected pins
- [ ] Single port selection displays formatted port properties
- [ ] Multi-selection of same type shows count and type name
- [ ] Multi-selection of mixed types shows count with "mixed types" indicator
- [ ] Unknown/invalid object IDs are handled gracefully with empty state

### 4.2 Performance Requirements
- [ ] Property panel update completes in < 50ms for single selection
- [ ] Property panel update completes in < 50ms for multi-selection (up to 100 objects)
- [ ] Repository queries complete in < 10ms for typical objects
- [ ] Formatting completes in < 5ms for typical objects
- [ ] UI update completes in < 40ms
- [ ] Performance warnings logged when exceeding 50ms target

### 4.3 Error Handling
- [ ] Missing objects (not found in repository) show empty state with error log
- [ ] Exception during property formatting shows empty state with error log
- [ ] Exception during repository query shows empty state with error log
- [ ] UI remains responsive even when errors occur
- [ ] Error details logged at ERROR level for debugging

### 4.4 Testing
- [ ] Unit tests for `_handle_single_selection()` with each object type
- [ ] Unit tests for `_handle_multi_selection()` with same type
- [ ] Unit tests for `_handle_multi_selection()` with mixed types
- [ ] Unit tests for empty selection handling
- [ ] Unit tests for error handling (object not found, exception during format)
- [ ] Integration test with mock SelectionService emitting events
- [ ] Integration test with mock DesignRepository returning test objects
- [ ] Performance test verifying < 50ms update time
- [ ] 85%+ code coverage on PropertyPanelController

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate controller class?**
- Decouples presentation layer (PropertyPanel) from application logic
- Follows Model-View-Controller (MVC) pattern
- Easier to test independently
- Single responsibility: handle selection events and coordinate updates

**Why query parent cell for pins?**
- Provides context for pin properties (which cell it belongs to)
- Useful for navigation and understanding circuit structure
- Minimal performance overhead (single repository query)

**Why query connected pins for nets?**
- Enables display of fanout count and driver information
- Essential for understanding net connectivity
- Performance acceptable for typical nets (< 100 connections)

**Why use time.perf_counter() for performance tracking?**
- High-resolution timer for accurate measurement
- Standard Python approach for performance profiling
- Helps identify bottlenecks during development
- Provides data for optimization decisions

**Why show empty state on errors?**
- Prevents showing stale or incorrect data
- Clear signal to user that something went wrong
- Error logged for developer debugging
- Fails gracefully without crashing application

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/presentation/controllers/test_property_panel_controller.py`):
- Mock PropertyPanel, SelectionService, DesignRepository, PropertyFormatterService
- Test each selection scenario independently
- Verify correct methods called on dependencies
- Test error handling paths

**Example Test**:
```python
def test_handle_single_cell_selection():
    # Setup mocks
    panel = Mock(spec=PropertyPanel)
    selection_service = Mock(spec=SelectionService)
    design_repo = Mock(spec=DesignRepository)
    formatter = Mock(spec=PropertyFormatterService)

    # Create controller
    controller = PropertyPanelController(
        property_panel=panel,
        selection_service=selection_service,
        design_repository=design_repo,
        property_formatter=formatter
    )

    # Setup test data
    cell_id = CellId("U1")
    cell = Cell(id=cell_id, name="U_NAND_1", cell_type="NAND2_X1", pins=[], is_sequential=False)
    formatted = FormattedProperties(
        object_type="Cell",
        object_name="U_NAND_1",
        groups={"General": {"Name": "U_NAND_1"}}
    )

    design_repo.get_cell.return_value = cell
    formatter.format_cell_properties.return_value = formatted

    # Trigger selection change
    event = SelectionChangedEvent(selected_objects=[cell_id])
    controller._on_selection_changed(event)

    # Verify calls
    design_repo.get_cell.assert_called_once_with(cell_id)
    formatter.format_cell_properties.assert_called_once_with(cell)
    panel.display_properties.assert_called_once_with(
        object_type="Cell",
        object_name="U_NAND_1",
        properties={"General": {"Name": "U_NAND_1"}}
    )
```

**Integration Tests** (`tests/integration/presentation/test_property_panel_integration.py`):
- Use real PropertyPanel widget
- Use mock SelectionService emitting real events
- Use mock DesignRepository with test data
- Verify end-to-end flow from event to UI update

**Performance Tests**:
- Measure update time with realistic domain objects
- Test with various selection sizes (1, 10, 50, 100 objects)
- Profile repository query time vs. formatting time vs. UI time
- Ensure < 50ms target is consistently met

### 5.3 Future Enhancements (Out of Scope)
- Debounced updates to handle rapid selection changes
- Async property queries for large objects
- Progressive property loading (show basic info immediately, detailed info later)
- Property caching to reduce repository queries
- Undo/redo integration for property-based operations

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F02 split |
