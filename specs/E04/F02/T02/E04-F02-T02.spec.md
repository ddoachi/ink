---
id: E04-F02-T02
title: Property Formatters
type: Task
priority: P0 (MVP)
status: Draft
parent: E04-F02
created: 2025-12-26
estimated_hours: 4
actual_hours:
effort: Medium
tags:
  - application
  - formatting
  - data-transformation
clickup_task_id: '86evzm2vh'
---

# Spec: E04-F02-T02 - Property Formatters

## 1. Overview

### 1.1 Problem Statement
Transform domain model objects (Cell, Pin, Net, Port) into structured property dictionaries suitable for display in the PropertyPanel. The formatters must extract relevant attributes, organize them into logical groups, and apply appropriate formatting rules for each object type.

### 1.2 Goals
- Create type-specific property formatters for Cell, Pin, Net, and Port
- Organize properties into logical groups (General, Pins, Connectivity)
- Format property values consistently (lists, booleans, counts, etc.)
- Handle missing or optional properties gracefully
- Provide a unified interface for property formatting
- Support multi-selection property aggregation

---

## 2. Technical Requirements

### 2.1 Property Formatter Service

**Location**: `src/ink/application/services/property_formatter_service.py`

**Class Structure**:
```python
from dataclasses import dataclass
from typing import Dict, List, Any, Optional
from ink.domain.model.cell import Cell
from ink.domain.model.pin import Pin
from ink.domain.model.net import Net
from ink.domain.model.port import Port
from ink.domain.value_objects.pin_direction import PinDirection
import logging


@dataclass
class FormattedProperties:
    """
    Formatted property data ready for display.

    Attributes:
        object_type: Type of object (Cell, Pin, Net, Port)
        object_name: Display name of the object
        groups: Nested dict of property groups and their values
                Example: {
                    "General": {"Name": "U_ALU_1", "Type": "NAND2_X1"},
                    "Pins": {"Inputs": ["A", "B"], "Outputs": ["Y"]}
                }
    """
    object_type: str
    object_name: str
    groups: Dict[str, Dict[str, Any]]


class PropertyFormatterService:
    """
    Application service for formatting domain objects into display properties.

    Transforms domain entities into structured property dictionaries
    organized by logical groups for UI presentation.
    """

    def __init__(self):
        self.logger = logging.getLogger(__name__)

    def format_cell_properties(self, cell: Cell) -> FormattedProperties:
        """
        Format cell properties for display.

        Args:
            cell: Cell domain entity

        Returns:
            FormattedProperties with cell data organized into groups
        """
        # General properties
        general = {
            "Name": cell.name,
            "Cell Type": cell.cell_type,
            "Sequential": cell.is_sequential,
            "Pin Count": len(cell.pins),
        }

        # Pin breakdown by direction
        input_pins = [p.name for p in cell.pins if p.direction == PinDirection.INPUT]
        output_pins = [p.name for p in cell.pins if p.direction == PinDirection.OUTPUT]
        inout_pins = [p.name for p in cell.pins if p.direction == PinDirection.INOUT]

        pins = {
            "Inputs": sorted(input_pins) if input_pins else None,
            "Outputs": sorted(output_pins) if output_pins else None,
            "Inout": sorted(inout_pins) if inout_pins else None,
        }
        # Remove None entries
        pins = {k: v for k, v in pins.items() if v is not None}

        # Connectivity (requires graph traversal - placeholder for now)
        connectivity = {
            "Instance ID": cell.id.value,
        }

        groups = {
            "General": general,
            "Pins": pins,
            "Connectivity": connectivity,
        }

        return FormattedProperties(
            object_type="Cell",
            object_name=cell.name,
            groups=groups
        )

    def format_pin_properties(self, pin: Pin, parent_cell: Optional[Cell] = None) -> FormattedProperties:
        """
        Format pin properties for display.

        Args:
            pin: Pin domain entity
            parent_cell: Parent cell containing this pin (optional for context)

        Returns:
            FormattedProperties with pin data organized into groups
        """
        # General properties
        general = {
            "Name": pin.name,
            "Direction": pin.direction.value,
            "Parent Cell": parent_cell.name if parent_cell else "(unknown)",
        }

        # Connectivity
        connectivity = {
            "Connected Net": pin.net_id.value if pin.net_id else "(unconnected)",
            "Pin ID": pin.id.value,
        }

        groups = {
            "General": general,
            "Connectivity": connectivity,
        }

        return FormattedProperties(
            object_type="Pin",
            object_name=pin.name,
            groups=groups
        )

    def format_net_properties(self, net: Net, connected_pins: Optional[List[Pin]] = None) -> FormattedProperties:
        """
        Format net properties for display.

        Args:
            net: Net domain entity
            connected_pins: List of pins connected to this net (optional)

        Returns:
            FormattedProperties with net data organized into groups
        """
        # General properties
        general = {
            "Name": net.name,
            "Net ID": net.id.value,
        }

        # Connectivity
        if connected_pins:
            driver_pins = [p for p in connected_pins if p.direction == PinDirection.OUTPUT]
            sink_pins = [p for p in connected_pins if p.direction == PinDirection.INPUT]

            connectivity = {
                "Driver": driver_pins[0].name if driver_pins else "(none)",
                "Fanout Count": len(sink_pins),
                "Sink Pins": sorted([p.name for p in sink_pins]) if sink_pins else None,
            }
        else:
            connectivity = {
                "Connected Pins": "(not loaded)",
            }

        groups = {
            "General": general,
            "Connectivity": connectivity,
        }

        return FormattedProperties(
            object_type="Net",
            object_name=net.name,
            groups=groups
        )

    def format_port_properties(self, port: Port) -> FormattedProperties:
        """
        Format port properties for display.

        Args:
            port: Port domain entity

        Returns:
            FormattedProperties with port data organized into groups
        """
        # General properties
        general = {
            "Name": port.name,
            "Direction": port.direction.value,
            "Top Level": True,
        }

        # Connectivity
        connectivity = {
            "Connected Net": port.net_id.value if port.net_id else "(unconnected)",
            "Port ID": port.id.value,
        }

        groups = {
            "General": general,
            "Connectivity": connectivity,
        }

        return FormattedProperties(
            object_type="Port",
            object_name=port.name,
            groups=groups
        )

    def format_multi_selection(
        self,
        objects: List[Any],
        object_type: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Format multi-selection summary.

        Args:
            objects: List of selected domain objects
            object_type: Common type if all objects are same type, None for mixed

        Returns:
            Dictionary with multi-selection summary data
        """
        count = len(objects)

        summary = {
            "count": count,
            "object_type": object_type,
            "mixed": object_type is None,
        }

        # Add object names list
        names = []
        for obj in objects:
            if hasattr(obj, 'name'):
                names.append(obj.name)
            else:
                names.append(str(obj.id))

        summary["names"] = sorted(names)[:10]  # Limit to first 10
        if count > 10:
            summary["names"].append(f"... and {count - 10} more")

        return summary
```

### 2.2 Property Value Formatting Utilities

**Helper functions for consistent value formatting**:

```python
class PropertyFormatterService:
    # ... existing methods ...

    @staticmethod
    def format_boolean(value: bool) -> str:
        """Format boolean as Yes/No"""
        return "Yes" if value else "No"

    @staticmethod
    def format_list(items: List[str], max_items: int = 20) -> str:
        """
        Format list as comma-separated string.

        Args:
            items: List of items to format
            max_items: Maximum items to show before truncating

        Returns:
            Comma-separated string or "(none)" for empty list
        """
        if not items:
            return "(none)"

        if len(items) > max_items:
            visible = items[:max_items]
            return ", ".join(visible) + f" ... (+{len(items) - max_items} more)"

        return ", ".join(items)

    @staticmethod
    def format_optional(value: Optional[Any], default: str = "(none)") -> str:
        """Format optional value with default for None"""
        return str(value) if value is not None else default

    @staticmethod
    def format_count(count: int, singular: str, plural: Optional[str] = None) -> str:
        """
        Format count with singular/plural labels.

        Args:
            count: Number to format
            singular: Label for count of 1
            plural: Label for count != 1 (defaults to singular + 's')

        Returns:
            Formatted string like "3 cells" or "1 cell"
        """
        if plural is None:
            plural = f"{singular}s"

        label = singular if count == 1 else plural
        return f"{count} {label}"
```

### 2.3 Integration with Application Layer

The PropertyFormatterService is an application service that bridges the domain layer and presentation layer:

**Dependencies**:
- **Input**: Domain entities (Cell, Pin, Net, Port)
- **Output**: FormattedProperties (presentation-ready data structures)
- **Layer**: Application layer (no UI dependencies)

**Usage Pattern**:
```python
# In selection listener (Task T03):
formatter = PropertyFormatterService()

# Format cell properties
cell = design_repository.get_cell(cell_id)
formatted = formatter.format_cell_properties(cell)

# Send to PropertyPanel
property_panel.display_properties(
    object_type=formatted.object_type,
    object_name=formatted.object_name,
    properties=formatted.groups
)
```

### 2.4 Property Group Organization

**Standard property groups**:
- **General**: Basic identifying information (name, type, ID)
- **Pins**: Pin-related information (for cells)
- **Connectivity**: Connection and graph-related information

**Ordering**: Groups are displayed in the order they appear in the dictionary.

---

## 3. Dependencies

### 3.1 Upstream
- Domain entities: Cell, Pin, Net, Port
- Domain value objects: PinDirection, CellId, PinId, NetId, PortId

### 3.2 Downstream
- Task E04-F02-T01: PropertyPanel uses FormattedProperties to display
- Task E04-F02-T03: Selection listener uses formatters to prepare data

### 3.3 External Dependencies
- Python standard library: `dataclasses`, `typing`, `logging`
- No third-party dependencies

---

## 4. Acceptance Criteria

### 4.1 Functional Requirements
- [ ] `format_cell_properties()` extracts name, type, pin count, sequential flag
- [ ] `format_cell_properties()` groups pins by direction (INPUT, OUTPUT, INOUT)
- [ ] `format_pin_properties()` includes name, direction, parent cell, connected net
- [ ] `format_net_properties()` includes name, driver, fanout count, sink pins
- [ ] `format_port_properties()` includes name, direction, top-level flag
- [ ] `format_multi_selection()` generates summary with count and names
- [ ] Pin lists are sorted alphabetically for consistent display
- [ ] Optional/None values are handled with appropriate defaults

### 4.2 Data Organization
- [ ] Properties are organized into logical groups (General, Pins, Connectivity)
- [ ] FormattedProperties contains object_type, object_name, and groups
- [ ] Groups dictionary preserves insertion order (Python 3.7+)
- [ ] Empty/None property values are filtered out or shown as "(none)"

### 4.3 Performance
- [ ] Cell property formatting completes in < 5ms for typical cells (10-20 pins)
- [ ] Pin property formatting completes in < 1ms
- [ ] Net property formatting completes in < 5ms for typical nets (1-50 fanout)
- [ ] Multi-selection formatting handles 100 objects in < 10ms

### 4.4 Testing
- [ ] Unit tests for each `format_*_properties()` method with sample domain objects
- [ ] Unit tests for formatting utilities (format_boolean, format_list, etc.)
- [ ] Unit tests for multi-selection formatting with mixed types
- [ ] Unit tests for edge cases (empty pins, unconnected nets, None values)
- [ ] Test property group ordering is preserved
- [ ] 90%+ code coverage on PropertyFormatterService

---

## 5. Implementation Notes

### 5.1 Design Decisions

**Why separate FormattedProperties dataclass?**
- Clear contract between application and presentation layers
- Type-safe data transfer object
- Easy to test formatting logic in isolation
- Decouples domain model structure from UI layout

**Why group properties into categories?**
- Improves visual organization in the UI
- Allows for collapsible sections (per T01 spec)
- Logical grouping aids comprehension
- Standard pattern in property inspectors

**Why sort pin lists alphabetically?**
- Predictable, consistent ordering
- Easy to find specific pins in long lists
- Standard convention for property displays
- No domain-specific ordering requirement for MVP

**Why limit multi-selection to 10 names?**
- Prevents UI overflow with large selections
- First 10 names provide context without clutter
- Remainder count shows full selection size
- User can still see count and type information

### 5.2 Testing Strategy

**Unit Tests** (`tests/unit/application/services/test_property_formatter_service.py`):
- Create mock domain objects for testing (Cell, Pin, Net, Port)
- Test each formatter method independently
- Verify group structure and content
- Test edge cases (empty lists, None values, large fanouts)
- Test formatting utilities in isolation

**Example Test**:
```python
def test_format_cell_properties_with_mixed_pins():
    # Create mock cell with various pin types
    cell = Cell(
        id=CellId("U1"),
        name="U_NAND_1",
        cell_type="NAND2_X1",
        pins=[
            Pin(id=PinId("U1.A"), name="A", direction=PinDirection.INPUT),
            Pin(id=PinId("U1.B"), name="B", direction=PinDirection.INPUT),
            Pin(id=PinId("U1.Y"), name="Y", direction=PinDirection.OUTPUT),
        ],
        is_sequential=False
    )

    formatter = PropertyFormatterService()
    result = formatter.format_cell_properties(cell)

    assert result.object_type == "Cell"
    assert result.object_name == "U_NAND_1"
    assert result.groups["General"]["Cell Type"] == "NAND2_X1"
    assert result.groups["General"]["Pin Count"] == 3
    assert result.groups["Pins"]["Inputs"] == ["A", "B"]
    assert result.groups["Pins"]["Outputs"] == ["Y"]
```

### 5.3 Future Enhancements (Out of Scope)
- Customizable property group ordering via configuration
- User-defined property groups and custom properties
- Property value units and formatting (e.g., capacitance, delay)
- Hierarchical property display (nested subcircuits)
- Property comparison mode for multi-selection

---

## Revision History
| Date | Version | Author | Changes |
|------|---------|--------|---------|
| 2025-12-26 | 0.1 | Claude | Initial task creation from E04-F02 split |
