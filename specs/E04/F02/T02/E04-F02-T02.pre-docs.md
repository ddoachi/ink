# E04-F02-T02 - Property Formatters: Pre-Implementation Documentation

## Document Information

- **Task ID**: E04-F02-T02
- **Task Title**: Property Formatters - Format cell/pin/net/port properties
- **Document Type**: Pre-Implementation Planning
- **Created**: 2025-12-26
- **Status**: Planning
- **Estimated Hours**: 4
- **Parent Feature**: [E04-F02](../E04-F02.spec.md) - Property Panel

---

## 1. Overview

### 1.1 Problem Context

Domain model objects (Cell, Pin, Net, Port) contain raw data that must be transformed into structured, presentation-ready property dictionaries. The PropertyFormatterService bridges the gap between domain entities and UI presentation, extracting relevant attributes, organizing them into logical groups, and applying consistent formatting rules.

This service is crucial for maintaining clean separation between domain logic and presentation logic, enabling the PropertyPanel to remain agnostic to domain model structure.

### 1.2 Scope

**In Scope:**
- Type-specific formatters for Cell, Pin, Net, Port
- Property grouping into logical categories (General, Pins, Connectivity)
- Value formatting utilities (boolean, list, optional, count)
- Multi-selection summary formatting
- FormattedProperties dataclass for type-safe data transfer
- Alphabetical sorting of pin/name lists

**Out of Scope:**
- Property validation or modification
- Computed properties requiring graph traversal (fanin/fanout counts - placeholder only)
- Property caching or memoization
- Custom property formatters (user-defined)
- Property filtering or search

### 1.3 Success Criteria

- Each object type has dedicated formatter method
- Properties organized into 2-3 logical groups
- Formatting completes in < 5ms for typical objects
- Consistent value formatting across all types
- Type-safe FormattedProperties contract

---

## 2. Implementation Approach

### 2.1 Service Architecture

**Layer Position**: Application Layer
- Input: Domain entities (Cell, Pin, Net, Port)
- Output: FormattedProperties (presentation-ready DTOs)
- No dependencies on presentation layer (Qt-free)
- No modifications to domain objects

**Service Structure:**
```python
PropertyFormatterService
├── format_cell_properties(cell) -> FormattedProperties
├── format_pin_properties(pin, parent_cell) -> FormattedProperties
├── format_net_properties(net, connected_pins) -> FormattedProperties
├── format_port_properties(port) -> FormattedProperties
├── format_multi_selection_summary(selected_ids) -> MultiSelectionSummary
└── Formatting utilities (static methods)
    ├── format_boolean(value) -> str
    ├── format_list(items) -> str
    ├── format_optional(value) -> str
    └── format_count(count, singular, plural) -> str
```

### 2.2 Data Transfer Objects

**FormattedProperties Dataclass:**
```python
@dataclass
class FormattedProperties:
    object_type: str          # "Cell", "Pin", "Net", "Port"
    object_name: str          # Display name
    groups: Dict[str, Dict[str, Any]]  # Nested property groups
```

**Property Group Structure:**
```python
{
    "General": {
        "Name": "U_NAND_1",
        "Cell Type": "NAND2_X1",
        "Sequential": False,  # Will be formatted by UI layer
        "Pin Count": 3
    },
    "Pins": {
        "Inputs": ["A", "B"],      # Lists preserved as lists
        "Outputs": ["Y"],
        "Inout": None              # None filtered out
    },
    "Connectivity": {
        "Instance ID": "cell_001"
    }
}
```

### 2.3 Formatting Strategy

**Type-Specific Extraction:**
- Cell: name, type, sequential flag, pin breakdown by direction
- Pin: name, direction, parent cell, connected net
- Net: name, driver, fanout count, sink pins
- Port: name, direction, top-level flag, connected net

**Property Grouping:**
- **General**: Identity and basic attributes
- **Pins**: Pin-related information (cells only)
- **Connectivity**: Connection and graph information

**Value Preservation:**
- Primitive types (str, int, bool) stored as-is
- Lists stored as lists (UI layer handles formatting)
- None values kept (UI layer handles display as "(none)")
- Empty lists filtered out or kept as None

### 2.4 Multi-Selection Handling

**Summary Data Structure:**
```python
@dataclass
class MultiSelectionSummary:
    count: int                      # Total objects
    object_type: Optional[str]      # "Cell" or None for mixed
    object_names: List[str]         # Sorted, truncated list
    is_truncated: bool              # True if > max_names
    total_truncated: int            # Count of hidden names
```

**Name Extraction and Sorting:**
- Extract name from each object ID
- Sort alphabetically for consistency
- Truncate at configurable limit (default 20)
- Add "... and N more" suffix if truncated

---

## 3. Key Design Decisions

### 3.1 Why Application Layer Service?

**Decision**: Place PropertyFormatterService in application layer

**Rationale:**
- Bridges domain and presentation without coupling them
- Application layer is appropriate for data transformation
- No business logic (domain) or UI logic (presentation)
- Easy to test with mock domain objects
- Reusable across different UI implementations

**Alternatives Considered:**
- Domain layer: Too presentation-focused for domain
- Presentation layer: Would couple UI to domain structure

### 3.2 Why Separate FormattedProperties Dataclass?

**Decision**: Use dedicated DTO instead of raw dictionaries

**Rationale:**
- Type-safe contract between formatter and UI
- Clear documentation of expected structure
- Easy to validate in tests
- Prevents typos in dictionary keys
- IDE autocomplete support
- Easy to extend with additional fields

**Alternatives Considered:**
- Raw dict: No type safety, error-prone
- Domain objects directly: Couples UI to domain

### 3.3 Why Group Properties into Categories?

**Decision**: Organize properties into 2-3 logical groups

**Rationale:**
- Improves visual organization in UI (collapsible sections)
- Logical grouping aids comprehension
- Separates identity from structure from connectivity
- Standard pattern in property inspectors
- Extensible for future property types

**Alternatives Considered:**
- Flat list: Harder to scan with many properties
- Too many groups: Clutters UI with small sections

### 3.4 Why Sort Pin/Name Lists Alphabetically?

**Decision**: Apply alphabetical sorting to all lists

**Rationale:**
- Predictable, consistent ordering
- Easy to find specific items in long lists
- No domain-specific ordering requirement for MVP
- Standard convention for property displays
- Minimal performance overhead (O(n log n))

**Alternatives Considered:**
- Declaration order: Not meaningful to users
- Direction-based grouping: More complex, not needed for MVP

### 3.5 Why Include Parent Cell for Pins?

**Decision**: Accept optional `parent_cell` parameter in `format_pin_properties()`

**Rationale:**
- Provides context for pin properties
- Useful for understanding which cell pin belongs to
- Enables navigation to parent (future)
- Minimal performance overhead (single object reference)

**Alternatives Considered:**
- Look up parent via repository: Couples formatter to infrastructure
- No parent context: Less useful property display

---

## 4. Dependencies and Integration Points

### 4.1 Upstream Dependencies

**Domain Layer:**
- `Cell` entity (from `ink.domain.model.cell`)
- `Pin` entity (from `ink.domain.model.pin`)
- `Net` entity (from `ink.domain.model.net`)
- `Port` entity (from `ink.domain.model.port`)
- `PinDirection` value object (from `ink.domain.value_objects.pin_direction`)
- Value object IDs: `CellId`, `PinId`, `NetId`, `PortId`

**Python Standard Library:**
- `dataclasses` for DTOs
- `typing` for type hints
- `logging` for debug logging

**No External Dependencies:**
- Pure Python implementation
- No Qt or UI framework dependencies
- No third-party libraries

### 4.2 Downstream Dependencies

**Task E04-F02-T01 (PropertyPanel):**
- Consumes `FormattedProperties` structure
- Expects specific dictionary format for groups
- Relies on consistent value types (str, int, bool, list, None)

**Task E04-F02-T03 (Selection Listener):**
- Uses formatter to prepare data for PropertyPanel
- Calls appropriate `format_*_properties()` methods
- Handles `MultiSelectionSummary` for multi-select

### 4.3 Repository Interface Requirements

**For full implementation, formatters need:**
- `get_pins_on_net(net_id)` - to populate net fanout info
- `get_cell_containing_pin(pin_id)` - to get parent cell for pins

**Note**: These queries are handled by PropertyPanelController (T03), not by the formatter service directly.

---

## 5. Testing Strategy

### 5.1 Unit Tests

**File**: `tests/unit/application/services/test_property_formatter_service.py`

**Test Coverage:**

1. **Cell Formatter Tests**
   - Format cell with mixed pin directions
   - Format cell with only input pins
   - Format cell with only output pins
   - Format sequential cell (is_sequential=True)
   - Format cell with no pins
   - Verify pin lists are sorted alphabetically

2. **Pin Formatter Tests**
   - Format pin with parent cell
   - Format pin without parent cell (None)
   - Format pin with connected net
   - Format pin with no connected net
   - Format input, output, and inout pins

3. **Net Formatter Tests**
   - Format net with connected pins
   - Format net without connected pins (not loaded)
   - Format net with driver and multiple sinks
   - Format net with no driver
   - Format net with large fanout (truncation)

4. **Port Formatter Tests**
   - Format port with connected net
   - Format port with no connected net
   - Format input and output ports

5. **Multi-Selection Formatter Tests**
   - Format same-type selection (all cells)
   - Format mixed-type selection (cells + nets)
   - Format selection with < 20 objects
   - Format selection with exactly 20 objects
   - Format selection with > 20 objects (truncation)
   - Verify names sorted alphabetically
   - Verify truncation message format

6. **Formatting Utility Tests**
   - `format_boolean()`: True/False → Yes/No
   - `format_list()`: ["A", "B"] → "A, B"
   - `format_list()`: [] → "(none)"
   - `format_list()`: Long list → truncation with "... (+N more)"
   - `format_optional()`: None → "(none)"
   - `format_optional()`: value → str(value)
   - `format_count()`: 1 → "1 cell", 3 → "3 cells"

**Example Test:**
```python
def test_format_cell_properties_with_mixed_pins():
    formatter = PropertyFormatterService()

    cell = Cell(
        id=CellId("U1"),
        name="U_NAND_1",
        cell_type="NAND2_X1",
        pins=[
            Pin(id=PinId("U1.A"), name="A", direction=PinDirection.INPUT),
            Pin(id=PinId("U1.B"), name="B", direction=PinDirection.INPUT),
            Pin(id=PinId("U1.Y"), name="Y", direction=PinDirection.OUTPUT),
        ],
        is_sequential=False
    )

    result = formatter.format_cell_properties(cell)

    assert result.object_type == "Cell"
    assert result.object_name == "U_NAND_1"
    assert result.groups["General"]["Cell Type"] == "NAND2_X1"
    assert result.groups["General"]["Sequential"] == False  # UI formats to Yes/No
    assert result.groups["General"]["Pin Count"] == 3
    assert result.groups["Pins"]["Inputs"] == ["A", "B"]  # Sorted
    assert result.groups["Pins"]["Outputs"] == ["Y"]

def test_format_multi_selection_summary_truncated():
    formatter = PropertyFormatterService()

    # Create 25 CellIds
    selected_ids = [CellId(f"U_CELL_{i:03d}") for i in range(25)]

    summary = formatter.format_multi_selection_summary(
        selected_ids,
        max_names=20
    )

    assert summary.count == 25
    assert summary.object_type == "Cell"
    assert summary.is_truncated is True
    assert summary.total_truncated == 5
    assert len(summary.object_names) == 21  # 20 + truncation message
    assert "... and 5 more" in summary.object_names[-1]
    # Verify first 20 are sorted
    assert summary.object_names[:20] == sorted([f"U_CELL_{i:03d}" for i in range(20)])
```

### 5.2 Integration Tests

**File**: `tests/integration/application/test_property_formatter_integration.py`

**Test Coverage:**
- Format properties using real domain objects from repository
- Verify formatting with complex cell hierarchy
- Test with actual CDL-parsed data structures
- Performance test with large nets (100+ fanout)

### 5.3 Performance Tests

**Benchmarks:**
- Cell formatting: < 5ms (typical 10-20 pin cell)
- Pin formatting: < 1ms
- Net formatting: < 5ms (typical 1-50 fanout net)
- Multi-selection: < 10ms (100 objects)

**Test Implementation:**
```python
def test_cell_formatting_performance():
    formatter = PropertyFormatterService()
    cell = create_test_cell_with_20_pins()

    import time
    start = time.perf_counter()
    result = formatter.format_cell_properties(cell)
    elapsed = time.perf_counter() - start

    assert elapsed < 0.005, f"Cell formatting took {elapsed*1000:.2f}ms"
```

### 5.4 Coverage Target

- **Unit tests**: 90%+ coverage on PropertyFormatterService
- **Edge cases**: All None/empty/missing value combinations
- **Type coverage**: All object types (Cell, Pin, Net, Port)

---

## 6. Risks and Considerations

### 6.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| **Domain model API changes** | High | Medium | Define required interfaces early, coordinate with E01 team |
| **Large fanout performance** | Medium | Low | Implement list truncation, lazy loading in UI if needed |
| **Missing optional fields** | Low | High | Handle all None cases gracefully, test edge cases |
| **Type mismatch in formatted data** | Medium | Low | Use dataclasses, type hints, strict testing |

### 6.2 Data Quality Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Incomplete domain objects** | Medium | Defensive programming, handle None/empty |
| **Circular references in graph** | Low | Formatters don't traverse graph (controller does) |
| **Invalid pin directions** | Low | Trust domain model validation |
| **Very long object names** | Low | No truncation at formatter level (UI handles) |

### 6.3 Performance Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Sorting large pin lists** | Low | O(n log n) acceptable for typical counts (<100) |
| **String concatenation overhead** | Low | Use list comprehension, avoid repeated concatenation |
| **Deep copy overhead** | Medium | Don't copy domain objects, extract primitives only |

### 6.4 Integration Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **PropertyPanel expects different format** | High | Define FormattedProperties contract clearly, share spec |
| **Controller queries wrong data** | Medium | Document required context (parent_cell, connected_pins) |
| **Type name mismatch** | Low | Use constants for type strings, test coverage |

---

## 7. Implementation Checklist

### 7.1 Core Implementation

- [ ] Create `FormattedProperties` dataclass
- [ ] Create `MultiSelectionSummary` dataclass
- [ ] Create `PropertyFormatterService` class
- [ ] Implement `format_cell_properties()`
- [ ] Implement `format_pin_properties()`
- [ ] Implement `format_net_properties()`
- [ ] Implement `format_port_properties()`
- [ ] Implement `format_multi_selection_summary()`
- [ ] Implement formatting utility static methods

### 7.2 Property Extraction Logic

- [ ] Extract cell pins and group by direction
- [ ] Sort pin lists alphabetically
- [ ] Filter out None/empty values from groups
- [ ] Handle optional parent_cell for pins
- [ ] Handle optional connected_pins for nets
- [ ] Extract object names from IDs for multi-selection

### 7.3 Testing

- [ ] Unit tests for each formatter method
- [ ] Unit tests for formatting utilities
- [ ] Unit tests for multi-selection with various counts
- [ ] Unit tests for edge cases (None, empty, missing)
- [ ] Performance tests for typical objects
- [ ] Performance test for large multi-selection

### 7.4 Documentation

- [ ] Docstrings for all public methods
- [ ] Document FormattedProperties structure
- [ ] Document expected input formats
- [ ] Document property group conventions
- [ ] Add inline comments for complex logic

---

## 8. Open Questions

### 8.1 Resolved Questions

**Q**: Should formatters handle graph traversal to get fanin/fanout?
**A**: No, controller (T03) provides this data. Formatters are pure transformation.

**Q**: Should pin lists be sorted?
**A**: Yes, alphabetically for consistency and ease of finding.

**Q**: What happens if parent_cell is None for a pin?
**A**: Display "(unknown)" in parent cell field.

**Q**: Should we format boolean values here or in UI?
**A**: Preserve as bool, UI layer formats to "Yes"/"No" for display.

### 8.2 Pending Questions

**Q**: Should formatters be cached to avoid repeated formatting?
**A**: Not for MVP. Consider in P1 if performance issues arise.

**Q**: Should we support custom property ordering?
**A**: No for MVP. Group order is fixed (General, Pins, Connectivity).

**Q**: Should very long lists be truncated here or in UI?
**A**: Lists preserved as-is. UI layer handles truncation/scrolling.

---

## 9. References

### 9.1 Specifications

- [E04-F02 Feature Spec](../E04-F02.spec.md) - Property Panel feature
- [E04-F02-T02 Task Spec](./E04-F02-T02.spec.md) - This task specification

### 9.2 Domain Model

- Cell entity specification (E01)
- Pin entity specification (E01)
- Net entity specification (E01)
- Port entity specification (E01)
- PinDirection value object (E01)

### 9.3 Design Patterns

- **Data Transfer Object (DTO)**: FormattedProperties, MultiSelectionSummary
- **Service Layer**: Application service pattern
- **Adapter**: Adapts domain model to presentation format

---

**End of Pre-Implementation Documentation**
